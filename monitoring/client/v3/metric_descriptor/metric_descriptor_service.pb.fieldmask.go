// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v3/metric_descriptor_service.proto
// DO NOT EDIT!!!

package metric_descriptor_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	metric_descriptor "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/metric_descriptor"
	project "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/project"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &metric_descriptor.MetricDescriptor{}
	_ = &project.Project{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type BatchGetMetricDescriptorsRequest_FieldMask struct {
	Paths []BatchGetMetricDescriptorsRequest_FieldPath
}

func FullBatchGetMetricDescriptorsRequest_FieldMask() *BatchGetMetricDescriptorsRequest_FieldMask {
	res := &BatchGetMetricDescriptorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetMetricDescriptorsRequest_FieldTerminalPath{selector: BatchGetMetricDescriptorsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetMetricDescriptorsRequest_FieldTerminalPath{selector: BatchGetMetricDescriptorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetMetricDescriptorsRequest_FieldTerminalPath{selector: BatchGetMetricDescriptorsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetMetricDescriptorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetMetricDescriptorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetMetricDescriptorsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) Subtract(other *BatchGetMetricDescriptorsRequest_FieldMask) *BatchGetMetricDescriptorsRequest_FieldMask {
	result := &BatchGetMetricDescriptorsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetMetricDescriptorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetMetricDescriptorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) FilterInputFields() *BatchGetMetricDescriptorsRequest_FieldMask {
	result := &BatchGetMetricDescriptorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetMetricDescriptorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetMetricDescriptorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetMetricDescriptorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetMetricDescriptorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) AppendPath(path BatchGetMetricDescriptorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetMetricDescriptorsRequest_FieldPath))
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) GetPaths() []BatchGetMetricDescriptorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetMetricDescriptorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) Set(target, source *BatchGetMetricDescriptorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetMetricDescriptorsRequest), source.(*BatchGetMetricDescriptorsRequest))
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) Project(source *BatchGetMetricDescriptorsRequest) *BatchGetMetricDescriptorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetMetricDescriptorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetMetricDescriptorsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetMetricDescriptorsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetMetricDescriptorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetMetricDescriptorsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetMetricDescriptorsRequest))
}

func (fieldMask *BatchGetMetricDescriptorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetMetricDescriptorsResponse_FieldMask struct {
	Paths []BatchGetMetricDescriptorsResponse_FieldPath
}

func FullBatchGetMetricDescriptorsResponse_FieldMask() *BatchGetMetricDescriptorsResponse_FieldMask {
	res := &BatchGetMetricDescriptorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetMetricDescriptorsResponse_FieldTerminalPath{selector: BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors})
	res.Paths = append(res.Paths, &BatchGetMetricDescriptorsResponse_FieldTerminalPath{selector: BatchGetMetricDescriptorsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetMetricDescriptorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetMetricDescriptorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetMetricDescriptorsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) Subtract(other *BatchGetMetricDescriptorsResponse_FieldMask) *BatchGetMetricDescriptorsResponse_FieldMask {
	result := &BatchGetMetricDescriptorsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetMetricDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors: &metric_descriptor.MetricDescriptor_FieldMask{},
	}
	mySubMasks := map[BatchGetMetricDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors: &metric_descriptor.MetricDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetMetricDescriptorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetMetricDescriptorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetMetricDescriptorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors:
						mySubMasks[BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors] = metric_descriptor.FullMetricDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetMetricDescriptorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetMetricDescriptorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetMetricDescriptorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) FilterInputFields() *BatchGetMetricDescriptorsResponse_FieldMask {
	result := &BatchGetMetricDescriptorsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors:
			if _, ok := path.(*BatchGetMetricDescriptorsResponse_FieldTerminalPath); ok {
				for _, subpath := range metric_descriptor.FullMetricDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetMetricDescriptorsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetMetricDescriptorsResponse_FieldSubPath); ok {
				selectedMask := &metric_descriptor.MetricDescriptor_FieldMask{
					Paths: []metric_descriptor.MetricDescriptor_FieldPath{sub.subPath.(metric_descriptor.MetricDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetMetricDescriptorsResponse_FieldSubPath{selector: BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetMetricDescriptorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetMetricDescriptorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetMetricDescriptorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetMetricDescriptorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) AppendPath(path BatchGetMetricDescriptorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetMetricDescriptorsResponse_FieldPath))
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) GetPaths() []BatchGetMetricDescriptorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetMetricDescriptorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) Set(target, source *BatchGetMetricDescriptorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetMetricDescriptorsResponse), source.(*BatchGetMetricDescriptorsResponse))
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) Project(source *BatchGetMetricDescriptorsResponse) *BatchGetMetricDescriptorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetMetricDescriptorsResponse{}
	metricDescriptorsMask := &metric_descriptor.MetricDescriptor_FieldMask{}
	wholeMetricDescriptorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetMetricDescriptorsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors:
				result.MetricDescriptors = source.MetricDescriptors
				wholeMetricDescriptorsAccepted = true
			case BatchGetMetricDescriptorsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetMetricDescriptorsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetMetricDescriptorsResponse_FieldPathSelectorMetricDescriptors:
				metricDescriptorsMask.AppendPath(tp.subPath.(metric_descriptor.MetricDescriptor_FieldPath))
			}
		}
	}
	if wholeMetricDescriptorsAccepted == false && len(metricDescriptorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetMetricDescriptors() {
			result.MetricDescriptors = append(result.MetricDescriptors, metricDescriptorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetMetricDescriptorsResponse))
}

func (fieldMask *BatchGetMetricDescriptorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMetricDescriptorRequest_FieldMask struct {
	Paths []WatchMetricDescriptorRequest_FieldPath
}

func FullWatchMetricDescriptorRequest_FieldMask() *WatchMetricDescriptorRequest_FieldMask {
	res := &WatchMetricDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchMetricDescriptorRequest_FieldTerminalPath{selector: WatchMetricDescriptorRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchMetricDescriptorRequest_FieldTerminalPath{selector: WatchMetricDescriptorRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchMetricDescriptorRequest_FieldTerminalPath{selector: WatchMetricDescriptorRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMetricDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMetricDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMetricDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMetricDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) Subtract(other *WatchMetricDescriptorRequest_FieldMask) *WatchMetricDescriptorRequest_FieldMask {
	result := &WatchMetricDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMetricDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMetricDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMetricDescriptorRequest_FieldMask) FilterInputFields() *WatchMetricDescriptorRequest_FieldMask {
	result := &WatchMetricDescriptorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMetricDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMetricDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMetricDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMetricDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMetricDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) AppendPath(path WatchMetricDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMetricDescriptorRequest_FieldPath))
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) GetPaths() []WatchMetricDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMetricDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) Set(target, source *WatchMetricDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMetricDescriptorRequest), source.(*WatchMetricDescriptorRequest))
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) Project(source *WatchMetricDescriptorRequest) *WatchMetricDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMetricDescriptorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMetricDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchMetricDescriptorRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchMetricDescriptorRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchMetricDescriptorRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMetricDescriptorRequest))
}

func (fieldMask *WatchMetricDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMetricDescriptorResponse_FieldMask struct {
	Paths []WatchMetricDescriptorResponse_FieldPath
}

func FullWatchMetricDescriptorResponse_FieldMask() *WatchMetricDescriptorResponse_FieldMask {
	res := &WatchMetricDescriptorResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchMetricDescriptorResponse_FieldTerminalPath{selector: WatchMetricDescriptorResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMetricDescriptorResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMetricDescriptorResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMetricDescriptorResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMetricDescriptorResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) Subtract(other *WatchMetricDescriptorResponse_FieldMask) *WatchMetricDescriptorResponse_FieldMask {
	result := &WatchMetricDescriptorResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMetricDescriptorResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMetricDescriptorResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMetricDescriptorResponse_FieldMask) FilterInputFields() *WatchMetricDescriptorResponse_FieldMask {
	result := &WatchMetricDescriptorResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMetricDescriptorResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMetricDescriptorResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMetricDescriptorResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMetricDescriptorResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMetricDescriptorResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) AppendPath(path WatchMetricDescriptorResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMetricDescriptorResponse_FieldPath))
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) GetPaths() []WatchMetricDescriptorResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMetricDescriptorResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) Set(target, source *WatchMetricDescriptorResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMetricDescriptorResponse), source.(*WatchMetricDescriptorResponse))
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) Project(source *WatchMetricDescriptorResponse) *WatchMetricDescriptorResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMetricDescriptorResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMetricDescriptorResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchMetricDescriptorResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMetricDescriptorResponse))
}

func (fieldMask *WatchMetricDescriptorResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMetricDescriptorsRequest_FieldMask struct {
	Paths []WatchMetricDescriptorsRequest_FieldPath
}

func FullWatchMetricDescriptorsRequest_FieldMask() *WatchMetricDescriptorsRequest_FieldMask {
	res := &WatchMetricDescriptorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsRequest_FieldTerminalPath{selector: WatchMetricDescriptorsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMetricDescriptorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMetricDescriptorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMetricDescriptorsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) Subtract(other *WatchMetricDescriptorsRequest_FieldMask) *WatchMetricDescriptorsRequest_FieldMask {
	result := &WatchMetricDescriptorsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMetricDescriptorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMetricDescriptorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) FilterInputFields() *WatchMetricDescriptorsRequest_FieldMask {
	result := &WatchMetricDescriptorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMetricDescriptorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMetricDescriptorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMetricDescriptorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMetricDescriptorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) AppendPath(path WatchMetricDescriptorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMetricDescriptorsRequest_FieldPath))
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) GetPaths() []WatchMetricDescriptorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMetricDescriptorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) Set(target, source *WatchMetricDescriptorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMetricDescriptorsRequest), source.(*WatchMetricDescriptorsRequest))
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) Project(source *WatchMetricDescriptorsRequest) *WatchMetricDescriptorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMetricDescriptorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMetricDescriptorsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchMetricDescriptorsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchMetricDescriptorsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchMetricDescriptorsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchMetricDescriptorsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchMetricDescriptorsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchMetricDescriptorsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchMetricDescriptorsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchMetricDescriptorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchMetricDescriptorsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchMetricDescriptorsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMetricDescriptorsRequest))
}

func (fieldMask *WatchMetricDescriptorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMetricDescriptorsResponse_FieldMask struct {
	Paths []WatchMetricDescriptorsResponse_FieldPath
}

func FullWatchMetricDescriptorsResponse_FieldMask() *WatchMetricDescriptorsResponse_FieldMask {
	res := &WatchMetricDescriptorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponse_FieldTerminalPath{selector: WatchMetricDescriptorsResponse_FieldPathSelectorMetricDescriptorChanges})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponse_FieldTerminalPath{selector: WatchMetricDescriptorsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponse_FieldTerminalPath{selector: WatchMetricDescriptorsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponse_FieldTerminalPath{selector: WatchMetricDescriptorsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponse_FieldTerminalPath{selector: WatchMetricDescriptorsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponse_FieldTerminalPath{selector: WatchMetricDescriptorsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponse_FieldTerminalPath{selector: WatchMetricDescriptorsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMetricDescriptorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMetricDescriptorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMetricDescriptorsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) Subtract(other *WatchMetricDescriptorsResponse_FieldMask) *WatchMetricDescriptorsResponse_FieldMask {
	result := &WatchMetricDescriptorsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchMetricDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchMetricDescriptorsResponse_FieldPathSelectorPageTokenChange: &WatchMetricDescriptorsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchMetricDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchMetricDescriptorsResponse_FieldPathSelectorPageTokenChange: &WatchMetricDescriptorsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMetricDescriptorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchMetricDescriptorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchMetricDescriptorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchMetricDescriptorsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchMetricDescriptorsResponse_FieldPathSelectorPageTokenChange] = FullWatchMetricDescriptorsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchMetricDescriptorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchMetricDescriptorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMetricDescriptorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) FilterInputFields() *WatchMetricDescriptorsResponse_FieldMask {
	result := &WatchMetricDescriptorsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMetricDescriptorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMetricDescriptorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMetricDescriptorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMetricDescriptorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) AppendPath(path WatchMetricDescriptorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMetricDescriptorsResponse_FieldPath))
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) GetPaths() []WatchMetricDescriptorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMetricDescriptorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) Set(target, source *WatchMetricDescriptorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMetricDescriptorsResponse), source.(*WatchMetricDescriptorsResponse))
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) Project(source *WatchMetricDescriptorsResponse) *WatchMetricDescriptorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMetricDescriptorsResponse{}
	pageTokenChangeMask := &WatchMetricDescriptorsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMetricDescriptorsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchMetricDescriptorsResponse_FieldPathSelectorMetricDescriptorChanges:
				result.MetricDescriptorChanges = source.MetricDescriptorChanges
			case WatchMetricDescriptorsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchMetricDescriptorsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchMetricDescriptorsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchMetricDescriptorsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchMetricDescriptorsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchMetricDescriptorsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchMetricDescriptorsResponse_FieldSubPath:
			switch tp.selector {
			case WatchMetricDescriptorsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchMetricDescriptorsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMetricDescriptorsResponse))
}

func (fieldMask *WatchMetricDescriptorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMetricDescriptorsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchMetricDescriptorsResponsePageTokenChange_FieldPath
}

func FullWatchMetricDescriptorsResponse_PageTokenChange_FieldMask() *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask {
	res := &WatchMetricDescriptorsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponsePageTokenChange_FieldTerminalPath{selector: WatchMetricDescriptorsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchMetricDescriptorsResponsePageTokenChange_FieldTerminalPath{selector: WatchMetricDescriptorsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMetricDescriptorsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMetricDescriptorsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMetricDescriptorsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) Subtract(other *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask {
	result := &WatchMetricDescriptorsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMetricDescriptorsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMetricDescriptorsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask {
	result := &WatchMetricDescriptorsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMetricDescriptorsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMetricDescriptorsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) AppendPath(path WatchMetricDescriptorsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMetricDescriptorsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) GetPaths() []WatchMetricDescriptorsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMetricDescriptorsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) Set(target, source *WatchMetricDescriptorsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMetricDescriptorsResponse_PageTokenChange), source.(*WatchMetricDescriptorsResponse_PageTokenChange))
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) Project(source *WatchMetricDescriptorsResponse_PageTokenChange) *WatchMetricDescriptorsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMetricDescriptorsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMetricDescriptorsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchMetricDescriptorsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchMetricDescriptorsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMetricDescriptorsResponse_PageTokenChange))
}

func (fieldMask *WatchMetricDescriptorsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateMetricDescriptorRequest_FieldMask struct {
	Paths []UpdateMetricDescriptorRequest_FieldPath
}

func FullUpdateMetricDescriptorRequest_FieldMask() *UpdateMetricDescriptorRequest_FieldMask {
	res := &UpdateMetricDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateMetricDescriptorRequest_FieldTerminalPath{selector: UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor})
	res.Paths = append(res.Paths, &UpdateMetricDescriptorRequest_FieldTerminalPath{selector: UpdateMetricDescriptorRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateMetricDescriptorRequest_FieldTerminalPath{selector: UpdateMetricDescriptorRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateMetricDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateMetricDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateMetricDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) Subtract(other *UpdateMetricDescriptorRequest_FieldMask) *UpdateMetricDescriptorRequest_FieldMask {
	result := &UpdateMetricDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateMetricDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor: &metric_descriptor.MetricDescriptor_FieldMask{},
		UpdateMetricDescriptorRequest_FieldPathSelectorCas:              &UpdateMetricDescriptorRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateMetricDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor: &metric_descriptor.MetricDescriptor_FieldMask{},
		UpdateMetricDescriptorRequest_FieldPathSelectorCas:              &UpdateMetricDescriptorRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateMetricDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateMetricDescriptorRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateMetricDescriptorRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor:
						mySubMasks[UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor] = metric_descriptor.FullMetricDescriptor_FieldMask()
					case UpdateMetricDescriptorRequest_FieldPathSelectorCas:
						mySubMasks[UpdateMetricDescriptorRequest_FieldPathSelectorCas] = FullUpdateMetricDescriptorRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateMetricDescriptorRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateMetricDescriptorRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateMetricDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) FilterInputFields() *UpdateMetricDescriptorRequest_FieldMask {
	result := &UpdateMetricDescriptorRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor:
			if _, ok := path.(*UpdateMetricDescriptorRequest_FieldTerminalPath); ok {
				for _, subpath := range metric_descriptor.FullMetricDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMetricDescriptorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateMetricDescriptorRequest_FieldSubPath); ok {
				selectedMask := &metric_descriptor.MetricDescriptor_FieldMask{
					Paths: []metric_descriptor.MetricDescriptor_FieldPath{sub.subPath.(metric_descriptor.MetricDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMetricDescriptorRequest_FieldSubPath{selector: UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor, subPath: allowedPath})
				}
			}
		case UpdateMetricDescriptorRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateMetricDescriptorRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateMetricDescriptorRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMetricDescriptorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateMetricDescriptorRequest_FieldSubPath); ok {
				selectedMask := &UpdateMetricDescriptorRequest_CAS_FieldMask{
					Paths: []UpdateMetricDescriptorRequestCAS_FieldPath{sub.subPath.(UpdateMetricDescriptorRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMetricDescriptorRequest_FieldSubPath{selector: UpdateMetricDescriptorRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateMetricDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateMetricDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateMetricDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateMetricDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) AppendPath(path UpdateMetricDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateMetricDescriptorRequest_FieldPath))
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) GetPaths() []UpdateMetricDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateMetricDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) Set(target, source *UpdateMetricDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateMetricDescriptorRequest), source.(*UpdateMetricDescriptorRequest))
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) Project(source *UpdateMetricDescriptorRequest) *UpdateMetricDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateMetricDescriptorRequest{}
	metricDescriptorMask := &metric_descriptor.MetricDescriptor_FieldMask{}
	wholeMetricDescriptorAccepted := false
	casMask := &UpdateMetricDescriptorRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateMetricDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor:
				result.MetricDescriptor = source.MetricDescriptor
				wholeMetricDescriptorAccepted = true
			case UpdateMetricDescriptorRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateMetricDescriptorRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateMetricDescriptorRequest_FieldSubPath:
			switch tp.selector {
			case UpdateMetricDescriptorRequest_FieldPathSelectorMetricDescriptor:
				metricDescriptorMask.AppendPath(tp.subPath.(metric_descriptor.MetricDescriptor_FieldPath))
			case UpdateMetricDescriptorRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateMetricDescriptorRequestCAS_FieldPath))
			}
		}
	}
	if wholeMetricDescriptorAccepted == false && len(metricDescriptorMask.Paths) > 0 {
		result.MetricDescriptor = metricDescriptorMask.Project(source.GetMetricDescriptor())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateMetricDescriptorRequest))
}

func (fieldMask *UpdateMetricDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateMetricDescriptorRequest_CAS_FieldMask struct {
	Paths []UpdateMetricDescriptorRequestCAS_FieldPath
}

func FullUpdateMetricDescriptorRequest_CAS_FieldMask() *UpdateMetricDescriptorRequest_CAS_FieldMask {
	res := &UpdateMetricDescriptorRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateMetricDescriptorRequestCAS_FieldTerminalPath{selector: UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateMetricDescriptorRequestCAS_FieldTerminalPath{selector: UpdateMetricDescriptorRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateMetricDescriptorRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateMetricDescriptorRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateMetricDescriptorRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) Subtract(other *UpdateMetricDescriptorRequest_CAS_FieldMask) *UpdateMetricDescriptorRequest_CAS_FieldMask {
	result := &UpdateMetricDescriptorRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateMetricDescriptorRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState: &metric_descriptor.MetricDescriptor_FieldMask{},
	}
	mySubMasks := map[UpdateMetricDescriptorRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState: &metric_descriptor.MetricDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateMetricDescriptorRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateMetricDescriptorRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateMetricDescriptorRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState] = metric_descriptor.FullMetricDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*UpdateMetricDescriptorRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateMetricDescriptorRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateMetricDescriptorRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) FilterInputFields() *UpdateMetricDescriptorRequest_CAS_FieldMask {
	result := &UpdateMetricDescriptorRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateMetricDescriptorRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range metric_descriptor.FullMetricDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMetricDescriptorRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateMetricDescriptorRequestCAS_FieldSubPath); ok {
				selectedMask := &metric_descriptor.MetricDescriptor_FieldMask{
					Paths: []metric_descriptor.MetricDescriptor_FieldPath{sub.subPath.(metric_descriptor.MetricDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMetricDescriptorRequestCAS_FieldSubPath{selector: UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateMetricDescriptorRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateMetricDescriptorRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateMetricDescriptorRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateMetricDescriptorRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) AppendPath(path UpdateMetricDescriptorRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateMetricDescriptorRequestCAS_FieldPath))
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) GetPaths() []UpdateMetricDescriptorRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateMetricDescriptorRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) Set(target, source *UpdateMetricDescriptorRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateMetricDescriptorRequest_CAS), source.(*UpdateMetricDescriptorRequest_CAS))
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) Project(source *UpdateMetricDescriptorRequest_CAS) *UpdateMetricDescriptorRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateMetricDescriptorRequest_CAS{}
	conditionalStateMask := &metric_descriptor.MetricDescriptor_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateMetricDescriptorRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateMetricDescriptorRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateMetricDescriptorRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateMetricDescriptorRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(metric_descriptor.MetricDescriptor_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateMetricDescriptorRequest_CAS))
}

func (fieldMask *UpdateMetricDescriptorRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
