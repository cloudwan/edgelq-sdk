// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v3/alerting_condition_service.proto
// DO NOT EDIT!!!

package alerting_condition_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	alerting_condition "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/alerting_condition"
	alerting_policy "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/alerting_policy"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &alerting_condition.AlertingCondition{}
	_ = &alerting_policy.AlertingPolicy{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetAlertingConditionRequest_FieldMask struct {
	Paths []GetAlertingConditionRequest_FieldPath
}

func FullGetAlertingConditionRequest_FieldMask() *GetAlertingConditionRequest_FieldMask {
	res := &GetAlertingConditionRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetAlertingConditionRequest_FieldTerminalPath{selector: GetAlertingConditionRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetAlertingConditionRequest_FieldTerminalPath{selector: GetAlertingConditionRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetAlertingConditionRequest_FieldTerminalPath{selector: GetAlertingConditionRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetAlertingConditionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetAlertingConditionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetAlertingConditionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetAlertingConditionRequest_FieldPath(raw)
	})
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetAlertingConditionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) Subtract(other *GetAlertingConditionRequest_FieldMask) *GetAlertingConditionRequest_FieldMask {
	result := &GetAlertingConditionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetAlertingConditionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetAlertingConditionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetAlertingConditionRequest_FieldMask) FilterInputFields() *GetAlertingConditionRequest_FieldMask {
	result := &GetAlertingConditionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetAlertingConditionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetAlertingConditionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetAlertingConditionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetAlertingConditionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetAlertingConditionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) AppendPath(path GetAlertingConditionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetAlertingConditionRequest_FieldPath))
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) GetPaths() []GetAlertingConditionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetAlertingConditionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) Set(target, source *GetAlertingConditionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetAlertingConditionRequest), source.(*GetAlertingConditionRequest))
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) Project(source *GetAlertingConditionRequest) *GetAlertingConditionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetAlertingConditionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetAlertingConditionRequest_FieldTerminalPath:
			switch tp.selector {
			case GetAlertingConditionRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetAlertingConditionRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetAlertingConditionRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetAlertingConditionRequest))
}

func (fieldMask *GetAlertingConditionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetAlertingConditionsRequest_FieldMask struct {
	Paths []BatchGetAlertingConditionsRequest_FieldPath
}

func FullBatchGetAlertingConditionsRequest_FieldMask() *BatchGetAlertingConditionsRequest_FieldMask {
	res := &BatchGetAlertingConditionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetAlertingConditionsRequest_FieldTerminalPath{selector: BatchGetAlertingConditionsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetAlertingConditionsRequest_FieldTerminalPath{selector: BatchGetAlertingConditionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetAlertingConditionsRequest_FieldTerminalPath{selector: BatchGetAlertingConditionsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetAlertingConditionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetAlertingConditionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetAlertingConditionsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) Subtract(other *BatchGetAlertingConditionsRequest_FieldMask) *BatchGetAlertingConditionsRequest_FieldMask {
	result := &BatchGetAlertingConditionsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetAlertingConditionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetAlertingConditionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) FilterInputFields() *BatchGetAlertingConditionsRequest_FieldMask {
	result := &BatchGetAlertingConditionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetAlertingConditionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetAlertingConditionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetAlertingConditionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetAlertingConditionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) AppendPath(path BatchGetAlertingConditionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetAlertingConditionsRequest_FieldPath))
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) GetPaths() []BatchGetAlertingConditionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetAlertingConditionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) Set(target, source *BatchGetAlertingConditionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetAlertingConditionsRequest), source.(*BatchGetAlertingConditionsRequest))
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) Project(source *BatchGetAlertingConditionsRequest) *BatchGetAlertingConditionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetAlertingConditionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetAlertingConditionsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetAlertingConditionsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetAlertingConditionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetAlertingConditionsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetAlertingConditionsRequest))
}

func (fieldMask *BatchGetAlertingConditionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetAlertingConditionsResponse_FieldMask struct {
	Paths []BatchGetAlertingConditionsResponse_FieldPath
}

func FullBatchGetAlertingConditionsResponse_FieldMask() *BatchGetAlertingConditionsResponse_FieldMask {
	res := &BatchGetAlertingConditionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetAlertingConditionsResponse_FieldTerminalPath{selector: BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions})
	res.Paths = append(res.Paths, &BatchGetAlertingConditionsResponse_FieldTerminalPath{selector: BatchGetAlertingConditionsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetAlertingConditionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetAlertingConditionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetAlertingConditionsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) Subtract(other *BatchGetAlertingConditionsResponse_FieldMask) *BatchGetAlertingConditionsResponse_FieldMask {
	result := &BatchGetAlertingConditionsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetAlertingConditionsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions: &alerting_condition.AlertingCondition_FieldMask{},
	}
	mySubMasks := map[BatchGetAlertingConditionsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions: &alerting_condition.AlertingCondition_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetAlertingConditionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetAlertingConditionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetAlertingConditionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
						mySubMasks[BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions] = alerting_condition.FullAlertingCondition_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetAlertingConditionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetAlertingConditionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetAlertingConditionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) FilterInputFields() *BatchGetAlertingConditionsResponse_FieldMask {
	result := &BatchGetAlertingConditionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
			if _, ok := path.(*BatchGetAlertingConditionsResponse_FieldTerminalPath); ok {
				for _, subpath := range alerting_condition.FullAlertingCondition_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetAlertingConditionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetAlertingConditionsResponse_FieldSubPath); ok {
				selectedMask := &alerting_condition.AlertingCondition_FieldMask{
					Paths: []alerting_condition.AlertingCondition_FieldPath{sub.subPath.(alerting_condition.AlertingCondition_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetAlertingConditionsResponse_FieldSubPath{selector: BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetAlertingConditionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetAlertingConditionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetAlertingConditionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetAlertingConditionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) AppendPath(path BatchGetAlertingConditionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetAlertingConditionsResponse_FieldPath))
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) GetPaths() []BatchGetAlertingConditionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetAlertingConditionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) Set(target, source *BatchGetAlertingConditionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetAlertingConditionsResponse), source.(*BatchGetAlertingConditionsResponse))
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) Project(source *BatchGetAlertingConditionsResponse) *BatchGetAlertingConditionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetAlertingConditionsResponse{}
	alertingConditionsMask := &alerting_condition.AlertingCondition_FieldMask{}
	wholeAlertingConditionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetAlertingConditionsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
				result.AlertingConditions = source.AlertingConditions
				wholeAlertingConditionsAccepted = true
			case BatchGetAlertingConditionsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetAlertingConditionsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
				alertingConditionsMask.AppendPath(tp.subPath.(alerting_condition.AlertingCondition_FieldPath))
			}
		}
	}
	if wholeAlertingConditionsAccepted == false && len(alertingConditionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetAlertingConditions() {
			result.AlertingConditions = append(result.AlertingConditions, alertingConditionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetAlertingConditionsResponse))
}

func (fieldMask *BatchGetAlertingConditionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListAlertingConditionsRequest_FieldMask struct {
	Paths []ListAlertingConditionsRequest_FieldPath
}

func FullListAlertingConditionsRequest_FieldMask() *ListAlertingConditionsRequest_FieldMask {
	res := &ListAlertingConditionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListAlertingConditionsRequest_FieldTerminalPath{selector: ListAlertingConditionsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListAlertingConditionsRequest_FieldTerminalPath{selector: ListAlertingConditionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListAlertingConditionsRequest_FieldTerminalPath{selector: ListAlertingConditionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListAlertingConditionsRequest_FieldTerminalPath{selector: ListAlertingConditionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListAlertingConditionsRequest_FieldTerminalPath{selector: ListAlertingConditionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListAlertingConditionsRequest_FieldTerminalPath{selector: ListAlertingConditionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListAlertingConditionsRequest_FieldTerminalPath{selector: ListAlertingConditionsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListAlertingConditionsRequest_FieldTerminalPath{selector: ListAlertingConditionsRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListAlertingConditionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListAlertingConditionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListAlertingConditionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListAlertingConditionsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) Subtract(other *ListAlertingConditionsRequest_FieldMask) *ListAlertingConditionsRequest_FieldMask {
	result := &ListAlertingConditionsRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListAlertingConditionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListAlertingConditionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListAlertingConditionsRequest_FieldMask) FilterInputFields() *ListAlertingConditionsRequest_FieldMask {
	result := &ListAlertingConditionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListAlertingConditionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListAlertingConditionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListAlertingConditionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListAlertingConditionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListAlertingConditionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) AppendPath(path ListAlertingConditionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListAlertingConditionsRequest_FieldPath))
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) GetPaths() []ListAlertingConditionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListAlertingConditionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) Set(target, source *ListAlertingConditionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListAlertingConditionsRequest), source.(*ListAlertingConditionsRequest))
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) Project(source *ListAlertingConditionsRequest) *ListAlertingConditionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListAlertingConditionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListAlertingConditionsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListAlertingConditionsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListAlertingConditionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListAlertingConditionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListAlertingConditionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListAlertingConditionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListAlertingConditionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListAlertingConditionsRequest_FieldPathSelectorView:
				result.View = source.View
			case ListAlertingConditionsRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListAlertingConditionsRequest))
}

func (fieldMask *ListAlertingConditionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListAlertingConditionsResponse_FieldMask struct {
	Paths []ListAlertingConditionsResponse_FieldPath
}

func FullListAlertingConditionsResponse_FieldMask() *ListAlertingConditionsResponse_FieldMask {
	res := &ListAlertingConditionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListAlertingConditionsResponse_FieldTerminalPath{selector: ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions})
	res.Paths = append(res.Paths, &ListAlertingConditionsResponse_FieldTerminalPath{selector: ListAlertingConditionsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListAlertingConditionsResponse_FieldTerminalPath{selector: ListAlertingConditionsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListAlertingConditionsResponse_FieldTerminalPath{selector: ListAlertingConditionsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListAlertingConditionsResponse_FieldTerminalPath{selector: ListAlertingConditionsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListAlertingConditionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListAlertingConditionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListAlertingConditionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListAlertingConditionsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) Subtract(other *ListAlertingConditionsResponse_FieldMask) *ListAlertingConditionsResponse_FieldMask {
	result := &ListAlertingConditionsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListAlertingConditionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions: &alerting_condition.AlertingCondition_FieldMask{},
	}
	mySubMasks := map[ListAlertingConditionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions: &alerting_condition.AlertingCondition_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListAlertingConditionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListAlertingConditionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListAlertingConditionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
						mySubMasks[ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions] = alerting_condition.FullAlertingCondition_FieldMask()
					}
				} else if tp, ok := path.(*ListAlertingConditionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListAlertingConditionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListAlertingConditionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListAlertingConditionsResponse_FieldMask) FilterInputFields() *ListAlertingConditionsResponse_FieldMask {
	result := &ListAlertingConditionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
			if _, ok := path.(*ListAlertingConditionsResponse_FieldTerminalPath); ok {
				for _, subpath := range alerting_condition.FullAlertingCondition_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListAlertingConditionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListAlertingConditionsResponse_FieldSubPath); ok {
				selectedMask := &alerting_condition.AlertingCondition_FieldMask{
					Paths: []alerting_condition.AlertingCondition_FieldPath{sub.subPath.(alerting_condition.AlertingCondition_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListAlertingConditionsResponse_FieldSubPath{selector: ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListAlertingConditionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListAlertingConditionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListAlertingConditionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListAlertingConditionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListAlertingConditionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) AppendPath(path ListAlertingConditionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListAlertingConditionsResponse_FieldPath))
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) GetPaths() []ListAlertingConditionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListAlertingConditionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) Set(target, source *ListAlertingConditionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListAlertingConditionsResponse), source.(*ListAlertingConditionsResponse))
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) Project(source *ListAlertingConditionsResponse) *ListAlertingConditionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListAlertingConditionsResponse{}
	alertingConditionsMask := &alerting_condition.AlertingCondition_FieldMask{}
	wholeAlertingConditionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListAlertingConditionsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
				result.AlertingConditions = source.AlertingConditions
				wholeAlertingConditionsAccepted = true
			case ListAlertingConditionsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListAlertingConditionsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListAlertingConditionsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListAlertingConditionsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListAlertingConditionsResponse_FieldSubPath:
			switch tp.selector {
			case ListAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
				alertingConditionsMask.AppendPath(tp.subPath.(alerting_condition.AlertingCondition_FieldPath))
			}
		}
	}
	if wholeAlertingConditionsAccepted == false && len(alertingConditionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetAlertingConditions() {
			result.AlertingConditions = append(result.AlertingConditions, alertingConditionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListAlertingConditionsResponse))
}

func (fieldMask *ListAlertingConditionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAlertingConditionRequest_FieldMask struct {
	Paths []WatchAlertingConditionRequest_FieldPath
}

func FullWatchAlertingConditionRequest_FieldMask() *WatchAlertingConditionRequest_FieldMask {
	res := &WatchAlertingConditionRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchAlertingConditionRequest_FieldTerminalPath{selector: WatchAlertingConditionRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchAlertingConditionRequest_FieldTerminalPath{selector: WatchAlertingConditionRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchAlertingConditionRequest_FieldTerminalPath{selector: WatchAlertingConditionRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAlertingConditionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAlertingConditionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAlertingConditionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAlertingConditionRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) Subtract(other *WatchAlertingConditionRequest_FieldMask) *WatchAlertingConditionRequest_FieldMask {
	result := &WatchAlertingConditionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAlertingConditionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAlertingConditionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAlertingConditionRequest_FieldMask) FilterInputFields() *WatchAlertingConditionRequest_FieldMask {
	result := &WatchAlertingConditionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAlertingConditionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAlertingConditionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAlertingConditionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAlertingConditionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAlertingConditionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) AppendPath(path WatchAlertingConditionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAlertingConditionRequest_FieldPath))
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) GetPaths() []WatchAlertingConditionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAlertingConditionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) Set(target, source *WatchAlertingConditionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAlertingConditionRequest), source.(*WatchAlertingConditionRequest))
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) Project(source *WatchAlertingConditionRequest) *WatchAlertingConditionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAlertingConditionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAlertingConditionRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchAlertingConditionRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchAlertingConditionRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchAlertingConditionRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAlertingConditionRequest))
}

func (fieldMask *WatchAlertingConditionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAlertingConditionResponse_FieldMask struct {
	Paths []WatchAlertingConditionResponse_FieldPath
}

func FullWatchAlertingConditionResponse_FieldMask() *WatchAlertingConditionResponse_FieldMask {
	res := &WatchAlertingConditionResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchAlertingConditionResponse_FieldTerminalPath{selector: WatchAlertingConditionResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAlertingConditionResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAlertingConditionResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAlertingConditionResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAlertingConditionResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) Subtract(other *WatchAlertingConditionResponse_FieldMask) *WatchAlertingConditionResponse_FieldMask {
	result := &WatchAlertingConditionResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAlertingConditionResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAlertingConditionResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAlertingConditionResponse_FieldMask) FilterInputFields() *WatchAlertingConditionResponse_FieldMask {
	result := &WatchAlertingConditionResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAlertingConditionResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAlertingConditionResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAlertingConditionResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAlertingConditionResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAlertingConditionResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) AppendPath(path WatchAlertingConditionResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAlertingConditionResponse_FieldPath))
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) GetPaths() []WatchAlertingConditionResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAlertingConditionResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) Set(target, source *WatchAlertingConditionResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAlertingConditionResponse), source.(*WatchAlertingConditionResponse))
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) Project(source *WatchAlertingConditionResponse) *WatchAlertingConditionResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAlertingConditionResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAlertingConditionResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchAlertingConditionResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAlertingConditionResponse))
}

func (fieldMask *WatchAlertingConditionResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAlertingConditionsRequest_FieldMask struct {
	Paths []WatchAlertingConditionsRequest_FieldPath
}

func FullWatchAlertingConditionsRequest_FieldMask() *WatchAlertingConditionsRequest_FieldMask {
	res := &WatchAlertingConditionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchAlertingConditionsRequest_FieldTerminalPath{selector: WatchAlertingConditionsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAlertingConditionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAlertingConditionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAlertingConditionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAlertingConditionsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) Subtract(other *WatchAlertingConditionsRequest_FieldMask) *WatchAlertingConditionsRequest_FieldMask {
	result := &WatchAlertingConditionsRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAlertingConditionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAlertingConditionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAlertingConditionsRequest_FieldMask) FilterInputFields() *WatchAlertingConditionsRequest_FieldMask {
	result := &WatchAlertingConditionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAlertingConditionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAlertingConditionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAlertingConditionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAlertingConditionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAlertingConditionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) AppendPath(path WatchAlertingConditionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAlertingConditionsRequest_FieldPath))
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) GetPaths() []WatchAlertingConditionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAlertingConditionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) Set(target, source *WatchAlertingConditionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAlertingConditionsRequest), source.(*WatchAlertingConditionsRequest))
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) Project(source *WatchAlertingConditionsRequest) *WatchAlertingConditionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAlertingConditionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAlertingConditionsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchAlertingConditionsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchAlertingConditionsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchAlertingConditionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchAlertingConditionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchAlertingConditionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchAlertingConditionsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchAlertingConditionsRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchAlertingConditionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchAlertingConditionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchAlertingConditionsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchAlertingConditionsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAlertingConditionsRequest))
}

func (fieldMask *WatchAlertingConditionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAlertingConditionsResponse_FieldMask struct {
	Paths []WatchAlertingConditionsResponse_FieldPath
}

func FullWatchAlertingConditionsResponse_FieldMask() *WatchAlertingConditionsResponse_FieldMask {
	res := &WatchAlertingConditionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponse_FieldTerminalPath{selector: WatchAlertingConditionsResponse_FieldPathSelectorAlertingConditionChanges})
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponse_FieldTerminalPath{selector: WatchAlertingConditionsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponse_FieldTerminalPath{selector: WatchAlertingConditionsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponse_FieldTerminalPath{selector: WatchAlertingConditionsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponse_FieldTerminalPath{selector: WatchAlertingConditionsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponse_FieldTerminalPath{selector: WatchAlertingConditionsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponse_FieldTerminalPath{selector: WatchAlertingConditionsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAlertingConditionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAlertingConditionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAlertingConditionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAlertingConditionsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) Subtract(other *WatchAlertingConditionsResponse_FieldMask) *WatchAlertingConditionsResponse_FieldMask {
	result := &WatchAlertingConditionsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchAlertingConditionsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchAlertingConditionsResponse_FieldPathSelectorPageTokenChange: &WatchAlertingConditionsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchAlertingConditionsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchAlertingConditionsResponse_FieldPathSelectorPageTokenChange: &WatchAlertingConditionsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAlertingConditionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchAlertingConditionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchAlertingConditionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchAlertingConditionsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchAlertingConditionsResponse_FieldPathSelectorPageTokenChange] = FullWatchAlertingConditionsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchAlertingConditionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchAlertingConditionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAlertingConditionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAlertingConditionsResponse_FieldMask) FilterInputFields() *WatchAlertingConditionsResponse_FieldMask {
	result := &WatchAlertingConditionsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAlertingConditionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAlertingConditionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAlertingConditionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAlertingConditionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAlertingConditionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) AppendPath(path WatchAlertingConditionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAlertingConditionsResponse_FieldPath))
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) GetPaths() []WatchAlertingConditionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAlertingConditionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) Set(target, source *WatchAlertingConditionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAlertingConditionsResponse), source.(*WatchAlertingConditionsResponse))
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) Project(source *WatchAlertingConditionsResponse) *WatchAlertingConditionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAlertingConditionsResponse{}
	pageTokenChangeMask := &WatchAlertingConditionsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAlertingConditionsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchAlertingConditionsResponse_FieldPathSelectorAlertingConditionChanges:
				result.AlertingConditionChanges = source.AlertingConditionChanges
			case WatchAlertingConditionsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchAlertingConditionsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchAlertingConditionsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchAlertingConditionsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchAlertingConditionsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchAlertingConditionsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchAlertingConditionsResponse_FieldSubPath:
			switch tp.selector {
			case WatchAlertingConditionsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchAlertingConditionsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAlertingConditionsResponse))
}

func (fieldMask *WatchAlertingConditionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchAlertingConditionsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchAlertingConditionsResponsePageTokenChange_FieldPath
}

func FullWatchAlertingConditionsResponse_PageTokenChange_FieldMask() *WatchAlertingConditionsResponse_PageTokenChange_FieldMask {
	res := &WatchAlertingConditionsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponsePageTokenChange_FieldTerminalPath{selector: WatchAlertingConditionsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchAlertingConditionsResponsePageTokenChange_FieldTerminalPath{selector: WatchAlertingConditionsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchAlertingConditionsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchAlertingConditionsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchAlertingConditionsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) Subtract(other *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) *WatchAlertingConditionsResponse_PageTokenChange_FieldMask {
	result := &WatchAlertingConditionsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchAlertingConditionsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchAlertingConditionsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchAlertingConditionsResponse_PageTokenChange_FieldMask {
	result := &WatchAlertingConditionsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchAlertingConditionsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchAlertingConditionsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchAlertingConditionsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchAlertingConditionsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) AppendPath(path WatchAlertingConditionsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchAlertingConditionsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) GetPaths() []WatchAlertingConditionsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchAlertingConditionsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) Set(target, source *WatchAlertingConditionsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchAlertingConditionsResponse_PageTokenChange), source.(*WatchAlertingConditionsResponse_PageTokenChange))
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) Project(source *WatchAlertingConditionsResponse_PageTokenChange) *WatchAlertingConditionsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchAlertingConditionsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchAlertingConditionsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchAlertingConditionsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchAlertingConditionsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchAlertingConditionsResponse_PageTokenChange))
}

func (fieldMask *WatchAlertingConditionsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateAlertingConditionRequest_FieldMask struct {
	Paths []CreateAlertingConditionRequest_FieldPath
}

func FullCreateAlertingConditionRequest_FieldMask() *CreateAlertingConditionRequest_FieldMask {
	res := &CreateAlertingConditionRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateAlertingConditionRequest_FieldTerminalPath{selector: CreateAlertingConditionRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateAlertingConditionRequest_FieldTerminalPath{selector: CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition})
	return res
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateAlertingConditionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateAlertingConditionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateAlertingConditionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateAlertingConditionRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) Subtract(other *CreateAlertingConditionRequest_FieldMask) *CreateAlertingConditionRequest_FieldMask {
	result := &CreateAlertingConditionRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateAlertingConditionRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition: &alerting_condition.AlertingCondition_FieldMask{},
	}
	mySubMasks := map[CreateAlertingConditionRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition: &alerting_condition.AlertingCondition_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateAlertingConditionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateAlertingConditionRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateAlertingConditionRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition:
						mySubMasks[CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition] = alerting_condition.FullAlertingCondition_FieldMask()
					}
				} else if tp, ok := path.(*CreateAlertingConditionRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateAlertingConditionRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateAlertingConditionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateAlertingConditionRequest_FieldMask) FilterInputFields() *CreateAlertingConditionRequest_FieldMask {
	result := &CreateAlertingConditionRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition:
			if _, ok := path.(*CreateAlertingConditionRequest_FieldTerminalPath); ok {
				for _, subpath := range alerting_condition.FullAlertingCondition_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateAlertingConditionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateAlertingConditionRequest_FieldSubPath); ok {
				selectedMask := &alerting_condition.AlertingCondition_FieldMask{
					Paths: []alerting_condition.AlertingCondition_FieldPath{sub.subPath.(alerting_condition.AlertingCondition_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateAlertingConditionRequest_FieldSubPath{selector: CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateAlertingConditionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateAlertingConditionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateAlertingConditionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateAlertingConditionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateAlertingConditionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) AppendPath(path CreateAlertingConditionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateAlertingConditionRequest_FieldPath))
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) GetPaths() []CreateAlertingConditionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateAlertingConditionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) Set(target, source *CreateAlertingConditionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateAlertingConditionRequest), source.(*CreateAlertingConditionRequest))
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) Project(source *CreateAlertingConditionRequest) *CreateAlertingConditionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateAlertingConditionRequest{}
	alertingConditionMask := &alerting_condition.AlertingCondition_FieldMask{}
	wholeAlertingConditionAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateAlertingConditionRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateAlertingConditionRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition:
				result.AlertingCondition = source.AlertingCondition
				wholeAlertingConditionAccepted = true
			}
		case *CreateAlertingConditionRequest_FieldSubPath:
			switch tp.selector {
			case CreateAlertingConditionRequest_FieldPathSelectorAlertingCondition:
				alertingConditionMask.AppendPath(tp.subPath.(alerting_condition.AlertingCondition_FieldPath))
			}
		}
	}
	if wholeAlertingConditionAccepted == false && len(alertingConditionMask.Paths) > 0 {
		result.AlertingCondition = alertingConditionMask.Project(source.GetAlertingCondition())
	}
	return result
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateAlertingConditionRequest))
}

func (fieldMask *CreateAlertingConditionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateAlertingConditionRequest_FieldMask struct {
	Paths []UpdateAlertingConditionRequest_FieldPath
}

func FullUpdateAlertingConditionRequest_FieldMask() *UpdateAlertingConditionRequest_FieldMask {
	res := &UpdateAlertingConditionRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateAlertingConditionRequest_FieldTerminalPath{selector: UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition})
	res.Paths = append(res.Paths, &UpdateAlertingConditionRequest_FieldTerminalPath{selector: UpdateAlertingConditionRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateAlertingConditionRequest_FieldTerminalPath{selector: UpdateAlertingConditionRequest_FieldPathSelectorCas})
	res.Paths = append(res.Paths, &UpdateAlertingConditionRequest_FieldTerminalPath{selector: UpdateAlertingConditionRequest_FieldPathSelectorAllowMissing})
	return res
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateAlertingConditionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateAlertingConditionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateAlertingConditionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateAlertingConditionRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) Subtract(other *UpdateAlertingConditionRequest_FieldMask) *UpdateAlertingConditionRequest_FieldMask {
	result := &UpdateAlertingConditionRequest_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[UpdateAlertingConditionRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition: &alerting_condition.AlertingCondition_FieldMask{},
		UpdateAlertingConditionRequest_FieldPathSelectorCas:               &UpdateAlertingConditionRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateAlertingConditionRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition: &alerting_condition.AlertingCondition_FieldMask{},
		UpdateAlertingConditionRequest_FieldPathSelectorCas:               &UpdateAlertingConditionRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateAlertingConditionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateAlertingConditionRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateAlertingConditionRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition:
						mySubMasks[UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition] = alerting_condition.FullAlertingCondition_FieldMask()
					case UpdateAlertingConditionRequest_FieldPathSelectorCas:
						mySubMasks[UpdateAlertingConditionRequest_FieldPathSelectorCas] = FullUpdateAlertingConditionRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateAlertingConditionRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateAlertingConditionRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateAlertingConditionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateAlertingConditionRequest_FieldMask) FilterInputFields() *UpdateAlertingConditionRequest_FieldMask {
	result := &UpdateAlertingConditionRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition:
			if _, ok := path.(*UpdateAlertingConditionRequest_FieldTerminalPath); ok {
				for _, subpath := range alerting_condition.FullAlertingCondition_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAlertingConditionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateAlertingConditionRequest_FieldSubPath); ok {
				selectedMask := &alerting_condition.AlertingCondition_FieldMask{
					Paths: []alerting_condition.AlertingCondition_FieldPath{sub.subPath.(alerting_condition.AlertingCondition_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAlertingConditionRequest_FieldSubPath{selector: UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition, subPath: allowedPath})
				}
			}
		case UpdateAlertingConditionRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateAlertingConditionRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateAlertingConditionRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAlertingConditionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateAlertingConditionRequest_FieldSubPath); ok {
				selectedMask := &UpdateAlertingConditionRequest_CAS_FieldMask{
					Paths: []UpdateAlertingConditionRequestCAS_FieldPath{sub.subPath.(UpdateAlertingConditionRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAlertingConditionRequest_FieldSubPath{selector: UpdateAlertingConditionRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateAlertingConditionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateAlertingConditionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateAlertingConditionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateAlertingConditionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateAlertingConditionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) AppendPath(path UpdateAlertingConditionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateAlertingConditionRequest_FieldPath))
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) GetPaths() []UpdateAlertingConditionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateAlertingConditionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) Set(target, source *UpdateAlertingConditionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateAlertingConditionRequest), source.(*UpdateAlertingConditionRequest))
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) Project(source *UpdateAlertingConditionRequest) *UpdateAlertingConditionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateAlertingConditionRequest{}
	alertingConditionMask := &alerting_condition.AlertingCondition_FieldMask{}
	wholeAlertingConditionAccepted := false
	casMask := &UpdateAlertingConditionRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateAlertingConditionRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition:
				result.AlertingCondition = source.AlertingCondition
				wholeAlertingConditionAccepted = true
			case UpdateAlertingConditionRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateAlertingConditionRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			case UpdateAlertingConditionRequest_FieldPathSelectorAllowMissing:
				result.AllowMissing = source.AllowMissing
			}
		case *UpdateAlertingConditionRequest_FieldSubPath:
			switch tp.selector {
			case UpdateAlertingConditionRequest_FieldPathSelectorAlertingCondition:
				alertingConditionMask.AppendPath(tp.subPath.(alerting_condition.AlertingCondition_FieldPath))
			case UpdateAlertingConditionRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateAlertingConditionRequestCAS_FieldPath))
			}
		}
	}
	if wholeAlertingConditionAccepted == false && len(alertingConditionMask.Paths) > 0 {
		result.AlertingCondition = alertingConditionMask.Project(source.GetAlertingCondition())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateAlertingConditionRequest))
}

func (fieldMask *UpdateAlertingConditionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateAlertingConditionRequest_CAS_FieldMask struct {
	Paths []UpdateAlertingConditionRequestCAS_FieldPath
}

func FullUpdateAlertingConditionRequest_CAS_FieldMask() *UpdateAlertingConditionRequest_CAS_FieldMask {
	res := &UpdateAlertingConditionRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateAlertingConditionRequestCAS_FieldTerminalPath{selector: UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateAlertingConditionRequestCAS_FieldTerminalPath{selector: UpdateAlertingConditionRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateAlertingConditionRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateAlertingConditionRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateAlertingConditionRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) Subtract(other *UpdateAlertingConditionRequest_CAS_FieldMask) *UpdateAlertingConditionRequest_CAS_FieldMask {
	result := &UpdateAlertingConditionRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateAlertingConditionRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState: &alerting_condition.AlertingCondition_FieldMask{},
	}
	mySubMasks := map[UpdateAlertingConditionRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState: &alerting_condition.AlertingCondition_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateAlertingConditionRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateAlertingConditionRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateAlertingConditionRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState] = alerting_condition.FullAlertingCondition_FieldMask()
					}
				} else if tp, ok := path.(*UpdateAlertingConditionRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateAlertingConditionRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateAlertingConditionRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) FilterInputFields() *UpdateAlertingConditionRequest_CAS_FieldMask {
	result := &UpdateAlertingConditionRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateAlertingConditionRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range alerting_condition.FullAlertingCondition_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAlertingConditionRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateAlertingConditionRequestCAS_FieldSubPath); ok {
				selectedMask := &alerting_condition.AlertingCondition_FieldMask{
					Paths: []alerting_condition.AlertingCondition_FieldPath{sub.subPath.(alerting_condition.AlertingCondition_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateAlertingConditionRequestCAS_FieldSubPath{selector: UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateAlertingConditionRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateAlertingConditionRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateAlertingConditionRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateAlertingConditionRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) AppendPath(path UpdateAlertingConditionRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateAlertingConditionRequestCAS_FieldPath))
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) GetPaths() []UpdateAlertingConditionRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateAlertingConditionRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) Set(target, source *UpdateAlertingConditionRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateAlertingConditionRequest_CAS), source.(*UpdateAlertingConditionRequest_CAS))
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) Project(source *UpdateAlertingConditionRequest_CAS) *UpdateAlertingConditionRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateAlertingConditionRequest_CAS{}
	conditionalStateMask := &alerting_condition.AlertingCondition_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateAlertingConditionRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateAlertingConditionRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateAlertingConditionRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateAlertingConditionRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(alerting_condition.AlertingCondition_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateAlertingConditionRequest_CAS))
}

func (fieldMask *UpdateAlertingConditionRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteAlertingConditionRequest_FieldMask struct {
	Paths []DeleteAlertingConditionRequest_FieldPath
}

func FullDeleteAlertingConditionRequest_FieldMask() *DeleteAlertingConditionRequest_FieldMask {
	res := &DeleteAlertingConditionRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteAlertingConditionRequest_FieldTerminalPath{selector: DeleteAlertingConditionRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteAlertingConditionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteAlertingConditionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteAlertingConditionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteAlertingConditionRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) Subtract(other *DeleteAlertingConditionRequest_FieldMask) *DeleteAlertingConditionRequest_FieldMask {
	result := &DeleteAlertingConditionRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteAlertingConditionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteAlertingConditionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteAlertingConditionRequest_FieldMask) FilterInputFields() *DeleteAlertingConditionRequest_FieldMask {
	result := &DeleteAlertingConditionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteAlertingConditionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteAlertingConditionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteAlertingConditionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteAlertingConditionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteAlertingConditionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) AppendPath(path DeleteAlertingConditionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteAlertingConditionRequest_FieldPath))
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) GetPaths() []DeleteAlertingConditionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteAlertingConditionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) Set(target, source *DeleteAlertingConditionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteAlertingConditionRequest), source.(*DeleteAlertingConditionRequest))
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) Project(source *DeleteAlertingConditionRequest) *DeleteAlertingConditionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteAlertingConditionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteAlertingConditionRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteAlertingConditionRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteAlertingConditionRequest))
}

func (fieldMask *DeleteAlertingConditionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SearchAlertingConditionsRequest_FieldMask struct {
	Paths []SearchAlertingConditionsRequest_FieldPath
}

func FullSearchAlertingConditionsRequest_FieldMask() *SearchAlertingConditionsRequest_FieldMask {
	res := &SearchAlertingConditionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &SearchAlertingConditionsRequest_FieldTerminalPath{selector: SearchAlertingConditionsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &SearchAlertingConditionsRequest_FieldTerminalPath{selector: SearchAlertingConditionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &SearchAlertingConditionsRequest_FieldTerminalPath{selector: SearchAlertingConditionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &SearchAlertingConditionsRequest_FieldTerminalPath{selector: SearchAlertingConditionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &SearchAlertingConditionsRequest_FieldTerminalPath{selector: SearchAlertingConditionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &SearchAlertingConditionsRequest_FieldTerminalPath{selector: SearchAlertingConditionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &SearchAlertingConditionsRequest_FieldTerminalPath{selector: SearchAlertingConditionsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &SearchAlertingConditionsRequest_FieldTerminalPath{selector: SearchAlertingConditionsRequest_FieldPathSelectorPhrase})
	return res
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SearchAlertingConditionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSearchAlertingConditionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SearchAlertingConditionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSearchAlertingConditionsRequest_FieldPath(raw)
	})
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) Subtract(other *SearchAlertingConditionsRequest_FieldMask) *SearchAlertingConditionsRequest_FieldMask {
	result := &SearchAlertingConditionsRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SearchAlertingConditionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SearchAlertingConditionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SearchAlertingConditionsRequest_FieldMask) FilterInputFields() *SearchAlertingConditionsRequest_FieldMask {
	result := &SearchAlertingConditionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SearchAlertingConditionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SearchAlertingConditionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSearchAlertingConditionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SearchAlertingConditionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SearchAlertingConditionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) AppendPath(path SearchAlertingConditionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SearchAlertingConditionsRequest_FieldPath))
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) GetPaths() []SearchAlertingConditionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSearchAlertingConditionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) Set(target, source *SearchAlertingConditionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SearchAlertingConditionsRequest), source.(*SearchAlertingConditionsRequest))
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) Project(source *SearchAlertingConditionsRequest) *SearchAlertingConditionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SearchAlertingConditionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SearchAlertingConditionsRequest_FieldTerminalPath:
			switch tp.selector {
			case SearchAlertingConditionsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case SearchAlertingConditionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case SearchAlertingConditionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case SearchAlertingConditionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case SearchAlertingConditionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case SearchAlertingConditionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case SearchAlertingConditionsRequest_FieldPathSelectorView:
				result.View = source.View
			case SearchAlertingConditionsRequest_FieldPathSelectorPhrase:
				result.Phrase = source.Phrase
			}
		}
	}
	return result
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SearchAlertingConditionsRequest))
}

func (fieldMask *SearchAlertingConditionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SearchAlertingConditionsResponse_FieldMask struct {
	Paths []SearchAlertingConditionsResponse_FieldPath
}

func FullSearchAlertingConditionsResponse_FieldMask() *SearchAlertingConditionsResponse_FieldMask {
	res := &SearchAlertingConditionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &SearchAlertingConditionsResponse_FieldTerminalPath{selector: SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions})
	res.Paths = append(res.Paths, &SearchAlertingConditionsResponse_FieldTerminalPath{selector: SearchAlertingConditionsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &SearchAlertingConditionsResponse_FieldTerminalPath{selector: SearchAlertingConditionsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &SearchAlertingConditionsResponse_FieldTerminalPath{selector: SearchAlertingConditionsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &SearchAlertingConditionsResponse_FieldTerminalPath{selector: SearchAlertingConditionsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SearchAlertingConditionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSearchAlertingConditionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SearchAlertingConditionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSearchAlertingConditionsResponse_FieldPath(raw)
	})
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) Subtract(other *SearchAlertingConditionsResponse_FieldMask) *SearchAlertingConditionsResponse_FieldMask {
	result := &SearchAlertingConditionsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[SearchAlertingConditionsResponse_FieldPathSelector]gotenobject.FieldMask{
		SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions: &alerting_condition.AlertingCondition_FieldMask{},
	}
	mySubMasks := map[SearchAlertingConditionsResponse_FieldPathSelector]gotenobject.FieldMask{
		SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions: &alerting_condition.AlertingCondition_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SearchAlertingConditionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *SearchAlertingConditionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*SearchAlertingConditionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
						mySubMasks[SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions] = alerting_condition.FullAlertingCondition_FieldMask()
					}
				} else if tp, ok := path.(*SearchAlertingConditionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &SearchAlertingConditionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SearchAlertingConditionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SearchAlertingConditionsResponse_FieldMask) FilterInputFields() *SearchAlertingConditionsResponse_FieldMask {
	result := &SearchAlertingConditionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
			if _, ok := path.(*SearchAlertingConditionsResponse_FieldTerminalPath); ok {
				for _, subpath := range alerting_condition.FullAlertingCondition_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &SearchAlertingConditionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*SearchAlertingConditionsResponse_FieldSubPath); ok {
				selectedMask := &alerting_condition.AlertingCondition_FieldMask{
					Paths: []alerting_condition.AlertingCondition_FieldPath{sub.subPath.(alerting_condition.AlertingCondition_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &SearchAlertingConditionsResponse_FieldSubPath{selector: SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SearchAlertingConditionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SearchAlertingConditionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSearchAlertingConditionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SearchAlertingConditionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SearchAlertingConditionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) AppendPath(path SearchAlertingConditionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SearchAlertingConditionsResponse_FieldPath))
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) GetPaths() []SearchAlertingConditionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSearchAlertingConditionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) Set(target, source *SearchAlertingConditionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SearchAlertingConditionsResponse), source.(*SearchAlertingConditionsResponse))
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) Project(source *SearchAlertingConditionsResponse) *SearchAlertingConditionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SearchAlertingConditionsResponse{}
	alertingConditionsMask := &alerting_condition.AlertingCondition_FieldMask{}
	wholeAlertingConditionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SearchAlertingConditionsResponse_FieldTerminalPath:
			switch tp.selector {
			case SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
				result.AlertingConditions = source.AlertingConditions
				wholeAlertingConditionsAccepted = true
			case SearchAlertingConditionsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case SearchAlertingConditionsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case SearchAlertingConditionsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case SearchAlertingConditionsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *SearchAlertingConditionsResponse_FieldSubPath:
			switch tp.selector {
			case SearchAlertingConditionsResponse_FieldPathSelectorAlertingConditions:
				alertingConditionsMask.AppendPath(tp.subPath.(alerting_condition.AlertingCondition_FieldPath))
			}
		}
	}
	if wholeAlertingConditionsAccepted == false && len(alertingConditionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetAlertingConditions() {
			result.AlertingConditions = append(result.AlertingConditions, alertingConditionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SearchAlertingConditionsResponse))
}

func (fieldMask *SearchAlertingConditionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
