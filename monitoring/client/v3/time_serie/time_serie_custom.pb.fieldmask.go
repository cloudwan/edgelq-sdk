// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v3/time_serie_custom.proto
// DO NOT EDIT!!!

package time_serie_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	rpc "github.com/cloudwan/edgelq-sdk/common/rpc"
	monitoring_common "github.com/cloudwan/edgelq-sdk/monitoring/common/v3"
	project "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/project"
	time_serie "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/time_serie"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &rpc.Status{}
	_ = &monitoring_common.LabelDescriptor{}
	_ = &project.Project{}
	_ = &time_serie.Point{}
	_ = &field_mask.FieldMask{}
)

type ListTimeSeriesRequest_FieldMask struct {
	Paths []ListTimeSeriesRequest_FieldPath
}

func FullListTimeSeriesRequest_FieldMask() *ListTimeSeriesRequest_FieldMask {
	res := &ListTimeSeriesRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorInterval})
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorAggregation})
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListTimeSeriesRequest_FieldTerminalPath{selector: ListTimeSeriesRequest_FieldPathSelectorPageToken})
	return res
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListTimeSeriesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListTimeSeriesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListTimeSeriesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListTimeSeriesRequest_FieldPath(raw)
	})
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListTimeSeriesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) Subtract(other *ListTimeSeriesRequest_FieldMask) *ListTimeSeriesRequest_FieldMask {
	result := &ListTimeSeriesRequest_FieldMask{}
	removedSelectors := make([]bool, 9)
	otherSubMasks := map[ListTimeSeriesRequest_FieldPathSelector]gotenobject.FieldMask{
		ListTimeSeriesRequest_FieldPathSelectorInterval:    &monitoring_common.TimeInterval_FieldMask{},
		ListTimeSeriesRequest_FieldPathSelectorAggregation: &monitoring_common.Aggregation_FieldMask{},
	}
	mySubMasks := map[ListTimeSeriesRequest_FieldPathSelector]gotenobject.FieldMask{
		ListTimeSeriesRequest_FieldPathSelectorInterval:    &monitoring_common.TimeInterval_FieldMask{},
		ListTimeSeriesRequest_FieldPathSelectorAggregation: &monitoring_common.Aggregation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListTimeSeriesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListTimeSeriesRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListTimeSeriesRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case ListTimeSeriesRequest_FieldPathSelectorInterval:
						mySubMasks[ListTimeSeriesRequest_FieldPathSelectorInterval] = monitoring_common.FullTimeInterval_FieldMask()
					case ListTimeSeriesRequest_FieldPathSelectorAggregation:
						mySubMasks[ListTimeSeriesRequest_FieldPathSelectorAggregation] = monitoring_common.FullAggregation_FieldMask()
					}
				} else if tp, ok := path.(*ListTimeSeriesRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListTimeSeriesRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListTimeSeriesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListTimeSeriesRequest_FieldMask) FilterInputFields() *ListTimeSeriesRequest_FieldMask {
	result := &ListTimeSeriesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListTimeSeriesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListTimeSeriesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListTimeSeriesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListTimeSeriesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListTimeSeriesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) AppendPath(path ListTimeSeriesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListTimeSeriesRequest_FieldPath))
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) GetPaths() []ListTimeSeriesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListTimeSeriesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) Set(target, source *ListTimeSeriesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListTimeSeriesRequest), source.(*ListTimeSeriesRequest))
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) Project(source *ListTimeSeriesRequest) *ListTimeSeriesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListTimeSeriesRequest{}
	intervalMask := &monitoring_common.TimeInterval_FieldMask{}
	wholeIntervalAccepted := false
	aggregationMask := &monitoring_common.Aggregation_FieldMask{}
	wholeAggregationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListTimeSeriesRequest_FieldTerminalPath:
			switch tp.selector {
			case ListTimeSeriesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListTimeSeriesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListTimeSeriesRequest_FieldPathSelectorInterval:
				result.Interval = source.Interval
				wholeIntervalAccepted = true
			case ListTimeSeriesRequest_FieldPathSelectorAggregation:
				result.Aggregation = source.Aggregation
				wholeAggregationAccepted = true
			case ListTimeSeriesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListTimeSeriesRequest_FieldPathSelectorView:
				result.View = source.View
			case ListTimeSeriesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListTimeSeriesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListTimeSeriesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			}
		case *ListTimeSeriesRequest_FieldSubPath:
			switch tp.selector {
			case ListTimeSeriesRequest_FieldPathSelectorInterval:
				intervalMask.AppendPath(tp.subPath.(monitoring_common.TimeInterval_FieldPath))
			case ListTimeSeriesRequest_FieldPathSelectorAggregation:
				aggregationMask.AppendPath(tp.subPath.(monitoring_common.Aggregation_FieldPath))
			}
		}
	}
	if wholeIntervalAccepted == false && len(intervalMask.Paths) > 0 {
		result.Interval = intervalMask.Project(source.GetInterval())
	}
	if wholeAggregationAccepted == false && len(aggregationMask.Paths) > 0 {
		result.Aggregation = aggregationMask.Project(source.GetAggregation())
	}
	return result
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListTimeSeriesRequest))
}

func (fieldMask *ListTimeSeriesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListTimeSeriesResponse_FieldMask struct {
	Paths []ListTimeSeriesResponse_FieldPath
}

func FullListTimeSeriesResponse_FieldMask() *ListTimeSeriesResponse_FieldMask {
	res := &ListTimeSeriesResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListTimeSeriesResponse_FieldTerminalPath{selector: ListTimeSeriesResponse_FieldPathSelectorTimeSeries})
	res.Paths = append(res.Paths, &ListTimeSeriesResponse_FieldTerminalPath{selector: ListTimeSeriesResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListTimeSeriesResponse_FieldTerminalPath{selector: ListTimeSeriesResponse_FieldPathSelectorExecutionErrors})
	return res
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListTimeSeriesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListTimeSeriesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListTimeSeriesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListTimeSeriesResponse_FieldPath(raw)
	})
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListTimeSeriesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) Subtract(other *ListTimeSeriesResponse_FieldMask) *ListTimeSeriesResponse_FieldMask {
	result := &ListTimeSeriesResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListTimeSeriesResponse_FieldPathSelectorTimeSeries:      &time_serie.TimeSerie_FieldMask{},
		ListTimeSeriesResponse_FieldPathSelectorExecutionErrors: &rpc.Status_FieldMask{},
	}
	mySubMasks := map[ListTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListTimeSeriesResponse_FieldPathSelectorTimeSeries:      &time_serie.TimeSerie_FieldMask{},
		ListTimeSeriesResponse_FieldPathSelectorExecutionErrors: &rpc.Status_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListTimeSeriesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListTimeSeriesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListTimeSeriesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListTimeSeriesResponse_FieldPathSelectorTimeSeries:
						mySubMasks[ListTimeSeriesResponse_FieldPathSelectorTimeSeries] = time_serie.FullTimeSerie_FieldMask()
					case ListTimeSeriesResponse_FieldPathSelectorExecutionErrors:
						mySubMasks[ListTimeSeriesResponse_FieldPathSelectorExecutionErrors] = rpc.FullStatus_FieldMask()
					}
				} else if tp, ok := path.(*ListTimeSeriesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListTimeSeriesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListTimeSeriesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListTimeSeriesResponse_FieldMask) FilterInputFields() *ListTimeSeriesResponse_FieldMask {
	result := &ListTimeSeriesResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListTimeSeriesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListTimeSeriesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListTimeSeriesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListTimeSeriesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListTimeSeriesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) AppendPath(path ListTimeSeriesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListTimeSeriesResponse_FieldPath))
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) GetPaths() []ListTimeSeriesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListTimeSeriesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) Set(target, source *ListTimeSeriesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListTimeSeriesResponse), source.(*ListTimeSeriesResponse))
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) Project(source *ListTimeSeriesResponse) *ListTimeSeriesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListTimeSeriesResponse{}
	timeSeriesMask := &time_serie.TimeSerie_FieldMask{}
	wholeTimeSeriesAccepted := false
	executionErrorsMask := &rpc.Status_FieldMask{}
	wholeExecutionErrorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListTimeSeriesResponse_FieldTerminalPath:
			switch tp.selector {
			case ListTimeSeriesResponse_FieldPathSelectorTimeSeries:
				result.TimeSeries = source.TimeSeries
				wholeTimeSeriesAccepted = true
			case ListTimeSeriesResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListTimeSeriesResponse_FieldPathSelectorExecutionErrors:
				result.ExecutionErrors = source.ExecutionErrors
				wholeExecutionErrorsAccepted = true
			}
		case *ListTimeSeriesResponse_FieldSubPath:
			switch tp.selector {
			case ListTimeSeriesResponse_FieldPathSelectorTimeSeries:
				timeSeriesMask.AppendPath(tp.subPath.(time_serie.TimeSerie_FieldPath))
			case ListTimeSeriesResponse_FieldPathSelectorExecutionErrors:
				executionErrorsMask.AppendPath(tp.subPath.(rpc.Status_FieldPath))
			}
		}
	}
	if wholeTimeSeriesAccepted == false && len(timeSeriesMask.Paths) > 0 {
		for _, sourceItem := range source.GetTimeSeries() {
			result.TimeSeries = append(result.TimeSeries, timeSeriesMask.Project(sourceItem))
		}
	}
	if wholeExecutionErrorsAccepted == false && len(executionErrorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetExecutionErrors() {
			result.ExecutionErrors = append(result.ExecutionErrors, executionErrorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListTimeSeriesResponse))
}

func (fieldMask *ListTimeSeriesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListTimeSeriesResponse_ErrorDetails_FieldMask struct {
	Paths []ListTimeSeriesResponseErrorDetails_FieldPath
}

func FullListTimeSeriesResponse_ErrorDetails_FieldMask() *ListTimeSeriesResponse_ErrorDetails_FieldMask {
	res := &ListTimeSeriesResponse_ErrorDetails_FieldMask{}
	res.Paths = append(res.Paths, &ListTimeSeriesResponseErrorDetails_FieldTerminalPath{selector: ListTimeSeriesResponseErrorDetails_FieldPathSelectorRegionId})
	return res
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListTimeSeriesResponseErrorDetails_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListTimeSeriesResponseErrorDetails_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListTimeSeriesResponseErrorDetails_FieldPath(raw)
	})
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) ProtoMessage() {}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) Subtract(other *ListTimeSeriesResponse_ErrorDetails_FieldMask) *ListTimeSeriesResponse_ErrorDetails_FieldMask {
	result := &ListTimeSeriesResponse_ErrorDetails_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListTimeSeriesResponseErrorDetails_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListTimeSeriesResponse_ErrorDetails_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) FilterInputFields() *ListTimeSeriesResponse_ErrorDetails_FieldMask {
	result := &ListTimeSeriesResponse_ErrorDetails_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListTimeSeriesResponseErrorDetails_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListTimeSeriesResponseErrorDetails_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListTimeSeriesResponse_ErrorDetails_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListTimeSeriesResponse_ErrorDetails_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) AppendPath(path ListTimeSeriesResponseErrorDetails_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListTimeSeriesResponseErrorDetails_FieldPath))
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) GetPaths() []ListTimeSeriesResponseErrorDetails_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListTimeSeriesResponseErrorDetails_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) Set(target, source *ListTimeSeriesResponse_ErrorDetails) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListTimeSeriesResponse_ErrorDetails), source.(*ListTimeSeriesResponse_ErrorDetails))
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) Project(source *ListTimeSeriesResponse_ErrorDetails) *ListTimeSeriesResponse_ErrorDetails {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListTimeSeriesResponse_ErrorDetails{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListTimeSeriesResponseErrorDetails_FieldTerminalPath:
			switch tp.selector {
			case ListTimeSeriesResponseErrorDetails_FieldPathSelectorRegionId:
				result.RegionId = source.RegionId
			}
		}
	}
	return result
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListTimeSeriesResponse_ErrorDetails))
}

func (fieldMask *ListTimeSeriesResponse_ErrorDetails_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateTimeSeriesRequest_FieldMask struct {
	Paths []CreateTimeSeriesRequest_FieldPath
}

func FullCreateTimeSeriesRequest_FieldMask() *CreateTimeSeriesRequest_FieldMask {
	res := &CreateTimeSeriesRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateTimeSeriesRequest_FieldTerminalPath{selector: CreateTimeSeriesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateTimeSeriesRequest_FieldTerminalPath{selector: CreateTimeSeriesRequest_FieldPathSelectorTimeSeries})
	return res
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateTimeSeriesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateTimeSeriesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateTimeSeriesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateTimeSeriesRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) Subtract(other *CreateTimeSeriesRequest_FieldMask) *CreateTimeSeriesRequest_FieldMask {
	result := &CreateTimeSeriesRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateTimeSeriesRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateTimeSeriesRequest_FieldPathSelectorTimeSeries: &time_serie.TimeSerie_FieldMask{},
	}
	mySubMasks := map[CreateTimeSeriesRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateTimeSeriesRequest_FieldPathSelectorTimeSeries: &time_serie.TimeSerie_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateTimeSeriesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateTimeSeriesRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateTimeSeriesRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateTimeSeriesRequest_FieldPathSelectorTimeSeries:
						mySubMasks[CreateTimeSeriesRequest_FieldPathSelectorTimeSeries] = time_serie.FullTimeSerie_FieldMask()
					}
				} else if tp, ok := path.(*CreateTimeSeriesRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateTimeSeriesRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateTimeSeriesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateTimeSeriesRequest_FieldMask) FilterInputFields() *CreateTimeSeriesRequest_FieldMask {
	result := &CreateTimeSeriesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateTimeSeriesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateTimeSeriesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateTimeSeriesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateTimeSeriesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateTimeSeriesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) AppendPath(path CreateTimeSeriesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateTimeSeriesRequest_FieldPath))
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) GetPaths() []CreateTimeSeriesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateTimeSeriesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) Set(target, source *CreateTimeSeriesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateTimeSeriesRequest), source.(*CreateTimeSeriesRequest))
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) Project(source *CreateTimeSeriesRequest) *CreateTimeSeriesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateTimeSeriesRequest{}
	timeSeriesMask := &time_serie.TimeSerie_FieldMask{}
	wholeTimeSeriesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateTimeSeriesRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateTimeSeriesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateTimeSeriesRequest_FieldPathSelectorTimeSeries:
				result.TimeSeries = source.TimeSeries
				wholeTimeSeriesAccepted = true
			}
		case *CreateTimeSeriesRequest_FieldSubPath:
			switch tp.selector {
			case CreateTimeSeriesRequest_FieldPathSelectorTimeSeries:
				timeSeriesMask.AppendPath(tp.subPath.(time_serie.TimeSerie_FieldPath))
			}
		}
	}
	if wholeTimeSeriesAccepted == false && len(timeSeriesMask.Paths) > 0 {
		for _, sourceItem := range source.GetTimeSeries() {
			result.TimeSeries = append(result.TimeSeries, timeSeriesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateTimeSeriesRequest))
}

func (fieldMask *CreateTimeSeriesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateTimeSeriesResponse_FieldMask struct {
	Paths []CreateTimeSeriesResponse_FieldPath
}

func FullCreateTimeSeriesResponse_FieldMask() *CreateTimeSeriesResponse_FieldMask {
	res := &CreateTimeSeriesResponse_FieldMask{}
	res.Paths = append(res.Paths, &CreateTimeSeriesResponse_FieldTerminalPath{selector: CreateTimeSeriesResponse_FieldPathSelectorTimeSerieKeys})
	res.Paths = append(res.Paths, &CreateTimeSeriesResponse_FieldTerminalPath{selector: CreateTimeSeriesResponse_FieldPathSelectorFailedTimeSeries})
	return res
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateTimeSeriesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateTimeSeriesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateTimeSeriesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateTimeSeriesResponse_FieldPath(raw)
	})
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) Subtract(other *CreateTimeSeriesResponse_FieldMask) *CreateTimeSeriesResponse_FieldMask {
	result := &CreateTimeSeriesResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		CreateTimeSeriesResponse_FieldPathSelectorFailedTimeSeries: &CreateTimeSeriesError_FieldMask{},
	}
	mySubMasks := map[CreateTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		CreateTimeSeriesResponse_FieldPathSelectorFailedTimeSeries: &CreateTimeSeriesError_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateTimeSeriesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateTimeSeriesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateTimeSeriesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateTimeSeriesResponse_FieldPathSelectorFailedTimeSeries:
						mySubMasks[CreateTimeSeriesResponse_FieldPathSelectorFailedTimeSeries] = FullCreateTimeSeriesError_FieldMask()
					}
				} else if tp, ok := path.(*CreateTimeSeriesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateTimeSeriesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateTimeSeriesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateTimeSeriesResponse_FieldMask) FilterInputFields() *CreateTimeSeriesResponse_FieldMask {
	result := &CreateTimeSeriesResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateTimeSeriesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateTimeSeriesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateTimeSeriesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateTimeSeriesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateTimeSeriesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) AppendPath(path CreateTimeSeriesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateTimeSeriesResponse_FieldPath))
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) GetPaths() []CreateTimeSeriesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateTimeSeriesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) Set(target, source *CreateTimeSeriesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateTimeSeriesResponse), source.(*CreateTimeSeriesResponse))
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) Project(source *CreateTimeSeriesResponse) *CreateTimeSeriesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateTimeSeriesResponse{}
	failedTimeSeriesMask := &CreateTimeSeriesError_FieldMask{}
	wholeFailedTimeSeriesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateTimeSeriesResponse_FieldTerminalPath:
			switch tp.selector {
			case CreateTimeSeriesResponse_FieldPathSelectorTimeSerieKeys:
				result.TimeSerieKeys = source.TimeSerieKeys
			case CreateTimeSeriesResponse_FieldPathSelectorFailedTimeSeries:
				result.FailedTimeSeries = source.FailedTimeSeries
				wholeFailedTimeSeriesAccepted = true
			}
		case *CreateTimeSeriesResponse_FieldSubPath:
			switch tp.selector {
			case CreateTimeSeriesResponse_FieldPathSelectorFailedTimeSeries:
				failedTimeSeriesMask.AppendPath(tp.subPath.(CreateTimeSeriesError_FieldPath))
			}
		}
	}
	if wholeFailedTimeSeriesAccepted == false && len(failedTimeSeriesMask.Paths) > 0 {
		for _, sourceItem := range source.GetFailedTimeSeries() {
			result.FailedTimeSeries = append(result.FailedTimeSeries, failedTimeSeriesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateTimeSeriesResponse))
}

func (fieldMask *CreateTimeSeriesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateTimeSeriesError_FieldMask struct {
	Paths []CreateTimeSeriesError_FieldPath
}

func FullCreateTimeSeriesError_FieldMask() *CreateTimeSeriesError_FieldMask {
	res := &CreateTimeSeriesError_FieldMask{}
	res.Paths = append(res.Paths, &CreateTimeSeriesError_FieldTerminalPath{selector: CreateTimeSeriesError_FieldPathSelectorTimeSeries})
	res.Paths = append(res.Paths, &CreateTimeSeriesError_FieldTerminalPath{selector: CreateTimeSeriesError_FieldPathSelectorStatus})
	return res
}

func (fieldMask *CreateTimeSeriesError_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateTimeSeriesError_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateTimeSeriesError_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateTimeSeriesError_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateTimeSeriesError_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateTimeSeriesError_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateTimeSeriesError_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateTimeSeriesError_FieldPath(raw)
	})
}

func (fieldMask *CreateTimeSeriesError_FieldMask) ProtoMessage() {}

func (fieldMask *CreateTimeSeriesError_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateTimeSeriesError_FieldMask) Subtract(other *CreateTimeSeriesError_FieldMask) *CreateTimeSeriesError_FieldMask {
	result := &CreateTimeSeriesError_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateTimeSeriesError_FieldPathSelector]gotenobject.FieldMask{
		CreateTimeSeriesError_FieldPathSelectorTimeSeries: &time_serie.TimeSerie_FieldMask{},
		CreateTimeSeriesError_FieldPathSelectorStatus:     &rpc.Status_FieldMask{},
	}
	mySubMasks := map[CreateTimeSeriesError_FieldPathSelector]gotenobject.FieldMask{
		CreateTimeSeriesError_FieldPathSelectorTimeSeries: &time_serie.TimeSerie_FieldMask{},
		CreateTimeSeriesError_FieldPathSelectorStatus:     &rpc.Status_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateTimeSeriesError_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateTimeSeriesError_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateTimeSeriesError_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateTimeSeriesError_FieldPathSelectorTimeSeries:
						mySubMasks[CreateTimeSeriesError_FieldPathSelectorTimeSeries] = time_serie.FullTimeSerie_FieldMask()
					case CreateTimeSeriesError_FieldPathSelectorStatus:
						mySubMasks[CreateTimeSeriesError_FieldPathSelectorStatus] = rpc.FullStatus_FieldMask()
					}
				} else if tp, ok := path.(*CreateTimeSeriesError_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateTimeSeriesError_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateTimeSeriesError_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateTimeSeriesError_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateTimeSeriesError_FieldMask) FilterInputFields() *CreateTimeSeriesError_FieldMask {
	result := &CreateTimeSeriesError_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateTimeSeriesError_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateTimeSeriesError_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateTimeSeriesError_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateTimeSeriesError_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateTimeSeriesError_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateTimeSeriesError_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateTimeSeriesError_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateTimeSeriesError_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateTimeSeriesError_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateTimeSeriesError_FieldMask) AppendPath(path CreateTimeSeriesError_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateTimeSeriesError_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateTimeSeriesError_FieldPath))
}

func (fieldMask *CreateTimeSeriesError_FieldMask) GetPaths() []CreateTimeSeriesError_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateTimeSeriesError_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateTimeSeriesError_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateTimeSeriesError_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateTimeSeriesError_FieldMask) Set(target, source *CreateTimeSeriesError) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateTimeSeriesError_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateTimeSeriesError), source.(*CreateTimeSeriesError))
}

func (fieldMask *CreateTimeSeriesError_FieldMask) Project(source *CreateTimeSeriesError) *CreateTimeSeriesError {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateTimeSeriesError{}
	timeSeriesMask := &time_serie.TimeSerie_FieldMask{}
	wholeTimeSeriesAccepted := false
	statusMask := &rpc.Status_FieldMask{}
	wholeStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateTimeSeriesError_FieldTerminalPath:
			switch tp.selector {
			case CreateTimeSeriesError_FieldPathSelectorTimeSeries:
				result.TimeSeries = source.TimeSeries
				wholeTimeSeriesAccepted = true
			case CreateTimeSeriesError_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			}
		case *CreateTimeSeriesError_FieldSubPath:
			switch tp.selector {
			case CreateTimeSeriesError_FieldPathSelectorTimeSeries:
				timeSeriesMask.AppendPath(tp.subPath.(time_serie.TimeSerie_FieldPath))
			case CreateTimeSeriesError_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(rpc.Status_FieldPath))
			}
		}
	}
	if wholeTimeSeriesAccepted == false && len(timeSeriesMask.Paths) > 0 {
		result.TimeSeries = timeSeriesMask.Project(source.GetTimeSeries())
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	return result
}

func (fieldMask *CreateTimeSeriesError_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateTimeSeriesError))
}

func (fieldMask *CreateTimeSeriesError_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
