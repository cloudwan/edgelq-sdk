// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v3/phantom_time_serie_service.proto
// DO NOT EDIT!!!

package phantom_time_serie_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	phantom_time_serie "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/phantom_time_serie"
	project "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/project"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &phantom_time_serie.PhantomTimeSerie{}
	_ = &project.Project{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetPhantomTimeSerieRequest_FieldMask struct {
	Paths []GetPhantomTimeSerieRequest_FieldPath
}

func FullGetPhantomTimeSerieRequest_FieldMask() *GetPhantomTimeSerieRequest_FieldMask {
	res := &GetPhantomTimeSerieRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetPhantomTimeSerieRequest_FieldTerminalPath{selector: GetPhantomTimeSerieRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetPhantomTimeSerieRequest_FieldTerminalPath{selector: GetPhantomTimeSerieRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetPhantomTimeSerieRequest_FieldTerminalPath{selector: GetPhantomTimeSerieRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetPhantomTimeSerieRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetPhantomTimeSerieRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetPhantomTimeSerieRequest_FieldPath(raw)
	})
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) Subtract(other *GetPhantomTimeSerieRequest_FieldMask) *GetPhantomTimeSerieRequest_FieldMask {
	result := &GetPhantomTimeSerieRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetPhantomTimeSerieRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetPhantomTimeSerieRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) FilterInputFields() *GetPhantomTimeSerieRequest_FieldMask {
	result := &GetPhantomTimeSerieRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetPhantomTimeSerieRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetPhantomTimeSerieRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetPhantomTimeSerieRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetPhantomTimeSerieRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) AppendPath(path GetPhantomTimeSerieRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetPhantomTimeSerieRequest_FieldPath))
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) GetPaths() []GetPhantomTimeSerieRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetPhantomTimeSerieRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) Set(target, source *GetPhantomTimeSerieRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetPhantomTimeSerieRequest), source.(*GetPhantomTimeSerieRequest))
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) Project(source *GetPhantomTimeSerieRequest) *GetPhantomTimeSerieRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetPhantomTimeSerieRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetPhantomTimeSerieRequest_FieldTerminalPath:
			switch tp.selector {
			case GetPhantomTimeSerieRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetPhantomTimeSerieRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetPhantomTimeSerieRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetPhantomTimeSerieRequest))
}

func (fieldMask *GetPhantomTimeSerieRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetPhantomTimeSeriesRequest_FieldMask struct {
	Paths []BatchGetPhantomTimeSeriesRequest_FieldPath
}

func FullBatchGetPhantomTimeSeriesRequest_FieldMask() *BatchGetPhantomTimeSeriesRequest_FieldMask {
	res := &BatchGetPhantomTimeSeriesRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetPhantomTimeSeriesRequest_FieldTerminalPath{selector: BatchGetPhantomTimeSeriesRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetPhantomTimeSeriesRequest_FieldTerminalPath{selector: BatchGetPhantomTimeSeriesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetPhantomTimeSeriesRequest_FieldTerminalPath{selector: BatchGetPhantomTimeSeriesRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetPhantomTimeSeriesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetPhantomTimeSeriesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetPhantomTimeSeriesRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) Subtract(other *BatchGetPhantomTimeSeriesRequest_FieldMask) *BatchGetPhantomTimeSeriesRequest_FieldMask {
	result := &BatchGetPhantomTimeSeriesRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetPhantomTimeSeriesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetPhantomTimeSeriesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) FilterInputFields() *BatchGetPhantomTimeSeriesRequest_FieldMask {
	result := &BatchGetPhantomTimeSeriesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetPhantomTimeSeriesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetPhantomTimeSeriesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetPhantomTimeSeriesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetPhantomTimeSeriesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) AppendPath(path BatchGetPhantomTimeSeriesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetPhantomTimeSeriesRequest_FieldPath))
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) GetPaths() []BatchGetPhantomTimeSeriesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetPhantomTimeSeriesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) Set(target, source *BatchGetPhantomTimeSeriesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetPhantomTimeSeriesRequest), source.(*BatchGetPhantomTimeSeriesRequest))
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) Project(source *BatchGetPhantomTimeSeriesRequest) *BatchGetPhantomTimeSeriesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetPhantomTimeSeriesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetPhantomTimeSeriesRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetPhantomTimeSeriesRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetPhantomTimeSeriesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetPhantomTimeSeriesRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetPhantomTimeSeriesRequest))
}

func (fieldMask *BatchGetPhantomTimeSeriesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetPhantomTimeSeriesResponse_FieldMask struct {
	Paths []BatchGetPhantomTimeSeriesResponse_FieldPath
}

func FullBatchGetPhantomTimeSeriesResponse_FieldMask() *BatchGetPhantomTimeSeriesResponse_FieldMask {
	res := &BatchGetPhantomTimeSeriesResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetPhantomTimeSeriesResponse_FieldTerminalPath{selector: BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries})
	res.Paths = append(res.Paths, &BatchGetPhantomTimeSeriesResponse_FieldTerminalPath{selector: BatchGetPhantomTimeSeriesResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetPhantomTimeSeriesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetPhantomTimeSeriesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetPhantomTimeSeriesResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) Subtract(other *BatchGetPhantomTimeSeriesResponse_FieldMask) *BatchGetPhantomTimeSeriesResponse_FieldMask {
	result := &BatchGetPhantomTimeSeriesResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetPhantomTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
	}
	mySubMasks := map[BatchGetPhantomTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetPhantomTimeSeriesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetPhantomTimeSeriesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetPhantomTimeSeriesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries:
						mySubMasks[BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries] = phantom_time_serie.FullPhantomTimeSerie_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetPhantomTimeSeriesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetPhantomTimeSeriesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetPhantomTimeSeriesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) FilterInputFields() *BatchGetPhantomTimeSeriesResponse_FieldMask {
	result := &BatchGetPhantomTimeSeriesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries:
			if _, ok := path.(*BatchGetPhantomTimeSeriesResponse_FieldTerminalPath); ok {
				for _, subpath := range phantom_time_serie.FullPhantomTimeSerie_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetPhantomTimeSeriesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetPhantomTimeSeriesResponse_FieldSubPath); ok {
				selectedMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{
					Paths: []phantom_time_serie.PhantomTimeSerie_FieldPath{sub.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetPhantomTimeSeriesResponse_FieldSubPath{selector: BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetPhantomTimeSeriesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetPhantomTimeSeriesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetPhantomTimeSeriesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetPhantomTimeSeriesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) AppendPath(path BatchGetPhantomTimeSeriesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetPhantomTimeSeriesResponse_FieldPath))
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) GetPaths() []BatchGetPhantomTimeSeriesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetPhantomTimeSeriesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) Set(target, source *BatchGetPhantomTimeSeriesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetPhantomTimeSeriesResponse), source.(*BatchGetPhantomTimeSeriesResponse))
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) Project(source *BatchGetPhantomTimeSeriesResponse) *BatchGetPhantomTimeSeriesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetPhantomTimeSeriesResponse{}
	phantomTimeSeriesMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{}
	wholePhantomTimeSeriesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetPhantomTimeSeriesResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries:
				result.PhantomTimeSeries = source.PhantomTimeSeries
				wholePhantomTimeSeriesAccepted = true
			case BatchGetPhantomTimeSeriesResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetPhantomTimeSeriesResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries:
				phantomTimeSeriesMask.AppendPath(tp.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath))
			}
		}
	}
	if wholePhantomTimeSeriesAccepted == false && len(phantomTimeSeriesMask.Paths) > 0 {
		for _, sourceItem := range source.GetPhantomTimeSeries() {
			result.PhantomTimeSeries = append(result.PhantomTimeSeries, phantomTimeSeriesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetPhantomTimeSeriesResponse))
}

func (fieldMask *BatchGetPhantomTimeSeriesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListPhantomTimeSeriesRequest_FieldMask struct {
	Paths []ListPhantomTimeSeriesRequest_FieldPath
}

func FullListPhantomTimeSeriesRequest_FieldMask() *ListPhantomTimeSeriesRequest_FieldMask {
	res := &ListPhantomTimeSeriesRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesRequest_FieldTerminalPath{selector: ListPhantomTimeSeriesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesRequest_FieldTerminalPath{selector: ListPhantomTimeSeriesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesRequest_FieldTerminalPath{selector: ListPhantomTimeSeriesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesRequest_FieldTerminalPath{selector: ListPhantomTimeSeriesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesRequest_FieldTerminalPath{selector: ListPhantomTimeSeriesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesRequest_FieldTerminalPath{selector: ListPhantomTimeSeriesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesRequest_FieldTerminalPath{selector: ListPhantomTimeSeriesRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesRequest_FieldTerminalPath{selector: ListPhantomTimeSeriesRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListPhantomTimeSeriesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListPhantomTimeSeriesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListPhantomTimeSeriesRequest_FieldPath(raw)
	})
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) Subtract(other *ListPhantomTimeSeriesRequest_FieldMask) *ListPhantomTimeSeriesRequest_FieldMask {
	result := &ListPhantomTimeSeriesRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListPhantomTimeSeriesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListPhantomTimeSeriesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) FilterInputFields() *ListPhantomTimeSeriesRequest_FieldMask {
	result := &ListPhantomTimeSeriesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListPhantomTimeSeriesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListPhantomTimeSeriesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListPhantomTimeSeriesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListPhantomTimeSeriesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) AppendPath(path ListPhantomTimeSeriesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListPhantomTimeSeriesRequest_FieldPath))
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) GetPaths() []ListPhantomTimeSeriesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListPhantomTimeSeriesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) Set(target, source *ListPhantomTimeSeriesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListPhantomTimeSeriesRequest), source.(*ListPhantomTimeSeriesRequest))
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) Project(source *ListPhantomTimeSeriesRequest) *ListPhantomTimeSeriesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListPhantomTimeSeriesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListPhantomTimeSeriesRequest_FieldTerminalPath:
			switch tp.selector {
			case ListPhantomTimeSeriesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListPhantomTimeSeriesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListPhantomTimeSeriesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListPhantomTimeSeriesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListPhantomTimeSeriesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListPhantomTimeSeriesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListPhantomTimeSeriesRequest_FieldPathSelectorView:
				result.View = source.View
			case ListPhantomTimeSeriesRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListPhantomTimeSeriesRequest))
}

func (fieldMask *ListPhantomTimeSeriesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListPhantomTimeSeriesResponse_FieldMask struct {
	Paths []ListPhantomTimeSeriesResponse_FieldPath
}

func FullListPhantomTimeSeriesResponse_FieldMask() *ListPhantomTimeSeriesResponse_FieldMask {
	res := &ListPhantomTimeSeriesResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesResponse_FieldTerminalPath{selector: ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesResponse_FieldTerminalPath{selector: ListPhantomTimeSeriesResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesResponse_FieldTerminalPath{selector: ListPhantomTimeSeriesResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesResponse_FieldTerminalPath{selector: ListPhantomTimeSeriesResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListPhantomTimeSeriesResponse_FieldTerminalPath{selector: ListPhantomTimeSeriesResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListPhantomTimeSeriesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListPhantomTimeSeriesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListPhantomTimeSeriesResponse_FieldPath(raw)
	})
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) Subtract(other *ListPhantomTimeSeriesResponse_FieldMask) *ListPhantomTimeSeriesResponse_FieldMask {
	result := &ListPhantomTimeSeriesResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListPhantomTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
	}
	mySubMasks := map[ListPhantomTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListPhantomTimeSeriesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListPhantomTimeSeriesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListPhantomTimeSeriesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries:
						mySubMasks[ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries] = phantom_time_serie.FullPhantomTimeSerie_FieldMask()
					}
				} else if tp, ok := path.(*ListPhantomTimeSeriesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListPhantomTimeSeriesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListPhantomTimeSeriesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) FilterInputFields() *ListPhantomTimeSeriesResponse_FieldMask {
	result := &ListPhantomTimeSeriesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries:
			if _, ok := path.(*ListPhantomTimeSeriesResponse_FieldTerminalPath); ok {
				for _, subpath := range phantom_time_serie.FullPhantomTimeSerie_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListPhantomTimeSeriesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListPhantomTimeSeriesResponse_FieldSubPath); ok {
				selectedMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{
					Paths: []phantom_time_serie.PhantomTimeSerie_FieldPath{sub.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListPhantomTimeSeriesResponse_FieldSubPath{selector: ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListPhantomTimeSeriesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListPhantomTimeSeriesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListPhantomTimeSeriesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListPhantomTimeSeriesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) AppendPath(path ListPhantomTimeSeriesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListPhantomTimeSeriesResponse_FieldPath))
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) GetPaths() []ListPhantomTimeSeriesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListPhantomTimeSeriesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) Set(target, source *ListPhantomTimeSeriesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListPhantomTimeSeriesResponse), source.(*ListPhantomTimeSeriesResponse))
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) Project(source *ListPhantomTimeSeriesResponse) *ListPhantomTimeSeriesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListPhantomTimeSeriesResponse{}
	phantomTimeSeriesMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{}
	wholePhantomTimeSeriesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListPhantomTimeSeriesResponse_FieldTerminalPath:
			switch tp.selector {
			case ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries:
				result.PhantomTimeSeries = source.PhantomTimeSeries
				wholePhantomTimeSeriesAccepted = true
			case ListPhantomTimeSeriesResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListPhantomTimeSeriesResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListPhantomTimeSeriesResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListPhantomTimeSeriesResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListPhantomTimeSeriesResponse_FieldSubPath:
			switch tp.selector {
			case ListPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSeries:
				phantomTimeSeriesMask.AppendPath(tp.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath))
			}
		}
	}
	if wholePhantomTimeSeriesAccepted == false && len(phantomTimeSeriesMask.Paths) > 0 {
		for _, sourceItem := range source.GetPhantomTimeSeries() {
			result.PhantomTimeSeries = append(result.PhantomTimeSeries, phantomTimeSeriesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListPhantomTimeSeriesResponse))
}

func (fieldMask *ListPhantomTimeSeriesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPhantomTimeSerieRequest_FieldMask struct {
	Paths []WatchPhantomTimeSerieRequest_FieldPath
}

func FullWatchPhantomTimeSerieRequest_FieldMask() *WatchPhantomTimeSerieRequest_FieldMask {
	res := &WatchPhantomTimeSerieRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchPhantomTimeSerieRequest_FieldTerminalPath{selector: WatchPhantomTimeSerieRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchPhantomTimeSerieRequest_FieldTerminalPath{selector: WatchPhantomTimeSerieRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchPhantomTimeSerieRequest_FieldTerminalPath{selector: WatchPhantomTimeSerieRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPhantomTimeSerieRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPhantomTimeSerieRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPhantomTimeSerieRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) Subtract(other *WatchPhantomTimeSerieRequest_FieldMask) *WatchPhantomTimeSerieRequest_FieldMask {
	result := &WatchPhantomTimeSerieRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPhantomTimeSerieRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPhantomTimeSerieRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) FilterInputFields() *WatchPhantomTimeSerieRequest_FieldMask {
	result := &WatchPhantomTimeSerieRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPhantomTimeSerieRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPhantomTimeSerieRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPhantomTimeSerieRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPhantomTimeSerieRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) AppendPath(path WatchPhantomTimeSerieRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPhantomTimeSerieRequest_FieldPath))
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) GetPaths() []WatchPhantomTimeSerieRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPhantomTimeSerieRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) Set(target, source *WatchPhantomTimeSerieRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPhantomTimeSerieRequest), source.(*WatchPhantomTimeSerieRequest))
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) Project(source *WatchPhantomTimeSerieRequest) *WatchPhantomTimeSerieRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPhantomTimeSerieRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPhantomTimeSerieRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchPhantomTimeSerieRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchPhantomTimeSerieRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchPhantomTimeSerieRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPhantomTimeSerieRequest))
}

func (fieldMask *WatchPhantomTimeSerieRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPhantomTimeSerieResponse_FieldMask struct {
	Paths []WatchPhantomTimeSerieResponse_FieldPath
}

func FullWatchPhantomTimeSerieResponse_FieldMask() *WatchPhantomTimeSerieResponse_FieldMask {
	res := &WatchPhantomTimeSerieResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchPhantomTimeSerieResponse_FieldTerminalPath{selector: WatchPhantomTimeSerieResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPhantomTimeSerieResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPhantomTimeSerieResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPhantomTimeSerieResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) Subtract(other *WatchPhantomTimeSerieResponse_FieldMask) *WatchPhantomTimeSerieResponse_FieldMask {
	result := &WatchPhantomTimeSerieResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPhantomTimeSerieResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPhantomTimeSerieResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) FilterInputFields() *WatchPhantomTimeSerieResponse_FieldMask {
	result := &WatchPhantomTimeSerieResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPhantomTimeSerieResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPhantomTimeSerieResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPhantomTimeSerieResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPhantomTimeSerieResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) AppendPath(path WatchPhantomTimeSerieResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPhantomTimeSerieResponse_FieldPath))
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) GetPaths() []WatchPhantomTimeSerieResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPhantomTimeSerieResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) Set(target, source *WatchPhantomTimeSerieResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPhantomTimeSerieResponse), source.(*WatchPhantomTimeSerieResponse))
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) Project(source *WatchPhantomTimeSerieResponse) *WatchPhantomTimeSerieResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPhantomTimeSerieResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPhantomTimeSerieResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchPhantomTimeSerieResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPhantomTimeSerieResponse))
}

func (fieldMask *WatchPhantomTimeSerieResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPhantomTimeSeriesRequest_FieldMask struct {
	Paths []WatchPhantomTimeSeriesRequest_FieldPath
}

func FullWatchPhantomTimeSeriesRequest_FieldMask() *WatchPhantomTimeSeriesRequest_FieldMask {
	res := &WatchPhantomTimeSeriesRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesRequest_FieldTerminalPath{selector: WatchPhantomTimeSeriesRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPhantomTimeSeriesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPhantomTimeSeriesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPhantomTimeSeriesRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) Subtract(other *WatchPhantomTimeSeriesRequest_FieldMask) *WatchPhantomTimeSeriesRequest_FieldMask {
	result := &WatchPhantomTimeSeriesRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPhantomTimeSeriesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPhantomTimeSeriesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) FilterInputFields() *WatchPhantomTimeSeriesRequest_FieldMask {
	result := &WatchPhantomTimeSeriesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPhantomTimeSeriesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPhantomTimeSeriesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPhantomTimeSeriesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPhantomTimeSeriesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) AppendPath(path WatchPhantomTimeSeriesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPhantomTimeSeriesRequest_FieldPath))
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) GetPaths() []WatchPhantomTimeSeriesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPhantomTimeSeriesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) Set(target, source *WatchPhantomTimeSeriesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPhantomTimeSeriesRequest), source.(*WatchPhantomTimeSeriesRequest))
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) Project(source *WatchPhantomTimeSeriesRequest) *WatchPhantomTimeSeriesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPhantomTimeSeriesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPhantomTimeSeriesRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchPhantomTimeSeriesRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPhantomTimeSeriesRequest))
}

func (fieldMask *WatchPhantomTimeSeriesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPhantomTimeSeriesResponse_FieldMask struct {
	Paths []WatchPhantomTimeSeriesResponse_FieldPath
}

func FullWatchPhantomTimeSeriesResponse_FieldMask() *WatchPhantomTimeSeriesResponse_FieldMask {
	res := &WatchPhantomTimeSeriesResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponse_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSerieChanges})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponse_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponse_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponse_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponse_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponse_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponse_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPhantomTimeSeriesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPhantomTimeSeriesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPhantomTimeSeriesResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) Subtract(other *WatchPhantomTimeSeriesResponse_FieldMask) *WatchPhantomTimeSeriesResponse_FieldMask {
	result := &WatchPhantomTimeSeriesResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchPhantomTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchPhantomTimeSeriesResponse_FieldPathSelectorPageTokenChange: &WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchPhantomTimeSeriesResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchPhantomTimeSeriesResponse_FieldPathSelectorPageTokenChange: &WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPhantomTimeSeriesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchPhantomTimeSeriesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchPhantomTimeSeriesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchPhantomTimeSeriesResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchPhantomTimeSeriesResponse_FieldPathSelectorPageTokenChange] = FullWatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchPhantomTimeSeriesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchPhantomTimeSeriesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPhantomTimeSeriesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) FilterInputFields() *WatchPhantomTimeSeriesResponse_FieldMask {
	result := &WatchPhantomTimeSeriesResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPhantomTimeSeriesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPhantomTimeSeriesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPhantomTimeSeriesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPhantomTimeSeriesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) AppendPath(path WatchPhantomTimeSeriesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPhantomTimeSeriesResponse_FieldPath))
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) GetPaths() []WatchPhantomTimeSeriesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPhantomTimeSeriesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) Set(target, source *WatchPhantomTimeSeriesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPhantomTimeSeriesResponse), source.(*WatchPhantomTimeSeriesResponse))
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) Project(source *WatchPhantomTimeSeriesResponse) *WatchPhantomTimeSeriesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPhantomTimeSeriesResponse{}
	pageTokenChangeMask := &WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPhantomTimeSeriesResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchPhantomTimeSeriesResponse_FieldPathSelectorPhantomTimeSerieChanges:
				result.PhantomTimeSerieChanges = source.PhantomTimeSerieChanges
			case WatchPhantomTimeSeriesResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchPhantomTimeSeriesResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchPhantomTimeSeriesResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchPhantomTimeSeriesResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchPhantomTimeSeriesResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchPhantomTimeSeriesResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchPhantomTimeSeriesResponse_FieldSubPath:
			switch tp.selector {
			case WatchPhantomTimeSeriesResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchPhantomTimeSeriesResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPhantomTimeSeriesResponse))
}

func (fieldMask *WatchPhantomTimeSeriesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask struct {
	Paths []WatchPhantomTimeSeriesResponsePageTokenChange_FieldPath
}

func FullWatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask() *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask {
	res := &WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponsePageTokenChange_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchPhantomTimeSeriesResponsePageTokenChange_FieldTerminalPath{selector: WatchPhantomTimeSeriesResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchPhantomTimeSeriesResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchPhantomTimeSeriesResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchPhantomTimeSeriesResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) Subtract(other *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask {
	result := &WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchPhantomTimeSeriesResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask {
	result := &WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchPhantomTimeSeriesResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchPhantomTimeSeriesResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) AppendPath(path WatchPhantomTimeSeriesResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchPhantomTimeSeriesResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) GetPaths() []WatchPhantomTimeSeriesResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchPhantomTimeSeriesResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) Set(target, source *WatchPhantomTimeSeriesResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchPhantomTimeSeriesResponse_PageTokenChange), source.(*WatchPhantomTimeSeriesResponse_PageTokenChange))
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) Project(source *WatchPhantomTimeSeriesResponse_PageTokenChange) *WatchPhantomTimeSeriesResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchPhantomTimeSeriesResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchPhantomTimeSeriesResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchPhantomTimeSeriesResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchPhantomTimeSeriesResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchPhantomTimeSeriesResponse_PageTokenChange))
}

func (fieldMask *WatchPhantomTimeSeriesResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreatePhantomTimeSerieRequest_FieldMask struct {
	Paths []CreatePhantomTimeSerieRequest_FieldPath
}

func FullCreatePhantomTimeSerieRequest_FieldMask() *CreatePhantomTimeSerieRequest_FieldMask {
	res := &CreatePhantomTimeSerieRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreatePhantomTimeSerieRequest_FieldTerminalPath{selector: CreatePhantomTimeSerieRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreatePhantomTimeSerieRequest_FieldTerminalPath{selector: CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie})
	return res
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreatePhantomTimeSerieRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreatePhantomTimeSerieRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreatePhantomTimeSerieRequest_FieldPath(raw)
	})
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) Subtract(other *CreatePhantomTimeSerieRequest_FieldMask) *CreatePhantomTimeSerieRequest_FieldMask {
	result := &CreatePhantomTimeSerieRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreatePhantomTimeSerieRequest_FieldPathSelector]gotenobject.FieldMask{
		CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
	}
	mySubMasks := map[CreatePhantomTimeSerieRequest_FieldPathSelector]gotenobject.FieldMask{
		CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreatePhantomTimeSerieRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreatePhantomTimeSerieRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreatePhantomTimeSerieRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie:
						mySubMasks[CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie] = phantom_time_serie.FullPhantomTimeSerie_FieldMask()
					}
				} else if tp, ok := path.(*CreatePhantomTimeSerieRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreatePhantomTimeSerieRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreatePhantomTimeSerieRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) FilterInputFields() *CreatePhantomTimeSerieRequest_FieldMask {
	result := &CreatePhantomTimeSerieRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie:
			if _, ok := path.(*CreatePhantomTimeSerieRequest_FieldTerminalPath); ok {
				for _, subpath := range phantom_time_serie.FullPhantomTimeSerie_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreatePhantomTimeSerieRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreatePhantomTimeSerieRequest_FieldSubPath); ok {
				selectedMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{
					Paths: []phantom_time_serie.PhantomTimeSerie_FieldPath{sub.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreatePhantomTimeSerieRequest_FieldSubPath{selector: CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreatePhantomTimeSerieRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreatePhantomTimeSerieRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreatePhantomTimeSerieRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreatePhantomTimeSerieRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) AppendPath(path CreatePhantomTimeSerieRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreatePhantomTimeSerieRequest_FieldPath))
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) GetPaths() []CreatePhantomTimeSerieRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreatePhantomTimeSerieRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) Set(target, source *CreatePhantomTimeSerieRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreatePhantomTimeSerieRequest), source.(*CreatePhantomTimeSerieRequest))
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) Project(source *CreatePhantomTimeSerieRequest) *CreatePhantomTimeSerieRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreatePhantomTimeSerieRequest{}
	phantomTimeSerieMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{}
	wholePhantomTimeSerieAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreatePhantomTimeSerieRequest_FieldTerminalPath:
			switch tp.selector {
			case CreatePhantomTimeSerieRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie:
				result.PhantomTimeSerie = source.PhantomTimeSerie
				wholePhantomTimeSerieAccepted = true
			}
		case *CreatePhantomTimeSerieRequest_FieldSubPath:
			switch tp.selector {
			case CreatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie:
				phantomTimeSerieMask.AppendPath(tp.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath))
			}
		}
	}
	if wholePhantomTimeSerieAccepted == false && len(phantomTimeSerieMask.Paths) > 0 {
		result.PhantomTimeSerie = phantomTimeSerieMask.Project(source.GetPhantomTimeSerie())
	}
	return result
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreatePhantomTimeSerieRequest))
}

func (fieldMask *CreatePhantomTimeSerieRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdatePhantomTimeSerieRequest_FieldMask struct {
	Paths []UpdatePhantomTimeSerieRequest_FieldPath
}

func FullUpdatePhantomTimeSerieRequest_FieldMask() *UpdatePhantomTimeSerieRequest_FieldMask {
	res := &UpdatePhantomTimeSerieRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdatePhantomTimeSerieRequest_FieldTerminalPath{selector: UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie})
	res.Paths = append(res.Paths, &UpdatePhantomTimeSerieRequest_FieldTerminalPath{selector: UpdatePhantomTimeSerieRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdatePhantomTimeSerieRequest_FieldTerminalPath{selector: UpdatePhantomTimeSerieRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdatePhantomTimeSerieRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdatePhantomTimeSerieRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdatePhantomTimeSerieRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) Subtract(other *UpdatePhantomTimeSerieRequest_FieldMask) *UpdatePhantomTimeSerieRequest_FieldMask {
	result := &UpdatePhantomTimeSerieRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdatePhantomTimeSerieRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
		UpdatePhantomTimeSerieRequest_FieldPathSelectorCas:              &UpdatePhantomTimeSerieRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdatePhantomTimeSerieRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
		UpdatePhantomTimeSerieRequest_FieldPathSelectorCas:              &UpdatePhantomTimeSerieRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdatePhantomTimeSerieRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdatePhantomTimeSerieRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdatePhantomTimeSerieRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie:
						mySubMasks[UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie] = phantom_time_serie.FullPhantomTimeSerie_FieldMask()
					case UpdatePhantomTimeSerieRequest_FieldPathSelectorCas:
						mySubMasks[UpdatePhantomTimeSerieRequest_FieldPathSelectorCas] = FullUpdatePhantomTimeSerieRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdatePhantomTimeSerieRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdatePhantomTimeSerieRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdatePhantomTimeSerieRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) FilterInputFields() *UpdatePhantomTimeSerieRequest_FieldMask {
	result := &UpdatePhantomTimeSerieRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie:
			if _, ok := path.(*UpdatePhantomTimeSerieRequest_FieldTerminalPath); ok {
				for _, subpath := range phantom_time_serie.FullPhantomTimeSerie_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePhantomTimeSerieRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdatePhantomTimeSerieRequest_FieldSubPath); ok {
				selectedMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{
					Paths: []phantom_time_serie.PhantomTimeSerie_FieldPath{sub.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePhantomTimeSerieRequest_FieldSubPath{selector: UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie, subPath: allowedPath})
				}
			}
		case UpdatePhantomTimeSerieRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdatePhantomTimeSerieRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdatePhantomTimeSerieRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePhantomTimeSerieRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdatePhantomTimeSerieRequest_FieldSubPath); ok {
				selectedMask := &UpdatePhantomTimeSerieRequest_CAS_FieldMask{
					Paths: []UpdatePhantomTimeSerieRequestCAS_FieldPath{sub.subPath.(UpdatePhantomTimeSerieRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePhantomTimeSerieRequest_FieldSubPath{selector: UpdatePhantomTimeSerieRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdatePhantomTimeSerieRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdatePhantomTimeSerieRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdatePhantomTimeSerieRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdatePhantomTimeSerieRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) AppendPath(path UpdatePhantomTimeSerieRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdatePhantomTimeSerieRequest_FieldPath))
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) GetPaths() []UpdatePhantomTimeSerieRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdatePhantomTimeSerieRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) Set(target, source *UpdatePhantomTimeSerieRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdatePhantomTimeSerieRequest), source.(*UpdatePhantomTimeSerieRequest))
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) Project(source *UpdatePhantomTimeSerieRequest) *UpdatePhantomTimeSerieRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdatePhantomTimeSerieRequest{}
	phantomTimeSerieMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{}
	wholePhantomTimeSerieAccepted := false
	casMask := &UpdatePhantomTimeSerieRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdatePhantomTimeSerieRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie:
				result.PhantomTimeSerie = source.PhantomTimeSerie
				wholePhantomTimeSerieAccepted = true
			case UpdatePhantomTimeSerieRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdatePhantomTimeSerieRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdatePhantomTimeSerieRequest_FieldSubPath:
			switch tp.selector {
			case UpdatePhantomTimeSerieRequest_FieldPathSelectorPhantomTimeSerie:
				phantomTimeSerieMask.AppendPath(tp.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath))
			case UpdatePhantomTimeSerieRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdatePhantomTimeSerieRequestCAS_FieldPath))
			}
		}
	}
	if wholePhantomTimeSerieAccepted == false && len(phantomTimeSerieMask.Paths) > 0 {
		result.PhantomTimeSerie = phantomTimeSerieMask.Project(source.GetPhantomTimeSerie())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdatePhantomTimeSerieRequest))
}

func (fieldMask *UpdatePhantomTimeSerieRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdatePhantomTimeSerieRequest_CAS_FieldMask struct {
	Paths []UpdatePhantomTimeSerieRequestCAS_FieldPath
}

func FullUpdatePhantomTimeSerieRequest_CAS_FieldMask() *UpdatePhantomTimeSerieRequest_CAS_FieldMask {
	res := &UpdatePhantomTimeSerieRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdatePhantomTimeSerieRequestCAS_FieldTerminalPath{selector: UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdatePhantomTimeSerieRequestCAS_FieldTerminalPath{selector: UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdatePhantomTimeSerieRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdatePhantomTimeSerieRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdatePhantomTimeSerieRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) Subtract(other *UpdatePhantomTimeSerieRequest_CAS_FieldMask) *UpdatePhantomTimeSerieRequest_CAS_FieldMask {
	result := &UpdatePhantomTimeSerieRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdatePhantomTimeSerieRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
	}
	mySubMasks := map[UpdatePhantomTimeSerieRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState: &phantom_time_serie.PhantomTimeSerie_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdatePhantomTimeSerieRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdatePhantomTimeSerieRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdatePhantomTimeSerieRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState] = phantom_time_serie.FullPhantomTimeSerie_FieldMask()
					}
				} else if tp, ok := path.(*UpdatePhantomTimeSerieRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdatePhantomTimeSerieRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdatePhantomTimeSerieRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) FilterInputFields() *UpdatePhantomTimeSerieRequest_CAS_FieldMask {
	result := &UpdatePhantomTimeSerieRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdatePhantomTimeSerieRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range phantom_time_serie.FullPhantomTimeSerie_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePhantomTimeSerieRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdatePhantomTimeSerieRequestCAS_FieldSubPath); ok {
				selectedMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{
					Paths: []phantom_time_serie.PhantomTimeSerie_FieldPath{sub.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdatePhantomTimeSerieRequestCAS_FieldSubPath{selector: UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdatePhantomTimeSerieRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdatePhantomTimeSerieRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdatePhantomTimeSerieRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdatePhantomTimeSerieRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) AppendPath(path UpdatePhantomTimeSerieRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdatePhantomTimeSerieRequestCAS_FieldPath))
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) GetPaths() []UpdatePhantomTimeSerieRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdatePhantomTimeSerieRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) Set(target, source *UpdatePhantomTimeSerieRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdatePhantomTimeSerieRequest_CAS), source.(*UpdatePhantomTimeSerieRequest_CAS))
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) Project(source *UpdatePhantomTimeSerieRequest_CAS) *UpdatePhantomTimeSerieRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdatePhantomTimeSerieRequest_CAS{}
	conditionalStateMask := &phantom_time_serie.PhantomTimeSerie_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdatePhantomTimeSerieRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdatePhantomTimeSerieRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdatePhantomTimeSerieRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(phantom_time_serie.PhantomTimeSerie_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdatePhantomTimeSerieRequest_CAS))
}

func (fieldMask *UpdatePhantomTimeSerieRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeletePhantomTimeSerieRequest_FieldMask struct {
	Paths []DeletePhantomTimeSerieRequest_FieldPath
}

func FullDeletePhantomTimeSerieRequest_FieldMask() *DeletePhantomTimeSerieRequest_FieldMask {
	res := &DeletePhantomTimeSerieRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeletePhantomTimeSerieRequest_FieldTerminalPath{selector: DeletePhantomTimeSerieRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeletePhantomTimeSerieRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeletePhantomTimeSerieRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeletePhantomTimeSerieRequest_FieldPath(raw)
	})
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) Subtract(other *DeletePhantomTimeSerieRequest_FieldMask) *DeletePhantomTimeSerieRequest_FieldMask {
	result := &DeletePhantomTimeSerieRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeletePhantomTimeSerieRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeletePhantomTimeSerieRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) FilterInputFields() *DeletePhantomTimeSerieRequest_FieldMask {
	result := &DeletePhantomTimeSerieRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeletePhantomTimeSerieRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeletePhantomTimeSerieRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeletePhantomTimeSerieRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeletePhantomTimeSerieRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) AppendPath(path DeletePhantomTimeSerieRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeletePhantomTimeSerieRequest_FieldPath))
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) GetPaths() []DeletePhantomTimeSerieRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeletePhantomTimeSerieRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) Set(target, source *DeletePhantomTimeSerieRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeletePhantomTimeSerieRequest), source.(*DeletePhantomTimeSerieRequest))
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) Project(source *DeletePhantomTimeSerieRequest) *DeletePhantomTimeSerieRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeletePhantomTimeSerieRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeletePhantomTimeSerieRequest_FieldTerminalPath:
			switch tp.selector {
			case DeletePhantomTimeSerieRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeletePhantomTimeSerieRequest))
}

func (fieldMask *DeletePhantomTimeSerieRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
