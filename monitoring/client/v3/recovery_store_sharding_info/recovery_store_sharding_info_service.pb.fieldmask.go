// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v3/recovery_store_sharding_info_service.proto
// DO NOT EDIT!!!

package recovery_store_sharding_info_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	recovery_store_sharding_info "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/recovery_store_sharding_info"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &recovery_store_sharding_info.RecoveryStoreShardingInfo{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetRecoveryStoreShardingInfoRequest_FieldMask struct {
	Paths []GetRecoveryStoreShardingInfoRequest_FieldPath
}

func FullGetRecoveryStoreShardingInfoRequest_FieldMask() *GetRecoveryStoreShardingInfoRequest_FieldMask {
	res := &GetRecoveryStoreShardingInfoRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: GetRecoveryStoreShardingInfoRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: GetRecoveryStoreShardingInfoRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: GetRecoveryStoreShardingInfoRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetRecoveryStoreShardingInfoRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetRecoveryStoreShardingInfoRequest_FieldPath(raw)
	})
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) Subtract(other *GetRecoveryStoreShardingInfoRequest_FieldMask) *GetRecoveryStoreShardingInfoRequest_FieldMask {
	result := &GetRecoveryStoreShardingInfoRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetRecoveryStoreShardingInfoRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) FilterInputFields() *GetRecoveryStoreShardingInfoRequest_FieldMask {
	result := &GetRecoveryStoreShardingInfoRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetRecoveryStoreShardingInfoRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetRecoveryStoreShardingInfoRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetRecoveryStoreShardingInfoRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetRecoveryStoreShardingInfoRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) AppendPath(path GetRecoveryStoreShardingInfoRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetRecoveryStoreShardingInfoRequest_FieldPath))
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) GetPaths() []GetRecoveryStoreShardingInfoRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetRecoveryStoreShardingInfoRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) Set(target, source *GetRecoveryStoreShardingInfoRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetRecoveryStoreShardingInfoRequest), source.(*GetRecoveryStoreShardingInfoRequest))
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) Project(source *GetRecoveryStoreShardingInfoRequest) *GetRecoveryStoreShardingInfoRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetRecoveryStoreShardingInfoRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			switch tp.selector {
			case GetRecoveryStoreShardingInfoRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetRecoveryStoreShardingInfoRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetRecoveryStoreShardingInfoRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetRecoveryStoreShardingInfoRequest))
}

func (fieldMask *GetRecoveryStoreShardingInfoRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetRecoveryStoreShardingInfosRequest_FieldMask struct {
	Paths []BatchGetRecoveryStoreShardingInfosRequest_FieldPath
}

func FullBatchGetRecoveryStoreShardingInfosRequest_FieldMask() *BatchGetRecoveryStoreShardingInfosRequest_FieldMask {
	res := &BatchGetRecoveryStoreShardingInfosRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: BatchGetRecoveryStoreShardingInfosRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: BatchGetRecoveryStoreShardingInfosRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: BatchGetRecoveryStoreShardingInfosRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetRecoveryStoreShardingInfosRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetRecoveryStoreShardingInfosRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetRecoveryStoreShardingInfosRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) Subtract(other *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) *BatchGetRecoveryStoreShardingInfosRequest_FieldMask {
	result := &BatchGetRecoveryStoreShardingInfosRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetRecoveryStoreShardingInfosRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetRecoveryStoreShardingInfosRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) FilterInputFields() *BatchGetRecoveryStoreShardingInfosRequest_FieldMask {
	result := &BatchGetRecoveryStoreShardingInfosRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetRecoveryStoreShardingInfosRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetRecoveryStoreShardingInfosRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetRecoveryStoreShardingInfosRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetRecoveryStoreShardingInfosRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) AppendPath(path BatchGetRecoveryStoreShardingInfosRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetRecoveryStoreShardingInfosRequest_FieldPath))
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) GetPaths() []BatchGetRecoveryStoreShardingInfosRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetRecoveryStoreShardingInfosRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) Set(target, source *BatchGetRecoveryStoreShardingInfosRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetRecoveryStoreShardingInfosRequest), source.(*BatchGetRecoveryStoreShardingInfosRequest))
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) Project(source *BatchGetRecoveryStoreShardingInfosRequest) *BatchGetRecoveryStoreShardingInfosRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetRecoveryStoreShardingInfosRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetRecoveryStoreShardingInfosRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetRecoveryStoreShardingInfosRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetRecoveryStoreShardingInfosRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetRecoveryStoreShardingInfosRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetRecoveryStoreShardingInfosRequest))
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetRecoveryStoreShardingInfosResponse_FieldMask struct {
	Paths []BatchGetRecoveryStoreShardingInfosResponse_FieldPath
}

func FullBatchGetRecoveryStoreShardingInfosResponse_FieldMask() *BatchGetRecoveryStoreShardingInfosResponse_FieldMask {
	res := &BatchGetRecoveryStoreShardingInfosResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos})
	res.Paths = append(res.Paths, &BatchGetRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetRecoveryStoreShardingInfosResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetRecoveryStoreShardingInfosResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetRecoveryStoreShardingInfosResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) Subtract(other *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) *BatchGetRecoveryStoreShardingInfosResponse_FieldMask {
	result := &BatchGetRecoveryStoreShardingInfosResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
	}
	mySubMasks := map[BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetRecoveryStoreShardingInfosResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetRecoveryStoreShardingInfosResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetRecoveryStoreShardingInfosResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos:
						mySubMasks[BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos] = recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetRecoveryStoreShardingInfosResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetRecoveryStoreShardingInfosResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetRecoveryStoreShardingInfosResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) FilterInputFields() *BatchGetRecoveryStoreShardingInfosResponse_FieldMask {
	result := &BatchGetRecoveryStoreShardingInfosResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos:
			if _, ok := path.(*BatchGetRecoveryStoreShardingInfosResponse_FieldTerminalPath); ok {
				for _, subpath := range recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetRecoveryStoreShardingInfosResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetRecoveryStoreShardingInfosResponse_FieldSubPath); ok {
				selectedMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{
					Paths: []recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath{sub.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetRecoveryStoreShardingInfosResponse_FieldSubPath{selector: BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetRecoveryStoreShardingInfosResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetRecoveryStoreShardingInfosResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetRecoveryStoreShardingInfosResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetRecoveryStoreShardingInfosResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) AppendPath(path BatchGetRecoveryStoreShardingInfosResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetRecoveryStoreShardingInfosResponse_FieldPath))
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) GetPaths() []BatchGetRecoveryStoreShardingInfosResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetRecoveryStoreShardingInfosResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) Set(target, source *BatchGetRecoveryStoreShardingInfosResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetRecoveryStoreShardingInfosResponse), source.(*BatchGetRecoveryStoreShardingInfosResponse))
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) Project(source *BatchGetRecoveryStoreShardingInfosResponse) *BatchGetRecoveryStoreShardingInfosResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetRecoveryStoreShardingInfosResponse{}
	recoveryStoreShardingInfosMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{}
	wholeRecoveryStoreShardingInfosAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetRecoveryStoreShardingInfosResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos:
				result.RecoveryStoreShardingInfos = source.RecoveryStoreShardingInfos
				wholeRecoveryStoreShardingInfosAccepted = true
			case BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetRecoveryStoreShardingInfosResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos:
				recoveryStoreShardingInfosMask.AppendPath(tp.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath))
			}
		}
	}
	if wholeRecoveryStoreShardingInfosAccepted == false && len(recoveryStoreShardingInfosMask.Paths) > 0 {
		for _, sourceItem := range source.GetRecoveryStoreShardingInfos() {
			result.RecoveryStoreShardingInfos = append(result.RecoveryStoreShardingInfos, recoveryStoreShardingInfosMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetRecoveryStoreShardingInfosResponse))
}

func (fieldMask *BatchGetRecoveryStoreShardingInfosResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListRecoveryStoreShardingInfosRequest_FieldMask struct {
	Paths []ListRecoveryStoreShardingInfosRequest_FieldPath
}

func FullListRecoveryStoreShardingInfosRequest_FieldMask() *ListRecoveryStoreShardingInfosRequest_FieldMask {
	res := &ListRecoveryStoreShardingInfosRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListRecoveryStoreShardingInfosRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListRecoveryStoreShardingInfosRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListRecoveryStoreShardingInfosRequest_FieldPath(raw)
	})
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) Subtract(other *ListRecoveryStoreShardingInfosRequest_FieldMask) *ListRecoveryStoreShardingInfosRequest_FieldMask {
	result := &ListRecoveryStoreShardingInfosRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListRecoveryStoreShardingInfosRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListRecoveryStoreShardingInfosRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) FilterInputFields() *ListRecoveryStoreShardingInfosRequest_FieldMask {
	result := &ListRecoveryStoreShardingInfosRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListRecoveryStoreShardingInfosRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListRecoveryStoreShardingInfosRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListRecoveryStoreShardingInfosRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListRecoveryStoreShardingInfosRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) AppendPath(path ListRecoveryStoreShardingInfosRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListRecoveryStoreShardingInfosRequest_FieldPath))
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) GetPaths() []ListRecoveryStoreShardingInfosRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListRecoveryStoreShardingInfosRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) Set(target, source *ListRecoveryStoreShardingInfosRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListRecoveryStoreShardingInfosRequest), source.(*ListRecoveryStoreShardingInfosRequest))
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) Project(source *ListRecoveryStoreShardingInfosRequest) *ListRecoveryStoreShardingInfosRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListRecoveryStoreShardingInfosRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListRecoveryStoreShardingInfosRequest_FieldTerminalPath:
			switch tp.selector {
			case ListRecoveryStoreShardingInfosRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListRecoveryStoreShardingInfosRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListRecoveryStoreShardingInfosRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListRecoveryStoreShardingInfosRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListRecoveryStoreShardingInfosRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListRecoveryStoreShardingInfosRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListRecoveryStoreShardingInfosRequest_FieldPathSelectorView:
				result.View = source.View
			case ListRecoveryStoreShardingInfosRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListRecoveryStoreShardingInfosRequest))
}

func (fieldMask *ListRecoveryStoreShardingInfosRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListRecoveryStoreShardingInfosResponse_FieldMask struct {
	Paths []ListRecoveryStoreShardingInfosResponse_FieldPath
}

func FullListRecoveryStoreShardingInfosResponse_FieldMask() *ListRecoveryStoreShardingInfosResponse_FieldMask {
	res := &ListRecoveryStoreShardingInfosResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: ListRecoveryStoreShardingInfosResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListRecoveryStoreShardingInfosResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListRecoveryStoreShardingInfosResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListRecoveryStoreShardingInfosResponse_FieldPath(raw)
	})
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) Subtract(other *ListRecoveryStoreShardingInfosResponse_FieldMask) *ListRecoveryStoreShardingInfosResponse_FieldMask {
	result := &ListRecoveryStoreShardingInfosResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListRecoveryStoreShardingInfosResponse_FieldPathSelector]gotenobject.FieldMask{
		ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
	}
	mySubMasks := map[ListRecoveryStoreShardingInfosResponse_FieldPathSelector]gotenobject.FieldMask{
		ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListRecoveryStoreShardingInfosResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListRecoveryStoreShardingInfosResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListRecoveryStoreShardingInfosResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos:
						mySubMasks[ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos] = recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask()
					}
				} else if tp, ok := path.(*ListRecoveryStoreShardingInfosResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListRecoveryStoreShardingInfosResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListRecoveryStoreShardingInfosResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) FilterInputFields() *ListRecoveryStoreShardingInfosResponse_FieldMask {
	result := &ListRecoveryStoreShardingInfosResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos:
			if _, ok := path.(*ListRecoveryStoreShardingInfosResponse_FieldTerminalPath); ok {
				for _, subpath := range recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListRecoveryStoreShardingInfosResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListRecoveryStoreShardingInfosResponse_FieldSubPath); ok {
				selectedMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{
					Paths: []recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath{sub.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListRecoveryStoreShardingInfosResponse_FieldSubPath{selector: ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListRecoveryStoreShardingInfosResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListRecoveryStoreShardingInfosResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListRecoveryStoreShardingInfosResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListRecoveryStoreShardingInfosResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) AppendPath(path ListRecoveryStoreShardingInfosResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListRecoveryStoreShardingInfosResponse_FieldPath))
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) GetPaths() []ListRecoveryStoreShardingInfosResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListRecoveryStoreShardingInfosResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) Set(target, source *ListRecoveryStoreShardingInfosResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListRecoveryStoreShardingInfosResponse), source.(*ListRecoveryStoreShardingInfosResponse))
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) Project(source *ListRecoveryStoreShardingInfosResponse) *ListRecoveryStoreShardingInfosResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListRecoveryStoreShardingInfosResponse{}
	recoveryStoreShardingInfosMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{}
	wholeRecoveryStoreShardingInfosAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListRecoveryStoreShardingInfosResponse_FieldTerminalPath:
			switch tp.selector {
			case ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos:
				result.RecoveryStoreShardingInfos = source.RecoveryStoreShardingInfos
				wholeRecoveryStoreShardingInfosAccepted = true
			case ListRecoveryStoreShardingInfosResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListRecoveryStoreShardingInfosResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListRecoveryStoreShardingInfosResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListRecoveryStoreShardingInfosResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListRecoveryStoreShardingInfosResponse_FieldSubPath:
			switch tp.selector {
			case ListRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfos:
				recoveryStoreShardingInfosMask.AppendPath(tp.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath))
			}
		}
	}
	if wholeRecoveryStoreShardingInfosAccepted == false && len(recoveryStoreShardingInfosMask.Paths) > 0 {
		for _, sourceItem := range source.GetRecoveryStoreShardingInfos() {
			result.RecoveryStoreShardingInfos = append(result.RecoveryStoreShardingInfos, recoveryStoreShardingInfosMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListRecoveryStoreShardingInfosResponse))
}

func (fieldMask *ListRecoveryStoreShardingInfosResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchRecoveryStoreShardingInfoRequest_FieldMask struct {
	Paths []WatchRecoveryStoreShardingInfoRequest_FieldPath
}

func FullWatchRecoveryStoreShardingInfoRequest_FieldMask() *WatchRecoveryStoreShardingInfoRequest_FieldMask {
	res := &WatchRecoveryStoreShardingInfoRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfoRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfoRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfoRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchRecoveryStoreShardingInfoRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchRecoveryStoreShardingInfoRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) Subtract(other *WatchRecoveryStoreShardingInfoRequest_FieldMask) *WatchRecoveryStoreShardingInfoRequest_FieldMask {
	result := &WatchRecoveryStoreShardingInfoRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchRecoveryStoreShardingInfoRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) FilterInputFields() *WatchRecoveryStoreShardingInfoRequest_FieldMask {
	result := &WatchRecoveryStoreShardingInfoRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchRecoveryStoreShardingInfoRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchRecoveryStoreShardingInfoRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchRecoveryStoreShardingInfoRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchRecoveryStoreShardingInfoRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) AppendPath(path WatchRecoveryStoreShardingInfoRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchRecoveryStoreShardingInfoRequest_FieldPath))
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) GetPaths() []WatchRecoveryStoreShardingInfoRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchRecoveryStoreShardingInfoRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) Set(target, source *WatchRecoveryStoreShardingInfoRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchRecoveryStoreShardingInfoRequest), source.(*WatchRecoveryStoreShardingInfoRequest))
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) Project(source *WatchRecoveryStoreShardingInfoRequest) *WatchRecoveryStoreShardingInfoRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchRecoveryStoreShardingInfoRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchRecoveryStoreShardingInfoRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchRecoveryStoreShardingInfoRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchRecoveryStoreShardingInfoRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchRecoveryStoreShardingInfoRequest))
}

func (fieldMask *WatchRecoveryStoreShardingInfoRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchRecoveryStoreShardingInfoResponse_FieldMask struct {
	Paths []WatchRecoveryStoreShardingInfoResponse_FieldPath
}

func FullWatchRecoveryStoreShardingInfoResponse_FieldMask() *WatchRecoveryStoreShardingInfoResponse_FieldMask {
	res := &WatchRecoveryStoreShardingInfoResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfoResponse_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfoResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchRecoveryStoreShardingInfoResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchRecoveryStoreShardingInfoResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchRecoveryStoreShardingInfoResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) Subtract(other *WatchRecoveryStoreShardingInfoResponse_FieldMask) *WatchRecoveryStoreShardingInfoResponse_FieldMask {
	result := &WatchRecoveryStoreShardingInfoResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchRecoveryStoreShardingInfoResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchRecoveryStoreShardingInfoResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) FilterInputFields() *WatchRecoveryStoreShardingInfoResponse_FieldMask {
	result := &WatchRecoveryStoreShardingInfoResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchRecoveryStoreShardingInfoResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchRecoveryStoreShardingInfoResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchRecoveryStoreShardingInfoResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchRecoveryStoreShardingInfoResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) AppendPath(path WatchRecoveryStoreShardingInfoResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchRecoveryStoreShardingInfoResponse_FieldPath))
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) GetPaths() []WatchRecoveryStoreShardingInfoResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchRecoveryStoreShardingInfoResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) Set(target, source *WatchRecoveryStoreShardingInfoResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchRecoveryStoreShardingInfoResponse), source.(*WatchRecoveryStoreShardingInfoResponse))
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) Project(source *WatchRecoveryStoreShardingInfoResponse) *WatchRecoveryStoreShardingInfoResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchRecoveryStoreShardingInfoResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchRecoveryStoreShardingInfoResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchRecoveryStoreShardingInfoResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchRecoveryStoreShardingInfoResponse))
}

func (fieldMask *WatchRecoveryStoreShardingInfoResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchRecoveryStoreShardingInfosRequest_FieldMask struct {
	Paths []WatchRecoveryStoreShardingInfosRequest_FieldPath
}

func FullWatchRecoveryStoreShardingInfosRequest_FieldMask() *WatchRecoveryStoreShardingInfosRequest_FieldMask {
	res := &WatchRecoveryStoreShardingInfosRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchRecoveryStoreShardingInfosRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchRecoveryStoreShardingInfosRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) Subtract(other *WatchRecoveryStoreShardingInfosRequest_FieldMask) *WatchRecoveryStoreShardingInfosRequest_FieldMask {
	result := &WatchRecoveryStoreShardingInfosRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchRecoveryStoreShardingInfosRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) FilterInputFields() *WatchRecoveryStoreShardingInfosRequest_FieldMask {
	result := &WatchRecoveryStoreShardingInfosRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchRecoveryStoreShardingInfosRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchRecoveryStoreShardingInfosRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchRecoveryStoreShardingInfosRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchRecoveryStoreShardingInfosRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) AppendPath(path WatchRecoveryStoreShardingInfosRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchRecoveryStoreShardingInfosRequest_FieldPath))
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) GetPaths() []WatchRecoveryStoreShardingInfosRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchRecoveryStoreShardingInfosRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) Set(target, source *WatchRecoveryStoreShardingInfosRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchRecoveryStoreShardingInfosRequest), source.(*WatchRecoveryStoreShardingInfosRequest))
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) Project(source *WatchRecoveryStoreShardingInfosRequest) *WatchRecoveryStoreShardingInfosRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchRecoveryStoreShardingInfosRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchRecoveryStoreShardingInfosRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchRecoveryStoreShardingInfosRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchRecoveryStoreShardingInfosRequest))
}

func (fieldMask *WatchRecoveryStoreShardingInfosRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchRecoveryStoreShardingInfosResponse_FieldMask struct {
	Paths []WatchRecoveryStoreShardingInfosResponse_FieldPath
}

func FullWatchRecoveryStoreShardingInfosResponse_FieldMask() *WatchRecoveryStoreShardingInfosResponse_FieldMask {
	res := &WatchRecoveryStoreShardingInfosResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfoChanges})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchRecoveryStoreShardingInfosResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchRecoveryStoreShardingInfosResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) Subtract(other *WatchRecoveryStoreShardingInfosResponse_FieldMask) *WatchRecoveryStoreShardingInfosResponse_FieldMask {
	result := &WatchRecoveryStoreShardingInfosResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchRecoveryStoreShardingInfosResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorPageTokenChange: &WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchRecoveryStoreShardingInfosResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorPageTokenChange: &WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchRecoveryStoreShardingInfosResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorPageTokenChange] = FullWatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchRecoveryStoreShardingInfosResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchRecoveryStoreShardingInfosResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchRecoveryStoreShardingInfosResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) FilterInputFields() *WatchRecoveryStoreShardingInfosResponse_FieldMask {
	result := &WatchRecoveryStoreShardingInfosResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchRecoveryStoreShardingInfosResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchRecoveryStoreShardingInfosResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchRecoveryStoreShardingInfosResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchRecoveryStoreShardingInfosResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) AppendPath(path WatchRecoveryStoreShardingInfosResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchRecoveryStoreShardingInfosResponse_FieldPath))
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) GetPaths() []WatchRecoveryStoreShardingInfosResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchRecoveryStoreShardingInfosResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) Set(target, source *WatchRecoveryStoreShardingInfosResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchRecoveryStoreShardingInfosResponse), source.(*WatchRecoveryStoreShardingInfosResponse))
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) Project(source *WatchRecoveryStoreShardingInfosResponse) *WatchRecoveryStoreShardingInfosResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchRecoveryStoreShardingInfosResponse{}
	pageTokenChangeMask := &WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchRecoveryStoreShardingInfosResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorRecoveryStoreShardingInfoChanges:
				result.RecoveryStoreShardingInfoChanges = source.RecoveryStoreShardingInfoChanges
			case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchRecoveryStoreShardingInfosResponse_FieldSubPath:
			switch tp.selector {
			case WatchRecoveryStoreShardingInfosResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchRecoveryStoreShardingInfosResponse))
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask struct {
	Paths []WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath
}

func FullWatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask() *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask {
	res := &WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldTerminalPath{selector: WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) Subtract(other *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask {
	result := &WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask {
	result := &WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) AppendPath(path WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) GetPaths() []WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) Set(target, source *WatchRecoveryStoreShardingInfosResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchRecoveryStoreShardingInfosResponse_PageTokenChange), source.(*WatchRecoveryStoreShardingInfosResponse_PageTokenChange))
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) Project(source *WatchRecoveryStoreShardingInfosResponse_PageTokenChange) *WatchRecoveryStoreShardingInfosResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchRecoveryStoreShardingInfosResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchRecoveryStoreShardingInfosResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchRecoveryStoreShardingInfosResponse_PageTokenChange))
}

func (fieldMask *WatchRecoveryStoreShardingInfosResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateRecoveryStoreShardingInfoRequest_FieldMask struct {
	Paths []CreateRecoveryStoreShardingInfoRequest_FieldPath
}

func FullCreateRecoveryStoreShardingInfoRequest_FieldMask() *CreateRecoveryStoreShardingInfoRequest_FieldMask {
	res := &CreateRecoveryStoreShardingInfoRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo})
	return res
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateRecoveryStoreShardingInfoRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateRecoveryStoreShardingInfoRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) Subtract(other *CreateRecoveryStoreShardingInfoRequest_FieldMask) *CreateRecoveryStoreShardingInfoRequest_FieldMask {
	result := &CreateRecoveryStoreShardingInfoRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateRecoveryStoreShardingInfoRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
	}
	mySubMasks := map[CreateRecoveryStoreShardingInfoRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateRecoveryStoreShardingInfoRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo:
						mySubMasks[CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo] = recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask()
					}
				} else if tp, ok := path.(*CreateRecoveryStoreShardingInfoRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateRecoveryStoreShardingInfoRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateRecoveryStoreShardingInfoRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) FilterInputFields() *CreateRecoveryStoreShardingInfoRequest_FieldMask {
	result := &CreateRecoveryStoreShardingInfoRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo:
			if _, ok := path.(*CreateRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
				for _, subpath := range recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateRecoveryStoreShardingInfoRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateRecoveryStoreShardingInfoRequest_FieldSubPath); ok {
				selectedMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{
					Paths: []recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath{sub.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateRecoveryStoreShardingInfoRequest_FieldSubPath{selector: CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateRecoveryStoreShardingInfoRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateRecoveryStoreShardingInfoRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateRecoveryStoreShardingInfoRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateRecoveryStoreShardingInfoRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) AppendPath(path CreateRecoveryStoreShardingInfoRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateRecoveryStoreShardingInfoRequest_FieldPath))
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) GetPaths() []CreateRecoveryStoreShardingInfoRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateRecoveryStoreShardingInfoRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) Set(target, source *CreateRecoveryStoreShardingInfoRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateRecoveryStoreShardingInfoRequest), source.(*CreateRecoveryStoreShardingInfoRequest))
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) Project(source *CreateRecoveryStoreShardingInfoRequest) *CreateRecoveryStoreShardingInfoRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateRecoveryStoreShardingInfoRequest{}
	recoveryStoreShardingInfoMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{}
	wholeRecoveryStoreShardingInfoAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo:
				result.RecoveryStoreShardingInfo = source.RecoveryStoreShardingInfo
				wholeRecoveryStoreShardingInfoAccepted = true
			}
		case *CreateRecoveryStoreShardingInfoRequest_FieldSubPath:
			switch tp.selector {
			case CreateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo:
				recoveryStoreShardingInfoMask.AppendPath(tp.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath))
			}
		}
	}
	if wholeRecoveryStoreShardingInfoAccepted == false && len(recoveryStoreShardingInfoMask.Paths) > 0 {
		result.RecoveryStoreShardingInfo = recoveryStoreShardingInfoMask.Project(source.GetRecoveryStoreShardingInfo())
	}
	return result
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateRecoveryStoreShardingInfoRequest))
}

func (fieldMask *CreateRecoveryStoreShardingInfoRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateRecoveryStoreShardingInfoRequest_FieldMask struct {
	Paths []UpdateRecoveryStoreShardingInfoRequest_FieldPath
}

func FullUpdateRecoveryStoreShardingInfoRequest_FieldMask() *UpdateRecoveryStoreShardingInfoRequest_FieldMask {
	res := &UpdateRecoveryStoreShardingInfoRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo})
	res.Paths = append(res.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas})
	res.Paths = append(res.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorAllowMissing})
	return res
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateRecoveryStoreShardingInfoRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateRecoveryStoreShardingInfoRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) Subtract(other *UpdateRecoveryStoreShardingInfoRequest_FieldMask) *UpdateRecoveryStoreShardingInfoRequest_FieldMask {
	result := &UpdateRecoveryStoreShardingInfoRequest_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[UpdateRecoveryStoreShardingInfoRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
		UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas:                       &UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateRecoveryStoreShardingInfoRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
		UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas:                       &UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateRecoveryStoreShardingInfoRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo:
						mySubMasks[UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo] = recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask()
					case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas:
						mySubMasks[UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas] = FullUpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateRecoveryStoreShardingInfoRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateRecoveryStoreShardingInfoRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) FilterInputFields() *UpdateRecoveryStoreShardingInfoRequest_FieldMask {
	result := &UpdateRecoveryStoreShardingInfoRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo:
			if _, ok := path.(*UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
				for _, subpath := range recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateRecoveryStoreShardingInfoRequest_FieldSubPath); ok {
				selectedMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{
					Paths: []recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath{sub.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldSubPath{selector: UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo, subPath: allowedPath})
				}
			}
		case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateRecoveryStoreShardingInfoRequest_FieldSubPath); ok {
				selectedMask := &UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask{
					Paths: []UpdateRecoveryStoreShardingInfoRequestCAS_FieldPath{sub.subPath.(UpdateRecoveryStoreShardingInfoRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateRecoveryStoreShardingInfoRequest_FieldSubPath{selector: UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateRecoveryStoreShardingInfoRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateRecoveryStoreShardingInfoRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateRecoveryStoreShardingInfoRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateRecoveryStoreShardingInfoRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) AppendPath(path UpdateRecoveryStoreShardingInfoRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateRecoveryStoreShardingInfoRequest_FieldPath))
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) GetPaths() []UpdateRecoveryStoreShardingInfoRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateRecoveryStoreShardingInfoRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) Set(target, source *UpdateRecoveryStoreShardingInfoRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateRecoveryStoreShardingInfoRequest), source.(*UpdateRecoveryStoreShardingInfoRequest))
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) Project(source *UpdateRecoveryStoreShardingInfoRequest) *UpdateRecoveryStoreShardingInfoRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateRecoveryStoreShardingInfoRequest{}
	recoveryStoreShardingInfoMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{}
	wholeRecoveryStoreShardingInfoAccepted := false
	casMask := &UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo:
				result.RecoveryStoreShardingInfo = source.RecoveryStoreShardingInfo
				wholeRecoveryStoreShardingInfoAccepted = true
			case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorAllowMissing:
				result.AllowMissing = source.AllowMissing
			}
		case *UpdateRecoveryStoreShardingInfoRequest_FieldSubPath:
			switch tp.selector {
			case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorRecoveryStoreShardingInfo:
				recoveryStoreShardingInfoMask.AppendPath(tp.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath))
			case UpdateRecoveryStoreShardingInfoRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateRecoveryStoreShardingInfoRequestCAS_FieldPath))
			}
		}
	}
	if wholeRecoveryStoreShardingInfoAccepted == false && len(recoveryStoreShardingInfoMask.Paths) > 0 {
		result.RecoveryStoreShardingInfo = recoveryStoreShardingInfoMask.Project(source.GetRecoveryStoreShardingInfo())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateRecoveryStoreShardingInfoRequest))
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask struct {
	Paths []UpdateRecoveryStoreShardingInfoRequestCAS_FieldPath
}

func FullUpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask() *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask {
	res := &UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateRecoveryStoreShardingInfoRequestCAS_FieldTerminalPath{selector: UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateRecoveryStoreShardingInfoRequestCAS_FieldTerminalPath{selector: UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateRecoveryStoreShardingInfoRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateRecoveryStoreShardingInfoRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateRecoveryStoreShardingInfoRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) Subtract(other *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask {
	result := &UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
	}
	mySubMasks := map[UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState: &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateRecoveryStoreShardingInfoRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateRecoveryStoreShardingInfoRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateRecoveryStoreShardingInfoRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState] = recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask()
					}
				} else if tp, ok := path.(*UpdateRecoveryStoreShardingInfoRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateRecoveryStoreShardingInfoRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) FilterInputFields() *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask {
	result := &UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateRecoveryStoreShardingInfoRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range recovery_store_sharding_info.FullRecoveryStoreShardingInfo_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateRecoveryStoreShardingInfoRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateRecoveryStoreShardingInfoRequestCAS_FieldSubPath); ok {
				selectedMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{
					Paths: []recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath{sub.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateRecoveryStoreShardingInfoRequestCAS_FieldSubPath{selector: UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateRecoveryStoreShardingInfoRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateRecoveryStoreShardingInfoRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) AppendPath(path UpdateRecoveryStoreShardingInfoRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateRecoveryStoreShardingInfoRequestCAS_FieldPath))
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) GetPaths() []UpdateRecoveryStoreShardingInfoRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateRecoveryStoreShardingInfoRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) Set(target, source *UpdateRecoveryStoreShardingInfoRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateRecoveryStoreShardingInfoRequest_CAS), source.(*UpdateRecoveryStoreShardingInfoRequest_CAS))
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) Project(source *UpdateRecoveryStoreShardingInfoRequest_CAS) *UpdateRecoveryStoreShardingInfoRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateRecoveryStoreShardingInfoRequest_CAS{}
	conditionalStateMask := &recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateRecoveryStoreShardingInfoRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateRecoveryStoreShardingInfoRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateRecoveryStoreShardingInfoRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(recovery_store_sharding_info.RecoveryStoreShardingInfo_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateRecoveryStoreShardingInfoRequest_CAS))
}

func (fieldMask *UpdateRecoveryStoreShardingInfoRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteRecoveryStoreShardingInfoRequest_FieldMask struct {
	Paths []DeleteRecoveryStoreShardingInfoRequest_FieldPath
}

func FullDeleteRecoveryStoreShardingInfoRequest_FieldMask() *DeleteRecoveryStoreShardingInfoRequest_FieldMask {
	res := &DeleteRecoveryStoreShardingInfoRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteRecoveryStoreShardingInfoRequest_FieldTerminalPath{selector: DeleteRecoveryStoreShardingInfoRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteRecoveryStoreShardingInfoRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteRecoveryStoreShardingInfoRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteRecoveryStoreShardingInfoRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) Subtract(other *DeleteRecoveryStoreShardingInfoRequest_FieldMask) *DeleteRecoveryStoreShardingInfoRequest_FieldMask {
	result := &DeleteRecoveryStoreShardingInfoRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteRecoveryStoreShardingInfoRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) FilterInputFields() *DeleteRecoveryStoreShardingInfoRequest_FieldMask {
	result := &DeleteRecoveryStoreShardingInfoRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteRecoveryStoreShardingInfoRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteRecoveryStoreShardingInfoRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteRecoveryStoreShardingInfoRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteRecoveryStoreShardingInfoRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) AppendPath(path DeleteRecoveryStoreShardingInfoRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteRecoveryStoreShardingInfoRequest_FieldPath))
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) GetPaths() []DeleteRecoveryStoreShardingInfoRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteRecoveryStoreShardingInfoRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) Set(target, source *DeleteRecoveryStoreShardingInfoRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteRecoveryStoreShardingInfoRequest), source.(*DeleteRecoveryStoreShardingInfoRequest))
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) Project(source *DeleteRecoveryStoreShardingInfoRequest) *DeleteRecoveryStoreShardingInfoRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteRecoveryStoreShardingInfoRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteRecoveryStoreShardingInfoRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteRecoveryStoreShardingInfoRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteRecoveryStoreShardingInfoRequest))
}

func (fieldMask *DeleteRecoveryStoreShardingInfoRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
