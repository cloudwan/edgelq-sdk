// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v3/notification_service.proto
// DO NOT EDIT!!!

package notification_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	alerting_policy "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/alerting_policy"
	notification "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/notification"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &alerting_policy.AlertingPolicy{}
	_ = &notification.Notification{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetNotificationRequest_FieldMask struct {
	Paths []GetNotificationRequest_FieldPath
}

func FullGetNotificationRequest_FieldMask() *GetNotificationRequest_FieldMask {
	res := &GetNotificationRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetNotificationRequest_FieldTerminalPath{selector: GetNotificationRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetNotificationRequest_FieldTerminalPath{selector: GetNotificationRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetNotificationRequest_FieldTerminalPath{selector: GetNotificationRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetNotificationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetNotificationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetNotificationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetNotificationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetNotificationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetNotificationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetNotificationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetNotificationRequest_FieldPath(raw)
	})
}

func (fieldMask *GetNotificationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetNotificationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetNotificationRequest_FieldMask) Subtract(other *GetNotificationRequest_FieldMask) *GetNotificationRequest_FieldMask {
	result := &GetNotificationRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetNotificationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetNotificationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetNotificationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetNotificationRequest_FieldMask) FilterInputFields() *GetNotificationRequest_FieldMask {
	result := &GetNotificationRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetNotificationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetNotificationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetNotificationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetNotificationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetNotificationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetNotificationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetNotificationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetNotificationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetNotificationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetNotificationRequest_FieldMask) AppendPath(path GetNotificationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetNotificationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetNotificationRequest_FieldPath))
}

func (fieldMask *GetNotificationRequest_FieldMask) GetPaths() []GetNotificationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetNotificationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetNotificationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetNotificationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetNotificationRequest_FieldMask) Set(target, source *GetNotificationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetNotificationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetNotificationRequest), source.(*GetNotificationRequest))
}

func (fieldMask *GetNotificationRequest_FieldMask) Project(source *GetNotificationRequest) *GetNotificationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetNotificationRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetNotificationRequest_FieldTerminalPath:
			switch tp.selector {
			case GetNotificationRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetNotificationRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetNotificationRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetNotificationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetNotificationRequest))
}

func (fieldMask *GetNotificationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetNotificationsRequest_FieldMask struct {
	Paths []BatchGetNotificationsRequest_FieldPath
}

func FullBatchGetNotificationsRequest_FieldMask() *BatchGetNotificationsRequest_FieldMask {
	res := &BatchGetNotificationsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetNotificationsRequest_FieldTerminalPath{selector: BatchGetNotificationsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetNotificationsRequest_FieldTerminalPath{selector: BatchGetNotificationsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetNotificationsRequest_FieldTerminalPath{selector: BatchGetNotificationsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetNotificationsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetNotificationsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetNotificationsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetNotificationsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) Subtract(other *BatchGetNotificationsRequest_FieldMask) *BatchGetNotificationsRequest_FieldMask {
	result := &BatchGetNotificationsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetNotificationsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetNotificationsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetNotificationsRequest_FieldMask) FilterInputFields() *BatchGetNotificationsRequest_FieldMask {
	result := &BatchGetNotificationsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetNotificationsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetNotificationsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetNotificationsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetNotificationsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetNotificationsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) AppendPath(path BatchGetNotificationsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetNotificationsRequest_FieldPath))
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) GetPaths() []BatchGetNotificationsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetNotificationsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) Set(target, source *BatchGetNotificationsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetNotificationsRequest), source.(*BatchGetNotificationsRequest))
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) Project(source *BatchGetNotificationsRequest) *BatchGetNotificationsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetNotificationsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetNotificationsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetNotificationsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetNotificationsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetNotificationsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetNotificationsRequest))
}

func (fieldMask *BatchGetNotificationsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetNotificationsResponse_FieldMask struct {
	Paths []BatchGetNotificationsResponse_FieldPath
}

func FullBatchGetNotificationsResponse_FieldMask() *BatchGetNotificationsResponse_FieldMask {
	res := &BatchGetNotificationsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetNotificationsResponse_FieldTerminalPath{selector: BatchGetNotificationsResponse_FieldPathSelectorNotifications})
	res.Paths = append(res.Paths, &BatchGetNotificationsResponse_FieldTerminalPath{selector: BatchGetNotificationsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetNotificationsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetNotificationsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetNotificationsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetNotificationsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) Subtract(other *BatchGetNotificationsResponse_FieldMask) *BatchGetNotificationsResponse_FieldMask {
	result := &BatchGetNotificationsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetNotificationsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetNotificationsResponse_FieldPathSelectorNotifications: &notification.Notification_FieldMask{},
	}
	mySubMasks := map[BatchGetNotificationsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetNotificationsResponse_FieldPathSelectorNotifications: &notification.Notification_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetNotificationsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetNotificationsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetNotificationsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetNotificationsResponse_FieldPathSelectorNotifications:
						mySubMasks[BatchGetNotificationsResponse_FieldPathSelectorNotifications] = notification.FullNotification_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetNotificationsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetNotificationsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetNotificationsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetNotificationsResponse_FieldMask) FilterInputFields() *BatchGetNotificationsResponse_FieldMask {
	result := &BatchGetNotificationsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetNotificationsResponse_FieldPathSelectorNotifications:
			if _, ok := path.(*BatchGetNotificationsResponse_FieldTerminalPath); ok {
				for _, subpath := range notification.FullNotification_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetNotificationsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetNotificationsResponse_FieldSubPath); ok {
				selectedMask := &notification.Notification_FieldMask{
					Paths: []notification.Notification_FieldPath{sub.subPath.(notification.Notification_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetNotificationsResponse_FieldSubPath{selector: BatchGetNotificationsResponse_FieldPathSelectorNotifications, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetNotificationsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetNotificationsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetNotificationsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetNotificationsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetNotificationsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) AppendPath(path BatchGetNotificationsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetNotificationsResponse_FieldPath))
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) GetPaths() []BatchGetNotificationsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetNotificationsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) Set(target, source *BatchGetNotificationsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetNotificationsResponse), source.(*BatchGetNotificationsResponse))
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) Project(source *BatchGetNotificationsResponse) *BatchGetNotificationsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetNotificationsResponse{}
	notificationsMask := &notification.Notification_FieldMask{}
	wholeNotificationsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetNotificationsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetNotificationsResponse_FieldPathSelectorNotifications:
				result.Notifications = source.Notifications
				wholeNotificationsAccepted = true
			case BatchGetNotificationsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetNotificationsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetNotificationsResponse_FieldPathSelectorNotifications:
				notificationsMask.AppendPath(tp.subPath.(notification.Notification_FieldPath))
			}
		}
	}
	if wholeNotificationsAccepted == false && len(notificationsMask.Paths) > 0 {
		for _, sourceItem := range source.GetNotifications() {
			result.Notifications = append(result.Notifications, notificationsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetNotificationsResponse))
}

func (fieldMask *BatchGetNotificationsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListNotificationsRequest_FieldMask struct {
	Paths []ListNotificationsRequest_FieldPath
}

func FullListNotificationsRequest_FieldMask() *ListNotificationsRequest_FieldMask {
	res := &ListNotificationsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListNotificationsRequest_FieldTerminalPath{selector: ListNotificationsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListNotificationsRequest_FieldTerminalPath{selector: ListNotificationsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListNotificationsRequest_FieldTerminalPath{selector: ListNotificationsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListNotificationsRequest_FieldTerminalPath{selector: ListNotificationsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListNotificationsRequest_FieldTerminalPath{selector: ListNotificationsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListNotificationsRequest_FieldTerminalPath{selector: ListNotificationsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListNotificationsRequest_FieldTerminalPath{selector: ListNotificationsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListNotificationsRequest_FieldTerminalPath{selector: ListNotificationsRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListNotificationsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListNotificationsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListNotificationsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListNotificationsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListNotificationsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListNotificationsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListNotificationsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListNotificationsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListNotificationsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListNotificationsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListNotificationsRequest_FieldMask) Subtract(other *ListNotificationsRequest_FieldMask) *ListNotificationsRequest_FieldMask {
	result := &ListNotificationsRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListNotificationsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListNotificationsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListNotificationsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListNotificationsRequest_FieldMask) FilterInputFields() *ListNotificationsRequest_FieldMask {
	result := &ListNotificationsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListNotificationsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListNotificationsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListNotificationsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListNotificationsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListNotificationsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListNotificationsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListNotificationsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListNotificationsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListNotificationsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListNotificationsRequest_FieldMask) AppendPath(path ListNotificationsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListNotificationsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListNotificationsRequest_FieldPath))
}

func (fieldMask *ListNotificationsRequest_FieldMask) GetPaths() []ListNotificationsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListNotificationsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListNotificationsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListNotificationsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListNotificationsRequest_FieldMask) Set(target, source *ListNotificationsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListNotificationsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListNotificationsRequest), source.(*ListNotificationsRequest))
}

func (fieldMask *ListNotificationsRequest_FieldMask) Project(source *ListNotificationsRequest) *ListNotificationsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListNotificationsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListNotificationsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListNotificationsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListNotificationsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListNotificationsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListNotificationsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListNotificationsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListNotificationsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListNotificationsRequest_FieldPathSelectorView:
				result.View = source.View
			case ListNotificationsRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListNotificationsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListNotificationsRequest))
}

func (fieldMask *ListNotificationsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListNotificationsResponse_FieldMask struct {
	Paths []ListNotificationsResponse_FieldPath
}

func FullListNotificationsResponse_FieldMask() *ListNotificationsResponse_FieldMask {
	res := &ListNotificationsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListNotificationsResponse_FieldTerminalPath{selector: ListNotificationsResponse_FieldPathSelectorNotifications})
	res.Paths = append(res.Paths, &ListNotificationsResponse_FieldTerminalPath{selector: ListNotificationsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListNotificationsResponse_FieldTerminalPath{selector: ListNotificationsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListNotificationsResponse_FieldTerminalPath{selector: ListNotificationsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListNotificationsResponse_FieldTerminalPath{selector: ListNotificationsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListNotificationsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListNotificationsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListNotificationsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListNotificationsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListNotificationsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListNotificationsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListNotificationsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListNotificationsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListNotificationsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListNotificationsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListNotificationsResponse_FieldMask) Subtract(other *ListNotificationsResponse_FieldMask) *ListNotificationsResponse_FieldMask {
	result := &ListNotificationsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListNotificationsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListNotificationsResponse_FieldPathSelectorNotifications: &notification.Notification_FieldMask{},
	}
	mySubMasks := map[ListNotificationsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListNotificationsResponse_FieldPathSelectorNotifications: &notification.Notification_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListNotificationsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListNotificationsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListNotificationsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListNotificationsResponse_FieldPathSelectorNotifications:
						mySubMasks[ListNotificationsResponse_FieldPathSelectorNotifications] = notification.FullNotification_FieldMask()
					}
				} else if tp, ok := path.(*ListNotificationsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListNotificationsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListNotificationsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListNotificationsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListNotificationsResponse_FieldMask) FilterInputFields() *ListNotificationsResponse_FieldMask {
	result := &ListNotificationsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListNotificationsResponse_FieldPathSelectorNotifications:
			if _, ok := path.(*ListNotificationsResponse_FieldTerminalPath); ok {
				for _, subpath := range notification.FullNotification_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListNotificationsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListNotificationsResponse_FieldSubPath); ok {
				selectedMask := &notification.Notification_FieldMask{
					Paths: []notification.Notification_FieldPath{sub.subPath.(notification.Notification_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListNotificationsResponse_FieldSubPath{selector: ListNotificationsResponse_FieldPathSelectorNotifications, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListNotificationsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListNotificationsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListNotificationsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListNotificationsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListNotificationsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListNotificationsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListNotificationsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListNotificationsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListNotificationsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListNotificationsResponse_FieldMask) AppendPath(path ListNotificationsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListNotificationsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListNotificationsResponse_FieldPath))
}

func (fieldMask *ListNotificationsResponse_FieldMask) GetPaths() []ListNotificationsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListNotificationsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListNotificationsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListNotificationsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListNotificationsResponse_FieldMask) Set(target, source *ListNotificationsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListNotificationsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListNotificationsResponse), source.(*ListNotificationsResponse))
}

func (fieldMask *ListNotificationsResponse_FieldMask) Project(source *ListNotificationsResponse) *ListNotificationsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListNotificationsResponse{}
	notificationsMask := &notification.Notification_FieldMask{}
	wholeNotificationsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListNotificationsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListNotificationsResponse_FieldPathSelectorNotifications:
				result.Notifications = source.Notifications
				wholeNotificationsAccepted = true
			case ListNotificationsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListNotificationsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListNotificationsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListNotificationsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListNotificationsResponse_FieldSubPath:
			switch tp.selector {
			case ListNotificationsResponse_FieldPathSelectorNotifications:
				notificationsMask.AppendPath(tp.subPath.(notification.Notification_FieldPath))
			}
		}
	}
	if wholeNotificationsAccepted == false && len(notificationsMask.Paths) > 0 {
		for _, sourceItem := range source.GetNotifications() {
			result.Notifications = append(result.Notifications, notificationsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListNotificationsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListNotificationsResponse))
}

func (fieldMask *ListNotificationsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchNotificationRequest_FieldMask struct {
	Paths []WatchNotificationRequest_FieldPath
}

func FullWatchNotificationRequest_FieldMask() *WatchNotificationRequest_FieldMask {
	res := &WatchNotificationRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchNotificationRequest_FieldTerminalPath{selector: WatchNotificationRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchNotificationRequest_FieldTerminalPath{selector: WatchNotificationRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchNotificationRequest_FieldTerminalPath{selector: WatchNotificationRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchNotificationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchNotificationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchNotificationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchNotificationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchNotificationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchNotificationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchNotificationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchNotificationRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchNotificationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchNotificationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchNotificationRequest_FieldMask) Subtract(other *WatchNotificationRequest_FieldMask) *WatchNotificationRequest_FieldMask {
	result := &WatchNotificationRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchNotificationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchNotificationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchNotificationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchNotificationRequest_FieldMask) FilterInputFields() *WatchNotificationRequest_FieldMask {
	result := &WatchNotificationRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchNotificationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchNotificationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchNotificationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchNotificationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchNotificationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchNotificationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchNotificationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchNotificationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationRequest_FieldMask) AppendPath(path WatchNotificationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchNotificationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchNotificationRequest_FieldPath))
}

func (fieldMask *WatchNotificationRequest_FieldMask) GetPaths() []WatchNotificationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchNotificationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchNotificationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchNotificationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchNotificationRequest_FieldMask) Set(target, source *WatchNotificationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchNotificationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchNotificationRequest), source.(*WatchNotificationRequest))
}

func (fieldMask *WatchNotificationRequest_FieldMask) Project(source *WatchNotificationRequest) *WatchNotificationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchNotificationRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchNotificationRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchNotificationRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchNotificationRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchNotificationRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchNotificationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchNotificationRequest))
}

func (fieldMask *WatchNotificationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchNotificationResponse_FieldMask struct {
	Paths []WatchNotificationResponse_FieldPath
}

func FullWatchNotificationResponse_FieldMask() *WatchNotificationResponse_FieldMask {
	res := &WatchNotificationResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchNotificationResponse_FieldTerminalPath{selector: WatchNotificationResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchNotificationResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchNotificationResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchNotificationResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchNotificationResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchNotificationResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchNotificationResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchNotificationResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchNotificationResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchNotificationResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchNotificationResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchNotificationResponse_FieldMask) Subtract(other *WatchNotificationResponse_FieldMask) *WatchNotificationResponse_FieldMask {
	result := &WatchNotificationResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchNotificationResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchNotificationResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchNotificationResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchNotificationResponse_FieldMask) FilterInputFields() *WatchNotificationResponse_FieldMask {
	result := &WatchNotificationResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchNotificationResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchNotificationResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchNotificationResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchNotificationResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchNotificationResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchNotificationResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchNotificationResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchNotificationResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationResponse_FieldMask) AppendPath(path WatchNotificationResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchNotificationResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchNotificationResponse_FieldPath))
}

func (fieldMask *WatchNotificationResponse_FieldMask) GetPaths() []WatchNotificationResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchNotificationResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchNotificationResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchNotificationResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchNotificationResponse_FieldMask) Set(target, source *WatchNotificationResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchNotificationResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchNotificationResponse), source.(*WatchNotificationResponse))
}

func (fieldMask *WatchNotificationResponse_FieldMask) Project(source *WatchNotificationResponse) *WatchNotificationResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchNotificationResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchNotificationResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchNotificationResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchNotificationResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchNotificationResponse))
}

func (fieldMask *WatchNotificationResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchNotificationsRequest_FieldMask struct {
	Paths []WatchNotificationsRequest_FieldPath
}

func FullWatchNotificationsRequest_FieldMask() *WatchNotificationsRequest_FieldMask {
	res := &WatchNotificationsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchNotificationsRequest_FieldTerminalPath{selector: WatchNotificationsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchNotificationsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchNotificationsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchNotificationsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchNotificationsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchNotificationsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchNotificationsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchNotificationsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchNotificationsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchNotificationsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchNotificationsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchNotificationsRequest_FieldMask) Subtract(other *WatchNotificationsRequest_FieldMask) *WatchNotificationsRequest_FieldMask {
	result := &WatchNotificationsRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchNotificationsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchNotificationsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchNotificationsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchNotificationsRequest_FieldMask) FilterInputFields() *WatchNotificationsRequest_FieldMask {
	result := &WatchNotificationsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchNotificationsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchNotificationsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchNotificationsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchNotificationsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchNotificationsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchNotificationsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchNotificationsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchNotificationsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationsRequest_FieldMask) AppendPath(path WatchNotificationsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchNotificationsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchNotificationsRequest_FieldPath))
}

func (fieldMask *WatchNotificationsRequest_FieldMask) GetPaths() []WatchNotificationsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchNotificationsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchNotificationsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchNotificationsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchNotificationsRequest_FieldMask) Set(target, source *WatchNotificationsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchNotificationsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchNotificationsRequest), source.(*WatchNotificationsRequest))
}

func (fieldMask *WatchNotificationsRequest_FieldMask) Project(source *WatchNotificationsRequest) *WatchNotificationsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchNotificationsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchNotificationsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchNotificationsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchNotificationsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchNotificationsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchNotificationsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchNotificationsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchNotificationsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchNotificationsRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchNotificationsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchNotificationsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchNotificationsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchNotificationsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchNotificationsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchNotificationsRequest))
}

func (fieldMask *WatchNotificationsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchNotificationsResponse_FieldMask struct {
	Paths []WatchNotificationsResponse_FieldPath
}

func FullWatchNotificationsResponse_FieldMask() *WatchNotificationsResponse_FieldMask {
	res := &WatchNotificationsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchNotificationsResponse_FieldTerminalPath{selector: WatchNotificationsResponse_FieldPathSelectorNotificationChanges})
	res.Paths = append(res.Paths, &WatchNotificationsResponse_FieldTerminalPath{selector: WatchNotificationsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchNotificationsResponse_FieldTerminalPath{selector: WatchNotificationsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchNotificationsResponse_FieldTerminalPath{selector: WatchNotificationsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchNotificationsResponse_FieldTerminalPath{selector: WatchNotificationsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchNotificationsResponse_FieldTerminalPath{selector: WatchNotificationsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchNotificationsResponse_FieldTerminalPath{selector: WatchNotificationsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchNotificationsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchNotificationsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchNotificationsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchNotificationsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchNotificationsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchNotificationsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchNotificationsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchNotificationsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchNotificationsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchNotificationsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchNotificationsResponse_FieldMask) Subtract(other *WatchNotificationsResponse_FieldMask) *WatchNotificationsResponse_FieldMask {
	result := &WatchNotificationsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchNotificationsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchNotificationsResponse_FieldPathSelectorPageTokenChange: &WatchNotificationsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchNotificationsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchNotificationsResponse_FieldPathSelectorPageTokenChange: &WatchNotificationsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchNotificationsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchNotificationsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchNotificationsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchNotificationsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchNotificationsResponse_FieldPathSelectorPageTokenChange] = FullWatchNotificationsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchNotificationsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchNotificationsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchNotificationsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchNotificationsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchNotificationsResponse_FieldMask) FilterInputFields() *WatchNotificationsResponse_FieldMask {
	result := &WatchNotificationsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchNotificationsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchNotificationsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchNotificationsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchNotificationsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchNotificationsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchNotificationsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchNotificationsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchNotificationsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationsResponse_FieldMask) AppendPath(path WatchNotificationsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchNotificationsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchNotificationsResponse_FieldPath))
}

func (fieldMask *WatchNotificationsResponse_FieldMask) GetPaths() []WatchNotificationsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchNotificationsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchNotificationsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchNotificationsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchNotificationsResponse_FieldMask) Set(target, source *WatchNotificationsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchNotificationsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchNotificationsResponse), source.(*WatchNotificationsResponse))
}

func (fieldMask *WatchNotificationsResponse_FieldMask) Project(source *WatchNotificationsResponse) *WatchNotificationsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchNotificationsResponse{}
	pageTokenChangeMask := &WatchNotificationsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchNotificationsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchNotificationsResponse_FieldPathSelectorNotificationChanges:
				result.NotificationChanges = source.NotificationChanges
			case WatchNotificationsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchNotificationsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchNotificationsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchNotificationsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchNotificationsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchNotificationsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchNotificationsResponse_FieldSubPath:
			switch tp.selector {
			case WatchNotificationsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchNotificationsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchNotificationsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchNotificationsResponse))
}

func (fieldMask *WatchNotificationsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchNotificationsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchNotificationsResponsePageTokenChange_FieldPath
}

func FullWatchNotificationsResponse_PageTokenChange_FieldMask() *WatchNotificationsResponse_PageTokenChange_FieldMask {
	res := &WatchNotificationsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchNotificationsResponsePageTokenChange_FieldTerminalPath{selector: WatchNotificationsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchNotificationsResponsePageTokenChange_FieldTerminalPath{selector: WatchNotificationsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchNotificationsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchNotificationsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchNotificationsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) Subtract(other *WatchNotificationsResponse_PageTokenChange_FieldMask) *WatchNotificationsResponse_PageTokenChange_FieldMask {
	result := &WatchNotificationsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchNotificationsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchNotificationsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchNotificationsResponse_PageTokenChange_FieldMask {
	result := &WatchNotificationsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchNotificationsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchNotificationsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchNotificationsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchNotificationsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) AppendPath(path WatchNotificationsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchNotificationsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) GetPaths() []WatchNotificationsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchNotificationsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) Set(target, source *WatchNotificationsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchNotificationsResponse_PageTokenChange), source.(*WatchNotificationsResponse_PageTokenChange))
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) Project(source *WatchNotificationsResponse_PageTokenChange) *WatchNotificationsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchNotificationsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchNotificationsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchNotificationsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchNotificationsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchNotificationsResponse_PageTokenChange))
}

func (fieldMask *WatchNotificationsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateNotificationRequest_FieldMask struct {
	Paths []CreateNotificationRequest_FieldPath
}

func FullCreateNotificationRequest_FieldMask() *CreateNotificationRequest_FieldMask {
	res := &CreateNotificationRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateNotificationRequest_FieldTerminalPath{selector: CreateNotificationRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateNotificationRequest_FieldTerminalPath{selector: CreateNotificationRequest_FieldPathSelectorNotification})
	return res
}

func (fieldMask *CreateNotificationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateNotificationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateNotificationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateNotificationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateNotificationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateNotificationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateNotificationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateNotificationRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateNotificationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateNotificationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateNotificationRequest_FieldMask) Subtract(other *CreateNotificationRequest_FieldMask) *CreateNotificationRequest_FieldMask {
	result := &CreateNotificationRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateNotificationRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateNotificationRequest_FieldPathSelectorNotification: &notification.Notification_FieldMask{},
	}
	mySubMasks := map[CreateNotificationRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateNotificationRequest_FieldPathSelectorNotification: &notification.Notification_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateNotificationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateNotificationRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateNotificationRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateNotificationRequest_FieldPathSelectorNotification:
						mySubMasks[CreateNotificationRequest_FieldPathSelectorNotification] = notification.FullNotification_FieldMask()
					}
				} else if tp, ok := path.(*CreateNotificationRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateNotificationRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateNotificationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateNotificationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateNotificationRequest_FieldMask) FilterInputFields() *CreateNotificationRequest_FieldMask {
	result := &CreateNotificationRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateNotificationRequest_FieldPathSelectorNotification:
			if _, ok := path.(*CreateNotificationRequest_FieldTerminalPath); ok {
				for _, subpath := range notification.FullNotification_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateNotificationRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateNotificationRequest_FieldSubPath); ok {
				selectedMask := &notification.Notification_FieldMask{
					Paths: []notification.Notification_FieldPath{sub.subPath.(notification.Notification_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateNotificationRequest_FieldSubPath{selector: CreateNotificationRequest_FieldPathSelectorNotification, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateNotificationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateNotificationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateNotificationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateNotificationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateNotificationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateNotificationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateNotificationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateNotificationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateNotificationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateNotificationRequest_FieldMask) AppendPath(path CreateNotificationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateNotificationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateNotificationRequest_FieldPath))
}

func (fieldMask *CreateNotificationRequest_FieldMask) GetPaths() []CreateNotificationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateNotificationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateNotificationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateNotificationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateNotificationRequest_FieldMask) Set(target, source *CreateNotificationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateNotificationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateNotificationRequest), source.(*CreateNotificationRequest))
}

func (fieldMask *CreateNotificationRequest_FieldMask) Project(source *CreateNotificationRequest) *CreateNotificationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateNotificationRequest{}
	notificationMask := &notification.Notification_FieldMask{}
	wholeNotificationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateNotificationRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateNotificationRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateNotificationRequest_FieldPathSelectorNotification:
				result.Notification = source.Notification
				wholeNotificationAccepted = true
			}
		case *CreateNotificationRequest_FieldSubPath:
			switch tp.selector {
			case CreateNotificationRequest_FieldPathSelectorNotification:
				notificationMask.AppendPath(tp.subPath.(notification.Notification_FieldPath))
			}
		}
	}
	if wholeNotificationAccepted == false && len(notificationMask.Paths) > 0 {
		result.Notification = notificationMask.Project(source.GetNotification())
	}
	return result
}

func (fieldMask *CreateNotificationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateNotificationRequest))
}

func (fieldMask *CreateNotificationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateNotificationRequest_FieldMask struct {
	Paths []UpdateNotificationRequest_FieldPath
}

func FullUpdateNotificationRequest_FieldMask() *UpdateNotificationRequest_FieldMask {
	res := &UpdateNotificationRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateNotificationRequest_FieldTerminalPath{selector: UpdateNotificationRequest_FieldPathSelectorNotification})
	res.Paths = append(res.Paths, &UpdateNotificationRequest_FieldTerminalPath{selector: UpdateNotificationRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateNotificationRequest_FieldTerminalPath{selector: UpdateNotificationRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateNotificationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateNotificationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateNotificationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateNotificationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateNotificationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateNotificationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateNotificationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateNotificationRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateNotificationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateNotificationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateNotificationRequest_FieldMask) Subtract(other *UpdateNotificationRequest_FieldMask) *UpdateNotificationRequest_FieldMask {
	result := &UpdateNotificationRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateNotificationRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateNotificationRequest_FieldPathSelectorNotification: &notification.Notification_FieldMask{},
		UpdateNotificationRequest_FieldPathSelectorCas:          &UpdateNotificationRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateNotificationRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateNotificationRequest_FieldPathSelectorNotification: &notification.Notification_FieldMask{},
		UpdateNotificationRequest_FieldPathSelectorCas:          &UpdateNotificationRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateNotificationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateNotificationRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateNotificationRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateNotificationRequest_FieldPathSelectorNotification:
						mySubMasks[UpdateNotificationRequest_FieldPathSelectorNotification] = notification.FullNotification_FieldMask()
					case UpdateNotificationRequest_FieldPathSelectorCas:
						mySubMasks[UpdateNotificationRequest_FieldPathSelectorCas] = FullUpdateNotificationRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateNotificationRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateNotificationRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateNotificationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateNotificationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateNotificationRequest_FieldMask) FilterInputFields() *UpdateNotificationRequest_FieldMask {
	result := &UpdateNotificationRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateNotificationRequest_FieldPathSelectorNotification:
			if _, ok := path.(*UpdateNotificationRequest_FieldTerminalPath); ok {
				for _, subpath := range notification.FullNotification_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateNotificationRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateNotificationRequest_FieldSubPath); ok {
				selectedMask := &notification.Notification_FieldMask{
					Paths: []notification.Notification_FieldPath{sub.subPath.(notification.Notification_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateNotificationRequest_FieldSubPath{selector: UpdateNotificationRequest_FieldPathSelectorNotification, subPath: allowedPath})
				}
			}
		case UpdateNotificationRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateNotificationRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateNotificationRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateNotificationRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateNotificationRequest_FieldSubPath); ok {
				selectedMask := &UpdateNotificationRequest_CAS_FieldMask{
					Paths: []UpdateNotificationRequestCAS_FieldPath{sub.subPath.(UpdateNotificationRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateNotificationRequest_FieldSubPath{selector: UpdateNotificationRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateNotificationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateNotificationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateNotificationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateNotificationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateNotificationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateNotificationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateNotificationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateNotificationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateNotificationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateNotificationRequest_FieldMask) AppendPath(path UpdateNotificationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateNotificationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateNotificationRequest_FieldPath))
}

func (fieldMask *UpdateNotificationRequest_FieldMask) GetPaths() []UpdateNotificationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateNotificationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateNotificationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateNotificationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateNotificationRequest_FieldMask) Set(target, source *UpdateNotificationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateNotificationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateNotificationRequest), source.(*UpdateNotificationRequest))
}

func (fieldMask *UpdateNotificationRequest_FieldMask) Project(source *UpdateNotificationRequest) *UpdateNotificationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateNotificationRequest{}
	notificationMask := &notification.Notification_FieldMask{}
	wholeNotificationAccepted := false
	casMask := &UpdateNotificationRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateNotificationRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateNotificationRequest_FieldPathSelectorNotification:
				result.Notification = source.Notification
				wholeNotificationAccepted = true
			case UpdateNotificationRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateNotificationRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateNotificationRequest_FieldSubPath:
			switch tp.selector {
			case UpdateNotificationRequest_FieldPathSelectorNotification:
				notificationMask.AppendPath(tp.subPath.(notification.Notification_FieldPath))
			case UpdateNotificationRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateNotificationRequestCAS_FieldPath))
			}
		}
	}
	if wholeNotificationAccepted == false && len(notificationMask.Paths) > 0 {
		result.Notification = notificationMask.Project(source.GetNotification())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateNotificationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateNotificationRequest))
}

func (fieldMask *UpdateNotificationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateNotificationRequest_CAS_FieldMask struct {
	Paths []UpdateNotificationRequestCAS_FieldPath
}

func FullUpdateNotificationRequest_CAS_FieldMask() *UpdateNotificationRequest_CAS_FieldMask {
	res := &UpdateNotificationRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateNotificationRequestCAS_FieldTerminalPath{selector: UpdateNotificationRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateNotificationRequestCAS_FieldTerminalPath{selector: UpdateNotificationRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateNotificationRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateNotificationRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateNotificationRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) Subtract(other *UpdateNotificationRequest_CAS_FieldMask) *UpdateNotificationRequest_CAS_FieldMask {
	result := &UpdateNotificationRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateNotificationRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateNotificationRequestCAS_FieldPathSelectorConditionalState: &notification.Notification_FieldMask{},
	}
	mySubMasks := map[UpdateNotificationRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateNotificationRequestCAS_FieldPathSelectorConditionalState: &notification.Notification_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateNotificationRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateNotificationRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateNotificationRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateNotificationRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateNotificationRequestCAS_FieldPathSelectorConditionalState] = notification.FullNotification_FieldMask()
					}
				} else if tp, ok := path.(*UpdateNotificationRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateNotificationRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateNotificationRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) FilterInputFields() *UpdateNotificationRequest_CAS_FieldMask {
	result := &UpdateNotificationRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateNotificationRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateNotificationRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range notification.FullNotification_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateNotificationRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateNotificationRequestCAS_FieldSubPath); ok {
				selectedMask := &notification.Notification_FieldMask{
					Paths: []notification.Notification_FieldPath{sub.subPath.(notification.Notification_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateNotificationRequestCAS_FieldSubPath{selector: UpdateNotificationRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateNotificationRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateNotificationRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateNotificationRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateNotificationRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) AppendPath(path UpdateNotificationRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateNotificationRequestCAS_FieldPath))
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) GetPaths() []UpdateNotificationRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateNotificationRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) Set(target, source *UpdateNotificationRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateNotificationRequest_CAS), source.(*UpdateNotificationRequest_CAS))
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) Project(source *UpdateNotificationRequest_CAS) *UpdateNotificationRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateNotificationRequest_CAS{}
	conditionalStateMask := &notification.Notification_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateNotificationRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateNotificationRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateNotificationRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateNotificationRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateNotificationRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(notification.Notification_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateNotificationRequest_CAS))
}

func (fieldMask *UpdateNotificationRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteNotificationRequest_FieldMask struct {
	Paths []DeleteNotificationRequest_FieldPath
}

func FullDeleteNotificationRequest_FieldMask() *DeleteNotificationRequest_FieldMask {
	res := &DeleteNotificationRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteNotificationRequest_FieldTerminalPath{selector: DeleteNotificationRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteNotificationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteNotificationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteNotificationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteNotificationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteNotificationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteNotificationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteNotificationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteNotificationRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteNotificationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteNotificationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteNotificationRequest_FieldMask) Subtract(other *DeleteNotificationRequest_FieldMask) *DeleteNotificationRequest_FieldMask {
	result := &DeleteNotificationRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteNotificationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteNotificationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteNotificationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteNotificationRequest_FieldMask) FilterInputFields() *DeleteNotificationRequest_FieldMask {
	result := &DeleteNotificationRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteNotificationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteNotificationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteNotificationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteNotificationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteNotificationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteNotificationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteNotificationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteNotificationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteNotificationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteNotificationRequest_FieldMask) AppendPath(path DeleteNotificationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteNotificationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteNotificationRequest_FieldPath))
}

func (fieldMask *DeleteNotificationRequest_FieldMask) GetPaths() []DeleteNotificationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteNotificationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteNotificationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteNotificationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteNotificationRequest_FieldMask) Set(target, source *DeleteNotificationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteNotificationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteNotificationRequest), source.(*DeleteNotificationRequest))
}

func (fieldMask *DeleteNotificationRequest_FieldMask) Project(source *DeleteNotificationRequest) *DeleteNotificationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteNotificationRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteNotificationRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteNotificationRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteNotificationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteNotificationRequest))
}

func (fieldMask *DeleteNotificationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SearchNotificationsRequest_FieldMask struct {
	Paths []SearchNotificationsRequest_FieldPath
}

func FullSearchNotificationsRequest_FieldMask() *SearchNotificationsRequest_FieldMask {
	res := &SearchNotificationsRequest_FieldMask{}
	res.Paths = append(res.Paths, &SearchNotificationsRequest_FieldTerminalPath{selector: SearchNotificationsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &SearchNotificationsRequest_FieldTerminalPath{selector: SearchNotificationsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &SearchNotificationsRequest_FieldTerminalPath{selector: SearchNotificationsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &SearchNotificationsRequest_FieldTerminalPath{selector: SearchNotificationsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &SearchNotificationsRequest_FieldTerminalPath{selector: SearchNotificationsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &SearchNotificationsRequest_FieldTerminalPath{selector: SearchNotificationsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &SearchNotificationsRequest_FieldTerminalPath{selector: SearchNotificationsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &SearchNotificationsRequest_FieldTerminalPath{selector: SearchNotificationsRequest_FieldPathSelectorPhrase})
	return res
}

func (fieldMask *SearchNotificationsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SearchNotificationsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SearchNotificationsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSearchNotificationsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SearchNotificationsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SearchNotificationsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SearchNotificationsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSearchNotificationsRequest_FieldPath(raw)
	})
}

func (fieldMask *SearchNotificationsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *SearchNotificationsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SearchNotificationsRequest_FieldMask) Subtract(other *SearchNotificationsRequest_FieldMask) *SearchNotificationsRequest_FieldMask {
	result := &SearchNotificationsRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SearchNotificationsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SearchNotificationsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SearchNotificationsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SearchNotificationsRequest_FieldMask) FilterInputFields() *SearchNotificationsRequest_FieldMask {
	result := &SearchNotificationsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SearchNotificationsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SearchNotificationsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SearchNotificationsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSearchNotificationsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SearchNotificationsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SearchNotificationsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchNotificationsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SearchNotificationsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SearchNotificationsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchNotificationsRequest_FieldMask) AppendPath(path SearchNotificationsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SearchNotificationsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SearchNotificationsRequest_FieldPath))
}

func (fieldMask *SearchNotificationsRequest_FieldMask) GetPaths() []SearchNotificationsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SearchNotificationsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SearchNotificationsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSearchNotificationsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SearchNotificationsRequest_FieldMask) Set(target, source *SearchNotificationsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SearchNotificationsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SearchNotificationsRequest), source.(*SearchNotificationsRequest))
}

func (fieldMask *SearchNotificationsRequest_FieldMask) Project(source *SearchNotificationsRequest) *SearchNotificationsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SearchNotificationsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SearchNotificationsRequest_FieldTerminalPath:
			switch tp.selector {
			case SearchNotificationsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case SearchNotificationsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case SearchNotificationsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case SearchNotificationsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case SearchNotificationsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case SearchNotificationsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case SearchNotificationsRequest_FieldPathSelectorView:
				result.View = source.View
			case SearchNotificationsRequest_FieldPathSelectorPhrase:
				result.Phrase = source.Phrase
			}
		}
	}
	return result
}

func (fieldMask *SearchNotificationsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SearchNotificationsRequest))
}

func (fieldMask *SearchNotificationsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SearchNotificationsResponse_FieldMask struct {
	Paths []SearchNotificationsResponse_FieldPath
}

func FullSearchNotificationsResponse_FieldMask() *SearchNotificationsResponse_FieldMask {
	res := &SearchNotificationsResponse_FieldMask{}
	res.Paths = append(res.Paths, &SearchNotificationsResponse_FieldTerminalPath{selector: SearchNotificationsResponse_FieldPathSelectorNotifications})
	res.Paths = append(res.Paths, &SearchNotificationsResponse_FieldTerminalPath{selector: SearchNotificationsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &SearchNotificationsResponse_FieldTerminalPath{selector: SearchNotificationsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &SearchNotificationsResponse_FieldTerminalPath{selector: SearchNotificationsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &SearchNotificationsResponse_FieldTerminalPath{selector: SearchNotificationsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *SearchNotificationsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SearchNotificationsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SearchNotificationsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSearchNotificationsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SearchNotificationsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SearchNotificationsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SearchNotificationsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSearchNotificationsResponse_FieldPath(raw)
	})
}

func (fieldMask *SearchNotificationsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *SearchNotificationsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SearchNotificationsResponse_FieldMask) Subtract(other *SearchNotificationsResponse_FieldMask) *SearchNotificationsResponse_FieldMask {
	result := &SearchNotificationsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[SearchNotificationsResponse_FieldPathSelector]gotenobject.FieldMask{
		SearchNotificationsResponse_FieldPathSelectorNotifications: &notification.Notification_FieldMask{},
	}
	mySubMasks := map[SearchNotificationsResponse_FieldPathSelector]gotenobject.FieldMask{
		SearchNotificationsResponse_FieldPathSelectorNotifications: &notification.Notification_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SearchNotificationsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *SearchNotificationsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*SearchNotificationsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case SearchNotificationsResponse_FieldPathSelectorNotifications:
						mySubMasks[SearchNotificationsResponse_FieldPathSelectorNotifications] = notification.FullNotification_FieldMask()
					}
				} else if tp, ok := path.(*SearchNotificationsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &SearchNotificationsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SearchNotificationsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SearchNotificationsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SearchNotificationsResponse_FieldMask) FilterInputFields() *SearchNotificationsResponse_FieldMask {
	result := &SearchNotificationsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case SearchNotificationsResponse_FieldPathSelectorNotifications:
			if _, ok := path.(*SearchNotificationsResponse_FieldTerminalPath); ok {
				for _, subpath := range notification.FullNotification_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &SearchNotificationsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*SearchNotificationsResponse_FieldSubPath); ok {
				selectedMask := &notification.Notification_FieldMask{
					Paths: []notification.Notification_FieldPath{sub.subPath.(notification.Notification_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &SearchNotificationsResponse_FieldSubPath{selector: SearchNotificationsResponse_FieldPathSelectorNotifications, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SearchNotificationsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SearchNotificationsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SearchNotificationsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSearchNotificationsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SearchNotificationsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SearchNotificationsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchNotificationsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SearchNotificationsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SearchNotificationsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SearchNotificationsResponse_FieldMask) AppendPath(path SearchNotificationsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SearchNotificationsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SearchNotificationsResponse_FieldPath))
}

func (fieldMask *SearchNotificationsResponse_FieldMask) GetPaths() []SearchNotificationsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SearchNotificationsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SearchNotificationsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSearchNotificationsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SearchNotificationsResponse_FieldMask) Set(target, source *SearchNotificationsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SearchNotificationsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SearchNotificationsResponse), source.(*SearchNotificationsResponse))
}

func (fieldMask *SearchNotificationsResponse_FieldMask) Project(source *SearchNotificationsResponse) *SearchNotificationsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SearchNotificationsResponse{}
	notificationsMask := &notification.Notification_FieldMask{}
	wholeNotificationsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SearchNotificationsResponse_FieldTerminalPath:
			switch tp.selector {
			case SearchNotificationsResponse_FieldPathSelectorNotifications:
				result.Notifications = source.Notifications
				wholeNotificationsAccepted = true
			case SearchNotificationsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case SearchNotificationsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case SearchNotificationsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case SearchNotificationsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *SearchNotificationsResponse_FieldSubPath:
			switch tp.selector {
			case SearchNotificationsResponse_FieldPathSelectorNotifications:
				notificationsMask.AppendPath(tp.subPath.(notification.Notification_FieldPath))
			}
		}
	}
	if wholeNotificationsAccepted == false && len(notificationsMask.Paths) > 0 {
		for _, sourceItem := range source.GetNotifications() {
			result.Notifications = append(result.Notifications, notificationsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *SearchNotificationsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SearchNotificationsResponse))
}

func (fieldMask *SearchNotificationsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
