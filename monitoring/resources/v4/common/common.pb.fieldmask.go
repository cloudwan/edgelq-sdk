// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v4/common.proto
// DO NOT EDIT!!!

package common

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &durationpb.Duration{}
	_ = &timestamppb.Timestamp{}
)

type LabelDescriptor_FieldMask struct {
	Paths []LabelDescriptor_FieldPath
}

func FullLabelDescriptor_FieldMask() *LabelDescriptor_FieldMask {
	res := &LabelDescriptor_FieldMask{}
	res.Paths = append(res.Paths, &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorValueType})
	res.Paths = append(res.Paths, &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorDefaultValue})
	res.Paths = append(res.Paths, &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorDisabled})
	return res
}

func (fieldMask *LabelDescriptor_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *LabelDescriptor_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *LabelDescriptor_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseLabelDescriptor_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *LabelDescriptor_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LabelDescriptor_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LabelDescriptor_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLabelDescriptor_FieldPath(raw)
	})
}

func (fieldMask *LabelDescriptor_FieldMask) ProtoMessage() {}

func (fieldMask *LabelDescriptor_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LabelDescriptor_FieldMask) Subtract(other *LabelDescriptor_FieldMask) *LabelDescriptor_FieldMask {
	result := &LabelDescriptor_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LabelDescriptor_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LabelDescriptor_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LabelDescriptor_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LabelDescriptor_FieldMask) FilterInputFields() *LabelDescriptor_FieldMask {
	result := &LabelDescriptor_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LabelDescriptor_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LabelDescriptor_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LabelDescriptor_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLabelDescriptor_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LabelDescriptor_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LabelDescriptor_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LabelDescriptor_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LabelDescriptor_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LabelDescriptor_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LabelDescriptor_FieldMask) AppendPath(path LabelDescriptor_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LabelDescriptor_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LabelDescriptor_FieldPath))
}

func (fieldMask *LabelDescriptor_FieldMask) GetPaths() []LabelDescriptor_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LabelDescriptor_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LabelDescriptor_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLabelDescriptor_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LabelDescriptor_FieldMask) Set(target, source *LabelDescriptor) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LabelDescriptor_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LabelDescriptor), source.(*LabelDescriptor))
}

func (fieldMask *LabelDescriptor_FieldMask) Project(source *LabelDescriptor) *LabelDescriptor {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LabelDescriptor{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LabelDescriptor_FieldTerminalPath:
			switch tp.selector {
			case LabelDescriptor_FieldPathSelectorKey:
				result.Key = source.Key
			case LabelDescriptor_FieldPathSelectorValueType:
				result.ValueType = source.ValueType
			case LabelDescriptor_FieldPathSelectorDescription:
				result.Description = source.Description
			case LabelDescriptor_FieldPathSelectorDefaultValue:
				result.DefaultValue = source.DefaultValue
			case LabelDescriptor_FieldPathSelectorDisabled:
				result.Disabled = source.Disabled
			}
		}
	}
	return result
}

func (fieldMask *LabelDescriptor_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LabelDescriptor))
}

func (fieldMask *LabelDescriptor_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type LabelKeySet_FieldMask struct {
	Paths []LabelKeySet_FieldPath
}

func FullLabelKeySet_FieldMask() *LabelKeySet_FieldMask {
	res := &LabelKeySet_FieldMask{}
	res.Paths = append(res.Paths, &LabelKeySet_FieldTerminalPath{selector: LabelKeySet_FieldPathSelectorLabelKeys})
	res.Paths = append(res.Paths, &LabelKeySet_FieldTerminalPath{selector: LabelKeySet_FieldPathSelectorWriteOnly})
	return res
}

func (fieldMask *LabelKeySet_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *LabelKeySet_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *LabelKeySet_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseLabelKeySet_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *LabelKeySet_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LabelKeySet_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LabelKeySet_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLabelKeySet_FieldPath(raw)
	})
}

func (fieldMask *LabelKeySet_FieldMask) ProtoMessage() {}

func (fieldMask *LabelKeySet_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LabelKeySet_FieldMask) Subtract(other *LabelKeySet_FieldMask) *LabelKeySet_FieldMask {
	result := &LabelKeySet_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LabelKeySet_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LabelKeySet_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LabelKeySet_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LabelKeySet_FieldMask) FilterInputFields() *LabelKeySet_FieldMask {
	result := &LabelKeySet_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LabelKeySet_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LabelKeySet_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LabelKeySet_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLabelKeySet_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LabelKeySet_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LabelKeySet_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LabelKeySet_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LabelKeySet_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LabelKeySet_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LabelKeySet_FieldMask) AppendPath(path LabelKeySet_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LabelKeySet_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LabelKeySet_FieldPath))
}

func (fieldMask *LabelKeySet_FieldMask) GetPaths() []LabelKeySet_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LabelKeySet_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LabelKeySet_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLabelKeySet_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LabelKeySet_FieldMask) Set(target, source *LabelKeySet) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LabelKeySet_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LabelKeySet), source.(*LabelKeySet))
}

func (fieldMask *LabelKeySet_FieldMask) Project(source *LabelKeySet) *LabelKeySet {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LabelKeySet{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LabelKeySet_FieldTerminalPath:
			switch tp.selector {
			case LabelKeySet_FieldPathSelectorLabelKeys:
				result.LabelKeys = source.LabelKeys
			case LabelKeySet_FieldPathSelectorWriteOnly:
				result.WriteOnly = source.WriteOnly
			}
		}
	}
	return result
}

func (fieldMask *LabelKeySet_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LabelKeySet))
}

func (fieldMask *LabelKeySet_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Distribution_FieldMask struct {
	Paths []Distribution_FieldPath
}

func FullDistribution_FieldMask() *Distribution_FieldMask {
	res := &Distribution_FieldMask{}
	res.Paths = append(res.Paths, &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorCount})
	res.Paths = append(res.Paths, &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorMean})
	res.Paths = append(res.Paths, &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorSumOfSquaredDeviation})
	res.Paths = append(res.Paths, &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorRange})
	res.Paths = append(res.Paths, &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorBucketOptions})
	res.Paths = append(res.Paths, &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorBucketCounts})
	return res
}

func (fieldMask *Distribution_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Distribution_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Distribution_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDistribution_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Distribution_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Distribution_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Distribution_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDistribution_FieldPath(raw)
	})
}

func (fieldMask *Distribution_FieldMask) ProtoMessage() {}

func (fieldMask *Distribution_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Distribution_FieldMask) Subtract(other *Distribution_FieldMask) *Distribution_FieldMask {
	result := &Distribution_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[Distribution_FieldPathSelector]gotenobject.FieldMask{
		Distribution_FieldPathSelectorRange:         &Distribution_Range_FieldMask{},
		Distribution_FieldPathSelectorBucketOptions: &Distribution_BucketOptions_FieldMask{},
	}
	mySubMasks := map[Distribution_FieldPathSelector]gotenobject.FieldMask{
		Distribution_FieldPathSelectorRange:         &Distribution_Range_FieldMask{},
		Distribution_FieldPathSelectorBucketOptions: &Distribution_BucketOptions_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Distribution_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Distribution_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Distribution_FieldTerminalPath); ok {
					switch tp.selector {
					case Distribution_FieldPathSelectorRange:
						mySubMasks[Distribution_FieldPathSelectorRange] = FullDistribution_Range_FieldMask()
					case Distribution_FieldPathSelectorBucketOptions:
						mySubMasks[Distribution_FieldPathSelectorBucketOptions] = FullDistribution_BucketOptions_FieldMask()
					}
				} else if tp, ok := path.(*Distribution_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Distribution_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Distribution_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Distribution_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Distribution_FieldMask) FilterInputFields() *Distribution_FieldMask {
	result := &Distribution_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Distribution_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Distribution_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Distribution_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDistribution_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Distribution_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Distribution_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Distribution_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Distribution_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_FieldMask) AppendPath(path Distribution_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Distribution_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Distribution_FieldPath))
}

func (fieldMask *Distribution_FieldMask) GetPaths() []Distribution_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Distribution_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Distribution_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDistribution_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Distribution_FieldMask) Set(target, source *Distribution) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Distribution_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Distribution), source.(*Distribution))
}

func (fieldMask *Distribution_FieldMask) Project(source *Distribution) *Distribution {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Distribution{}
	rangeMask := &Distribution_Range_FieldMask{}
	wholeRangeAccepted := false
	bucketOptionsMask := &Distribution_BucketOptions_FieldMask{}
	wholeBucketOptionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Distribution_FieldTerminalPath:
			switch tp.selector {
			case Distribution_FieldPathSelectorCount:
				result.Count = source.Count
			case Distribution_FieldPathSelectorMean:
				result.Mean = source.Mean
			case Distribution_FieldPathSelectorSumOfSquaredDeviation:
				result.SumOfSquaredDeviation = source.SumOfSquaredDeviation
			case Distribution_FieldPathSelectorRange:
				result.Range = source.Range
				wholeRangeAccepted = true
			case Distribution_FieldPathSelectorBucketOptions:
				result.BucketOptions = source.BucketOptions
				wholeBucketOptionsAccepted = true
			case Distribution_FieldPathSelectorBucketCounts:
				result.BucketCounts = source.BucketCounts
			}
		case *Distribution_FieldSubPath:
			switch tp.selector {
			case Distribution_FieldPathSelectorRange:
				rangeMask.AppendPath(tp.subPath.(DistributionRange_FieldPath))
			case Distribution_FieldPathSelectorBucketOptions:
				bucketOptionsMask.AppendPath(tp.subPath.(DistributionBucketOptions_FieldPath))
			}
		}
	}
	if wholeRangeAccepted == false && len(rangeMask.Paths) > 0 {
		result.Range = rangeMask.Project(source.GetRange())
	}
	if wholeBucketOptionsAccepted == false && len(bucketOptionsMask.Paths) > 0 {
		result.BucketOptions = bucketOptionsMask.Project(source.GetBucketOptions())
	}
	return result
}

func (fieldMask *Distribution_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Distribution))
}

func (fieldMask *Distribution_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Distribution_Range_FieldMask struct {
	Paths []DistributionRange_FieldPath
}

func FullDistribution_Range_FieldMask() *Distribution_Range_FieldMask {
	res := &Distribution_Range_FieldMask{}
	res.Paths = append(res.Paths, &DistributionRange_FieldTerminalPath{selector: DistributionRange_FieldPathSelectorMin})
	res.Paths = append(res.Paths, &DistributionRange_FieldTerminalPath{selector: DistributionRange_FieldPathSelectorMax})
	return res
}

func (fieldMask *Distribution_Range_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Distribution_Range_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Distribution_Range_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDistributionRange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Distribution_Range_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DistributionRange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Distribution_Range_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDistributionRange_FieldPath(raw)
	})
}

func (fieldMask *Distribution_Range_FieldMask) ProtoMessage() {}

func (fieldMask *Distribution_Range_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Distribution_Range_FieldMask) Subtract(other *Distribution_Range_FieldMask) *Distribution_Range_FieldMask {
	result := &Distribution_Range_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DistributionRange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Distribution_Range_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Distribution_Range_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Distribution_Range_FieldMask) FilterInputFields() *Distribution_Range_FieldMask {
	result := &Distribution_Range_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Distribution_Range_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Distribution_Range_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DistributionRange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDistributionRange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Distribution_Range_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Distribution_Range_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_Range_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Distribution_Range_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Distribution_Range_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_Range_FieldMask) AppendPath(path DistributionRange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Distribution_Range_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DistributionRange_FieldPath))
}

func (fieldMask *Distribution_Range_FieldMask) GetPaths() []DistributionRange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Distribution_Range_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Distribution_Range_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDistributionRange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Distribution_Range_FieldMask) Set(target, source *Distribution_Range) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Distribution_Range_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Distribution_Range), source.(*Distribution_Range))
}

func (fieldMask *Distribution_Range_FieldMask) Project(source *Distribution_Range) *Distribution_Range {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Distribution_Range{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DistributionRange_FieldTerminalPath:
			switch tp.selector {
			case DistributionRange_FieldPathSelectorMin:
				result.Min = source.Min
			case DistributionRange_FieldPathSelectorMax:
				result.Max = source.Max
			}
		}
	}
	return result
}

func (fieldMask *Distribution_Range_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Distribution_Range))
}

func (fieldMask *Distribution_Range_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Distribution_BucketOptions_FieldMask struct {
	Paths []DistributionBucketOptions_FieldPath
}

func FullDistribution_BucketOptions_FieldMask() *Distribution_BucketOptions_FieldMask {
	res := &Distribution_BucketOptions_FieldMask{}
	res.Paths = append(res.Paths, &DistributionBucketOptions_FieldTerminalPath{selector: DistributionBucketOptions_FieldPathSelectorLinearBuckets})
	res.Paths = append(res.Paths, &DistributionBucketOptions_FieldTerminalPath{selector: DistributionBucketOptions_FieldPathSelectorExponentialBuckets})
	res.Paths = append(res.Paths, &DistributionBucketOptions_FieldTerminalPath{selector: DistributionBucketOptions_FieldPathSelectorExplicitBuckets})
	res.Paths = append(res.Paths, &DistributionBucketOptions_FieldTerminalPath{selector: DistributionBucketOptions_FieldPathSelectorDynamicBuckets})
	return res
}

func (fieldMask *Distribution_BucketOptions_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Distribution_BucketOptions_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Distribution_BucketOptions_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDistributionBucketOptions_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DistributionBucketOptions_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Distribution_BucketOptions_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDistributionBucketOptions_FieldPath(raw)
	})
}

func (fieldMask *Distribution_BucketOptions_FieldMask) ProtoMessage() {}

func (fieldMask *Distribution_BucketOptions_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Distribution_BucketOptions_FieldMask) Subtract(other *Distribution_BucketOptions_FieldMask) *Distribution_BucketOptions_FieldMask {
	result := &Distribution_BucketOptions_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DistributionBucketOptions_FieldPathSelector]gotenobject.FieldMask{
		DistributionBucketOptions_FieldPathSelectorLinearBuckets:      &Distribution_BucketOptions_Linear_FieldMask{},
		DistributionBucketOptions_FieldPathSelectorExponentialBuckets: &Distribution_BucketOptions_Exponential_FieldMask{},
		DistributionBucketOptions_FieldPathSelectorExplicitBuckets:    &Distribution_BucketOptions_Explicit_FieldMask{},
		DistributionBucketOptions_FieldPathSelectorDynamicBuckets:     &Distribution_BucketOptions_Dynamic_FieldMask{},
	}
	mySubMasks := map[DistributionBucketOptions_FieldPathSelector]gotenobject.FieldMask{
		DistributionBucketOptions_FieldPathSelectorLinearBuckets:      &Distribution_BucketOptions_Linear_FieldMask{},
		DistributionBucketOptions_FieldPathSelectorExponentialBuckets: &Distribution_BucketOptions_Exponential_FieldMask{},
		DistributionBucketOptions_FieldPathSelectorExplicitBuckets:    &Distribution_BucketOptions_Explicit_FieldMask{},
		DistributionBucketOptions_FieldPathSelectorDynamicBuckets:     &Distribution_BucketOptions_Dynamic_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DistributionBucketOptions_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DistributionBucketOptions_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DistributionBucketOptions_FieldTerminalPath); ok {
					switch tp.selector {
					case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
						mySubMasks[DistributionBucketOptions_FieldPathSelectorLinearBuckets] = FullDistribution_BucketOptions_Linear_FieldMask()
					case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
						mySubMasks[DistributionBucketOptions_FieldPathSelectorExponentialBuckets] = FullDistribution_BucketOptions_Exponential_FieldMask()
					case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
						mySubMasks[DistributionBucketOptions_FieldPathSelectorExplicitBuckets] = FullDistribution_BucketOptions_Explicit_FieldMask()
					case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
						mySubMasks[DistributionBucketOptions_FieldPathSelectorDynamicBuckets] = FullDistribution_BucketOptions_Dynamic_FieldMask()
					}
				} else if tp, ok := path.(*DistributionBucketOptions_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DistributionBucketOptions_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Distribution_BucketOptions_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Distribution_BucketOptions_FieldMask) FilterInputFields() *Distribution_BucketOptions_FieldMask {
	result := &Distribution_BucketOptions_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Distribution_BucketOptions_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Distribution_BucketOptions_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DistributionBucketOptions_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDistributionBucketOptions_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Distribution_BucketOptions_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Distribution_BucketOptions_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Distribution_BucketOptions_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Distribution_BucketOptions_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_FieldMask) AppendPath(path DistributionBucketOptions_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Distribution_BucketOptions_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DistributionBucketOptions_FieldPath))
}

func (fieldMask *Distribution_BucketOptions_FieldMask) GetPaths() []DistributionBucketOptions_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Distribution_BucketOptions_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Distribution_BucketOptions_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDistributionBucketOptions_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Distribution_BucketOptions_FieldMask) Set(target, source *Distribution_BucketOptions) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Distribution_BucketOptions_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Distribution_BucketOptions), source.(*Distribution_BucketOptions))
}

func (fieldMask *Distribution_BucketOptions_FieldMask) Project(source *Distribution_BucketOptions) *Distribution_BucketOptions {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Distribution_BucketOptions{}
	linearBucketsMask := &Distribution_BucketOptions_Linear_FieldMask{}
	wholeLinearBucketsAccepted := false
	exponentialBucketsMask := &Distribution_BucketOptions_Exponential_FieldMask{}
	wholeExponentialBucketsAccepted := false
	explicitBucketsMask := &Distribution_BucketOptions_Explicit_FieldMask{}
	wholeExplicitBucketsAccepted := false
	dynamicBucketsMask := &Distribution_BucketOptions_Dynamic_FieldMask{}
	wholeDynamicBucketsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DistributionBucketOptions_FieldTerminalPath:
			switch tp.selector {
			case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
				if source, ok := source.Options.(*Distribution_BucketOptions_LinearBuckets); ok {
					result.Options = &Distribution_BucketOptions_LinearBuckets{
						LinearBuckets: source.LinearBuckets,
					}
				}
				wholeLinearBucketsAccepted = true
			case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
				if source, ok := source.Options.(*Distribution_BucketOptions_ExponentialBuckets); ok {
					result.Options = &Distribution_BucketOptions_ExponentialBuckets{
						ExponentialBuckets: source.ExponentialBuckets,
					}
				}
				wholeExponentialBucketsAccepted = true
			case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
				if source, ok := source.Options.(*Distribution_BucketOptions_ExplicitBuckets); ok {
					result.Options = &Distribution_BucketOptions_ExplicitBuckets{
						ExplicitBuckets: source.ExplicitBuckets,
					}
				}
				wholeExplicitBucketsAccepted = true
			case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
				if source, ok := source.Options.(*Distribution_BucketOptions_DynamicBuckets); ok {
					result.Options = &Distribution_BucketOptions_DynamicBuckets{
						DynamicBuckets: source.DynamicBuckets,
					}
				}
				wholeDynamicBucketsAccepted = true
			}
		case *DistributionBucketOptions_FieldSubPath:
			switch tp.selector {
			case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
				linearBucketsMask.AppendPath(tp.subPath.(DistributionBucketOptionsLinear_FieldPath))
			case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
				exponentialBucketsMask.AppendPath(tp.subPath.(DistributionBucketOptionsExponential_FieldPath))
			case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
				explicitBucketsMask.AppendPath(tp.subPath.(DistributionBucketOptionsExplicit_FieldPath))
			case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
				dynamicBucketsMask.AppendPath(tp.subPath.(DistributionBucketOptionsDynamic_FieldPath))
			}
		}
	}
	if wholeLinearBucketsAccepted == false && len(linearBucketsMask.Paths) > 0 {
		if asOneOf, ok := source.Options.(*Distribution_BucketOptions_LinearBuckets); ok {
			result.Options = (*Distribution_BucketOptions_LinearBuckets)(nil)
			if asOneOf != nil {
				oneOfRes := &Distribution_BucketOptions_LinearBuckets{}
				oneOfRes.LinearBuckets = linearBucketsMask.Project(asOneOf.LinearBuckets)
				result.Options = oneOfRes
			}
		}
	}
	if wholeExponentialBucketsAccepted == false && len(exponentialBucketsMask.Paths) > 0 {
		if asOneOf, ok := source.Options.(*Distribution_BucketOptions_ExponentialBuckets); ok {
			result.Options = (*Distribution_BucketOptions_ExponentialBuckets)(nil)
			if asOneOf != nil {
				oneOfRes := &Distribution_BucketOptions_ExponentialBuckets{}
				oneOfRes.ExponentialBuckets = exponentialBucketsMask.Project(asOneOf.ExponentialBuckets)
				result.Options = oneOfRes
			}
		}
	}
	if wholeExplicitBucketsAccepted == false && len(explicitBucketsMask.Paths) > 0 {
		if asOneOf, ok := source.Options.(*Distribution_BucketOptions_ExplicitBuckets); ok {
			result.Options = (*Distribution_BucketOptions_ExplicitBuckets)(nil)
			if asOneOf != nil {
				oneOfRes := &Distribution_BucketOptions_ExplicitBuckets{}
				oneOfRes.ExplicitBuckets = explicitBucketsMask.Project(asOneOf.ExplicitBuckets)
				result.Options = oneOfRes
			}
		}
	}
	if wholeDynamicBucketsAccepted == false && len(dynamicBucketsMask.Paths) > 0 {
		if asOneOf, ok := source.Options.(*Distribution_BucketOptions_DynamicBuckets); ok {
			result.Options = (*Distribution_BucketOptions_DynamicBuckets)(nil)
			if asOneOf != nil {
				oneOfRes := &Distribution_BucketOptions_DynamicBuckets{}
				oneOfRes.DynamicBuckets = dynamicBucketsMask.Project(asOneOf.DynamicBuckets)
				result.Options = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Distribution_BucketOptions))
}

func (fieldMask *Distribution_BucketOptions_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Distribution_BucketOptions_Linear_FieldMask struct {
	Paths []DistributionBucketOptionsLinear_FieldPath
}

func FullDistribution_BucketOptions_Linear_FieldMask() *Distribution_BucketOptions_Linear_FieldMask {
	res := &Distribution_BucketOptions_Linear_FieldMask{}
	res.Paths = append(res.Paths, &DistributionBucketOptionsLinear_FieldTerminalPath{selector: DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets})
	res.Paths = append(res.Paths, &DistributionBucketOptionsLinear_FieldTerminalPath{selector: DistributionBucketOptionsLinear_FieldPathSelectorWidth})
	res.Paths = append(res.Paths, &DistributionBucketOptionsLinear_FieldTerminalPath{selector: DistributionBucketOptionsLinear_FieldPathSelectorOffset})
	return res
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDistributionBucketOptionsLinear_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DistributionBucketOptionsLinear_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDistributionBucketOptionsLinear_FieldPath(raw)
	})
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) ProtoMessage() {}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) Subtract(other *Distribution_BucketOptions_Linear_FieldMask) *Distribution_BucketOptions_Linear_FieldMask {
	result := &Distribution_BucketOptions_Linear_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DistributionBucketOptionsLinear_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Distribution_BucketOptions_Linear_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) FilterInputFields() *Distribution_BucketOptions_Linear_FieldMask {
	result := &Distribution_BucketOptions_Linear_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DistributionBucketOptionsLinear_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDistributionBucketOptionsLinear_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Distribution_BucketOptions_Linear_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Distribution_BucketOptions_Linear_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) AppendPath(path DistributionBucketOptionsLinear_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DistributionBucketOptionsLinear_FieldPath))
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) GetPaths() []DistributionBucketOptionsLinear_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDistributionBucketOptionsLinear_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) Set(target, source *Distribution_BucketOptions_Linear) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Distribution_BucketOptions_Linear), source.(*Distribution_BucketOptions_Linear))
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) Project(source *Distribution_BucketOptions_Linear) *Distribution_BucketOptions_Linear {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Distribution_BucketOptions_Linear{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DistributionBucketOptionsLinear_FieldTerminalPath:
			switch tp.selector {
			case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
				result.NumFiniteBuckets = source.NumFiniteBuckets
			case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
				result.Width = source.Width
			case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
				result.Offset = source.Offset
			}
		}
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Distribution_BucketOptions_Linear))
}

func (fieldMask *Distribution_BucketOptions_Linear_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Distribution_BucketOptions_Exponential_FieldMask struct {
	Paths []DistributionBucketOptionsExponential_FieldPath
}

func FullDistribution_BucketOptions_Exponential_FieldMask() *Distribution_BucketOptions_Exponential_FieldMask {
	res := &Distribution_BucketOptions_Exponential_FieldMask{}
	res.Paths = append(res.Paths, &DistributionBucketOptionsExponential_FieldTerminalPath{selector: DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets})
	res.Paths = append(res.Paths, &DistributionBucketOptionsExponential_FieldTerminalPath{selector: DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor})
	res.Paths = append(res.Paths, &DistributionBucketOptionsExponential_FieldTerminalPath{selector: DistributionBucketOptionsExponential_FieldPathSelectorScale})
	return res
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDistributionBucketOptionsExponential_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DistributionBucketOptionsExponential_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDistributionBucketOptionsExponential_FieldPath(raw)
	})
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) ProtoMessage() {}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) Subtract(other *Distribution_BucketOptions_Exponential_FieldMask) *Distribution_BucketOptions_Exponential_FieldMask {
	result := &Distribution_BucketOptions_Exponential_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DistributionBucketOptionsExponential_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Distribution_BucketOptions_Exponential_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) FilterInputFields() *Distribution_BucketOptions_Exponential_FieldMask {
	result := &Distribution_BucketOptions_Exponential_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DistributionBucketOptionsExponential_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDistributionBucketOptionsExponential_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Distribution_BucketOptions_Exponential_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Distribution_BucketOptions_Exponential_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) AppendPath(path DistributionBucketOptionsExponential_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DistributionBucketOptionsExponential_FieldPath))
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) GetPaths() []DistributionBucketOptionsExponential_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDistributionBucketOptionsExponential_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) Set(target, source *Distribution_BucketOptions_Exponential) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Distribution_BucketOptions_Exponential), source.(*Distribution_BucketOptions_Exponential))
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) Project(source *Distribution_BucketOptions_Exponential) *Distribution_BucketOptions_Exponential {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Distribution_BucketOptions_Exponential{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DistributionBucketOptionsExponential_FieldTerminalPath:
			switch tp.selector {
			case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
				result.NumFiniteBuckets = source.NumFiniteBuckets
			case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
				result.GrowthFactor = source.GrowthFactor
			case DistributionBucketOptionsExponential_FieldPathSelectorScale:
				result.Scale = source.Scale
			}
		}
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Distribution_BucketOptions_Exponential))
}

func (fieldMask *Distribution_BucketOptions_Exponential_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Distribution_BucketOptions_Explicit_FieldMask struct {
	Paths []DistributionBucketOptionsExplicit_FieldPath
}

func FullDistribution_BucketOptions_Explicit_FieldMask() *Distribution_BucketOptions_Explicit_FieldMask {
	res := &Distribution_BucketOptions_Explicit_FieldMask{}
	res.Paths = append(res.Paths, &DistributionBucketOptionsExplicit_FieldTerminalPath{selector: DistributionBucketOptionsExplicit_FieldPathSelectorBounds})
	return res
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDistributionBucketOptionsExplicit_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DistributionBucketOptionsExplicit_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDistributionBucketOptionsExplicit_FieldPath(raw)
	})
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) ProtoMessage() {}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) Subtract(other *Distribution_BucketOptions_Explicit_FieldMask) *Distribution_BucketOptions_Explicit_FieldMask {
	result := &Distribution_BucketOptions_Explicit_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DistributionBucketOptionsExplicit_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Distribution_BucketOptions_Explicit_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) FilterInputFields() *Distribution_BucketOptions_Explicit_FieldMask {
	result := &Distribution_BucketOptions_Explicit_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DistributionBucketOptionsExplicit_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDistributionBucketOptionsExplicit_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Distribution_BucketOptions_Explicit_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Distribution_BucketOptions_Explicit_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) AppendPath(path DistributionBucketOptionsExplicit_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DistributionBucketOptionsExplicit_FieldPath))
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) GetPaths() []DistributionBucketOptionsExplicit_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDistributionBucketOptionsExplicit_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) Set(target, source *Distribution_BucketOptions_Explicit) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Distribution_BucketOptions_Explicit), source.(*Distribution_BucketOptions_Explicit))
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) Project(source *Distribution_BucketOptions_Explicit) *Distribution_BucketOptions_Explicit {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Distribution_BucketOptions_Explicit{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DistributionBucketOptionsExplicit_FieldTerminalPath:
			switch tp.selector {
			case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
				result.Bounds = source.Bounds
			}
		}
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Distribution_BucketOptions_Explicit))
}

func (fieldMask *Distribution_BucketOptions_Explicit_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Distribution_BucketOptions_Dynamic_FieldMask struct {
	Paths []DistributionBucketOptionsDynamic_FieldPath
}

func FullDistribution_BucketOptions_Dynamic_FieldMask() *Distribution_BucketOptions_Dynamic_FieldMask {
	res := &Distribution_BucketOptions_Dynamic_FieldMask{}
	res.Paths = append(res.Paths, &DistributionBucketOptionsDynamic_FieldTerminalPath{selector: DistributionBucketOptionsDynamic_FieldPathSelectorCompression})
	res.Paths = append(res.Paths, &DistributionBucketOptionsDynamic_FieldTerminalPath{selector: DistributionBucketOptionsDynamic_FieldPathSelectorMeans})
	return res
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDistributionBucketOptionsDynamic_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DistributionBucketOptionsDynamic_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDistributionBucketOptionsDynamic_FieldPath(raw)
	})
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) ProtoMessage() {}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) Subtract(other *Distribution_BucketOptions_Dynamic_FieldMask) *Distribution_BucketOptions_Dynamic_FieldMask {
	result := &Distribution_BucketOptions_Dynamic_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DistributionBucketOptionsDynamic_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Distribution_BucketOptions_Dynamic_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) FilterInputFields() *Distribution_BucketOptions_Dynamic_FieldMask {
	result := &Distribution_BucketOptions_Dynamic_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DistributionBucketOptionsDynamic_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDistributionBucketOptionsDynamic_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Distribution_BucketOptions_Dynamic_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Distribution_BucketOptions_Dynamic_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) AppendPath(path DistributionBucketOptionsDynamic_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DistributionBucketOptionsDynamic_FieldPath))
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) GetPaths() []DistributionBucketOptionsDynamic_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDistributionBucketOptionsDynamic_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) Set(target, source *Distribution_BucketOptions_Dynamic) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Distribution_BucketOptions_Dynamic), source.(*Distribution_BucketOptions_Dynamic))
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) Project(source *Distribution_BucketOptions_Dynamic) *Distribution_BucketOptions_Dynamic {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Distribution_BucketOptions_Dynamic{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DistributionBucketOptionsDynamic_FieldTerminalPath:
			switch tp.selector {
			case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
				result.Compression = source.Compression
			case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
				result.Means = source.Means
			}
		}
	}
	return result
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Distribution_BucketOptions_Dynamic))
}

func (fieldMask *Distribution_BucketOptions_Dynamic_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TypedValue_FieldMask struct {
	Paths []TypedValue_FieldPath
}

func FullTypedValue_FieldMask() *TypedValue_FieldMask {
	res := &TypedValue_FieldMask{}
	res.Paths = append(res.Paths, &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorBoolValue})
	res.Paths = append(res.Paths, &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorInt64Value})
	res.Paths = append(res.Paths, &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorDoubleValue})
	res.Paths = append(res.Paths, &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorStringValue})
	res.Paths = append(res.Paths, &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorDistributionValue})
	return res
}

func (fieldMask *TypedValue_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *TypedValue_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *TypedValue_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseTypedValue_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *TypedValue_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TypedValue_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TypedValue_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTypedValue_FieldPath(raw)
	})
}

func (fieldMask *TypedValue_FieldMask) ProtoMessage() {}

func (fieldMask *TypedValue_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TypedValue_FieldMask) Subtract(other *TypedValue_FieldMask) *TypedValue_FieldMask {
	result := &TypedValue_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[TypedValue_FieldPathSelector]gotenobject.FieldMask{
		TypedValue_FieldPathSelectorDistributionValue: &Distribution_FieldMask{},
	}
	mySubMasks := map[TypedValue_FieldPathSelector]gotenobject.FieldMask{
		TypedValue_FieldPathSelectorDistributionValue: &Distribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TypedValue_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TypedValue_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TypedValue_FieldTerminalPath); ok {
					switch tp.selector {
					case TypedValue_FieldPathSelectorDistributionValue:
						mySubMasks[TypedValue_FieldPathSelectorDistributionValue] = FullDistribution_FieldMask()
					}
				} else if tp, ok := path.(*TypedValue_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TypedValue_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TypedValue_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TypedValue_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TypedValue_FieldMask) FilterInputFields() *TypedValue_FieldMask {
	result := &TypedValue_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TypedValue_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TypedValue_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TypedValue_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTypedValue_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TypedValue_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TypedValue_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TypedValue_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TypedValue_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TypedValue_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TypedValue_FieldMask) AppendPath(path TypedValue_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TypedValue_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TypedValue_FieldPath))
}

func (fieldMask *TypedValue_FieldMask) GetPaths() []TypedValue_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TypedValue_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TypedValue_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTypedValue_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TypedValue_FieldMask) Set(target, source *TypedValue) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TypedValue_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TypedValue), source.(*TypedValue))
}

func (fieldMask *TypedValue_FieldMask) Project(source *TypedValue) *TypedValue {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TypedValue{}
	distributionValueMask := &Distribution_FieldMask{}
	wholeDistributionValueAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TypedValue_FieldTerminalPath:
			switch tp.selector {
			case TypedValue_FieldPathSelectorBoolValue:
				if source, ok := source.Value.(*TypedValue_BoolValue); ok {
					result.Value = &TypedValue_BoolValue{
						BoolValue: source.BoolValue,
					}
				}
			case TypedValue_FieldPathSelectorInt64Value:
				if source, ok := source.Value.(*TypedValue_Int64Value); ok {
					result.Value = &TypedValue_Int64Value{
						Int64Value: source.Int64Value,
					}
				}
			case TypedValue_FieldPathSelectorDoubleValue:
				if source, ok := source.Value.(*TypedValue_DoubleValue); ok {
					result.Value = &TypedValue_DoubleValue{
						DoubleValue: source.DoubleValue,
					}
				}
			case TypedValue_FieldPathSelectorStringValue:
				if source, ok := source.Value.(*TypedValue_StringValue); ok {
					result.Value = &TypedValue_StringValue{
						StringValue: source.StringValue,
					}
				}
			case TypedValue_FieldPathSelectorDistributionValue:
				if source, ok := source.Value.(*TypedValue_DistributionValue); ok {
					result.Value = &TypedValue_DistributionValue{
						DistributionValue: source.DistributionValue,
					}
				}
				wholeDistributionValueAccepted = true
			}
		case *TypedValue_FieldSubPath:
			switch tp.selector {
			case TypedValue_FieldPathSelectorDistributionValue:
				distributionValueMask.AppendPath(tp.subPath.(Distribution_FieldPath))
			}
		}
	}
	if wholeDistributionValueAccepted == false && len(distributionValueMask.Paths) > 0 {
		if asOneOf, ok := source.Value.(*TypedValue_DistributionValue); ok {
			result.Value = (*TypedValue_DistributionValue)(nil)
			if asOneOf != nil {
				oneOfRes := &TypedValue_DistributionValue{}
				oneOfRes.DistributionValue = distributionValueMask.Project(asOneOf.DistributionValue)
				result.Value = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *TypedValue_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TypedValue))
}

func (fieldMask *TypedValue_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TimeInterval_FieldMask struct {
	Paths []TimeInterval_FieldPath
}

func FullTimeInterval_FieldMask() *TimeInterval_FieldMask {
	res := &TimeInterval_FieldMask{}
	res.Paths = append(res.Paths, &TimeInterval_FieldTerminalPath{selector: TimeInterval_FieldPathSelectorEndTime})
	res.Paths = append(res.Paths, &TimeInterval_FieldTerminalPath{selector: TimeInterval_FieldPathSelectorStartTime})
	return res
}

func (fieldMask *TimeInterval_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *TimeInterval_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *TimeInterval_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseTimeInterval_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *TimeInterval_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TimeInterval_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TimeInterval_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTimeInterval_FieldPath(raw)
	})
}

func (fieldMask *TimeInterval_FieldMask) ProtoMessage() {}

func (fieldMask *TimeInterval_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TimeInterval_FieldMask) Subtract(other *TimeInterval_FieldMask) *TimeInterval_FieldMask {
	result := &TimeInterval_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TimeInterval_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TimeInterval_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TimeInterval_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TimeInterval_FieldMask) FilterInputFields() *TimeInterval_FieldMask {
	result := &TimeInterval_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TimeInterval_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TimeInterval_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TimeInterval_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTimeInterval_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TimeInterval_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TimeInterval_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TimeInterval_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TimeInterval_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TimeInterval_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TimeInterval_FieldMask) AppendPath(path TimeInterval_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TimeInterval_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TimeInterval_FieldPath))
}

func (fieldMask *TimeInterval_FieldMask) GetPaths() []TimeInterval_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TimeInterval_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TimeInterval_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTimeInterval_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TimeInterval_FieldMask) Set(target, source *TimeInterval) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TimeInterval_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TimeInterval), source.(*TimeInterval))
}

func (fieldMask *TimeInterval_FieldMask) Project(source *TimeInterval) *TimeInterval {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TimeInterval{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TimeInterval_FieldTerminalPath:
			switch tp.selector {
			case TimeInterval_FieldPathSelectorEndTime:
				result.EndTime = source.EndTime
			case TimeInterval_FieldPathSelectorStartTime:
				result.StartTime = source.StartTime
			}
		}
	}
	return result
}

func (fieldMask *TimeInterval_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TimeInterval))
}

func (fieldMask *TimeInterval_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TimeRange_FieldMask struct {
	Paths []TimeRange_FieldPath
}

func FullTimeRange_FieldMask() *TimeRange_FieldMask {
	res := &TimeRange_FieldMask{}
	res.Paths = append(res.Paths, &TimeRange_FieldTerminalPath{selector: TimeRange_FieldPathSelectorStartTime})
	res.Paths = append(res.Paths, &TimeRange_FieldTerminalPath{selector: TimeRange_FieldPathSelectorEndTime})
	return res
}

func (fieldMask *TimeRange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *TimeRange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *TimeRange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseTimeRange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *TimeRange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TimeRange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TimeRange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTimeRange_FieldPath(raw)
	})
}

func (fieldMask *TimeRange_FieldMask) ProtoMessage() {}

func (fieldMask *TimeRange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TimeRange_FieldMask) Subtract(other *TimeRange_FieldMask) *TimeRange_FieldMask {
	result := &TimeRange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TimeRange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TimeRange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TimeRange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TimeRange_FieldMask) FilterInputFields() *TimeRange_FieldMask {
	result := &TimeRange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TimeRange_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TimeRange_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TimeRange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTimeRange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TimeRange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TimeRange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TimeRange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TimeRange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TimeRange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TimeRange_FieldMask) AppendPath(path TimeRange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TimeRange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TimeRange_FieldPath))
}

func (fieldMask *TimeRange_FieldMask) GetPaths() []TimeRange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TimeRange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TimeRange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTimeRange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TimeRange_FieldMask) Set(target, source *TimeRange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TimeRange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TimeRange), source.(*TimeRange))
}

func (fieldMask *TimeRange_FieldMask) Project(source *TimeRange) *TimeRange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TimeRange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TimeRange_FieldTerminalPath:
			switch tp.selector {
			case TimeRange_FieldPathSelectorStartTime:
				result.StartTime = source.StartTime
			case TimeRange_FieldPathSelectorEndTime:
				result.EndTime = source.EndTime
			}
		}
	}
	return result
}

func (fieldMask *TimeRange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TimeRange))
}

func (fieldMask *TimeRange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Aggregation_FieldMask struct {
	Paths []Aggregation_FieldPath
}

func FullAggregation_FieldMask() *Aggregation_FieldMask {
	res := &Aggregation_FieldMask{}
	res.Paths = append(res.Paths, &Aggregation_FieldTerminalPath{selector: Aggregation_FieldPathSelectorAlignmentPeriod})
	res.Paths = append(res.Paths, &Aggregation_FieldTerminalPath{selector: Aggregation_FieldPathSelectorPerSeriesAligner})
	res.Paths = append(res.Paths, &Aggregation_FieldTerminalPath{selector: Aggregation_FieldPathSelectorCrossSeriesReducer})
	res.Paths = append(res.Paths, &Aggregation_FieldTerminalPath{selector: Aggregation_FieldPathSelectorGroupByFields})
	return res
}

func (fieldMask *Aggregation_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Aggregation_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Aggregation_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseAggregation_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Aggregation_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Aggregation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Aggregation_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAggregation_FieldPath(raw)
	})
}

func (fieldMask *Aggregation_FieldMask) ProtoMessage() {}

func (fieldMask *Aggregation_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Aggregation_FieldMask) Subtract(other *Aggregation_FieldMask) *Aggregation_FieldMask {
	result := &Aggregation_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Aggregation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Aggregation_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Aggregation_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Aggregation_FieldMask) FilterInputFields() *Aggregation_FieldMask {
	result := &Aggregation_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Aggregation_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Aggregation_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Aggregation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAggregation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Aggregation_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Aggregation_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Aggregation_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Aggregation_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Aggregation_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Aggregation_FieldMask) AppendPath(path Aggregation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Aggregation_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Aggregation_FieldPath))
}

func (fieldMask *Aggregation_FieldMask) GetPaths() []Aggregation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Aggregation_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Aggregation_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAggregation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Aggregation_FieldMask) Set(target, source *Aggregation) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Aggregation_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Aggregation), source.(*Aggregation))
}

func (fieldMask *Aggregation_FieldMask) Project(source *Aggregation) *Aggregation {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Aggregation{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Aggregation_FieldTerminalPath:
			switch tp.selector {
			case Aggregation_FieldPathSelectorAlignmentPeriod:
				result.AlignmentPeriod = source.AlignmentPeriod
			case Aggregation_FieldPathSelectorPerSeriesAligner:
				result.PerSeriesAligner = source.PerSeriesAligner
			case Aggregation_FieldPathSelectorCrossSeriesReducer:
				result.CrossSeriesReducer = source.CrossSeriesReducer
			case Aggregation_FieldPathSelectorGroupByFields:
				result.GroupByFields = source.GroupByFields
			}
		}
	}
	return result
}

func (fieldMask *Aggregation_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Aggregation))
}

func (fieldMask *Aggregation_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Metric_FieldMask struct {
	Paths []Metric_FieldPath
}

func FullMetric_FieldMask() *Metric_FieldMask {
	res := &Metric_FieldMask{}
	res.Paths = append(res.Paths, &Metric_FieldTerminalPath{selector: Metric_FieldPathSelectorType})
	res.Paths = append(res.Paths, &Metric_FieldTerminalPath{selector: Metric_FieldPathSelectorLabels})
	res.Paths = append(res.Paths, &Metric_FieldTerminalPath{selector: Metric_FieldPathSelectorReducedLabels})
	return res
}

func (fieldMask *Metric_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Metric_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Metric_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseMetric_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Metric_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Metric_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Metric_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseMetric_FieldPath(raw)
	})
}

func (fieldMask *Metric_FieldMask) ProtoMessage() {}

func (fieldMask *Metric_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Metric_FieldMask) Subtract(other *Metric_FieldMask) *Metric_FieldMask {
	result := &Metric_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Metric_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Metric_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Metric_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Metric_FieldMask) FilterInputFields() *Metric_FieldMask {
	result := &Metric_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Metric_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Metric_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Metric_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseMetric_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Metric_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Metric_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Metric_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Metric_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Metric_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Metric_FieldMask) AppendPath(path Metric_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Metric_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Metric_FieldPath))
}

func (fieldMask *Metric_FieldMask) GetPaths() []Metric_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Metric_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Metric_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseMetric_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Metric_FieldMask) Set(target, source *Metric) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Metric_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Metric), source.(*Metric))
}

func (fieldMask *Metric_FieldMask) Project(source *Metric) *Metric {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Metric{}
	var labelsMapKeys []string
	wholeLabelsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Metric_FieldTerminalPath:
			switch tp.selector {
			case Metric_FieldPathSelectorType:
				result.Type = source.Type
			case Metric_FieldPathSelectorLabels:
				result.Labels = source.Labels
				wholeLabelsAccepted = true
			case Metric_FieldPathSelectorReducedLabels:
				result.ReducedLabels = source.ReducedLabels
			}
		case *Metric_FieldPathMap:
			switch tp.selector {
			case Metric_FieldPathSelectorLabels:
				labelsMapKeys = append(labelsMapKeys, tp.key)
			}
		}
	}
	if wholeLabelsAccepted == false && len(labelsMapKeys) > 0 && source.GetLabels() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetLabels()
		for _, key := range labelsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Labels = copiedMap
	}
	return result
}

func (fieldMask *Metric_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Metric))
}

func (fieldMask *Metric_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type MonitoredResource_FieldMask struct {
	Paths []MonitoredResource_FieldPath
}

func FullMonitoredResource_FieldMask() *MonitoredResource_FieldMask {
	res := &MonitoredResource_FieldMask{}
	res.Paths = append(res.Paths, &MonitoredResource_FieldTerminalPath{selector: MonitoredResource_FieldPathSelectorType})
	res.Paths = append(res.Paths, &MonitoredResource_FieldTerminalPath{selector: MonitoredResource_FieldPathSelectorLabels})
	res.Paths = append(res.Paths, &MonitoredResource_FieldTerminalPath{selector: MonitoredResource_FieldPathSelectorReducedLabels})
	return res
}

func (fieldMask *MonitoredResource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *MonitoredResource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *MonitoredResource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseMonitoredResource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *MonitoredResource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*MonitoredResource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *MonitoredResource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseMonitoredResource_FieldPath(raw)
	})
}

func (fieldMask *MonitoredResource_FieldMask) ProtoMessage() {}

func (fieldMask *MonitoredResource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *MonitoredResource_FieldMask) Subtract(other *MonitoredResource_FieldMask) *MonitoredResource_FieldMask {
	result := &MonitoredResource_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *MonitoredResource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *MonitoredResource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*MonitoredResource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *MonitoredResource_FieldMask) FilterInputFields() *MonitoredResource_FieldMask {
	result := &MonitoredResource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *MonitoredResource_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *MonitoredResource_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]MonitoredResource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseMonitoredResource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask MonitoredResource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *MonitoredResource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *MonitoredResource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask MonitoredResource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *MonitoredResource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *MonitoredResource_FieldMask) AppendPath(path MonitoredResource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *MonitoredResource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(MonitoredResource_FieldPath))
}

func (fieldMask *MonitoredResource_FieldMask) GetPaths() []MonitoredResource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *MonitoredResource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *MonitoredResource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseMonitoredResource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *MonitoredResource_FieldMask) Set(target, source *MonitoredResource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *MonitoredResource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*MonitoredResource), source.(*MonitoredResource))
}

func (fieldMask *MonitoredResource_FieldMask) Project(source *MonitoredResource) *MonitoredResource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &MonitoredResource{}
	var labelsMapKeys []string
	wholeLabelsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *MonitoredResource_FieldTerminalPath:
			switch tp.selector {
			case MonitoredResource_FieldPathSelectorType:
				result.Type = source.Type
			case MonitoredResource_FieldPathSelectorLabels:
				result.Labels = source.Labels
				wholeLabelsAccepted = true
			case MonitoredResource_FieldPathSelectorReducedLabels:
				result.ReducedLabels = source.ReducedLabels
			}
		case *MonitoredResource_FieldPathMap:
			switch tp.selector {
			case MonitoredResource_FieldPathSelectorLabels:
				labelsMapKeys = append(labelsMapKeys, tp.key)
			}
		}
	}
	if wholeLabelsAccepted == false && len(labelsMapKeys) > 0 && source.GetLabels() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetLabels()
		for _, key := range labelsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Labels = copiedMap
	}
	return result
}

func (fieldMask *MonitoredResource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*MonitoredResource))
}

func (fieldMask *MonitoredResource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
