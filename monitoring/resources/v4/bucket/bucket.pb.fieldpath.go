// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v4/bucket.proto
// DO NOT EDIT!!!

package bucket

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
	"github.com/cloudwan/goten-sdk/runtime/strcase"
)

// proto imports
import (
	project "github.com/cloudwan/edgelq-sdk/monitoring/resources/v4/project"
	meta "github.com/cloudwan/goten-sdk/types/meta"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &project.Project{}
	_ = &meta.Meta{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Bucket_FieldPath interface {
	gotenobject.FieldPath
	Selector() Bucket_FieldPathSelector
	Get(source *Bucket) []interface{}
	GetSingle(source *Bucket) (interface{}, bool)
	ClearValue(item *Bucket)

	// Those methods build corresponding Bucket_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Bucket_FieldPathValue
	WithIArrayOfValues(values interface{}) Bucket_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Bucket_FieldPathArrayItemValue
}

type Bucket_FieldPathSelector int32

const (
	Bucket_FieldPathSelectorName           Bucket_FieldPathSelector = 0
	Bucket_FieldPathSelectorMetadata       Bucket_FieldPathSelector = 1
	Bucket_FieldPathSelectorMetrics        Bucket_FieldPathSelector = 2
	Bucket_FieldPathSelectorResources      Bucket_FieldPathSelector = 3
	Bucket_FieldPathSelectorRequiredAltKvs Bucket_FieldPathSelector = 4
)

func (s Bucket_FieldPathSelector) String() string {
	switch s {
	case Bucket_FieldPathSelectorName:
		return "name"
	case Bucket_FieldPathSelectorMetadata:
		return "metadata"
	case Bucket_FieldPathSelectorMetrics:
		return "metrics"
	case Bucket_FieldPathSelectorResources:
		return "resources"
	case Bucket_FieldPathSelectorRequiredAltKvs:
		return "required_alt_kvs"
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", s))
	}
}

func BuildBucket_FieldPath(fp gotenobject.RawFieldPath) (Bucket_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Bucket")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &Bucket_FieldTerminalPath{selector: Bucket_FieldPathSelectorName}, nil
		case "metadata":
			return &Bucket_FieldTerminalPath{selector: Bucket_FieldPathSelectorMetadata}, nil
		case "metrics":
			return &Bucket_FieldTerminalPath{selector: Bucket_FieldPathSelectorMetrics}, nil
		case "resources":
			return &Bucket_FieldTerminalPath{selector: Bucket_FieldPathSelectorResources}, nil
		case "required_alt_kvs", "requiredAltKvs", "required-alt-kvs":
			return &Bucket_FieldTerminalPath{selector: Bucket_FieldPathSelectorRequiredAltKvs}, nil
		}
	} else {
		switch fp[0] {
		case "metadata":
			if subpath, err := meta.BuildMeta_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Bucket_FieldSubPath{selector: Bucket_FieldPathSelectorMetadata, subPath: subpath}, nil
			}
		case "metrics":
			if subpath, err := BuildBucketRequiredTypedLabels_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Bucket_FieldSubPath{selector: Bucket_FieldPathSelectorMetrics, subPath: subpath}, nil
			}
		case "resources":
			if subpath, err := BuildBucketRequiredTypedLabels_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Bucket_FieldSubPath{selector: Bucket_FieldPathSelectorResources, subPath: subpath}, nil
			}
		case "required_alt_kvs", "requiredAltKvs", "required-alt-kvs":
			if subpath, err := BuildBucketResolvedKeysWithValues_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Bucket_FieldSubPath{selector: Bucket_FieldPathSelectorRequiredAltKvs, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Bucket", fp)
}

func ParseBucket_FieldPath(rawField string) (Bucket_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBucket_FieldPath(fp)
}

func MustParseBucket_FieldPath(rawField string) Bucket_FieldPath {
	fp, err := ParseBucket_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Bucket_FieldTerminalPath struct {
	selector Bucket_FieldPathSelector
}

var _ Bucket_FieldPath = (*Bucket_FieldTerminalPath)(nil)

func (fp *Bucket_FieldTerminalPath) Selector() Bucket_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Bucket_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Bucket_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Bucket
func (fp *Bucket_FieldTerminalPath) Get(source *Bucket) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Bucket_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		case Bucket_FieldPathSelectorMetadata:
			if source.Metadata != nil {
				values = append(values, source.Metadata)
			}
		case Bucket_FieldPathSelectorMetrics:
			for _, value := range source.GetMetrics() {
				values = append(values, value)
			}
		case Bucket_FieldPathSelectorResources:
			for _, value := range source.GetResources() {
				values = append(values, value)
			}
		case Bucket_FieldPathSelectorRequiredAltKvs:
			for _, value := range source.GetRequiredAltKvs() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket: %d", fp.selector))
		}
	}
	return
}

func (fp *Bucket_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Bucket))
}

// GetSingle returns value pointed by specific field of from source Bucket
func (fp *Bucket_FieldTerminalPath) GetSingle(source *Bucket) (interface{}, bool) {
	switch fp.selector {
	case Bucket_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	case Bucket_FieldPathSelectorMetadata:
		res := source.GetMetadata()
		return res, res != nil
	case Bucket_FieldPathSelectorMetrics:
		res := source.GetMetrics()
		return res, res != nil
	case Bucket_FieldPathSelectorResources:
		res := source.GetResources()
		return res, res != nil
	case Bucket_FieldPathSelectorRequiredAltKvs:
		res := source.GetRequiredAltKvs()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fp.selector))
	}
}

func (fp *Bucket_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Bucket))
}

// GetDefault returns a default value of the field type
func (fp *Bucket_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Bucket_FieldPathSelectorName:
		return (*Name)(nil)
	case Bucket_FieldPathSelectorMetadata:
		return (*meta.Meta)(nil)
	case Bucket_FieldPathSelectorMetrics:
		return ([]*Bucket_RequiredTypedLabels)(nil)
	case Bucket_FieldPathSelectorResources:
		return ([]*Bucket_RequiredTypedLabels)(nil)
	case Bucket_FieldPathSelectorRequiredAltKvs:
		return ([]*Bucket_ResolvedKeysWithValues)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fp.selector))
	}
}

func (fp *Bucket_FieldTerminalPath) ClearValue(item *Bucket) {
	if item != nil {
		switch fp.selector {
		case Bucket_FieldPathSelectorName:
			item.Name = nil
		case Bucket_FieldPathSelectorMetadata:
			item.Metadata = nil
		case Bucket_FieldPathSelectorMetrics:
			item.Metrics = nil
		case Bucket_FieldPathSelectorResources:
			item.Resources = nil
		case Bucket_FieldPathSelectorRequiredAltKvs:
			item.RequiredAltKvs = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket: %d", fp.selector))
		}
	}
}

func (fp *Bucket_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Bucket))
}

// IsLeaf - whether field path is holds simple value
func (fp *Bucket_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Bucket_FieldPathSelectorName
}

func (fp *Bucket_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Bucket_FieldTerminalPath) WithIValue(value interface{}) Bucket_FieldPathValue {
	switch fp.selector {
	case Bucket_FieldPathSelectorName:
		return &Bucket_FieldTerminalPathValue{Bucket_FieldTerminalPath: *fp, value: value.(*Name)}
	case Bucket_FieldPathSelectorMetadata:
		return &Bucket_FieldTerminalPathValue{Bucket_FieldTerminalPath: *fp, value: value.(*meta.Meta)}
	case Bucket_FieldPathSelectorMetrics:
		return &Bucket_FieldTerminalPathValue{Bucket_FieldTerminalPath: *fp, value: value.([]*Bucket_RequiredTypedLabels)}
	case Bucket_FieldPathSelectorResources:
		return &Bucket_FieldTerminalPathValue{Bucket_FieldTerminalPath: *fp, value: value.([]*Bucket_RequiredTypedLabels)}
	case Bucket_FieldPathSelectorRequiredAltKvs:
		return &Bucket_FieldTerminalPathValue{Bucket_FieldTerminalPath: *fp, value: value.([]*Bucket_ResolvedKeysWithValues)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fp.selector))
	}
}

func (fp *Bucket_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Bucket_FieldTerminalPath) WithIArrayOfValues(values interface{}) Bucket_FieldPathArrayOfValues {
	fpaov := &Bucket_FieldTerminalPathArrayOfValues{Bucket_FieldTerminalPath: *fp}
	switch fp.selector {
	case Bucket_FieldPathSelectorName:
		return &Bucket_FieldTerminalPathArrayOfValues{Bucket_FieldTerminalPath: *fp, values: values.([]*Name)}
	case Bucket_FieldPathSelectorMetadata:
		return &Bucket_FieldTerminalPathArrayOfValues{Bucket_FieldTerminalPath: *fp, values: values.([]*meta.Meta)}
	case Bucket_FieldPathSelectorMetrics:
		return &Bucket_FieldTerminalPathArrayOfValues{Bucket_FieldTerminalPath: *fp, values: values.([][]*Bucket_RequiredTypedLabels)}
	case Bucket_FieldPathSelectorResources:
		return &Bucket_FieldTerminalPathArrayOfValues{Bucket_FieldTerminalPath: *fp, values: values.([][]*Bucket_RequiredTypedLabels)}
	case Bucket_FieldPathSelectorRequiredAltKvs:
		return &Bucket_FieldTerminalPathArrayOfValues{Bucket_FieldTerminalPath: *fp, values: values.([][]*Bucket_ResolvedKeysWithValues)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fp.selector))
	}
	return fpaov
}

func (fp *Bucket_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Bucket_FieldTerminalPath) WithIArrayItemValue(value interface{}) Bucket_FieldPathArrayItemValue {
	switch fp.selector {
	case Bucket_FieldPathSelectorMetrics:
		return &Bucket_FieldTerminalPathArrayItemValue{Bucket_FieldTerminalPath: *fp, value: value.(*Bucket_RequiredTypedLabels)}
	case Bucket_FieldPathSelectorResources:
		return &Bucket_FieldTerminalPathArrayItemValue{Bucket_FieldTerminalPath: *fp, value: value.(*Bucket_RequiredTypedLabels)}
	case Bucket_FieldPathSelectorRequiredAltKvs:
		return &Bucket_FieldTerminalPathArrayItemValue{Bucket_FieldTerminalPath: *fp, value: value.(*Bucket_ResolvedKeysWithValues)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fp.selector))
	}
}

func (fp *Bucket_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type Bucket_FieldSubPath struct {
	selector Bucket_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ Bucket_FieldPath = (*Bucket_FieldSubPath)(nil)

func (fps *Bucket_FieldSubPath) Selector() Bucket_FieldPathSelector {
	return fps.selector
}
func (fps *Bucket_FieldSubPath) AsMetadataSubPath() (meta.Meta_FieldPath, bool) {
	res, ok := fps.subPath.(meta.Meta_FieldPath)
	return res, ok
}
func (fps *Bucket_FieldSubPath) AsMetricsSubPath() (BucketRequiredTypedLabels_FieldPath, bool) {
	res, ok := fps.subPath.(BucketRequiredTypedLabels_FieldPath)
	return res, ok
}
func (fps *Bucket_FieldSubPath) AsResourcesSubPath() (BucketRequiredTypedLabels_FieldPath, bool) {
	res, ok := fps.subPath.(BucketRequiredTypedLabels_FieldPath)
	return res, ok
}
func (fps *Bucket_FieldSubPath) AsRequiredAltKvsSubPath() (BucketResolvedKeysWithValues_FieldPath, bool) {
	res, ok := fps.subPath.(BucketResolvedKeysWithValues_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *Bucket_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *Bucket_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Bucket
func (fps *Bucket_FieldSubPath) Get(source *Bucket) (values []interface{}) {
	switch fps.selector {
	case Bucket_FieldPathSelectorMetadata:
		values = append(values, fps.subPath.GetRaw(source.GetMetadata())...)
	case Bucket_FieldPathSelectorMetrics:
		for _, item := range source.GetMetrics() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case Bucket_FieldPathSelectorResources:
		for _, item := range source.GetResources() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case Bucket_FieldPathSelectorRequiredAltKvs:
		for _, item := range source.GetRequiredAltKvs() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fps.selector))
	}
	return
}

func (fps *Bucket_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Bucket))
}

// GetSingle returns value of selected field from source Bucket
func (fps *Bucket_FieldSubPath) GetSingle(source *Bucket) (interface{}, bool) {
	switch fps.selector {
	case Bucket_FieldPathSelectorMetadata:
		if source.GetMetadata() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetMetadata())
	case Bucket_FieldPathSelectorMetrics:
		if len(source.GetMetrics()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetMetrics()[0])
	case Bucket_FieldPathSelectorResources:
		if len(source.GetResources()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetResources()[0])
	case Bucket_FieldPathSelectorRequiredAltKvs:
		if len(source.GetRequiredAltKvs()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetRequiredAltKvs()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fps.selector))
	}
}

func (fps *Bucket_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Bucket))
}

// GetDefault returns a default value of the field type
func (fps *Bucket_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *Bucket_FieldSubPath) ClearValue(item *Bucket) {
	if item != nil {
		switch fps.selector {
		case Bucket_FieldPathSelectorMetadata:
			fps.subPath.ClearValueRaw(item.Metadata)
		case Bucket_FieldPathSelectorMetrics:
			for _, subItem := range item.Metrics {
				fps.subPath.ClearValueRaw(subItem)
			}
		case Bucket_FieldPathSelectorResources:
			for _, subItem := range item.Resources {
				fps.subPath.ClearValueRaw(subItem)
			}
		case Bucket_FieldPathSelectorRequiredAltKvs:
			for _, subItem := range item.RequiredAltKvs {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket: %d", fps.selector))
		}
	}
}

func (fps *Bucket_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Bucket))
}

// IsLeaf - whether field path is holds simple value
func (fps *Bucket_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *Bucket_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&Bucket_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *Bucket_FieldSubPath) WithIValue(value interface{}) Bucket_FieldPathValue {
	return &Bucket_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *Bucket_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *Bucket_FieldSubPath) WithIArrayOfValues(values interface{}) Bucket_FieldPathArrayOfValues {
	return &Bucket_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *Bucket_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *Bucket_FieldSubPath) WithIArrayItemValue(value interface{}) Bucket_FieldPathArrayItemValue {
	return &Bucket_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *Bucket_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// Bucket_FieldPathValue allows storing values for Bucket fields according to their type
type Bucket_FieldPathValue interface {
	Bucket_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Bucket)
	CompareWith(*Bucket) (cmp int, comparable bool)
}

func ParseBucket_FieldPathValue(pathStr, valueStr string) (Bucket_FieldPathValue, error) {
	fp, err := ParseBucket_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Bucket field path value from %s: %v", valueStr, err)
	}
	return fpv.(Bucket_FieldPathValue), nil
}

func MustParseBucket_FieldPathValue(pathStr, valueStr string) Bucket_FieldPathValue {
	fpv, err := ParseBucket_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Bucket_FieldTerminalPathValue struct {
	Bucket_FieldTerminalPath
	value interface{}
}

var _ Bucket_FieldPathValue = (*Bucket_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Bucket' as interface{}
func (fpv *Bucket_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Bucket_FieldTerminalPathValue) AsNameValue() (*Name, bool) {
	res, ok := fpv.value.(*Name)
	return res, ok
}
func (fpv *Bucket_FieldTerminalPathValue) AsMetadataValue() (*meta.Meta, bool) {
	res, ok := fpv.value.(*meta.Meta)
	return res, ok
}
func (fpv *Bucket_FieldTerminalPathValue) AsMetricsValue() ([]*Bucket_RequiredTypedLabels, bool) {
	res, ok := fpv.value.([]*Bucket_RequiredTypedLabels)
	return res, ok
}
func (fpv *Bucket_FieldTerminalPathValue) AsResourcesValue() ([]*Bucket_RequiredTypedLabels, bool) {
	res, ok := fpv.value.([]*Bucket_RequiredTypedLabels)
	return res, ok
}
func (fpv *Bucket_FieldTerminalPathValue) AsRequiredAltKvsValue() ([]*Bucket_ResolvedKeysWithValues, bool) {
	res, ok := fpv.value.([]*Bucket_ResolvedKeysWithValues)
	return res, ok
}

// SetTo stores value for selected field for object Bucket
func (fpv *Bucket_FieldTerminalPathValue) SetTo(target **Bucket) {
	if *target == nil {
		*target = new(Bucket)
	}
	switch fpv.selector {
	case Bucket_FieldPathSelectorName:
		(*target).Name = fpv.value.(*Name)
	case Bucket_FieldPathSelectorMetadata:
		(*target).Metadata = fpv.value.(*meta.Meta)
	case Bucket_FieldPathSelectorMetrics:
		(*target).Metrics = fpv.value.([]*Bucket_RequiredTypedLabels)
	case Bucket_FieldPathSelectorResources:
		(*target).Resources = fpv.value.([]*Bucket_RequiredTypedLabels)
	case Bucket_FieldPathSelectorRequiredAltKvs:
		(*target).RequiredAltKvs = fpv.value.([]*Bucket_ResolvedKeysWithValues)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fpv.selector))
	}
}

func (fpv *Bucket_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Bucket)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Bucket_FieldTerminalPathValue' with the value under path in 'Bucket'.
func (fpv *Bucket_FieldTerminalPathValue) CompareWith(source *Bucket) (int, bool) {
	switch fpv.selector {
	case Bucket_FieldPathSelectorName:
		leftValue := fpv.value.(*Name)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case Bucket_FieldPathSelectorMetadata:
		return 0, false
	case Bucket_FieldPathSelectorMetrics:
		return 0, false
	case Bucket_FieldPathSelectorResources:
		return 0, false
	case Bucket_FieldPathSelectorRequiredAltKvs:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fpv.selector))
	}
}

func (fpv *Bucket_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Bucket))
}

type Bucket_FieldSubPathValue struct {
	Bucket_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ Bucket_FieldPathValue = (*Bucket_FieldSubPathValue)(nil)

func (fpvs *Bucket_FieldSubPathValue) AsMetadataPathValue() (meta.Meta_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(meta.Meta_FieldPathValue)
	return res, ok
}
func (fpvs *Bucket_FieldSubPathValue) AsMetricsPathValue() (BucketRequiredTypedLabels_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(BucketRequiredTypedLabels_FieldPathValue)
	return res, ok
}
func (fpvs *Bucket_FieldSubPathValue) AsResourcesPathValue() (BucketRequiredTypedLabels_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(BucketRequiredTypedLabels_FieldPathValue)
	return res, ok
}
func (fpvs *Bucket_FieldSubPathValue) AsRequiredAltKvsPathValue() (BucketResolvedKeysWithValues_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(BucketResolvedKeysWithValues_FieldPathValue)
	return res, ok
}

func (fpvs *Bucket_FieldSubPathValue) SetTo(target **Bucket) {
	if *target == nil {
		*target = new(Bucket)
	}
	switch fpvs.Selector() {
	case Bucket_FieldPathSelectorMetadata:
		fpvs.subPathValue.(meta.Meta_FieldPathValue).SetTo(&(*target).Metadata)
	case Bucket_FieldPathSelectorMetrics:
		panic("FieldPath setter is unsupported for array subpaths")
	case Bucket_FieldPathSelectorResources:
		panic("FieldPath setter is unsupported for array subpaths")
	case Bucket_FieldPathSelectorRequiredAltKvs:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fpvs.Selector()))
	}
}

func (fpvs *Bucket_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Bucket)
	fpvs.SetTo(&typedObject)
}

func (fpvs *Bucket_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *Bucket_FieldSubPathValue) CompareWith(source *Bucket) (int, bool) {
	switch fpvs.Selector() {
	case Bucket_FieldPathSelectorMetadata:
		return fpvs.subPathValue.(meta.Meta_FieldPathValue).CompareWith(source.GetMetadata())
	case Bucket_FieldPathSelectorMetrics:
		return 0, false // repeated field
	case Bucket_FieldPathSelectorResources:
		return 0, false // repeated field
	case Bucket_FieldPathSelectorRequiredAltKvs:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fpvs.Selector()))
	}
}

func (fpvs *Bucket_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Bucket))
}

// Bucket_FieldPathArrayItemValue allows storing single item in Path-specific values for Bucket according to their type
// Present only for array (repeated) types.
type Bucket_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Bucket_FieldPath
	ContainsValue(*Bucket) bool
}

// ParseBucket_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBucket_FieldPathArrayItemValue(pathStr, valueStr string) (Bucket_FieldPathArrayItemValue, error) {
	fp, err := ParseBucket_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Bucket field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Bucket_FieldPathArrayItemValue), nil
}

func MustParseBucket_FieldPathArrayItemValue(pathStr, valueStr string) Bucket_FieldPathArrayItemValue {
	fpaiv, err := ParseBucket_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Bucket_FieldTerminalPathArrayItemValue struct {
	Bucket_FieldTerminalPath
	value interface{}
}

var _ Bucket_FieldPathArrayItemValue = (*Bucket_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Bucket as interface{}
func (fpaiv *Bucket_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Bucket_FieldTerminalPathArrayItemValue) AsMetricsItemValue() (*Bucket_RequiredTypedLabels, bool) {
	res, ok := fpaiv.value.(*Bucket_RequiredTypedLabels)
	return res, ok
}
func (fpaiv *Bucket_FieldTerminalPathArrayItemValue) AsResourcesItemValue() (*Bucket_RequiredTypedLabels, bool) {
	res, ok := fpaiv.value.(*Bucket_RequiredTypedLabels)
	return res, ok
}
func (fpaiv *Bucket_FieldTerminalPathArrayItemValue) AsRequiredAltKvsItemValue() (*Bucket_ResolvedKeysWithValues, bool) {
	res, ok := fpaiv.value.(*Bucket_ResolvedKeysWithValues)
	return res, ok
}

func (fpaiv *Bucket_FieldTerminalPathArrayItemValue) GetSingle(source *Bucket) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Bucket_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Bucket))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Bucket'
func (fpaiv *Bucket_FieldTerminalPathArrayItemValue) ContainsValue(source *Bucket) bool {
	slice := fpaiv.Bucket_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type Bucket_FieldSubPathArrayItemValue struct {
	Bucket_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *Bucket_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *Bucket_FieldSubPathArrayItemValue) AsMetadataPathItemValue() (meta.Meta_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(meta.Meta_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Bucket_FieldSubPathArrayItemValue) AsMetricsPathItemValue() (BucketRequiredTypedLabels_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(BucketRequiredTypedLabels_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Bucket_FieldSubPathArrayItemValue) AsResourcesPathItemValue() (BucketRequiredTypedLabels_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(BucketRequiredTypedLabels_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Bucket_FieldSubPathArrayItemValue) AsRequiredAltKvsPathItemValue() (BucketResolvedKeysWithValues_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(BucketResolvedKeysWithValues_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'Bucket'
func (fpaivs *Bucket_FieldSubPathArrayItemValue) ContainsValue(source *Bucket) bool {
	switch fpaivs.Selector() {
	case Bucket_FieldPathSelectorMetadata:
		return fpaivs.subPathItemValue.(meta.Meta_FieldPathArrayItemValue).ContainsValue(source.GetMetadata())
	case Bucket_FieldPathSelectorMetrics:
		return false // repeated/map field
	case Bucket_FieldPathSelectorResources:
		return false // repeated/map field
	case Bucket_FieldPathSelectorRequiredAltKvs:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket: %d", fpaivs.Selector()))
	}
}

// Bucket_FieldPathArrayOfValues allows storing slice of values for Bucket fields according to their type
type Bucket_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Bucket_FieldPath
}

func ParseBucket_FieldPathArrayOfValues(pathStr, valuesStr string) (Bucket_FieldPathArrayOfValues, error) {
	fp, err := ParseBucket_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Bucket field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Bucket_FieldPathArrayOfValues), nil
}

func MustParseBucket_FieldPathArrayOfValues(pathStr, valuesStr string) Bucket_FieldPathArrayOfValues {
	fpaov, err := ParseBucket_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Bucket_FieldTerminalPathArrayOfValues struct {
	Bucket_FieldTerminalPath
	values interface{}
}

var _ Bucket_FieldPathArrayOfValues = (*Bucket_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Bucket_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Bucket_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*Name) {
			values = append(values, v)
		}
	case Bucket_FieldPathSelectorMetadata:
		for _, v := range fpaov.values.([]*meta.Meta) {
			values = append(values, v)
		}
	case Bucket_FieldPathSelectorMetrics:
		for _, v := range fpaov.values.([][]*Bucket_RequiredTypedLabels) {
			values = append(values, v)
		}
	case Bucket_FieldPathSelectorResources:
		for _, v := range fpaov.values.([][]*Bucket_RequiredTypedLabels) {
			values = append(values, v)
		}
	case Bucket_FieldPathSelectorRequiredAltKvs:
		for _, v := range fpaov.values.([][]*Bucket_ResolvedKeysWithValues) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Bucket_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*Name, bool) {
	res, ok := fpaov.values.([]*Name)
	return res, ok
}
func (fpaov *Bucket_FieldTerminalPathArrayOfValues) AsMetadataArrayOfValues() ([]*meta.Meta, bool) {
	res, ok := fpaov.values.([]*meta.Meta)
	return res, ok
}
func (fpaov *Bucket_FieldTerminalPathArrayOfValues) AsMetricsArrayOfValues() ([][]*Bucket_RequiredTypedLabels, bool) {
	res, ok := fpaov.values.([][]*Bucket_RequiredTypedLabels)
	return res, ok
}
func (fpaov *Bucket_FieldTerminalPathArrayOfValues) AsResourcesArrayOfValues() ([][]*Bucket_RequiredTypedLabels, bool) {
	res, ok := fpaov.values.([][]*Bucket_RequiredTypedLabels)
	return res, ok
}
func (fpaov *Bucket_FieldTerminalPathArrayOfValues) AsRequiredAltKvsArrayOfValues() ([][]*Bucket_ResolvedKeysWithValues, bool) {
	res, ok := fpaov.values.([][]*Bucket_ResolvedKeysWithValues)
	return res, ok
}

type Bucket_FieldSubPathArrayOfValues struct {
	Bucket_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ Bucket_FieldPathArrayOfValues = (*Bucket_FieldSubPathArrayOfValues)(nil)

func (fpsaov *Bucket_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *Bucket_FieldSubPathArrayOfValues) AsMetadataPathArrayOfValues() (meta.Meta_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(meta.Meta_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Bucket_FieldSubPathArrayOfValues) AsMetricsPathArrayOfValues() (BucketRequiredTypedLabels_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(BucketRequiredTypedLabels_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Bucket_FieldSubPathArrayOfValues) AsResourcesPathArrayOfValues() (BucketRequiredTypedLabels_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(BucketRequiredTypedLabels_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Bucket_FieldSubPathArrayOfValues) AsRequiredAltKvsPathArrayOfValues() (BucketResolvedKeysWithValues_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(BucketResolvedKeysWithValues_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BucketResolvedValues_FieldPath interface {
	gotenobject.FieldPath
	Selector() BucketResolvedValues_FieldPathSelector
	Get(source *Bucket_ResolvedValues) []interface{}
	GetSingle(source *Bucket_ResolvedValues) (interface{}, bool)
	ClearValue(item *Bucket_ResolvedValues)

	// Those methods build corresponding BucketResolvedValues_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BucketResolvedValues_FieldPathValue
	WithIArrayOfValues(values interface{}) BucketResolvedValues_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BucketResolvedValues_FieldPathArrayItemValue
}

type BucketResolvedValues_FieldPathSelector int32

const (
	BucketResolvedValues_FieldPathSelectorKey    BucketResolvedValues_FieldPathSelector = 0
	BucketResolvedValues_FieldPathSelectorValues BucketResolvedValues_FieldPathSelector = 1
)

func (s BucketResolvedValues_FieldPathSelector) String() string {
	switch s {
	case BucketResolvedValues_FieldPathSelectorKey:
		return "key"
	case BucketResolvedValues_FieldPathSelectorValues:
		return "values"
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", s))
	}
}

func BuildBucketResolvedValues_FieldPath(fp gotenobject.RawFieldPath) (BucketResolvedValues_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Bucket_ResolvedValues")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "key":
			return &BucketResolvedValues_FieldTerminalPath{selector: BucketResolvedValues_FieldPathSelectorKey}, nil
		case "values":
			return &BucketResolvedValues_FieldTerminalPath{selector: BucketResolvedValues_FieldPathSelectorValues}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Bucket_ResolvedValues", fp)
}

func ParseBucketResolvedValues_FieldPath(rawField string) (BucketResolvedValues_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBucketResolvedValues_FieldPath(fp)
}

func MustParseBucketResolvedValues_FieldPath(rawField string) BucketResolvedValues_FieldPath {
	fp, err := ParseBucketResolvedValues_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BucketResolvedValues_FieldTerminalPath struct {
	selector BucketResolvedValues_FieldPathSelector
}

var _ BucketResolvedValues_FieldPath = (*BucketResolvedValues_FieldTerminalPath)(nil)

func (fp *BucketResolvedValues_FieldTerminalPath) Selector() BucketResolvedValues_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BucketResolvedValues_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BucketResolvedValues_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Bucket_ResolvedValues
func (fp *BucketResolvedValues_FieldTerminalPath) Get(source *Bucket_ResolvedValues) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BucketResolvedValues_FieldPathSelectorKey:
			values = append(values, source.Key)
		case BucketResolvedValues_FieldPathSelectorValues:
			for _, value := range source.GetValues() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fp.selector))
		}
	}
	return
}

func (fp *BucketResolvedValues_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Bucket_ResolvedValues))
}

// GetSingle returns value pointed by specific field of from source Bucket_ResolvedValues
func (fp *BucketResolvedValues_FieldTerminalPath) GetSingle(source *Bucket_ResolvedValues) (interface{}, bool) {
	switch fp.selector {
	case BucketResolvedValues_FieldPathSelectorKey:
		return source.GetKey(), source != nil
	case BucketResolvedValues_FieldPathSelectorValues:
		res := source.GetValues()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fp.selector))
	}
}

func (fp *BucketResolvedValues_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Bucket_ResolvedValues))
}

// GetDefault returns a default value of the field type
func (fp *BucketResolvedValues_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BucketResolvedValues_FieldPathSelectorKey:
		return int64(0)
	case BucketResolvedValues_FieldPathSelectorValues:
		return ([]int64)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fp.selector))
	}
}

func (fp *BucketResolvedValues_FieldTerminalPath) ClearValue(item *Bucket_ResolvedValues) {
	if item != nil {
		switch fp.selector {
		case BucketResolvedValues_FieldPathSelectorKey:
			item.Key = int64(0)
		case BucketResolvedValues_FieldPathSelectorValues:
			item.Values = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fp.selector))
		}
	}
}

func (fp *BucketResolvedValues_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Bucket_ResolvedValues))
}

// IsLeaf - whether field path is holds simple value
func (fp *BucketResolvedValues_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == BucketResolvedValues_FieldPathSelectorKey ||
		fp.selector == BucketResolvedValues_FieldPathSelectorValues
}

func (fp *BucketResolvedValues_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *BucketResolvedValues_FieldTerminalPath) WithIValue(value interface{}) BucketResolvedValues_FieldPathValue {
	switch fp.selector {
	case BucketResolvedValues_FieldPathSelectorKey:
		return &BucketResolvedValues_FieldTerminalPathValue{BucketResolvedValues_FieldTerminalPath: *fp, value: value.(int64)}
	case BucketResolvedValues_FieldPathSelectorValues:
		return &BucketResolvedValues_FieldTerminalPathValue{BucketResolvedValues_FieldTerminalPath: *fp, value: value.([]int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fp.selector))
	}
}

func (fp *BucketResolvedValues_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BucketResolvedValues_FieldTerminalPath) WithIArrayOfValues(values interface{}) BucketResolvedValues_FieldPathArrayOfValues {
	fpaov := &BucketResolvedValues_FieldTerminalPathArrayOfValues{BucketResolvedValues_FieldTerminalPath: *fp}
	switch fp.selector {
	case BucketResolvedValues_FieldPathSelectorKey:
		return &BucketResolvedValues_FieldTerminalPathArrayOfValues{BucketResolvedValues_FieldTerminalPath: *fp, values: values.([]int64)}
	case BucketResolvedValues_FieldPathSelectorValues:
		return &BucketResolvedValues_FieldTerminalPathArrayOfValues{BucketResolvedValues_FieldTerminalPath: *fp, values: values.([][]int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fp.selector))
	}
	return fpaov
}

func (fp *BucketResolvedValues_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BucketResolvedValues_FieldTerminalPath) WithIArrayItemValue(value interface{}) BucketResolvedValues_FieldPathArrayItemValue {
	switch fp.selector {
	case BucketResolvedValues_FieldPathSelectorValues:
		return &BucketResolvedValues_FieldTerminalPathArrayItemValue{BucketResolvedValues_FieldTerminalPath: *fp, value: value.(int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fp.selector))
	}
}

func (fp *BucketResolvedValues_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// BucketResolvedValues_FieldPathValue allows storing values for ResolvedValues fields according to their type
type BucketResolvedValues_FieldPathValue interface {
	BucketResolvedValues_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Bucket_ResolvedValues)
	CompareWith(*Bucket_ResolvedValues) (cmp int, comparable bool)
}

func ParseBucketResolvedValues_FieldPathValue(pathStr, valueStr string) (BucketResolvedValues_FieldPathValue, error) {
	fp, err := ParseBucketResolvedValues_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResolvedValues field path value from %s: %v", valueStr, err)
	}
	return fpv.(BucketResolvedValues_FieldPathValue), nil
}

func MustParseBucketResolvedValues_FieldPathValue(pathStr, valueStr string) BucketResolvedValues_FieldPathValue {
	fpv, err := ParseBucketResolvedValues_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BucketResolvedValues_FieldTerminalPathValue struct {
	BucketResolvedValues_FieldTerminalPath
	value interface{}
}

var _ BucketResolvedValues_FieldPathValue = (*BucketResolvedValues_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ResolvedValues' as interface{}
func (fpv *BucketResolvedValues_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BucketResolvedValues_FieldTerminalPathValue) AsKeyValue() (int64, bool) {
	res, ok := fpv.value.(int64)
	return res, ok
}
func (fpv *BucketResolvedValues_FieldTerminalPathValue) AsValuesValue() ([]int64, bool) {
	res, ok := fpv.value.([]int64)
	return res, ok
}

// SetTo stores value for selected field for object ResolvedValues
func (fpv *BucketResolvedValues_FieldTerminalPathValue) SetTo(target **Bucket_ResolvedValues) {
	if *target == nil {
		*target = new(Bucket_ResolvedValues)
	}
	switch fpv.selector {
	case BucketResolvedValues_FieldPathSelectorKey:
		(*target).Key = fpv.value.(int64)
	case BucketResolvedValues_FieldPathSelectorValues:
		(*target).Values = fpv.value.([]int64)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fpv.selector))
	}
}

func (fpv *BucketResolvedValues_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Bucket_ResolvedValues)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BucketResolvedValues_FieldTerminalPathValue' with the value under path in 'Bucket_ResolvedValues'.
func (fpv *BucketResolvedValues_FieldTerminalPathValue) CompareWith(source *Bucket_ResolvedValues) (int, bool) {
	switch fpv.selector {
	case BucketResolvedValues_FieldPathSelectorKey:
		leftValue := fpv.value.(int64)
		rightValue := source.GetKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case BucketResolvedValues_FieldPathSelectorValues:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedValues: %d", fpv.selector))
	}
}

func (fpv *BucketResolvedValues_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Bucket_ResolvedValues))
}

// BucketResolvedValues_FieldPathArrayItemValue allows storing single item in Path-specific values for ResolvedValues according to their type
// Present only for array (repeated) types.
type BucketResolvedValues_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BucketResolvedValues_FieldPath
	ContainsValue(*Bucket_ResolvedValues) bool
}

// ParseBucketResolvedValues_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBucketResolvedValues_FieldPathArrayItemValue(pathStr, valueStr string) (BucketResolvedValues_FieldPathArrayItemValue, error) {
	fp, err := ParseBucketResolvedValues_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResolvedValues field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BucketResolvedValues_FieldPathArrayItemValue), nil
}

func MustParseBucketResolvedValues_FieldPathArrayItemValue(pathStr, valueStr string) BucketResolvedValues_FieldPathArrayItemValue {
	fpaiv, err := ParseBucketResolvedValues_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BucketResolvedValues_FieldTerminalPathArrayItemValue struct {
	BucketResolvedValues_FieldTerminalPath
	value interface{}
}

var _ BucketResolvedValues_FieldPathArrayItemValue = (*BucketResolvedValues_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Bucket_ResolvedValues as interface{}
func (fpaiv *BucketResolvedValues_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *BucketResolvedValues_FieldTerminalPathArrayItemValue) AsValuesItemValue() (int64, bool) {
	res, ok := fpaiv.value.(int64)
	return res, ok
}

func (fpaiv *BucketResolvedValues_FieldTerminalPathArrayItemValue) GetSingle(source *Bucket_ResolvedValues) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BucketResolvedValues_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Bucket_ResolvedValues))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ResolvedValues'
func (fpaiv *BucketResolvedValues_FieldTerminalPathArrayItemValue) ContainsValue(source *Bucket_ResolvedValues) bool {
	slice := fpaiv.BucketResolvedValues_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// BucketResolvedValues_FieldPathArrayOfValues allows storing slice of values for ResolvedValues fields according to their type
type BucketResolvedValues_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BucketResolvedValues_FieldPath
}

func ParseBucketResolvedValues_FieldPathArrayOfValues(pathStr, valuesStr string) (BucketResolvedValues_FieldPathArrayOfValues, error) {
	fp, err := ParseBucketResolvedValues_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResolvedValues field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BucketResolvedValues_FieldPathArrayOfValues), nil
}

func MustParseBucketResolvedValues_FieldPathArrayOfValues(pathStr, valuesStr string) BucketResolvedValues_FieldPathArrayOfValues {
	fpaov, err := ParseBucketResolvedValues_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BucketResolvedValues_FieldTerminalPathArrayOfValues struct {
	BucketResolvedValues_FieldTerminalPath
	values interface{}
}

var _ BucketResolvedValues_FieldPathArrayOfValues = (*BucketResolvedValues_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BucketResolvedValues_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BucketResolvedValues_FieldPathSelectorKey:
		for _, v := range fpaov.values.([]int64) {
			values = append(values, v)
		}
	case BucketResolvedValues_FieldPathSelectorValues:
		for _, v := range fpaov.values.([][]int64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BucketResolvedValues_FieldTerminalPathArrayOfValues) AsKeyArrayOfValues() ([]int64, bool) {
	res, ok := fpaov.values.([]int64)
	return res, ok
}
func (fpaov *BucketResolvedValues_FieldTerminalPathArrayOfValues) AsValuesArrayOfValues() ([][]int64, bool) {
	res, ok := fpaov.values.([][]int64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BucketResolvedKeysWithValues_FieldPath interface {
	gotenobject.FieldPath
	Selector() BucketResolvedKeysWithValues_FieldPathSelector
	Get(source *Bucket_ResolvedKeysWithValues) []interface{}
	GetSingle(source *Bucket_ResolvedKeysWithValues) (interface{}, bool)
	ClearValue(item *Bucket_ResolvedKeysWithValues)

	// Those methods build corresponding BucketResolvedKeysWithValues_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BucketResolvedKeysWithValues_FieldPathValue
	WithIArrayOfValues(values interface{}) BucketResolvedKeysWithValues_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BucketResolvedKeysWithValues_FieldPathArrayItemValue
}

type BucketResolvedKeysWithValues_FieldPathSelector int32

const (
	BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs BucketResolvedKeysWithValues_FieldPathSelector = 0
)

func (s BucketResolvedKeysWithValues_FieldPathSelector) String() string {
	switch s {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		return "resolved_kvs"
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", s))
	}
}

func BuildBucketResolvedKeysWithValues_FieldPath(fp gotenobject.RawFieldPath) (BucketResolvedKeysWithValues_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Bucket_ResolvedKeysWithValues")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "resolved_kvs", "resolvedKvs", "resolved-kvs":
			return &BucketResolvedKeysWithValues_FieldTerminalPath{selector: BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs}, nil
		}
	} else {
		switch fp[0] {
		case "resolved_kvs", "resolvedKvs", "resolved-kvs":
			if subpath, err := BuildBucketResolvedValues_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &BucketResolvedKeysWithValues_FieldSubPath{selector: BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Bucket_ResolvedKeysWithValues", fp)
}

func ParseBucketResolvedKeysWithValues_FieldPath(rawField string) (BucketResolvedKeysWithValues_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBucketResolvedKeysWithValues_FieldPath(fp)
}

func MustParseBucketResolvedKeysWithValues_FieldPath(rawField string) BucketResolvedKeysWithValues_FieldPath {
	fp, err := ParseBucketResolvedKeysWithValues_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BucketResolvedKeysWithValues_FieldTerminalPath struct {
	selector BucketResolvedKeysWithValues_FieldPathSelector
}

var _ BucketResolvedKeysWithValues_FieldPath = (*BucketResolvedKeysWithValues_FieldTerminalPath)(nil)

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) Selector() BucketResolvedKeysWithValues_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Bucket_ResolvedKeysWithValues
func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) Get(source *Bucket_ResolvedKeysWithValues) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
			for _, value := range source.GetResolvedKvs() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fp.selector))
		}
	}
	return
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Bucket_ResolvedKeysWithValues))
}

// GetSingle returns value pointed by specific field of from source Bucket_ResolvedKeysWithValues
func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) GetSingle(source *Bucket_ResolvedKeysWithValues) (interface{}, bool) {
	switch fp.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		res := source.GetResolvedKvs()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fp.selector))
	}
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Bucket_ResolvedKeysWithValues))
}

// GetDefault returns a default value of the field type
func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		return ([]*Bucket_ResolvedValues)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fp.selector))
	}
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) ClearValue(item *Bucket_ResolvedKeysWithValues) {
	if item != nil {
		switch fp.selector {
		case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
			item.ResolvedKvs = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fp.selector))
		}
	}
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Bucket_ResolvedKeysWithValues))
}

// IsLeaf - whether field path is holds simple value
func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) IsLeaf() bool {
	return false
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) WithIValue(value interface{}) BucketResolvedKeysWithValues_FieldPathValue {
	switch fp.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		return &BucketResolvedKeysWithValues_FieldTerminalPathValue{BucketResolvedKeysWithValues_FieldTerminalPath: *fp, value: value.([]*Bucket_ResolvedValues)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fp.selector))
	}
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) WithIArrayOfValues(values interface{}) BucketResolvedKeysWithValues_FieldPathArrayOfValues {
	fpaov := &BucketResolvedKeysWithValues_FieldTerminalPathArrayOfValues{BucketResolvedKeysWithValues_FieldTerminalPath: *fp}
	switch fp.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		return &BucketResolvedKeysWithValues_FieldTerminalPathArrayOfValues{BucketResolvedKeysWithValues_FieldTerminalPath: *fp, values: values.([][]*Bucket_ResolvedValues)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fp.selector))
	}
	return fpaov
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) WithIArrayItemValue(value interface{}) BucketResolvedKeysWithValues_FieldPathArrayItemValue {
	switch fp.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		return &BucketResolvedKeysWithValues_FieldTerminalPathArrayItemValue{BucketResolvedKeysWithValues_FieldTerminalPath: *fp, value: value.(*Bucket_ResolvedValues)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fp.selector))
	}
}

func (fp *BucketResolvedKeysWithValues_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type BucketResolvedKeysWithValues_FieldSubPath struct {
	selector BucketResolvedKeysWithValues_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ BucketResolvedKeysWithValues_FieldPath = (*BucketResolvedKeysWithValues_FieldSubPath)(nil)

func (fps *BucketResolvedKeysWithValues_FieldSubPath) Selector() BucketResolvedKeysWithValues_FieldPathSelector {
	return fps.selector
}
func (fps *BucketResolvedKeysWithValues_FieldSubPath) AsResolvedKvsSubPath() (BucketResolvedValues_FieldPath, bool) {
	res, ok := fps.subPath.(BucketResolvedValues_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *BucketResolvedKeysWithValues_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *BucketResolvedKeysWithValues_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Bucket_ResolvedKeysWithValues
func (fps *BucketResolvedKeysWithValues_FieldSubPath) Get(source *Bucket_ResolvedKeysWithValues) (values []interface{}) {
	switch fps.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		for _, item := range source.GetResolvedKvs() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fps.selector))
	}
	return
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Bucket_ResolvedKeysWithValues))
}

// GetSingle returns value of selected field from source Bucket_ResolvedKeysWithValues
func (fps *BucketResolvedKeysWithValues_FieldSubPath) GetSingle(source *Bucket_ResolvedKeysWithValues) (interface{}, bool) {
	switch fps.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		if len(source.GetResolvedKvs()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetResolvedKvs()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fps.selector))
	}
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Bucket_ResolvedKeysWithValues))
}

// GetDefault returns a default value of the field type
func (fps *BucketResolvedKeysWithValues_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) ClearValue(item *Bucket_ResolvedKeysWithValues) {
	if item != nil {
		switch fps.selector {
		case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
			for _, subItem := range item.ResolvedKvs {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fps.selector))
		}
	}
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Bucket_ResolvedKeysWithValues))
}

// IsLeaf - whether field path is holds simple value
func (fps *BucketResolvedKeysWithValues_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&BucketResolvedKeysWithValues_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) WithIValue(value interface{}) BucketResolvedKeysWithValues_FieldPathValue {
	return &BucketResolvedKeysWithValues_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) WithIArrayOfValues(values interface{}) BucketResolvedKeysWithValues_FieldPathArrayOfValues {
	return &BucketResolvedKeysWithValues_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) WithIArrayItemValue(value interface{}) BucketResolvedKeysWithValues_FieldPathArrayItemValue {
	return &BucketResolvedKeysWithValues_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *BucketResolvedKeysWithValues_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// BucketResolvedKeysWithValues_FieldPathValue allows storing values for ResolvedKeysWithValues fields according to their type
type BucketResolvedKeysWithValues_FieldPathValue interface {
	BucketResolvedKeysWithValues_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Bucket_ResolvedKeysWithValues)
	CompareWith(*Bucket_ResolvedKeysWithValues) (cmp int, comparable bool)
}

func ParseBucketResolvedKeysWithValues_FieldPathValue(pathStr, valueStr string) (BucketResolvedKeysWithValues_FieldPathValue, error) {
	fp, err := ParseBucketResolvedKeysWithValues_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResolvedKeysWithValues field path value from %s: %v", valueStr, err)
	}
	return fpv.(BucketResolvedKeysWithValues_FieldPathValue), nil
}

func MustParseBucketResolvedKeysWithValues_FieldPathValue(pathStr, valueStr string) BucketResolvedKeysWithValues_FieldPathValue {
	fpv, err := ParseBucketResolvedKeysWithValues_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BucketResolvedKeysWithValues_FieldTerminalPathValue struct {
	BucketResolvedKeysWithValues_FieldTerminalPath
	value interface{}
}

var _ BucketResolvedKeysWithValues_FieldPathValue = (*BucketResolvedKeysWithValues_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ResolvedKeysWithValues' as interface{}
func (fpv *BucketResolvedKeysWithValues_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BucketResolvedKeysWithValues_FieldTerminalPathValue) AsResolvedKvsValue() ([]*Bucket_ResolvedValues, bool) {
	res, ok := fpv.value.([]*Bucket_ResolvedValues)
	return res, ok
}

// SetTo stores value for selected field for object ResolvedKeysWithValues
func (fpv *BucketResolvedKeysWithValues_FieldTerminalPathValue) SetTo(target **Bucket_ResolvedKeysWithValues) {
	if *target == nil {
		*target = new(Bucket_ResolvedKeysWithValues)
	}
	switch fpv.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		(*target).ResolvedKvs = fpv.value.([]*Bucket_ResolvedValues)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fpv.selector))
	}
}

func (fpv *BucketResolvedKeysWithValues_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Bucket_ResolvedKeysWithValues)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BucketResolvedKeysWithValues_FieldTerminalPathValue' with the value under path in 'Bucket_ResolvedKeysWithValues'.
func (fpv *BucketResolvedKeysWithValues_FieldTerminalPathValue) CompareWith(source *Bucket_ResolvedKeysWithValues) (int, bool) {
	switch fpv.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fpv.selector))
	}
}

func (fpv *BucketResolvedKeysWithValues_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Bucket_ResolvedKeysWithValues))
}

type BucketResolvedKeysWithValues_FieldSubPathValue struct {
	BucketResolvedKeysWithValues_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ BucketResolvedKeysWithValues_FieldPathValue = (*BucketResolvedKeysWithValues_FieldSubPathValue)(nil)

func (fpvs *BucketResolvedKeysWithValues_FieldSubPathValue) AsResolvedKvsPathValue() (BucketResolvedValues_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(BucketResolvedValues_FieldPathValue)
	return res, ok
}

func (fpvs *BucketResolvedKeysWithValues_FieldSubPathValue) SetTo(target **Bucket_ResolvedKeysWithValues) {
	if *target == nil {
		*target = new(Bucket_ResolvedKeysWithValues)
	}
	switch fpvs.Selector() {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fpvs.Selector()))
	}
}

func (fpvs *BucketResolvedKeysWithValues_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Bucket_ResolvedKeysWithValues)
	fpvs.SetTo(&typedObject)
}

func (fpvs *BucketResolvedKeysWithValues_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *BucketResolvedKeysWithValues_FieldSubPathValue) CompareWith(source *Bucket_ResolvedKeysWithValues) (int, bool) {
	switch fpvs.Selector() {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fpvs.Selector()))
	}
}

func (fpvs *BucketResolvedKeysWithValues_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Bucket_ResolvedKeysWithValues))
}

// BucketResolvedKeysWithValues_FieldPathArrayItemValue allows storing single item in Path-specific values for ResolvedKeysWithValues according to their type
// Present only for array (repeated) types.
type BucketResolvedKeysWithValues_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BucketResolvedKeysWithValues_FieldPath
	ContainsValue(*Bucket_ResolvedKeysWithValues) bool
}

// ParseBucketResolvedKeysWithValues_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBucketResolvedKeysWithValues_FieldPathArrayItemValue(pathStr, valueStr string) (BucketResolvedKeysWithValues_FieldPathArrayItemValue, error) {
	fp, err := ParseBucketResolvedKeysWithValues_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResolvedKeysWithValues field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BucketResolvedKeysWithValues_FieldPathArrayItemValue), nil
}

func MustParseBucketResolvedKeysWithValues_FieldPathArrayItemValue(pathStr, valueStr string) BucketResolvedKeysWithValues_FieldPathArrayItemValue {
	fpaiv, err := ParseBucketResolvedKeysWithValues_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BucketResolvedKeysWithValues_FieldTerminalPathArrayItemValue struct {
	BucketResolvedKeysWithValues_FieldTerminalPath
	value interface{}
}

var _ BucketResolvedKeysWithValues_FieldPathArrayItemValue = (*BucketResolvedKeysWithValues_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Bucket_ResolvedKeysWithValues as interface{}
func (fpaiv *BucketResolvedKeysWithValues_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *BucketResolvedKeysWithValues_FieldTerminalPathArrayItemValue) AsResolvedKvsItemValue() (*Bucket_ResolvedValues, bool) {
	res, ok := fpaiv.value.(*Bucket_ResolvedValues)
	return res, ok
}

func (fpaiv *BucketResolvedKeysWithValues_FieldTerminalPathArrayItemValue) GetSingle(source *Bucket_ResolvedKeysWithValues) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BucketResolvedKeysWithValues_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Bucket_ResolvedKeysWithValues))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ResolvedKeysWithValues'
func (fpaiv *BucketResolvedKeysWithValues_FieldTerminalPathArrayItemValue) ContainsValue(source *Bucket_ResolvedKeysWithValues) bool {
	slice := fpaiv.BucketResolvedKeysWithValues_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type BucketResolvedKeysWithValues_FieldSubPathArrayItemValue struct {
	BucketResolvedKeysWithValues_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *BucketResolvedKeysWithValues_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *BucketResolvedKeysWithValues_FieldSubPathArrayItemValue) AsResolvedKvsPathItemValue() (BucketResolvedValues_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(BucketResolvedValues_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ResolvedKeysWithValues'
func (fpaivs *BucketResolvedKeysWithValues_FieldSubPathArrayItemValue) ContainsValue(source *Bucket_ResolvedKeysWithValues) bool {
	switch fpaivs.Selector() {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_ResolvedKeysWithValues: %d", fpaivs.Selector()))
	}
}

// BucketResolvedKeysWithValues_FieldPathArrayOfValues allows storing slice of values for ResolvedKeysWithValues fields according to their type
type BucketResolvedKeysWithValues_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BucketResolvedKeysWithValues_FieldPath
}

func ParseBucketResolvedKeysWithValues_FieldPathArrayOfValues(pathStr, valuesStr string) (BucketResolvedKeysWithValues_FieldPathArrayOfValues, error) {
	fp, err := ParseBucketResolvedKeysWithValues_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResolvedKeysWithValues field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BucketResolvedKeysWithValues_FieldPathArrayOfValues), nil
}

func MustParseBucketResolvedKeysWithValues_FieldPathArrayOfValues(pathStr, valuesStr string) BucketResolvedKeysWithValues_FieldPathArrayOfValues {
	fpaov, err := ParseBucketResolvedKeysWithValues_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BucketResolvedKeysWithValues_FieldTerminalPathArrayOfValues struct {
	BucketResolvedKeysWithValues_FieldTerminalPath
	values interface{}
}

var _ BucketResolvedKeysWithValues_FieldPathArrayOfValues = (*BucketResolvedKeysWithValues_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BucketResolvedKeysWithValues_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BucketResolvedKeysWithValues_FieldPathSelectorResolvedKvs:
		for _, v := range fpaov.values.([][]*Bucket_ResolvedValues) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BucketResolvedKeysWithValues_FieldTerminalPathArrayOfValues) AsResolvedKvsArrayOfValues() ([][]*Bucket_ResolvedValues, bool) {
	res, ok := fpaov.values.([][]*Bucket_ResolvedValues)
	return res, ok
}

type BucketResolvedKeysWithValues_FieldSubPathArrayOfValues struct {
	BucketResolvedKeysWithValues_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ BucketResolvedKeysWithValues_FieldPathArrayOfValues = (*BucketResolvedKeysWithValues_FieldSubPathArrayOfValues)(nil)

func (fpsaov *BucketResolvedKeysWithValues_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *BucketResolvedKeysWithValues_FieldSubPathArrayOfValues) AsResolvedKvsPathArrayOfValues() (BucketResolvedValues_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(BucketResolvedValues_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BucketRequiredTypedLabels_FieldPath interface {
	gotenobject.FieldPath
	Selector() BucketRequiredTypedLabels_FieldPathSelector
	Get(source *Bucket_RequiredTypedLabels) []interface{}
	GetSingle(source *Bucket_RequiredTypedLabels) (interface{}, bool)
	ClearValue(item *Bucket_RequiredTypedLabels)

	// Those methods build corresponding BucketRequiredTypedLabels_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BucketRequiredTypedLabels_FieldPathValue
	WithIArrayOfValues(values interface{}) BucketRequiredTypedLabels_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BucketRequiredTypedLabels_FieldPathArrayItemValue
}

type BucketRequiredTypedLabels_FieldPathSelector int32

const (
	BucketRequiredTypedLabels_FieldPathSelectorTypes  BucketRequiredTypedLabels_FieldPathSelector = 0
	BucketRequiredTypedLabels_FieldPathSelectorLabels BucketRequiredTypedLabels_FieldPathSelector = 1
)

func (s BucketRequiredTypedLabels_FieldPathSelector) String() string {
	switch s {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		return "types"
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return "labels"
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", s))
	}
}

func BuildBucketRequiredTypedLabels_FieldPath(fp gotenobject.RawFieldPath) (BucketRequiredTypedLabels_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Bucket_RequiredTypedLabels")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "types":
			return &BucketRequiredTypedLabels_FieldTerminalPath{selector: BucketRequiredTypedLabels_FieldPathSelectorTypes}, nil
		case "labels":
			return &BucketRequiredTypedLabels_FieldTerminalPath{selector: BucketRequiredTypedLabels_FieldPathSelectorLabels}, nil
		}
	} else {
		switch fp[0] {
		case "labels":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object Bucket_RequiredTypedLabels)", fp)
			}
			return &BucketRequiredTypedLabels_FieldPathMap{selector: BucketRequiredTypedLabels_FieldPathSelectorLabels, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Bucket_RequiredTypedLabels", fp)
}

func ParseBucketRequiredTypedLabels_FieldPath(rawField string) (BucketRequiredTypedLabels_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBucketRequiredTypedLabels_FieldPath(fp)
}

func MustParseBucketRequiredTypedLabels_FieldPath(rawField string) BucketRequiredTypedLabels_FieldPath {
	fp, err := ParseBucketRequiredTypedLabels_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BucketRequiredTypedLabels_FieldTerminalPath struct {
	selector BucketRequiredTypedLabels_FieldPathSelector
}

var _ BucketRequiredTypedLabels_FieldPath = (*BucketRequiredTypedLabels_FieldTerminalPath)(nil)

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) Selector() BucketRequiredTypedLabels_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BucketRequiredTypedLabels_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BucketRequiredTypedLabels_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Bucket_RequiredTypedLabels
func (fp *BucketRequiredTypedLabels_FieldTerminalPath) Get(source *Bucket_RequiredTypedLabels) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BucketRequiredTypedLabels_FieldPathSelectorTypes:
			for _, value := range source.GetTypes() {
				values = append(values, value)
			}
		case BucketRequiredTypedLabels_FieldPathSelectorLabels:
			if source.Labels != nil {
				values = append(values, source.Labels)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fp.selector))
		}
	}
	return
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Bucket_RequiredTypedLabels))
}

// GetSingle returns value pointed by specific field of from source Bucket_RequiredTypedLabels
func (fp *BucketRequiredTypedLabels_FieldTerminalPath) GetSingle(source *Bucket_RequiredTypedLabels) (interface{}, bool) {
	switch fp.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		res := source.GetTypes()
		return res, res != nil
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		res := source.GetLabels()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fp.selector))
	}
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Bucket_RequiredTypedLabels))
}

// GetDefault returns a default value of the field type
func (fp *BucketRequiredTypedLabels_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		return ([]string)(nil)
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return (map[string]*Bucket_RequiredTypedLabels_Strings)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fp.selector))
	}
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) ClearValue(item *Bucket_RequiredTypedLabels) {
	if item != nil {
		switch fp.selector {
		case BucketRequiredTypedLabels_FieldPathSelectorTypes:
			item.Types = nil
		case BucketRequiredTypedLabels_FieldPathSelectorLabels:
			item.Labels = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fp.selector))
		}
	}
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Bucket_RequiredTypedLabels))
}

// IsLeaf - whether field path is holds simple value
func (fp *BucketRequiredTypedLabels_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == BucketRequiredTypedLabels_FieldPathSelectorTypes
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) WithIValue(value interface{}) BucketRequiredTypedLabels_FieldPathValue {
	switch fp.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		return &BucketRequiredTypedLabels_FieldTerminalPathValue{BucketRequiredTypedLabels_FieldTerminalPath: *fp, value: value.([]string)}
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return &BucketRequiredTypedLabels_FieldTerminalPathValue{BucketRequiredTypedLabels_FieldTerminalPath: *fp, value: value.(map[string]*Bucket_RequiredTypedLabels_Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fp.selector))
	}
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) WithIArrayOfValues(values interface{}) BucketRequiredTypedLabels_FieldPathArrayOfValues {
	fpaov := &BucketRequiredTypedLabels_FieldTerminalPathArrayOfValues{BucketRequiredTypedLabels_FieldTerminalPath: *fp}
	switch fp.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		return &BucketRequiredTypedLabels_FieldTerminalPathArrayOfValues{BucketRequiredTypedLabels_FieldTerminalPath: *fp, values: values.([][]string)}
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return &BucketRequiredTypedLabels_FieldTerminalPathArrayOfValues{BucketRequiredTypedLabels_FieldTerminalPath: *fp, values: values.([]map[string]*Bucket_RequiredTypedLabels_Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fp.selector))
	}
	return fpaov
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) WithIArrayItemValue(value interface{}) BucketRequiredTypedLabels_FieldPathArrayItemValue {
	switch fp.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		return &BucketRequiredTypedLabels_FieldTerminalPathArrayItemValue{BucketRequiredTypedLabels_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fp.selector))
	}
}

func (fp *BucketRequiredTypedLabels_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type BucketRequiredTypedLabels_FieldPathMap struct {
	key      string
	selector BucketRequiredTypedLabels_FieldPathSelector
}

var _ BucketRequiredTypedLabels_FieldPath = (*BucketRequiredTypedLabels_FieldPathMap)(nil)

func (fpm *BucketRequiredTypedLabels_FieldPathMap) Selector() BucketRequiredTypedLabels_FieldPathSelector {
	return fpm.selector
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *BucketRequiredTypedLabels_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *BucketRequiredTypedLabels_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source Bucket_RequiredTypedLabels
func (fpm *BucketRequiredTypedLabels_FieldPathMap) Get(source *Bucket_RequiredTypedLabels) (values []interface{}) {
	switch fpm.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		if value, ok := source.GetLabels()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpm.selector))
	}
	return
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*Bucket_RequiredTypedLabels))
}

// GetSingle returns value by selected field map key from source Bucket_RequiredTypedLabels
func (fpm *BucketRequiredTypedLabels_FieldPathMap) GetSingle(source *Bucket_RequiredTypedLabels) (interface{}, bool) {
	switch fpm.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		res, ok := source.GetLabels()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpm.selector))
	}
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*Bucket_RequiredTypedLabels))
}

// GetDefault returns a default value of the field type
func (fpm *BucketRequiredTypedLabels_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		var v *Bucket_RequiredTypedLabels_Strings
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpm.selector))
	}
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) ClearValue(item *Bucket_RequiredTypedLabels) {
	if item != nil {
		switch fpm.selector {
		case BucketRequiredTypedLabels_FieldPathSelectorLabels:
			delete(item.Labels, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpm.selector))
		}
	}
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*Bucket_RequiredTypedLabels))
}

// IsLeaf - whether field path is holds simple value
func (fpm *BucketRequiredTypedLabels_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpm.selector))
	}
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) WithIValue(value interface{}) BucketRequiredTypedLabels_FieldPathValue {
	switch fpm.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return &BucketRequiredTypedLabels_FieldPathMapValue{BucketRequiredTypedLabels_FieldPathMap: *fpm, value: value.(*Bucket_RequiredTypedLabels_Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpm.selector))
	}
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) WithIArrayOfValues(values interface{}) BucketRequiredTypedLabels_FieldPathArrayOfValues {
	switch fpm.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return &BucketRequiredTypedLabels_FieldPathMapArrayOfValues{BucketRequiredTypedLabels_FieldPathMap: *fpm, values: values.([]*Bucket_RequiredTypedLabels_Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpm.selector))
	}
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) WithIArrayItemValue(value interface{}) BucketRequiredTypedLabels_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *BucketRequiredTypedLabels_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

// BucketRequiredTypedLabels_FieldPathValue allows storing values for RequiredTypedLabels fields according to their type
type BucketRequiredTypedLabels_FieldPathValue interface {
	BucketRequiredTypedLabels_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Bucket_RequiredTypedLabels)
	CompareWith(*Bucket_RequiredTypedLabels) (cmp int, comparable bool)
}

func ParseBucketRequiredTypedLabels_FieldPathValue(pathStr, valueStr string) (BucketRequiredTypedLabels_FieldPathValue, error) {
	fp, err := ParseBucketRequiredTypedLabels_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RequiredTypedLabels field path value from %s: %v", valueStr, err)
	}
	return fpv.(BucketRequiredTypedLabels_FieldPathValue), nil
}

func MustParseBucketRequiredTypedLabels_FieldPathValue(pathStr, valueStr string) BucketRequiredTypedLabels_FieldPathValue {
	fpv, err := ParseBucketRequiredTypedLabels_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BucketRequiredTypedLabels_FieldTerminalPathValue struct {
	BucketRequiredTypedLabels_FieldTerminalPath
	value interface{}
}

var _ BucketRequiredTypedLabels_FieldPathValue = (*BucketRequiredTypedLabels_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'RequiredTypedLabels' as interface{}
func (fpv *BucketRequiredTypedLabels_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BucketRequiredTypedLabels_FieldTerminalPathValue) AsTypesValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *BucketRequiredTypedLabels_FieldTerminalPathValue) AsLabelsValue() (map[string]*Bucket_RequiredTypedLabels_Strings, bool) {
	res, ok := fpv.value.(map[string]*Bucket_RequiredTypedLabels_Strings)
	return res, ok
}

// SetTo stores value for selected field for object RequiredTypedLabels
func (fpv *BucketRequiredTypedLabels_FieldTerminalPathValue) SetTo(target **Bucket_RequiredTypedLabels) {
	if *target == nil {
		*target = new(Bucket_RequiredTypedLabels)
	}
	switch fpv.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		(*target).Types = fpv.value.([]string)
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		(*target).Labels = fpv.value.(map[string]*Bucket_RequiredTypedLabels_Strings)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpv.selector))
	}
}

func (fpv *BucketRequiredTypedLabels_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Bucket_RequiredTypedLabels)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BucketRequiredTypedLabels_FieldTerminalPathValue' with the value under path in 'Bucket_RequiredTypedLabels'.
func (fpv *BucketRequiredTypedLabels_FieldTerminalPathValue) CompareWith(source *Bucket_RequiredTypedLabels) (int, bool) {
	switch fpv.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		return 0, false
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpv.selector))
	}
}

func (fpv *BucketRequiredTypedLabels_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Bucket_RequiredTypedLabels))
}

type BucketRequiredTypedLabels_FieldPathMapValue struct {
	BucketRequiredTypedLabels_FieldPathMap
	value interface{}
}

var _ BucketRequiredTypedLabels_FieldPathValue = (*BucketRequiredTypedLabels_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in RequiredTypedLabels as interface{}
func (fpmv *BucketRequiredTypedLabels_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *BucketRequiredTypedLabels_FieldPathMapValue) AsLabelsElementValue() (*Bucket_RequiredTypedLabels_Strings, bool) {
	res, ok := fpmv.value.(*Bucket_RequiredTypedLabels_Strings)
	return res, ok
}

// SetTo stores value for selected field in RequiredTypedLabels
func (fpmv *BucketRequiredTypedLabels_FieldPathMapValue) SetTo(target **Bucket_RequiredTypedLabels) {
	if *target == nil {
		*target = new(Bucket_RequiredTypedLabels)
	}
	switch fpmv.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		if (*target).Labels == nil {
			(*target).Labels = make(map[string]*Bucket_RequiredTypedLabels_Strings)
		}
		(*target).Labels[fpmv.key] = fpmv.value.(*Bucket_RequiredTypedLabels_Strings)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpmv.selector))
	}
}

func (fpmv *BucketRequiredTypedLabels_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Bucket_RequiredTypedLabels)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BucketRequiredTypedLabels_FieldPathMapValue' with the value under path in 'Bucket_RequiredTypedLabels'.
func (fpmv *BucketRequiredTypedLabels_FieldPathMapValue) CompareWith(source *Bucket_RequiredTypedLabels) (int, bool) {
	switch fpmv.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels: %d", fpmv.selector))
	}
}

func (fpmv *BucketRequiredTypedLabels_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*Bucket_RequiredTypedLabels))
}

// BucketRequiredTypedLabels_FieldPathArrayItemValue allows storing single item in Path-specific values for RequiredTypedLabels according to their type
// Present only for array (repeated) types.
type BucketRequiredTypedLabels_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BucketRequiredTypedLabels_FieldPath
	ContainsValue(*Bucket_RequiredTypedLabels) bool
}

// ParseBucketRequiredTypedLabels_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBucketRequiredTypedLabels_FieldPathArrayItemValue(pathStr, valueStr string) (BucketRequiredTypedLabels_FieldPathArrayItemValue, error) {
	fp, err := ParseBucketRequiredTypedLabels_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RequiredTypedLabels field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BucketRequiredTypedLabels_FieldPathArrayItemValue), nil
}

func MustParseBucketRequiredTypedLabels_FieldPathArrayItemValue(pathStr, valueStr string) BucketRequiredTypedLabels_FieldPathArrayItemValue {
	fpaiv, err := ParseBucketRequiredTypedLabels_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BucketRequiredTypedLabels_FieldTerminalPathArrayItemValue struct {
	BucketRequiredTypedLabels_FieldTerminalPath
	value interface{}
}

var _ BucketRequiredTypedLabels_FieldPathArrayItemValue = (*BucketRequiredTypedLabels_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Bucket_RequiredTypedLabels as interface{}
func (fpaiv *BucketRequiredTypedLabels_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *BucketRequiredTypedLabels_FieldTerminalPathArrayItemValue) AsTypesItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *BucketRequiredTypedLabels_FieldTerminalPathArrayItemValue) GetSingle(source *Bucket_RequiredTypedLabels) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BucketRequiredTypedLabels_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Bucket_RequiredTypedLabels))
}

// Contains returns a boolean indicating if value that is being held is present in given 'RequiredTypedLabels'
func (fpaiv *BucketRequiredTypedLabels_FieldTerminalPathArrayItemValue) ContainsValue(source *Bucket_RequiredTypedLabels) bool {
	slice := fpaiv.BucketRequiredTypedLabels_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// BucketRequiredTypedLabels_FieldPathArrayOfValues allows storing slice of values for RequiredTypedLabels fields according to their type
type BucketRequiredTypedLabels_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BucketRequiredTypedLabels_FieldPath
}

func ParseBucketRequiredTypedLabels_FieldPathArrayOfValues(pathStr, valuesStr string) (BucketRequiredTypedLabels_FieldPathArrayOfValues, error) {
	fp, err := ParseBucketRequiredTypedLabels_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RequiredTypedLabels field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BucketRequiredTypedLabels_FieldPathArrayOfValues), nil
}

func MustParseBucketRequiredTypedLabels_FieldPathArrayOfValues(pathStr, valuesStr string) BucketRequiredTypedLabels_FieldPathArrayOfValues {
	fpaov, err := ParseBucketRequiredTypedLabels_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BucketRequiredTypedLabels_FieldTerminalPathArrayOfValues struct {
	BucketRequiredTypedLabels_FieldTerminalPath
	values interface{}
}

var _ BucketRequiredTypedLabels_FieldPathArrayOfValues = (*BucketRequiredTypedLabels_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BucketRequiredTypedLabels_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorTypes:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		for _, v := range fpaov.values.([]map[string]*Bucket_RequiredTypedLabels_Strings) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BucketRequiredTypedLabels_FieldTerminalPathArrayOfValues) AsTypesArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *BucketRequiredTypedLabels_FieldTerminalPathArrayOfValues) AsLabelsArrayOfValues() ([]map[string]*Bucket_RequiredTypedLabels_Strings, bool) {
	res, ok := fpaov.values.([]map[string]*Bucket_RequiredTypedLabels_Strings)
	return res, ok
}

type BucketRequiredTypedLabels_FieldPathMapArrayOfValues struct {
	BucketRequiredTypedLabels_FieldPathMap
	values interface{}
}

var _ BucketRequiredTypedLabels_FieldPathArrayOfValues = (*BucketRequiredTypedLabels_FieldPathMapArrayOfValues)(nil)

func (fpmaov *BucketRequiredTypedLabels_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case BucketRequiredTypedLabels_FieldPathSelectorLabels:
		for _, v := range fpmaov.values.([]*Bucket_RequiredTypedLabels_Strings) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *BucketRequiredTypedLabels_FieldPathMapArrayOfValues) AsLabelsArrayOfElementValues() ([]*Bucket_RequiredTypedLabels_Strings, bool) {
	res, ok := fpmaov.values.([]*Bucket_RequiredTypedLabels_Strings)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BucketRequiredTypedLabelsStrings_FieldPath interface {
	gotenobject.FieldPath
	Selector() BucketRequiredTypedLabelsStrings_FieldPathSelector
	Get(source *Bucket_RequiredTypedLabels_Strings) []interface{}
	GetSingle(source *Bucket_RequiredTypedLabels_Strings) (interface{}, bool)
	ClearValue(item *Bucket_RequiredTypedLabels_Strings)

	// Those methods build corresponding BucketRequiredTypedLabelsStrings_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BucketRequiredTypedLabelsStrings_FieldPathValue
	WithIArrayOfValues(values interface{}) BucketRequiredTypedLabelsStrings_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BucketRequiredTypedLabelsStrings_FieldPathArrayItemValue
}

type BucketRequiredTypedLabelsStrings_FieldPathSelector int32

const (
	BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings BucketRequiredTypedLabelsStrings_FieldPathSelector = 0
)

func (s BucketRequiredTypedLabelsStrings_FieldPathSelector) String() string {
	switch s {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		return "strings"
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", s))
	}
}

func BuildBucketRequiredTypedLabelsStrings_FieldPath(fp gotenobject.RawFieldPath) (BucketRequiredTypedLabelsStrings_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Bucket_RequiredTypedLabels_Strings")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "strings":
			return &BucketRequiredTypedLabelsStrings_FieldTerminalPath{selector: BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Bucket_RequiredTypedLabels_Strings", fp)
}

func ParseBucketRequiredTypedLabelsStrings_FieldPath(rawField string) (BucketRequiredTypedLabelsStrings_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBucketRequiredTypedLabelsStrings_FieldPath(fp)
}

func MustParseBucketRequiredTypedLabelsStrings_FieldPath(rawField string) BucketRequiredTypedLabelsStrings_FieldPath {
	fp, err := ParseBucketRequiredTypedLabelsStrings_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BucketRequiredTypedLabelsStrings_FieldTerminalPath struct {
	selector BucketRequiredTypedLabelsStrings_FieldPathSelector
}

var _ BucketRequiredTypedLabelsStrings_FieldPath = (*BucketRequiredTypedLabelsStrings_FieldTerminalPath)(nil)

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) Selector() BucketRequiredTypedLabelsStrings_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Bucket_RequiredTypedLabels_Strings
func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) Get(source *Bucket_RequiredTypedLabels_Strings) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
			for _, value := range source.GetStrings() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fp.selector))
		}
	}
	return
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Bucket_RequiredTypedLabels_Strings))
}

// GetSingle returns value pointed by specific field of from source Bucket_RequiredTypedLabels_Strings
func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) GetSingle(source *Bucket_RequiredTypedLabels_Strings) (interface{}, bool) {
	switch fp.selector {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		res := source.GetStrings()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fp.selector))
	}
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Bucket_RequiredTypedLabels_Strings))
}

// GetDefault returns a default value of the field type
func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fp.selector))
	}
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) ClearValue(item *Bucket_RequiredTypedLabels_Strings) {
	if item != nil {
		switch fp.selector {
		case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
			item.Strings = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fp.selector))
		}
	}
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Bucket_RequiredTypedLabels_Strings))
}

// IsLeaf - whether field path is holds simple value
func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) WithIValue(value interface{}) BucketRequiredTypedLabelsStrings_FieldPathValue {
	switch fp.selector {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		return &BucketRequiredTypedLabelsStrings_FieldTerminalPathValue{BucketRequiredTypedLabelsStrings_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fp.selector))
	}
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) WithIArrayOfValues(values interface{}) BucketRequiredTypedLabelsStrings_FieldPathArrayOfValues {
	fpaov := &BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayOfValues{BucketRequiredTypedLabelsStrings_FieldTerminalPath: *fp}
	switch fp.selector {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		return &BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayOfValues{BucketRequiredTypedLabelsStrings_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fp.selector))
	}
	return fpaov
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) WithIArrayItemValue(value interface{}) BucketRequiredTypedLabelsStrings_FieldPathArrayItemValue {
	switch fp.selector {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		return &BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayItemValue{BucketRequiredTypedLabelsStrings_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fp.selector))
	}
}

func (fp *BucketRequiredTypedLabelsStrings_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// BucketRequiredTypedLabelsStrings_FieldPathValue allows storing values for Strings fields according to their type
type BucketRequiredTypedLabelsStrings_FieldPathValue interface {
	BucketRequiredTypedLabelsStrings_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Bucket_RequiredTypedLabels_Strings)
	CompareWith(*Bucket_RequiredTypedLabels_Strings) (cmp int, comparable bool)
}

func ParseBucketRequiredTypedLabelsStrings_FieldPathValue(pathStr, valueStr string) (BucketRequiredTypedLabelsStrings_FieldPathValue, error) {
	fp, err := ParseBucketRequiredTypedLabelsStrings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Strings field path value from %s: %v", valueStr, err)
	}
	return fpv.(BucketRequiredTypedLabelsStrings_FieldPathValue), nil
}

func MustParseBucketRequiredTypedLabelsStrings_FieldPathValue(pathStr, valueStr string) BucketRequiredTypedLabelsStrings_FieldPathValue {
	fpv, err := ParseBucketRequiredTypedLabelsStrings_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BucketRequiredTypedLabelsStrings_FieldTerminalPathValue struct {
	BucketRequiredTypedLabelsStrings_FieldTerminalPath
	value interface{}
}

var _ BucketRequiredTypedLabelsStrings_FieldPathValue = (*BucketRequiredTypedLabelsStrings_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Strings' as interface{}
func (fpv *BucketRequiredTypedLabelsStrings_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BucketRequiredTypedLabelsStrings_FieldTerminalPathValue) AsStringsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object Strings
func (fpv *BucketRequiredTypedLabelsStrings_FieldTerminalPathValue) SetTo(target **Bucket_RequiredTypedLabels_Strings) {
	if *target == nil {
		*target = new(Bucket_RequiredTypedLabels_Strings)
	}
	switch fpv.selector {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		(*target).Strings = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fpv.selector))
	}
}

func (fpv *BucketRequiredTypedLabelsStrings_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Bucket_RequiredTypedLabels_Strings)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BucketRequiredTypedLabelsStrings_FieldTerminalPathValue' with the value under path in 'Bucket_RequiredTypedLabels_Strings'.
func (fpv *BucketRequiredTypedLabelsStrings_FieldTerminalPathValue) CompareWith(source *Bucket_RequiredTypedLabels_Strings) (int, bool) {
	switch fpv.selector {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Bucket_RequiredTypedLabels_Strings: %d", fpv.selector))
	}
}

func (fpv *BucketRequiredTypedLabelsStrings_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Bucket_RequiredTypedLabels_Strings))
}

// BucketRequiredTypedLabelsStrings_FieldPathArrayItemValue allows storing single item in Path-specific values for Strings according to their type
// Present only for array (repeated) types.
type BucketRequiredTypedLabelsStrings_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BucketRequiredTypedLabelsStrings_FieldPath
	ContainsValue(*Bucket_RequiredTypedLabels_Strings) bool
}

// ParseBucketRequiredTypedLabelsStrings_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBucketRequiredTypedLabelsStrings_FieldPathArrayItemValue(pathStr, valueStr string) (BucketRequiredTypedLabelsStrings_FieldPathArrayItemValue, error) {
	fp, err := ParseBucketRequiredTypedLabelsStrings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Strings field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BucketRequiredTypedLabelsStrings_FieldPathArrayItemValue), nil
}

func MustParseBucketRequiredTypedLabelsStrings_FieldPathArrayItemValue(pathStr, valueStr string) BucketRequiredTypedLabelsStrings_FieldPathArrayItemValue {
	fpaiv, err := ParseBucketRequiredTypedLabelsStrings_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayItemValue struct {
	BucketRequiredTypedLabelsStrings_FieldTerminalPath
	value interface{}
}

var _ BucketRequiredTypedLabelsStrings_FieldPathArrayItemValue = (*BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Bucket_RequiredTypedLabels_Strings as interface{}
func (fpaiv *BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayItemValue) AsStringsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayItemValue) GetSingle(source *Bucket_RequiredTypedLabels_Strings) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Bucket_RequiredTypedLabels_Strings))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Strings'
func (fpaiv *BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayItemValue) ContainsValue(source *Bucket_RequiredTypedLabels_Strings) bool {
	slice := fpaiv.BucketRequiredTypedLabelsStrings_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// BucketRequiredTypedLabelsStrings_FieldPathArrayOfValues allows storing slice of values for Strings fields according to their type
type BucketRequiredTypedLabelsStrings_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BucketRequiredTypedLabelsStrings_FieldPath
}

func ParseBucketRequiredTypedLabelsStrings_FieldPathArrayOfValues(pathStr, valuesStr string) (BucketRequiredTypedLabelsStrings_FieldPathArrayOfValues, error) {
	fp, err := ParseBucketRequiredTypedLabelsStrings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Strings field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BucketRequiredTypedLabelsStrings_FieldPathArrayOfValues), nil
}

func MustParseBucketRequiredTypedLabelsStrings_FieldPathArrayOfValues(pathStr, valuesStr string) BucketRequiredTypedLabelsStrings_FieldPathArrayOfValues {
	fpaov, err := ParseBucketRequiredTypedLabelsStrings_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayOfValues struct {
	BucketRequiredTypedLabelsStrings_FieldTerminalPath
	values interface{}
}

var _ BucketRequiredTypedLabelsStrings_FieldPathArrayOfValues = (*BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BucketRequiredTypedLabelsStrings_FieldPathSelectorStrings:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BucketRequiredTypedLabelsStrings_FieldTerminalPathArrayOfValues) AsStringsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
