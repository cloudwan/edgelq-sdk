// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v3/time_serie.proto
// DO NOT EDIT!!!

package time_serie

import (
	"fmt"
	"sort"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	monitoring_common "github.com/cloudwan/edgelq-sdk/monitoring/common/v3"
	metric_descriptor "github.com/cloudwan/edgelq-sdk/monitoring/resources/v3/metric_descriptor"
)

// ensure the imports are used
var (
	_ = fmt.Stringer(nil)
	_ = sort.Interface(nil)

	_ = proto.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldPath(nil)
)

// make sure we're using proto imports
var (
	_ = &monitoring_common.LabelDescriptor{}
	_ = &metric_descriptor.MetricDescriptor{}
)

func (o *Point) GotenObjectExt() {}

func (o *Point) MakeFullFieldMask() *Point_FieldMask {
	return FullPoint_FieldMask()
}

func (o *Point) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullPoint_FieldMask()
}

func (o *Point) MakeDiffFieldMask(other *Point) *Point_FieldMask {
	if o == nil && other == nil {
		return &Point_FieldMask{}
	}
	if o == nil || other == nil {
		return FullPoint_FieldMask()
	}

	res := &Point_FieldMask{}
	{
		subMask := o.GetInterval().MakeDiffFieldMask(other.GetInterval())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &Point_FieldTerminalPath{selector: Point_FieldPathSelectorInterval})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &Point_FieldSubPath{selector: Point_FieldPathSelectorInterval, subPath: subpath})
			}
		}
	}
	{
		subMask := o.GetValue().MakeDiffFieldMask(other.GetValue())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &Point_FieldTerminalPath{selector: Point_FieldPathSelectorValue})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &Point_FieldSubPath{selector: Point_FieldPathSelectorValue, subPath: subpath})
			}
		}
	}
	{
		subMask := o.GetAggregation().MakeDiffFieldMask(other.GetAggregation())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &Point_FieldTerminalPath{selector: Point_FieldPathSelectorAggregation})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &Point_FieldSubPath{selector: Point_FieldPathSelectorAggregation, subPath: subpath})
			}
		}
	}
	return res
}

func (o *Point) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*Point))
}

func (o *Point) Clone() *Point {
	if o == nil {
		return nil
	}
	result := &Point{}
	result.Interval = o.Interval.Clone()
	result.Value = o.Value.Clone()
	result.Aggregation = o.Aggregation.Clone()
	return result
}

func (o *Point) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *Point) Merge(source *Point) {
	if source.GetInterval() != nil {
		if o.Interval == nil {
			o.Interval = new(monitoring_common.TimeInterval)
		}
		o.Interval.Merge(source.GetInterval())
	}
	if source.GetValue() != nil {
		if o.Value == nil {
			o.Value = new(monitoring_common.TypedValue)
		}
		o.Value.Merge(source.GetValue())
	}
	if source.GetAggregation() != nil {
		if o.Aggregation == nil {
			o.Aggregation = new(monitoring_common.Aggregation)
		}
		o.Aggregation.Merge(source.GetAggregation())
	}
}

func (o *Point) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*Point))
}

func (o *TimeSerie) GotenObjectExt() {}

func (o *TimeSerie) MakeFullFieldMask() *TimeSerie_FieldMask {
	return FullTimeSerie_FieldMask()
}

func (o *TimeSerie) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullTimeSerie_FieldMask()
}

func (o *TimeSerie) MakeDiffFieldMask(other *TimeSerie) *TimeSerie_FieldMask {
	if o == nil && other == nil {
		return &TimeSerie_FieldMask{}
	}
	if o == nil || other == nil {
		return FullTimeSerie_FieldMask()
	}

	res := &TimeSerie_FieldMask{}
	if string(o.GetKey()) != string(other.GetKey()) {
		res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorKey})
	}
	if o.GetProject() != other.GetProject() {
		res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorProject})
	}
	if o.GetRegion() != other.GetRegion() {
		res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorRegion})
	}
	{
		subMask := o.GetMetric().MakeDiffFieldMask(other.GetMetric())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorMetric})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &TimeSerie_FieldSubPath{selector: TimeSerie_FieldPathSelectorMetric, subPath: subpath})
			}
		}
	}
	{
		subMask := o.GetResource().MakeDiffFieldMask(other.GetResource())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorResource})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &TimeSerie_FieldSubPath{selector: TimeSerie_FieldPathSelectorResource, subPath: subpath})
			}
		}
	}
	{
		subMask := o.GetMetadata().MakeDiffFieldMask(other.GetMetadata())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorMetadata})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &TimeSerie_FieldSubPath{selector: TimeSerie_FieldPathSelectorMetadata, subPath: subpath})
			}
		}
	}
	if o.GetMetricKind() != other.GetMetricKind() {
		res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorMetricKind})
	}
	if o.GetValueType() != other.GetValueType() {
		res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorValueType})
	}

	if len(o.GetPoints()) == len(other.GetPoints()) {
		for i, lValue := range o.GetPoints() {
			rValue := other.GetPoints()[i]
			if len(lValue.MakeDiffFieldMask(rValue).Paths) > 0 {
				res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorPoints})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &TimeSerie_FieldTerminalPath{selector: TimeSerie_FieldPathSelectorPoints})
	}
	return res
}

func (o *TimeSerie) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*TimeSerie))
}

func (o *TimeSerie) Clone() *TimeSerie {
	if o == nil {
		return nil
	}
	result := &TimeSerie{}
	result.Key = make([]byte, len(o.Key))
	for i, bt := range o.Key {
		result.Key[i] = bt
	}
	result.Project = o.Project
	result.Region = o.Region
	result.Metric = o.Metric.Clone()
	result.Resource = o.Resource.Clone()
	result.Metadata = o.Metadata.Clone()
	result.MetricKind = o.MetricKind
	result.ValueType = o.ValueType
	result.Points = make([]*Point, len(o.Points))
	for i, sourceValue := range o.Points {
		result.Points[i] = sourceValue.Clone()
	}
	return result
}

func (o *TimeSerie) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *TimeSerie) Merge(source *TimeSerie) {
	o.Key = make([]byte, len(source.GetKey()))
	for i, bt := range source.GetKey() {
		o.Key[i] = bt
	}
	o.Project = source.GetProject()
	o.Region = source.GetRegion()
	if source.GetMetric() != nil {
		if o.Metric == nil {
			o.Metric = new(monitoring_common.Metric)
		}
		o.Metric.Merge(source.GetMetric())
	}
	if source.GetResource() != nil {
		if o.Resource == nil {
			o.Resource = new(monitoring_common.MonitoredResource)
		}
		o.Resource.Merge(source.GetResource())
	}
	if source.GetMetadata() != nil {
		if o.Metadata == nil {
			o.Metadata = new(monitoring_common.MonitoredResourceMetadata)
		}
		o.Metadata.Merge(source.GetMetadata())
	}
	o.MetricKind = source.GetMetricKind()
	o.ValueType = source.GetValueType()
	for _, sourceValue := range source.GetPoints() {
		exists := false
		for _, currentValue := range o.Points {
			if proto.Equal(sourceValue, currentValue) {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *Point
			if sourceValue != nil {
				newDstElement = new(Point)
				newDstElement.Merge(sourceValue)
			}
			o.Points = append(o.Points, newDstElement)
		}
	}

}

func (o *TimeSerie) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*TimeSerie))
}

func (o *BulkTimeSeries) GotenObjectExt() {}

func (o *BulkTimeSeries) MakeFullFieldMask() *BulkTimeSeries_FieldMask {
	return FullBulkTimeSeries_FieldMask()
}

func (o *BulkTimeSeries) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullBulkTimeSeries_FieldMask()
}

func (o *BulkTimeSeries) MakeDiffFieldMask(other *BulkTimeSeries) *BulkTimeSeries_FieldMask {
	if o == nil && other == nil {
		return &BulkTimeSeries_FieldMask{}
	}
	if o == nil || other == nil {
		return FullBulkTimeSeries_FieldMask()
	}

	res := &BulkTimeSeries_FieldMask{}

	if len(o.GetTimeSeries()) == len(other.GetTimeSeries()) {
		for i, lValue := range o.GetTimeSeries() {
			rValue := other.GetTimeSeries()[i]
			if len(lValue.MakeDiffFieldMask(rValue).Paths) > 0 {
				res.Paths = append(res.Paths, &BulkTimeSeries_FieldTerminalPath{selector: BulkTimeSeries_FieldPathSelectorTimeSeries})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &BulkTimeSeries_FieldTerminalPath{selector: BulkTimeSeries_FieldPathSelectorTimeSeries})
	}
	return res
}

func (o *BulkTimeSeries) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*BulkTimeSeries))
}

func (o *BulkTimeSeries) Clone() *BulkTimeSeries {
	if o == nil {
		return nil
	}
	result := &BulkTimeSeries{}
	result.TimeSeries = make([]*TimeSerie, len(o.TimeSeries))
	for i, sourceValue := range o.TimeSeries {
		result.TimeSeries[i] = sourceValue.Clone()
	}
	return result
}

func (o *BulkTimeSeries) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *BulkTimeSeries) Merge(source *BulkTimeSeries) {
	for _, sourceValue := range source.GetTimeSeries() {
		exists := false
		for _, currentValue := range o.TimeSeries {
			if proto.Equal(sourceValue, currentValue) {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *TimeSerie
			if sourceValue != nil {
				newDstElement = new(TimeSerie)
				newDstElement.Merge(sourceValue)
			}
			o.TimeSeries = append(o.TimeSeries, newDstElement)
		}
	}

}

func (o *BulkTimeSeries) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*BulkTimeSeries))
}
