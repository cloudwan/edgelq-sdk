// Code generated by protoc-gen-goten-object
// File: edgelq/monitoring/proto/v3/common.proto
// DO NOT EDIT!!!

package common

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
	"github.com/cloudwan/goten-sdk/runtime/strcase"
)

// proto imports
import (
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &durationpb.Duration{}
	_ = &timestamppb.Timestamp{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type LabelDescriptor_FieldPath interface {
	gotenobject.FieldPath
	Selector() LabelDescriptor_FieldPathSelector
	Get(source *LabelDescriptor) []interface{}
	GetSingle(source *LabelDescriptor) (interface{}, bool)
	ClearValue(item *LabelDescriptor)

	// Those methods build corresponding LabelDescriptor_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) LabelDescriptor_FieldPathValue
	WithIArrayOfValues(values interface{}) LabelDescriptor_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) LabelDescriptor_FieldPathArrayItemValue
}

type LabelDescriptor_FieldPathSelector int32

const (
	LabelDescriptor_FieldPathSelectorKey          LabelDescriptor_FieldPathSelector = 0
	LabelDescriptor_FieldPathSelectorValueType    LabelDescriptor_FieldPathSelector = 1
	LabelDescriptor_FieldPathSelectorDescription  LabelDescriptor_FieldPathSelector = 2
	LabelDescriptor_FieldPathSelectorDefaultValue LabelDescriptor_FieldPathSelector = 3
	LabelDescriptor_FieldPathSelectorDisabled     LabelDescriptor_FieldPathSelector = 4
)

func (s LabelDescriptor_FieldPathSelector) String() string {
	switch s {
	case LabelDescriptor_FieldPathSelectorKey:
		return "key"
	case LabelDescriptor_FieldPathSelectorValueType:
		return "value_type"
	case LabelDescriptor_FieldPathSelectorDescription:
		return "description"
	case LabelDescriptor_FieldPathSelectorDefaultValue:
		return "default_value"
	case LabelDescriptor_FieldPathSelectorDisabled:
		return "disabled"
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", s))
	}
}

func BuildLabelDescriptor_FieldPath(fp gotenobject.RawFieldPath) (LabelDescriptor_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object LabelDescriptor")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "key":
			return &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorKey}, nil
		case "value_type", "valueType", "value-type":
			return &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorValueType}, nil
		case "description":
			return &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorDescription}, nil
		case "default_value", "defaultValue", "default-value":
			return &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorDefaultValue}, nil
		case "disabled":
			return &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorDisabled}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object LabelDescriptor", fp)
}

func ParseLabelDescriptor_FieldPath(rawField string) (LabelDescriptor_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLabelDescriptor_FieldPath(fp)
}

func MustParseLabelDescriptor_FieldPath(rawField string) LabelDescriptor_FieldPath {
	fp, err := ParseLabelDescriptor_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type LabelDescriptor_FieldTerminalPath struct {
	selector LabelDescriptor_FieldPathSelector
}

var _ LabelDescriptor_FieldPath = (*LabelDescriptor_FieldTerminalPath)(nil)

func (fp *LabelDescriptor_FieldTerminalPath) Selector() LabelDescriptor_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *LabelDescriptor_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *LabelDescriptor_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source LabelDescriptor
func (fp *LabelDescriptor_FieldTerminalPath) Get(source *LabelDescriptor) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case LabelDescriptor_FieldPathSelectorKey:
			values = append(values, source.Key)
		case LabelDescriptor_FieldPathSelectorValueType:
			values = append(values, source.ValueType)
		case LabelDescriptor_FieldPathSelectorDescription:
			values = append(values, source.Description)
		case LabelDescriptor_FieldPathSelectorDefaultValue:
			values = append(values, source.DefaultValue)
		case LabelDescriptor_FieldPathSelectorDisabled:
			values = append(values, source.Disabled)
		default:
			panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
		}
	}
	return
}

func (fp *LabelDescriptor_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*LabelDescriptor))
}

// GetSingle returns value pointed by specific field of from source LabelDescriptor
func (fp *LabelDescriptor_FieldTerminalPath) GetSingle(source *LabelDescriptor) (interface{}, bool) {
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		return source.GetKey(), source != nil
	case LabelDescriptor_FieldPathSelectorValueType:
		return source.GetValueType(), source != nil
	case LabelDescriptor_FieldPathSelectorDescription:
		return source.GetDescription(), source != nil
	case LabelDescriptor_FieldPathSelectorDefaultValue:
		return source.GetDefaultValue(), source != nil
	case LabelDescriptor_FieldPathSelectorDisabled:
		return source.GetDisabled(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*LabelDescriptor))
}

// GetDefault returns a default value of the field type
func (fp *LabelDescriptor_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		return ""
	case LabelDescriptor_FieldPathSelectorValueType:
		return LabelDescriptor_STRING
	case LabelDescriptor_FieldPathSelectorDescription:
		return ""
	case LabelDescriptor_FieldPathSelectorDefaultValue:
		return ""
	case LabelDescriptor_FieldPathSelectorDisabled:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) ClearValue(item *LabelDescriptor) {
	if item != nil {
		switch fp.selector {
		case LabelDescriptor_FieldPathSelectorKey:
			item.Key = ""
		case LabelDescriptor_FieldPathSelectorValueType:
			item.ValueType = LabelDescriptor_STRING
		case LabelDescriptor_FieldPathSelectorDescription:
			item.Description = ""
		case LabelDescriptor_FieldPathSelectorDefaultValue:
			item.DefaultValue = ""
		case LabelDescriptor_FieldPathSelectorDisabled:
			item.Disabled = false
		default:
			panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
		}
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*LabelDescriptor))
}

// IsLeaf - whether field path is holds simple value
func (fp *LabelDescriptor_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == LabelDescriptor_FieldPathSelectorKey ||
		fp.selector == LabelDescriptor_FieldPathSelectorValueType ||
		fp.selector == LabelDescriptor_FieldPathSelectorDescription ||
		fp.selector == LabelDescriptor_FieldPathSelectorDefaultValue ||
		fp.selector == LabelDescriptor_FieldPathSelectorDisabled
}

func (fp *LabelDescriptor_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *LabelDescriptor_FieldTerminalPath) WithIValue(value interface{}) LabelDescriptor_FieldPathValue {
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		return &LabelDescriptor_FieldTerminalPathValue{LabelDescriptor_FieldTerminalPath: *fp, value: value.(string)}
	case LabelDescriptor_FieldPathSelectorValueType:
		return &LabelDescriptor_FieldTerminalPathValue{LabelDescriptor_FieldTerminalPath: *fp, value: value.(LabelDescriptor_ValueType)}
	case LabelDescriptor_FieldPathSelectorDescription:
		return &LabelDescriptor_FieldTerminalPathValue{LabelDescriptor_FieldTerminalPath: *fp, value: value.(string)}
	case LabelDescriptor_FieldPathSelectorDefaultValue:
		return &LabelDescriptor_FieldTerminalPathValue{LabelDescriptor_FieldTerminalPath: *fp, value: value.(string)}
	case LabelDescriptor_FieldPathSelectorDisabled:
		return &LabelDescriptor_FieldTerminalPathValue{LabelDescriptor_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *LabelDescriptor_FieldTerminalPath) WithIArrayOfValues(values interface{}) LabelDescriptor_FieldPathArrayOfValues {
	fpaov := &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp}
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		return &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp, values: values.([]string)}
	case LabelDescriptor_FieldPathSelectorValueType:
		return &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp, values: values.([]LabelDescriptor_ValueType)}
	case LabelDescriptor_FieldPathSelectorDescription:
		return &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp, values: values.([]string)}
	case LabelDescriptor_FieldPathSelectorDefaultValue:
		return &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp, values: values.([]string)}
	case LabelDescriptor_FieldPathSelectorDisabled:
		return &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
	return fpaov
}

func (fp *LabelDescriptor_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *LabelDescriptor_FieldTerminalPath) WithIArrayItemValue(value interface{}) LabelDescriptor_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// LabelDescriptor_FieldPathValue allows storing values for LabelDescriptor fields according to their type
type LabelDescriptor_FieldPathValue interface {
	LabelDescriptor_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **LabelDescriptor)
	CompareWith(*LabelDescriptor) (cmp int, comparable bool)
}

func ParseLabelDescriptor_FieldPathValue(pathStr, valueStr string) (LabelDescriptor_FieldPathValue, error) {
	fp, err := ParseLabelDescriptor_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelDescriptor field path value from %s: %v", valueStr, err)
	}
	return fpv.(LabelDescriptor_FieldPathValue), nil
}

func MustParseLabelDescriptor_FieldPathValue(pathStr, valueStr string) LabelDescriptor_FieldPathValue {
	fpv, err := ParseLabelDescriptor_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type LabelDescriptor_FieldTerminalPathValue struct {
	LabelDescriptor_FieldTerminalPath
	value interface{}
}

var _ LabelDescriptor_FieldPathValue = (*LabelDescriptor_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'LabelDescriptor' as interface{}
func (fpv *LabelDescriptor_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *LabelDescriptor_FieldTerminalPathValue) AsKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *LabelDescriptor_FieldTerminalPathValue) AsValueTypeValue() (LabelDescriptor_ValueType, bool) {
	res, ok := fpv.value.(LabelDescriptor_ValueType)
	return res, ok
}
func (fpv *LabelDescriptor_FieldTerminalPathValue) AsDescriptionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *LabelDescriptor_FieldTerminalPathValue) AsDefaultValueValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *LabelDescriptor_FieldTerminalPathValue) AsDisabledValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object LabelDescriptor
func (fpv *LabelDescriptor_FieldTerminalPathValue) SetTo(target **LabelDescriptor) {
	if *target == nil {
		*target = new(LabelDescriptor)
	}
	switch fpv.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		(*target).Key = fpv.value.(string)
	case LabelDescriptor_FieldPathSelectorValueType:
		(*target).ValueType = fpv.value.(LabelDescriptor_ValueType)
	case LabelDescriptor_FieldPathSelectorDescription:
		(*target).Description = fpv.value.(string)
	case LabelDescriptor_FieldPathSelectorDefaultValue:
		(*target).DefaultValue = fpv.value.(string)
	case LabelDescriptor_FieldPathSelectorDisabled:
		(*target).Disabled = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fpv.selector))
	}
}

func (fpv *LabelDescriptor_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LabelDescriptor)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LabelDescriptor_FieldTerminalPathValue' with the value under path in 'LabelDescriptor'.
func (fpv *LabelDescriptor_FieldTerminalPathValue) CompareWith(source *LabelDescriptor) (int, bool) {
	switch fpv.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case LabelDescriptor_FieldPathSelectorValueType:
		leftValue := fpv.value.(LabelDescriptor_ValueType)
		rightValue := source.GetValueType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case LabelDescriptor_FieldPathSelectorDescription:
		leftValue := fpv.value.(string)
		rightValue := source.GetDescription()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case LabelDescriptor_FieldPathSelectorDefaultValue:
		leftValue := fpv.value.(string)
		rightValue := source.GetDefaultValue()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case LabelDescriptor_FieldPathSelectorDisabled:
		leftValue := fpv.value.(bool)
		rightValue := source.GetDisabled()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fpv.selector))
	}
}

func (fpv *LabelDescriptor_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*LabelDescriptor))
}

// LabelDescriptor_FieldPathArrayItemValue allows storing single item in Path-specific values for LabelDescriptor according to their type
// Present only for array (repeated) types.
type LabelDescriptor_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	LabelDescriptor_FieldPath
	ContainsValue(*LabelDescriptor) bool
}

// ParseLabelDescriptor_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLabelDescriptor_FieldPathArrayItemValue(pathStr, valueStr string) (LabelDescriptor_FieldPathArrayItemValue, error) {
	fp, err := ParseLabelDescriptor_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelDescriptor field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(LabelDescriptor_FieldPathArrayItemValue), nil
}

func MustParseLabelDescriptor_FieldPathArrayItemValue(pathStr, valueStr string) LabelDescriptor_FieldPathArrayItemValue {
	fpaiv, err := ParseLabelDescriptor_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type LabelDescriptor_FieldTerminalPathArrayItemValue struct {
	LabelDescriptor_FieldTerminalPath
	value interface{}
}

var _ LabelDescriptor_FieldPathArrayItemValue = (*LabelDescriptor_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object LabelDescriptor as interface{}
func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) GetSingle(source *LabelDescriptor) (interface{}, bool) {
	return nil, false
}

func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*LabelDescriptor))
}

// Contains returns a boolean indicating if value that is being held is present in given 'LabelDescriptor'
func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) ContainsValue(source *LabelDescriptor) bool {
	slice := fpaiv.LabelDescriptor_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// LabelDescriptor_FieldPathArrayOfValues allows storing slice of values for LabelDescriptor fields according to their type
type LabelDescriptor_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	LabelDescriptor_FieldPath
}

func ParseLabelDescriptor_FieldPathArrayOfValues(pathStr, valuesStr string) (LabelDescriptor_FieldPathArrayOfValues, error) {
	fp, err := ParseLabelDescriptor_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelDescriptor field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(LabelDescriptor_FieldPathArrayOfValues), nil
}

func MustParseLabelDescriptor_FieldPathArrayOfValues(pathStr, valuesStr string) LabelDescriptor_FieldPathArrayOfValues {
	fpaov, err := ParseLabelDescriptor_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type LabelDescriptor_FieldTerminalPathArrayOfValues struct {
	LabelDescriptor_FieldTerminalPath
	values interface{}
}

var _ LabelDescriptor_FieldPathArrayOfValues = (*LabelDescriptor_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case LabelDescriptor_FieldPathSelectorValueType:
		for _, v := range fpaov.values.([]LabelDescriptor_ValueType) {
			values = append(values, v)
		}
	case LabelDescriptor_FieldPathSelectorDescription:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case LabelDescriptor_FieldPathSelectorDefaultValue:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case LabelDescriptor_FieldPathSelectorDisabled:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) AsKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) AsValueTypeArrayOfValues() ([]LabelDescriptor_ValueType, bool) {
	res, ok := fpaov.values.([]LabelDescriptor_ValueType)
	return res, ok
}
func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) AsDescriptionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) AsDefaultValueArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) AsDisabledArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type LabelKeySet_FieldPath interface {
	gotenobject.FieldPath
	Selector() LabelKeySet_FieldPathSelector
	Get(source *LabelKeySet) []interface{}
	GetSingle(source *LabelKeySet) (interface{}, bool)
	ClearValue(item *LabelKeySet)

	// Those methods build corresponding LabelKeySet_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) LabelKeySet_FieldPathValue
	WithIArrayOfValues(values interface{}) LabelKeySet_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) LabelKeySet_FieldPathArrayItemValue
}

type LabelKeySet_FieldPathSelector int32

const (
	LabelKeySet_FieldPathSelectorLabelKeys LabelKeySet_FieldPathSelector = 0
	LabelKeySet_FieldPathSelectorWriteOnly LabelKeySet_FieldPathSelector = 1
)

func (s LabelKeySet_FieldPathSelector) String() string {
	switch s {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return "label_keys"
	case LabelKeySet_FieldPathSelectorWriteOnly:
		return "write_only"
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", s))
	}
}

func BuildLabelKeySet_FieldPath(fp gotenobject.RawFieldPath) (LabelKeySet_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object LabelKeySet")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "label_keys", "labelKeys", "label-keys":
			return &LabelKeySet_FieldTerminalPath{selector: LabelKeySet_FieldPathSelectorLabelKeys}, nil
		case "write_only", "writeOnly", "write-only":
			return &LabelKeySet_FieldTerminalPath{selector: LabelKeySet_FieldPathSelectorWriteOnly}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object LabelKeySet", fp)
}

func ParseLabelKeySet_FieldPath(rawField string) (LabelKeySet_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLabelKeySet_FieldPath(fp)
}

func MustParseLabelKeySet_FieldPath(rawField string) LabelKeySet_FieldPath {
	fp, err := ParseLabelKeySet_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type LabelKeySet_FieldTerminalPath struct {
	selector LabelKeySet_FieldPathSelector
}

var _ LabelKeySet_FieldPath = (*LabelKeySet_FieldTerminalPath)(nil)

func (fp *LabelKeySet_FieldTerminalPath) Selector() LabelKeySet_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *LabelKeySet_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *LabelKeySet_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source LabelKeySet
func (fp *LabelKeySet_FieldTerminalPath) Get(source *LabelKeySet) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case LabelKeySet_FieldPathSelectorLabelKeys:
			for _, value := range source.GetLabelKeys() {
				values = append(values, value)
			}
		case LabelKeySet_FieldPathSelectorWriteOnly:
			values = append(values, source.WriteOnly)
		default:
			panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
		}
	}
	return
}

func (fp *LabelKeySet_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*LabelKeySet))
}

// GetSingle returns value pointed by specific field of from source LabelKeySet
func (fp *LabelKeySet_FieldTerminalPath) GetSingle(source *LabelKeySet) (interface{}, bool) {
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		res := source.GetLabelKeys()
		return res, res != nil
	case LabelKeySet_FieldPathSelectorWriteOnly:
		return source.GetWriteOnly(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
}

func (fp *LabelKeySet_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*LabelKeySet))
}

// GetDefault returns a default value of the field type
func (fp *LabelKeySet_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return ([]string)(nil)
	case LabelKeySet_FieldPathSelectorWriteOnly:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
}

func (fp *LabelKeySet_FieldTerminalPath) ClearValue(item *LabelKeySet) {
	if item != nil {
		switch fp.selector {
		case LabelKeySet_FieldPathSelectorLabelKeys:
			item.LabelKeys = nil
		case LabelKeySet_FieldPathSelectorWriteOnly:
			item.WriteOnly = false
		default:
			panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
		}
	}
}

func (fp *LabelKeySet_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*LabelKeySet))
}

// IsLeaf - whether field path is holds simple value
func (fp *LabelKeySet_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == LabelKeySet_FieldPathSelectorLabelKeys ||
		fp.selector == LabelKeySet_FieldPathSelectorWriteOnly
}

func (fp *LabelKeySet_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *LabelKeySet_FieldTerminalPath) WithIValue(value interface{}) LabelKeySet_FieldPathValue {
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return &LabelKeySet_FieldTerminalPathValue{LabelKeySet_FieldTerminalPath: *fp, value: value.([]string)}
	case LabelKeySet_FieldPathSelectorWriteOnly:
		return &LabelKeySet_FieldTerminalPathValue{LabelKeySet_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
}

func (fp *LabelKeySet_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *LabelKeySet_FieldTerminalPath) WithIArrayOfValues(values interface{}) LabelKeySet_FieldPathArrayOfValues {
	fpaov := &LabelKeySet_FieldTerminalPathArrayOfValues{LabelKeySet_FieldTerminalPath: *fp}
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return &LabelKeySet_FieldTerminalPathArrayOfValues{LabelKeySet_FieldTerminalPath: *fp, values: values.([][]string)}
	case LabelKeySet_FieldPathSelectorWriteOnly:
		return &LabelKeySet_FieldTerminalPathArrayOfValues{LabelKeySet_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
	return fpaov
}

func (fp *LabelKeySet_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *LabelKeySet_FieldTerminalPath) WithIArrayItemValue(value interface{}) LabelKeySet_FieldPathArrayItemValue {
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return &LabelKeySet_FieldTerminalPathArrayItemValue{LabelKeySet_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
}

func (fp *LabelKeySet_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// LabelKeySet_FieldPathValue allows storing values for LabelKeySet fields according to their type
type LabelKeySet_FieldPathValue interface {
	LabelKeySet_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **LabelKeySet)
	CompareWith(*LabelKeySet) (cmp int, comparable bool)
}

func ParseLabelKeySet_FieldPathValue(pathStr, valueStr string) (LabelKeySet_FieldPathValue, error) {
	fp, err := ParseLabelKeySet_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelKeySet field path value from %s: %v", valueStr, err)
	}
	return fpv.(LabelKeySet_FieldPathValue), nil
}

func MustParseLabelKeySet_FieldPathValue(pathStr, valueStr string) LabelKeySet_FieldPathValue {
	fpv, err := ParseLabelKeySet_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type LabelKeySet_FieldTerminalPathValue struct {
	LabelKeySet_FieldTerminalPath
	value interface{}
}

var _ LabelKeySet_FieldPathValue = (*LabelKeySet_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'LabelKeySet' as interface{}
func (fpv *LabelKeySet_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *LabelKeySet_FieldTerminalPathValue) AsLabelKeysValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *LabelKeySet_FieldTerminalPathValue) AsWriteOnlyValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object LabelKeySet
func (fpv *LabelKeySet_FieldTerminalPathValue) SetTo(target **LabelKeySet) {
	if *target == nil {
		*target = new(LabelKeySet)
	}
	switch fpv.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		(*target).LabelKeys = fpv.value.([]string)
	case LabelKeySet_FieldPathSelectorWriteOnly:
		(*target).WriteOnly = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fpv.selector))
	}
}

func (fpv *LabelKeySet_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LabelKeySet)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LabelKeySet_FieldTerminalPathValue' with the value under path in 'LabelKeySet'.
func (fpv *LabelKeySet_FieldTerminalPathValue) CompareWith(source *LabelKeySet) (int, bool) {
	switch fpv.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return 0, false
	case LabelKeySet_FieldPathSelectorWriteOnly:
		leftValue := fpv.value.(bool)
		rightValue := source.GetWriteOnly()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fpv.selector))
	}
}

func (fpv *LabelKeySet_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*LabelKeySet))
}

// LabelKeySet_FieldPathArrayItemValue allows storing single item in Path-specific values for LabelKeySet according to their type
// Present only for array (repeated) types.
type LabelKeySet_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	LabelKeySet_FieldPath
	ContainsValue(*LabelKeySet) bool
}

// ParseLabelKeySet_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLabelKeySet_FieldPathArrayItemValue(pathStr, valueStr string) (LabelKeySet_FieldPathArrayItemValue, error) {
	fp, err := ParseLabelKeySet_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelKeySet field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(LabelKeySet_FieldPathArrayItemValue), nil
}

func MustParseLabelKeySet_FieldPathArrayItemValue(pathStr, valueStr string) LabelKeySet_FieldPathArrayItemValue {
	fpaiv, err := ParseLabelKeySet_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type LabelKeySet_FieldTerminalPathArrayItemValue struct {
	LabelKeySet_FieldTerminalPath
	value interface{}
}

var _ LabelKeySet_FieldPathArrayItemValue = (*LabelKeySet_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object LabelKeySet as interface{}
func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) AsLabelKeysItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) GetSingle(source *LabelKeySet) (interface{}, bool) {
	return nil, false
}

func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*LabelKeySet))
}

// Contains returns a boolean indicating if value that is being held is present in given 'LabelKeySet'
func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) ContainsValue(source *LabelKeySet) bool {
	slice := fpaiv.LabelKeySet_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// LabelKeySet_FieldPathArrayOfValues allows storing slice of values for LabelKeySet fields according to their type
type LabelKeySet_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	LabelKeySet_FieldPath
}

func ParseLabelKeySet_FieldPathArrayOfValues(pathStr, valuesStr string) (LabelKeySet_FieldPathArrayOfValues, error) {
	fp, err := ParseLabelKeySet_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelKeySet field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(LabelKeySet_FieldPathArrayOfValues), nil
}

func MustParseLabelKeySet_FieldPathArrayOfValues(pathStr, valuesStr string) LabelKeySet_FieldPathArrayOfValues {
	fpaov, err := ParseLabelKeySet_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type LabelKeySet_FieldTerminalPathArrayOfValues struct {
	LabelKeySet_FieldTerminalPath
	values interface{}
}

var _ LabelKeySet_FieldPathArrayOfValues = (*LabelKeySet_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *LabelKeySet_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case LabelKeySet_FieldPathSelectorWriteOnly:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *LabelKeySet_FieldTerminalPathArrayOfValues) AsLabelKeysArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *LabelKeySet_FieldTerminalPathArrayOfValues) AsWriteOnlyArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Distribution_FieldPath interface {
	gotenobject.FieldPath
	Selector() Distribution_FieldPathSelector
	Get(source *Distribution) []interface{}
	GetSingle(source *Distribution) (interface{}, bool)
	ClearValue(item *Distribution)

	// Those methods build corresponding Distribution_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Distribution_FieldPathValue
	WithIArrayOfValues(values interface{}) Distribution_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Distribution_FieldPathArrayItemValue
}

type Distribution_FieldPathSelector int32

const (
	Distribution_FieldPathSelectorCount                 Distribution_FieldPathSelector = 0
	Distribution_FieldPathSelectorMean                  Distribution_FieldPathSelector = 1
	Distribution_FieldPathSelectorSumOfSquaredDeviation Distribution_FieldPathSelector = 2
	Distribution_FieldPathSelectorRange                 Distribution_FieldPathSelector = 3
	Distribution_FieldPathSelectorBucketOptions         Distribution_FieldPathSelector = 4
	Distribution_FieldPathSelectorBucketCounts          Distribution_FieldPathSelector = 5
)

func (s Distribution_FieldPathSelector) String() string {
	switch s {
	case Distribution_FieldPathSelectorCount:
		return "count"
	case Distribution_FieldPathSelectorMean:
		return "mean"
	case Distribution_FieldPathSelectorSumOfSquaredDeviation:
		return "sum_of_squared_deviation"
	case Distribution_FieldPathSelectorRange:
		return "range"
	case Distribution_FieldPathSelectorBucketOptions:
		return "bucket_options"
	case Distribution_FieldPathSelectorBucketCounts:
		return "bucket_counts"
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", s))
	}
}

func BuildDistribution_FieldPath(fp gotenobject.RawFieldPath) (Distribution_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Distribution")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "count":
			return &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorCount}, nil
		case "mean":
			return &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorMean}, nil
		case "sum_of_squared_deviation", "sumOfSquaredDeviation", "sum-of-squared-deviation":
			return &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorSumOfSquaredDeviation}, nil
		case "range":
			return &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorRange}, nil
		case "bucket_options", "bucketOptions", "bucket-options":
			return &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorBucketOptions}, nil
		case "bucket_counts", "bucketCounts", "bucket-counts":
			return &Distribution_FieldTerminalPath{selector: Distribution_FieldPathSelectorBucketCounts}, nil
		}
	} else {
		switch fp[0] {
		case "range":
			if subpath, err := BuildDistributionRange_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Distribution_FieldSubPath{selector: Distribution_FieldPathSelectorRange, subPath: subpath}, nil
			}
		case "bucket_options", "bucketOptions", "bucket-options":
			if subpath, err := BuildDistributionBucketOptions_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Distribution_FieldSubPath{selector: Distribution_FieldPathSelectorBucketOptions, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Distribution", fp)
}

func ParseDistribution_FieldPath(rawField string) (Distribution_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDistribution_FieldPath(fp)
}

func MustParseDistribution_FieldPath(rawField string) Distribution_FieldPath {
	fp, err := ParseDistribution_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Distribution_FieldTerminalPath struct {
	selector Distribution_FieldPathSelector
}

var _ Distribution_FieldPath = (*Distribution_FieldTerminalPath)(nil)

func (fp *Distribution_FieldTerminalPath) Selector() Distribution_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Distribution_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Distribution_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Distribution
func (fp *Distribution_FieldTerminalPath) Get(source *Distribution) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Distribution_FieldPathSelectorCount:
			values = append(values, source.Count)
		case Distribution_FieldPathSelectorMean:
			values = append(values, source.Mean)
		case Distribution_FieldPathSelectorSumOfSquaredDeviation:
			values = append(values, source.SumOfSquaredDeviation)
		case Distribution_FieldPathSelectorRange:
			if source.Range != nil {
				values = append(values, source.Range)
			}
		case Distribution_FieldPathSelectorBucketOptions:
			if source.BucketOptions != nil {
				values = append(values, source.BucketOptions)
			}
		case Distribution_FieldPathSelectorBucketCounts:
			for _, value := range source.GetBucketCounts() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution: %d", fp.selector))
		}
	}
	return
}

func (fp *Distribution_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Distribution))
}

// GetSingle returns value pointed by specific field of from source Distribution
func (fp *Distribution_FieldTerminalPath) GetSingle(source *Distribution) (interface{}, bool) {
	switch fp.selector {
	case Distribution_FieldPathSelectorCount:
		return source.GetCount(), source != nil
	case Distribution_FieldPathSelectorMean:
		return source.GetMean(), source != nil
	case Distribution_FieldPathSelectorSumOfSquaredDeviation:
		return source.GetSumOfSquaredDeviation(), source != nil
	case Distribution_FieldPathSelectorRange:
		res := source.GetRange()
		return res, res != nil
	case Distribution_FieldPathSelectorBucketOptions:
		res := source.GetBucketOptions()
		return res, res != nil
	case Distribution_FieldPathSelectorBucketCounts:
		res := source.GetBucketCounts()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fp.selector))
	}
}

func (fp *Distribution_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Distribution))
}

// GetDefault returns a default value of the field type
func (fp *Distribution_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Distribution_FieldPathSelectorCount:
		return int64(0)
	case Distribution_FieldPathSelectorMean:
		return float64(0)
	case Distribution_FieldPathSelectorSumOfSquaredDeviation:
		return float64(0)
	case Distribution_FieldPathSelectorRange:
		return (*Distribution_Range)(nil)
	case Distribution_FieldPathSelectorBucketOptions:
		return (*Distribution_BucketOptions)(nil)
	case Distribution_FieldPathSelectorBucketCounts:
		return ([]int64)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fp.selector))
	}
}

func (fp *Distribution_FieldTerminalPath) ClearValue(item *Distribution) {
	if item != nil {
		switch fp.selector {
		case Distribution_FieldPathSelectorCount:
			item.Count = int64(0)
		case Distribution_FieldPathSelectorMean:
			item.Mean = float64(0)
		case Distribution_FieldPathSelectorSumOfSquaredDeviation:
			item.SumOfSquaredDeviation = float64(0)
		case Distribution_FieldPathSelectorRange:
			item.Range = nil
		case Distribution_FieldPathSelectorBucketOptions:
			item.BucketOptions = nil
		case Distribution_FieldPathSelectorBucketCounts:
			item.BucketCounts = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution: %d", fp.selector))
		}
	}
}

func (fp *Distribution_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Distribution))
}

// IsLeaf - whether field path is holds simple value
func (fp *Distribution_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Distribution_FieldPathSelectorCount ||
		fp.selector == Distribution_FieldPathSelectorMean ||
		fp.selector == Distribution_FieldPathSelectorSumOfSquaredDeviation ||
		fp.selector == Distribution_FieldPathSelectorBucketCounts
}

func (fp *Distribution_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Distribution_FieldTerminalPath) WithIValue(value interface{}) Distribution_FieldPathValue {
	switch fp.selector {
	case Distribution_FieldPathSelectorCount:
		return &Distribution_FieldTerminalPathValue{Distribution_FieldTerminalPath: *fp, value: value.(int64)}
	case Distribution_FieldPathSelectorMean:
		return &Distribution_FieldTerminalPathValue{Distribution_FieldTerminalPath: *fp, value: value.(float64)}
	case Distribution_FieldPathSelectorSumOfSquaredDeviation:
		return &Distribution_FieldTerminalPathValue{Distribution_FieldTerminalPath: *fp, value: value.(float64)}
	case Distribution_FieldPathSelectorRange:
		return &Distribution_FieldTerminalPathValue{Distribution_FieldTerminalPath: *fp, value: value.(*Distribution_Range)}
	case Distribution_FieldPathSelectorBucketOptions:
		return &Distribution_FieldTerminalPathValue{Distribution_FieldTerminalPath: *fp, value: value.(*Distribution_BucketOptions)}
	case Distribution_FieldPathSelectorBucketCounts:
		return &Distribution_FieldTerminalPathValue{Distribution_FieldTerminalPath: *fp, value: value.([]int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fp.selector))
	}
}

func (fp *Distribution_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Distribution_FieldTerminalPath) WithIArrayOfValues(values interface{}) Distribution_FieldPathArrayOfValues {
	fpaov := &Distribution_FieldTerminalPathArrayOfValues{Distribution_FieldTerminalPath: *fp}
	switch fp.selector {
	case Distribution_FieldPathSelectorCount:
		return &Distribution_FieldTerminalPathArrayOfValues{Distribution_FieldTerminalPath: *fp, values: values.([]int64)}
	case Distribution_FieldPathSelectorMean:
		return &Distribution_FieldTerminalPathArrayOfValues{Distribution_FieldTerminalPath: *fp, values: values.([]float64)}
	case Distribution_FieldPathSelectorSumOfSquaredDeviation:
		return &Distribution_FieldTerminalPathArrayOfValues{Distribution_FieldTerminalPath: *fp, values: values.([]float64)}
	case Distribution_FieldPathSelectorRange:
		return &Distribution_FieldTerminalPathArrayOfValues{Distribution_FieldTerminalPath: *fp, values: values.([]*Distribution_Range)}
	case Distribution_FieldPathSelectorBucketOptions:
		return &Distribution_FieldTerminalPathArrayOfValues{Distribution_FieldTerminalPath: *fp, values: values.([]*Distribution_BucketOptions)}
	case Distribution_FieldPathSelectorBucketCounts:
		return &Distribution_FieldTerminalPathArrayOfValues{Distribution_FieldTerminalPath: *fp, values: values.([][]int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fp.selector))
	}
	return fpaov
}

func (fp *Distribution_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Distribution_FieldTerminalPath) WithIArrayItemValue(value interface{}) Distribution_FieldPathArrayItemValue {
	switch fp.selector {
	case Distribution_FieldPathSelectorBucketCounts:
		return &Distribution_FieldTerminalPathArrayItemValue{Distribution_FieldTerminalPath: *fp, value: value.(int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fp.selector))
	}
}

func (fp *Distribution_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type Distribution_FieldSubPath struct {
	selector Distribution_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ Distribution_FieldPath = (*Distribution_FieldSubPath)(nil)

func (fps *Distribution_FieldSubPath) Selector() Distribution_FieldPathSelector {
	return fps.selector
}
func (fps *Distribution_FieldSubPath) AsRangeSubPath() (DistributionRange_FieldPath, bool) {
	res, ok := fps.subPath.(DistributionRange_FieldPath)
	return res, ok
}
func (fps *Distribution_FieldSubPath) AsBucketOptionsSubPath() (DistributionBucketOptions_FieldPath, bool) {
	res, ok := fps.subPath.(DistributionBucketOptions_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *Distribution_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *Distribution_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Distribution
func (fps *Distribution_FieldSubPath) Get(source *Distribution) (values []interface{}) {
	switch fps.selector {
	case Distribution_FieldPathSelectorRange:
		values = append(values, fps.subPath.GetRaw(source.GetRange())...)
	case Distribution_FieldPathSelectorBucketOptions:
		values = append(values, fps.subPath.GetRaw(source.GetBucketOptions())...)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fps.selector))
	}
	return
}

func (fps *Distribution_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Distribution))
}

// GetSingle returns value of selected field from source Distribution
func (fps *Distribution_FieldSubPath) GetSingle(source *Distribution) (interface{}, bool) {
	switch fps.selector {
	case Distribution_FieldPathSelectorRange:
		if source.GetRange() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetRange())
	case Distribution_FieldPathSelectorBucketOptions:
		if source.GetBucketOptions() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetBucketOptions())
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fps.selector))
	}
}

func (fps *Distribution_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Distribution))
}

// GetDefault returns a default value of the field type
func (fps *Distribution_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *Distribution_FieldSubPath) ClearValue(item *Distribution) {
	if item != nil {
		switch fps.selector {
		case Distribution_FieldPathSelectorRange:
			fps.subPath.ClearValueRaw(item.Range)
		case Distribution_FieldPathSelectorBucketOptions:
			fps.subPath.ClearValueRaw(item.BucketOptions)
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution: %d", fps.selector))
		}
	}
}

func (fps *Distribution_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Distribution))
}

// IsLeaf - whether field path is holds simple value
func (fps *Distribution_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *Distribution_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&Distribution_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *Distribution_FieldSubPath) WithIValue(value interface{}) Distribution_FieldPathValue {
	return &Distribution_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *Distribution_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *Distribution_FieldSubPath) WithIArrayOfValues(values interface{}) Distribution_FieldPathArrayOfValues {
	return &Distribution_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *Distribution_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *Distribution_FieldSubPath) WithIArrayItemValue(value interface{}) Distribution_FieldPathArrayItemValue {
	return &Distribution_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *Distribution_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// Distribution_FieldPathValue allows storing values for Distribution fields according to their type
type Distribution_FieldPathValue interface {
	Distribution_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Distribution)
	CompareWith(*Distribution) (cmp int, comparable bool)
}

func ParseDistribution_FieldPathValue(pathStr, valueStr string) (Distribution_FieldPathValue, error) {
	fp, err := ParseDistribution_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Distribution field path value from %s: %v", valueStr, err)
	}
	return fpv.(Distribution_FieldPathValue), nil
}

func MustParseDistribution_FieldPathValue(pathStr, valueStr string) Distribution_FieldPathValue {
	fpv, err := ParseDistribution_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Distribution_FieldTerminalPathValue struct {
	Distribution_FieldTerminalPath
	value interface{}
}

var _ Distribution_FieldPathValue = (*Distribution_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Distribution' as interface{}
func (fpv *Distribution_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Distribution_FieldTerminalPathValue) AsCountValue() (int64, bool) {
	res, ok := fpv.value.(int64)
	return res, ok
}
func (fpv *Distribution_FieldTerminalPathValue) AsMeanValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}
func (fpv *Distribution_FieldTerminalPathValue) AsSumOfSquaredDeviationValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}
func (fpv *Distribution_FieldTerminalPathValue) AsRangeValue() (*Distribution_Range, bool) {
	res, ok := fpv.value.(*Distribution_Range)
	return res, ok
}
func (fpv *Distribution_FieldTerminalPathValue) AsBucketOptionsValue() (*Distribution_BucketOptions, bool) {
	res, ok := fpv.value.(*Distribution_BucketOptions)
	return res, ok
}
func (fpv *Distribution_FieldTerminalPathValue) AsBucketCountsValue() ([]int64, bool) {
	res, ok := fpv.value.([]int64)
	return res, ok
}

// SetTo stores value for selected field for object Distribution
func (fpv *Distribution_FieldTerminalPathValue) SetTo(target **Distribution) {
	if *target == nil {
		*target = new(Distribution)
	}
	switch fpv.selector {
	case Distribution_FieldPathSelectorCount:
		(*target).Count = fpv.value.(int64)
	case Distribution_FieldPathSelectorMean:
		(*target).Mean = fpv.value.(float64)
	case Distribution_FieldPathSelectorSumOfSquaredDeviation:
		(*target).SumOfSquaredDeviation = fpv.value.(float64)
	case Distribution_FieldPathSelectorRange:
		(*target).Range = fpv.value.(*Distribution_Range)
	case Distribution_FieldPathSelectorBucketOptions:
		(*target).BucketOptions = fpv.value.(*Distribution_BucketOptions)
	case Distribution_FieldPathSelectorBucketCounts:
		(*target).BucketCounts = fpv.value.([]int64)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fpv.selector))
	}
}

func (fpv *Distribution_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Distribution_FieldTerminalPathValue' with the value under path in 'Distribution'.
func (fpv *Distribution_FieldTerminalPathValue) CompareWith(source *Distribution) (int, bool) {
	switch fpv.selector {
	case Distribution_FieldPathSelectorCount:
		leftValue := fpv.value.(int64)
		rightValue := source.GetCount()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Distribution_FieldPathSelectorMean:
		leftValue := fpv.value.(float64)
		rightValue := source.GetMean()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Distribution_FieldPathSelectorSumOfSquaredDeviation:
		leftValue := fpv.value.(float64)
		rightValue := source.GetSumOfSquaredDeviation()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Distribution_FieldPathSelectorRange:
		return 0, false
	case Distribution_FieldPathSelectorBucketOptions:
		return 0, false
	case Distribution_FieldPathSelectorBucketCounts:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fpv.selector))
	}
}

func (fpv *Distribution_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Distribution))
}

type Distribution_FieldSubPathValue struct {
	Distribution_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ Distribution_FieldPathValue = (*Distribution_FieldSubPathValue)(nil)

func (fpvs *Distribution_FieldSubPathValue) AsRangePathValue() (DistributionRange_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(DistributionRange_FieldPathValue)
	return res, ok
}
func (fpvs *Distribution_FieldSubPathValue) AsBucketOptionsPathValue() (DistributionBucketOptions_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(DistributionBucketOptions_FieldPathValue)
	return res, ok
}

func (fpvs *Distribution_FieldSubPathValue) SetTo(target **Distribution) {
	if *target == nil {
		*target = new(Distribution)
	}
	switch fpvs.Selector() {
	case Distribution_FieldPathSelectorRange:
		fpvs.subPathValue.(DistributionRange_FieldPathValue).SetTo(&(*target).Range)
	case Distribution_FieldPathSelectorBucketOptions:
		fpvs.subPathValue.(DistributionBucketOptions_FieldPathValue).SetTo(&(*target).BucketOptions)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fpvs.Selector()))
	}
}

func (fpvs *Distribution_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution)
	fpvs.SetTo(&typedObject)
}

func (fpvs *Distribution_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *Distribution_FieldSubPathValue) CompareWith(source *Distribution) (int, bool) {
	switch fpvs.Selector() {
	case Distribution_FieldPathSelectorRange:
		return fpvs.subPathValue.(DistributionRange_FieldPathValue).CompareWith(source.GetRange())
	case Distribution_FieldPathSelectorBucketOptions:
		return fpvs.subPathValue.(DistributionBucketOptions_FieldPathValue).CompareWith(source.GetBucketOptions())
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fpvs.Selector()))
	}
}

func (fpvs *Distribution_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Distribution))
}

// Distribution_FieldPathArrayItemValue allows storing single item in Path-specific values for Distribution according to their type
// Present only for array (repeated) types.
type Distribution_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Distribution_FieldPath
	ContainsValue(*Distribution) bool
}

// ParseDistribution_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDistribution_FieldPathArrayItemValue(pathStr, valueStr string) (Distribution_FieldPathArrayItemValue, error) {
	fp, err := ParseDistribution_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Distribution field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Distribution_FieldPathArrayItemValue), nil
}

func MustParseDistribution_FieldPathArrayItemValue(pathStr, valueStr string) Distribution_FieldPathArrayItemValue {
	fpaiv, err := ParseDistribution_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Distribution_FieldTerminalPathArrayItemValue struct {
	Distribution_FieldTerminalPath
	value interface{}
}

var _ Distribution_FieldPathArrayItemValue = (*Distribution_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Distribution as interface{}
func (fpaiv *Distribution_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Distribution_FieldTerminalPathArrayItemValue) AsBucketCountsItemValue() (int64, bool) {
	res, ok := fpaiv.value.(int64)
	return res, ok
}

func (fpaiv *Distribution_FieldTerminalPathArrayItemValue) GetSingle(source *Distribution) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Distribution_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Distribution))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Distribution'
func (fpaiv *Distribution_FieldTerminalPathArrayItemValue) ContainsValue(source *Distribution) bool {
	slice := fpaiv.Distribution_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type Distribution_FieldSubPathArrayItemValue struct {
	Distribution_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *Distribution_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *Distribution_FieldSubPathArrayItemValue) AsRangePathItemValue() (DistributionRange_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(DistributionRange_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Distribution_FieldSubPathArrayItemValue) AsBucketOptionsPathItemValue() (DistributionBucketOptions_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(DistributionBucketOptions_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'Distribution'
func (fpaivs *Distribution_FieldSubPathArrayItemValue) ContainsValue(source *Distribution) bool {
	switch fpaivs.Selector() {
	case Distribution_FieldPathSelectorRange:
		return fpaivs.subPathItemValue.(DistributionRange_FieldPathArrayItemValue).ContainsValue(source.GetRange())
	case Distribution_FieldPathSelectorBucketOptions:
		return fpaivs.subPathItemValue.(DistributionBucketOptions_FieldPathArrayItemValue).ContainsValue(source.GetBucketOptions())
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution: %d", fpaivs.Selector()))
	}
}

// Distribution_FieldPathArrayOfValues allows storing slice of values for Distribution fields according to their type
type Distribution_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Distribution_FieldPath
}

func ParseDistribution_FieldPathArrayOfValues(pathStr, valuesStr string) (Distribution_FieldPathArrayOfValues, error) {
	fp, err := ParseDistribution_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Distribution field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Distribution_FieldPathArrayOfValues), nil
}

func MustParseDistribution_FieldPathArrayOfValues(pathStr, valuesStr string) Distribution_FieldPathArrayOfValues {
	fpaov, err := ParseDistribution_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Distribution_FieldTerminalPathArrayOfValues struct {
	Distribution_FieldTerminalPath
	values interface{}
}

var _ Distribution_FieldPathArrayOfValues = (*Distribution_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Distribution_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Distribution_FieldPathSelectorCount:
		for _, v := range fpaov.values.([]int64) {
			values = append(values, v)
		}
	case Distribution_FieldPathSelectorMean:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	case Distribution_FieldPathSelectorSumOfSquaredDeviation:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	case Distribution_FieldPathSelectorRange:
		for _, v := range fpaov.values.([]*Distribution_Range) {
			values = append(values, v)
		}
	case Distribution_FieldPathSelectorBucketOptions:
		for _, v := range fpaov.values.([]*Distribution_BucketOptions) {
			values = append(values, v)
		}
	case Distribution_FieldPathSelectorBucketCounts:
		for _, v := range fpaov.values.([][]int64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Distribution_FieldTerminalPathArrayOfValues) AsCountArrayOfValues() ([]int64, bool) {
	res, ok := fpaov.values.([]int64)
	return res, ok
}
func (fpaov *Distribution_FieldTerminalPathArrayOfValues) AsMeanArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}
func (fpaov *Distribution_FieldTerminalPathArrayOfValues) AsSumOfSquaredDeviationArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}
func (fpaov *Distribution_FieldTerminalPathArrayOfValues) AsRangeArrayOfValues() ([]*Distribution_Range, bool) {
	res, ok := fpaov.values.([]*Distribution_Range)
	return res, ok
}
func (fpaov *Distribution_FieldTerminalPathArrayOfValues) AsBucketOptionsArrayOfValues() ([]*Distribution_BucketOptions, bool) {
	res, ok := fpaov.values.([]*Distribution_BucketOptions)
	return res, ok
}
func (fpaov *Distribution_FieldTerminalPathArrayOfValues) AsBucketCountsArrayOfValues() ([][]int64, bool) {
	res, ok := fpaov.values.([][]int64)
	return res, ok
}

type Distribution_FieldSubPathArrayOfValues struct {
	Distribution_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ Distribution_FieldPathArrayOfValues = (*Distribution_FieldSubPathArrayOfValues)(nil)

func (fpsaov *Distribution_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *Distribution_FieldSubPathArrayOfValues) AsRangePathArrayOfValues() (DistributionRange_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(DistributionRange_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Distribution_FieldSubPathArrayOfValues) AsBucketOptionsPathArrayOfValues() (DistributionBucketOptions_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(DistributionBucketOptions_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DistributionRange_FieldPath interface {
	gotenobject.FieldPath
	Selector() DistributionRange_FieldPathSelector
	Get(source *Distribution_Range) []interface{}
	GetSingle(source *Distribution_Range) (interface{}, bool)
	ClearValue(item *Distribution_Range)

	// Those methods build corresponding DistributionRange_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DistributionRange_FieldPathValue
	WithIArrayOfValues(values interface{}) DistributionRange_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DistributionRange_FieldPathArrayItemValue
}

type DistributionRange_FieldPathSelector int32

const (
	DistributionRange_FieldPathSelectorMin DistributionRange_FieldPathSelector = 0
	DistributionRange_FieldPathSelectorMax DistributionRange_FieldPathSelector = 1
)

func (s DistributionRange_FieldPathSelector) String() string {
	switch s {
	case DistributionRange_FieldPathSelectorMin:
		return "min"
	case DistributionRange_FieldPathSelectorMax:
		return "max"
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", s))
	}
}

func BuildDistributionRange_FieldPath(fp gotenobject.RawFieldPath) (DistributionRange_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Distribution_Range")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "min":
			return &DistributionRange_FieldTerminalPath{selector: DistributionRange_FieldPathSelectorMin}, nil
		case "max":
			return &DistributionRange_FieldTerminalPath{selector: DistributionRange_FieldPathSelectorMax}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Distribution_Range", fp)
}

func ParseDistributionRange_FieldPath(rawField string) (DistributionRange_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDistributionRange_FieldPath(fp)
}

func MustParseDistributionRange_FieldPath(rawField string) DistributionRange_FieldPath {
	fp, err := ParseDistributionRange_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DistributionRange_FieldTerminalPath struct {
	selector DistributionRange_FieldPathSelector
}

var _ DistributionRange_FieldPath = (*DistributionRange_FieldTerminalPath)(nil)

func (fp *DistributionRange_FieldTerminalPath) Selector() DistributionRange_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DistributionRange_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DistributionRange_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Distribution_Range
func (fp *DistributionRange_FieldTerminalPath) Get(source *Distribution_Range) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DistributionRange_FieldPathSelectorMin:
			values = append(values, source.Min)
		case DistributionRange_FieldPathSelectorMax:
			values = append(values, source.Max)
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fp.selector))
		}
	}
	return
}

func (fp *DistributionRange_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Distribution_Range))
}

// GetSingle returns value pointed by specific field of from source Distribution_Range
func (fp *DistributionRange_FieldTerminalPath) GetSingle(source *Distribution_Range) (interface{}, bool) {
	switch fp.selector {
	case DistributionRange_FieldPathSelectorMin:
		return source.GetMin(), source != nil
	case DistributionRange_FieldPathSelectorMax:
		return source.GetMax(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fp.selector))
	}
}

func (fp *DistributionRange_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Distribution_Range))
}

// GetDefault returns a default value of the field type
func (fp *DistributionRange_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DistributionRange_FieldPathSelectorMin:
		return float64(0)
	case DistributionRange_FieldPathSelectorMax:
		return float64(0)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fp.selector))
	}
}

func (fp *DistributionRange_FieldTerminalPath) ClearValue(item *Distribution_Range) {
	if item != nil {
		switch fp.selector {
		case DistributionRange_FieldPathSelectorMin:
			item.Min = float64(0)
		case DistributionRange_FieldPathSelectorMax:
			item.Max = float64(0)
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fp.selector))
		}
	}
}

func (fp *DistributionRange_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Distribution_Range))
}

// IsLeaf - whether field path is holds simple value
func (fp *DistributionRange_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DistributionRange_FieldPathSelectorMin ||
		fp.selector == DistributionRange_FieldPathSelectorMax
}

func (fp *DistributionRange_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *DistributionRange_FieldTerminalPath) WithIValue(value interface{}) DistributionRange_FieldPathValue {
	switch fp.selector {
	case DistributionRange_FieldPathSelectorMin:
		return &DistributionRange_FieldTerminalPathValue{DistributionRange_FieldTerminalPath: *fp, value: value.(float64)}
	case DistributionRange_FieldPathSelectorMax:
		return &DistributionRange_FieldTerminalPathValue{DistributionRange_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fp.selector))
	}
}

func (fp *DistributionRange_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DistributionRange_FieldTerminalPath) WithIArrayOfValues(values interface{}) DistributionRange_FieldPathArrayOfValues {
	fpaov := &DistributionRange_FieldTerminalPathArrayOfValues{DistributionRange_FieldTerminalPath: *fp}
	switch fp.selector {
	case DistributionRange_FieldPathSelectorMin:
		return &DistributionRange_FieldTerminalPathArrayOfValues{DistributionRange_FieldTerminalPath: *fp, values: values.([]float64)}
	case DistributionRange_FieldPathSelectorMax:
		return &DistributionRange_FieldTerminalPathArrayOfValues{DistributionRange_FieldTerminalPath: *fp, values: values.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fp.selector))
	}
	return fpaov
}

func (fp *DistributionRange_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DistributionRange_FieldTerminalPath) WithIArrayItemValue(value interface{}) DistributionRange_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fp.selector))
	}
}

func (fp *DistributionRange_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DistributionRange_FieldPathValue allows storing values for Range fields according to their type
type DistributionRange_FieldPathValue interface {
	DistributionRange_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Distribution_Range)
	CompareWith(*Distribution_Range) (cmp int, comparable bool)
}

func ParseDistributionRange_FieldPathValue(pathStr, valueStr string) (DistributionRange_FieldPathValue, error) {
	fp, err := ParseDistributionRange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Range field path value from %s: %v", valueStr, err)
	}
	return fpv.(DistributionRange_FieldPathValue), nil
}

func MustParseDistributionRange_FieldPathValue(pathStr, valueStr string) DistributionRange_FieldPathValue {
	fpv, err := ParseDistributionRange_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DistributionRange_FieldTerminalPathValue struct {
	DistributionRange_FieldTerminalPath
	value interface{}
}

var _ DistributionRange_FieldPathValue = (*DistributionRange_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Range' as interface{}
func (fpv *DistributionRange_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DistributionRange_FieldTerminalPathValue) AsMinValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}
func (fpv *DistributionRange_FieldTerminalPathValue) AsMaxValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}

// SetTo stores value for selected field for object Range
func (fpv *DistributionRange_FieldTerminalPathValue) SetTo(target **Distribution_Range) {
	if *target == nil {
		*target = new(Distribution_Range)
	}
	switch fpv.selector {
	case DistributionRange_FieldPathSelectorMin:
		(*target).Min = fpv.value.(float64)
	case DistributionRange_FieldPathSelectorMax:
		(*target).Max = fpv.value.(float64)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fpv.selector))
	}
}

func (fpv *DistributionRange_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution_Range)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DistributionRange_FieldTerminalPathValue' with the value under path in 'Distribution_Range'.
func (fpv *DistributionRange_FieldTerminalPathValue) CompareWith(source *Distribution_Range) (int, bool) {
	switch fpv.selector {
	case DistributionRange_FieldPathSelectorMin:
		leftValue := fpv.value.(float64)
		rightValue := source.GetMin()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DistributionRange_FieldPathSelectorMax:
		leftValue := fpv.value.(float64)
		rightValue := source.GetMax()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_Range: %d", fpv.selector))
	}
}

func (fpv *DistributionRange_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Distribution_Range))
}

// DistributionRange_FieldPathArrayItemValue allows storing single item in Path-specific values for Range according to their type
// Present only for array (repeated) types.
type DistributionRange_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DistributionRange_FieldPath
	ContainsValue(*Distribution_Range) bool
}

// ParseDistributionRange_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDistributionRange_FieldPathArrayItemValue(pathStr, valueStr string) (DistributionRange_FieldPathArrayItemValue, error) {
	fp, err := ParseDistributionRange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Range field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DistributionRange_FieldPathArrayItemValue), nil
}

func MustParseDistributionRange_FieldPathArrayItemValue(pathStr, valueStr string) DistributionRange_FieldPathArrayItemValue {
	fpaiv, err := ParseDistributionRange_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DistributionRange_FieldTerminalPathArrayItemValue struct {
	DistributionRange_FieldTerminalPath
	value interface{}
}

var _ DistributionRange_FieldPathArrayItemValue = (*DistributionRange_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Distribution_Range as interface{}
func (fpaiv *DistributionRange_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *DistributionRange_FieldTerminalPathArrayItemValue) GetSingle(source *Distribution_Range) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DistributionRange_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Distribution_Range))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Range'
func (fpaiv *DistributionRange_FieldTerminalPathArrayItemValue) ContainsValue(source *Distribution_Range) bool {
	slice := fpaiv.DistributionRange_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DistributionRange_FieldPathArrayOfValues allows storing slice of values for Range fields according to their type
type DistributionRange_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DistributionRange_FieldPath
}

func ParseDistributionRange_FieldPathArrayOfValues(pathStr, valuesStr string) (DistributionRange_FieldPathArrayOfValues, error) {
	fp, err := ParseDistributionRange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Range field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DistributionRange_FieldPathArrayOfValues), nil
}

func MustParseDistributionRange_FieldPathArrayOfValues(pathStr, valuesStr string) DistributionRange_FieldPathArrayOfValues {
	fpaov, err := ParseDistributionRange_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DistributionRange_FieldTerminalPathArrayOfValues struct {
	DistributionRange_FieldTerminalPath
	values interface{}
}

var _ DistributionRange_FieldPathArrayOfValues = (*DistributionRange_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DistributionRange_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DistributionRange_FieldPathSelectorMin:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	case DistributionRange_FieldPathSelectorMax:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DistributionRange_FieldTerminalPathArrayOfValues) AsMinArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}
func (fpaov *DistributionRange_FieldTerminalPathArrayOfValues) AsMaxArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DistributionBucketOptions_FieldPath interface {
	gotenobject.FieldPath
	Selector() DistributionBucketOptions_FieldPathSelector
	Get(source *Distribution_BucketOptions) []interface{}
	GetSingle(source *Distribution_BucketOptions) (interface{}, bool)
	ClearValue(item *Distribution_BucketOptions)

	// Those methods build corresponding DistributionBucketOptions_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DistributionBucketOptions_FieldPathValue
	WithIArrayOfValues(values interface{}) DistributionBucketOptions_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DistributionBucketOptions_FieldPathArrayItemValue
}

type DistributionBucketOptions_FieldPathSelector int32

const (
	DistributionBucketOptions_FieldPathSelectorLinearBuckets      DistributionBucketOptions_FieldPathSelector = 0
	DistributionBucketOptions_FieldPathSelectorExponentialBuckets DistributionBucketOptions_FieldPathSelector = 1
	DistributionBucketOptions_FieldPathSelectorExplicitBuckets    DistributionBucketOptions_FieldPathSelector = 2
	DistributionBucketOptions_FieldPathSelectorDynamicBuckets     DistributionBucketOptions_FieldPathSelector = 3
)

func (s DistributionBucketOptions_FieldPathSelector) String() string {
	switch s {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		return "linear_buckets"
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		return "exponential_buckets"
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		return "explicit_buckets"
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		return "dynamic_buckets"
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", s))
	}
}

func BuildDistributionBucketOptions_FieldPath(fp gotenobject.RawFieldPath) (DistributionBucketOptions_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Distribution_BucketOptions")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "linear_buckets", "linearBuckets", "linear-buckets":
			return &DistributionBucketOptions_FieldTerminalPath{selector: DistributionBucketOptions_FieldPathSelectorLinearBuckets}, nil
		case "exponential_buckets", "exponentialBuckets", "exponential-buckets":
			return &DistributionBucketOptions_FieldTerminalPath{selector: DistributionBucketOptions_FieldPathSelectorExponentialBuckets}, nil
		case "explicit_buckets", "explicitBuckets", "explicit-buckets":
			return &DistributionBucketOptions_FieldTerminalPath{selector: DistributionBucketOptions_FieldPathSelectorExplicitBuckets}, nil
		case "dynamic_buckets", "dynamicBuckets", "dynamic-buckets":
			return &DistributionBucketOptions_FieldTerminalPath{selector: DistributionBucketOptions_FieldPathSelectorDynamicBuckets}, nil
		}
	} else {
		switch fp[0] {
		case "linear_buckets", "linearBuckets", "linear-buckets":
			if subpath, err := BuildDistributionBucketOptionsLinear_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &DistributionBucketOptions_FieldSubPath{selector: DistributionBucketOptions_FieldPathSelectorLinearBuckets, subPath: subpath}, nil
			}
		case "exponential_buckets", "exponentialBuckets", "exponential-buckets":
			if subpath, err := BuildDistributionBucketOptionsExponential_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &DistributionBucketOptions_FieldSubPath{selector: DistributionBucketOptions_FieldPathSelectorExponentialBuckets, subPath: subpath}, nil
			}
		case "explicit_buckets", "explicitBuckets", "explicit-buckets":
			if subpath, err := BuildDistributionBucketOptionsExplicit_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &DistributionBucketOptions_FieldSubPath{selector: DistributionBucketOptions_FieldPathSelectorExplicitBuckets, subPath: subpath}, nil
			}
		case "dynamic_buckets", "dynamicBuckets", "dynamic-buckets":
			if subpath, err := BuildDistributionBucketOptionsDynamic_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &DistributionBucketOptions_FieldSubPath{selector: DistributionBucketOptions_FieldPathSelectorDynamicBuckets, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Distribution_BucketOptions", fp)
}

func ParseDistributionBucketOptions_FieldPath(rawField string) (DistributionBucketOptions_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDistributionBucketOptions_FieldPath(fp)
}

func MustParseDistributionBucketOptions_FieldPath(rawField string) DistributionBucketOptions_FieldPath {
	fp, err := ParseDistributionBucketOptions_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DistributionBucketOptions_FieldTerminalPath struct {
	selector DistributionBucketOptions_FieldPathSelector
}

var _ DistributionBucketOptions_FieldPath = (*DistributionBucketOptions_FieldTerminalPath)(nil)

func (fp *DistributionBucketOptions_FieldTerminalPath) Selector() DistributionBucketOptions_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DistributionBucketOptions_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DistributionBucketOptions_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Distribution_BucketOptions
func (fp *DistributionBucketOptions_FieldTerminalPath) Get(source *Distribution_BucketOptions) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
			if source, ok := source.Options.(*Distribution_BucketOptions_LinearBuckets); ok && source != nil {
				if source.LinearBuckets != nil {
					values = append(values, source.LinearBuckets)
				}
			}
		case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
			if source, ok := source.Options.(*Distribution_BucketOptions_ExponentialBuckets); ok && source != nil {
				if source.ExponentialBuckets != nil {
					values = append(values, source.ExponentialBuckets)
				}
			}
		case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
			if source, ok := source.Options.(*Distribution_BucketOptions_ExplicitBuckets); ok && source != nil {
				if source.ExplicitBuckets != nil {
					values = append(values, source.ExplicitBuckets)
				}
			}
		case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
			if source, ok := source.Options.(*Distribution_BucketOptions_DynamicBuckets); ok && source != nil {
				if source.DynamicBuckets != nil {
					values = append(values, source.DynamicBuckets)
				}
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fp.selector))
		}
	}
	return
}

func (fp *DistributionBucketOptions_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Distribution_BucketOptions))
}

// GetSingle returns value pointed by specific field of from source Distribution_BucketOptions
func (fp *DistributionBucketOptions_FieldTerminalPath) GetSingle(source *Distribution_BucketOptions) (interface{}, bool) {
	switch fp.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetLinearBuckets(), false
		}
		_, oneOfSelected := source.Options.(*Distribution_BucketOptions_LinearBuckets)
		if !oneOfSelected {
			return source.GetLinearBuckets(), false // to return "type" information
		}
		res := source.GetLinearBuckets()
		return res, res != nil
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetExponentialBuckets(), false
		}
		_, oneOfSelected := source.Options.(*Distribution_BucketOptions_ExponentialBuckets)
		if !oneOfSelected {
			return source.GetExponentialBuckets(), false // to return "type" information
		}
		res := source.GetExponentialBuckets()
		return res, res != nil
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetExplicitBuckets(), false
		}
		_, oneOfSelected := source.Options.(*Distribution_BucketOptions_ExplicitBuckets)
		if !oneOfSelected {
			return source.GetExplicitBuckets(), false // to return "type" information
		}
		res := source.GetExplicitBuckets()
		return res, res != nil
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetDynamicBuckets(), false
		}
		_, oneOfSelected := source.Options.(*Distribution_BucketOptions_DynamicBuckets)
		if !oneOfSelected {
			return source.GetDynamicBuckets(), false // to return "type" information
		}
		res := source.GetDynamicBuckets()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptions_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Distribution_BucketOptions))
}

// GetDefault returns a default value of the field type
func (fp *DistributionBucketOptions_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		return (*Distribution_BucketOptions_Linear)(nil)
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		return (*Distribution_BucketOptions_Exponential)(nil)
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		return (*Distribution_BucketOptions_Explicit)(nil)
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		return (*Distribution_BucketOptions_Dynamic)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptions_FieldTerminalPath) ClearValue(item *Distribution_BucketOptions) {
	if item != nil {
		switch fp.selector {
		case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
			if item, ok := item.Options.(*Distribution_BucketOptions_LinearBuckets); ok {
				item.LinearBuckets = nil
			}
		case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
			if item, ok := item.Options.(*Distribution_BucketOptions_ExponentialBuckets); ok {
				item.ExponentialBuckets = nil
			}
		case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
			if item, ok := item.Options.(*Distribution_BucketOptions_ExplicitBuckets); ok {
				item.ExplicitBuckets = nil
			}
		case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
			if item, ok := item.Options.(*Distribution_BucketOptions_DynamicBuckets); ok {
				item.DynamicBuckets = nil
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fp.selector))
		}
	}
}

func (fp *DistributionBucketOptions_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Distribution_BucketOptions))
}

// IsLeaf - whether field path is holds simple value
func (fp *DistributionBucketOptions_FieldTerminalPath) IsLeaf() bool {
	return false
}

func (fp *DistributionBucketOptions_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *DistributionBucketOptions_FieldTerminalPath) WithIValue(value interface{}) DistributionBucketOptions_FieldPathValue {
	switch fp.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		return &DistributionBucketOptions_FieldTerminalPathValue{DistributionBucketOptions_FieldTerminalPath: *fp, value: value.(*Distribution_BucketOptions_Linear)}
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		return &DistributionBucketOptions_FieldTerminalPathValue{DistributionBucketOptions_FieldTerminalPath: *fp, value: value.(*Distribution_BucketOptions_Exponential)}
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		return &DistributionBucketOptions_FieldTerminalPathValue{DistributionBucketOptions_FieldTerminalPath: *fp, value: value.(*Distribution_BucketOptions_Explicit)}
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		return &DistributionBucketOptions_FieldTerminalPathValue{DistributionBucketOptions_FieldTerminalPath: *fp, value: value.(*Distribution_BucketOptions_Dynamic)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptions_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DistributionBucketOptions_FieldTerminalPath) WithIArrayOfValues(values interface{}) DistributionBucketOptions_FieldPathArrayOfValues {
	fpaov := &DistributionBucketOptions_FieldTerminalPathArrayOfValues{DistributionBucketOptions_FieldTerminalPath: *fp}
	switch fp.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		return &DistributionBucketOptions_FieldTerminalPathArrayOfValues{DistributionBucketOptions_FieldTerminalPath: *fp, values: values.([]*Distribution_BucketOptions_Linear)}
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		return &DistributionBucketOptions_FieldTerminalPathArrayOfValues{DistributionBucketOptions_FieldTerminalPath: *fp, values: values.([]*Distribution_BucketOptions_Exponential)}
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		return &DistributionBucketOptions_FieldTerminalPathArrayOfValues{DistributionBucketOptions_FieldTerminalPath: *fp, values: values.([]*Distribution_BucketOptions_Explicit)}
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		return &DistributionBucketOptions_FieldTerminalPathArrayOfValues{DistributionBucketOptions_FieldTerminalPath: *fp, values: values.([]*Distribution_BucketOptions_Dynamic)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fp.selector))
	}
	return fpaov
}

func (fp *DistributionBucketOptions_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DistributionBucketOptions_FieldTerminalPath) WithIArrayItemValue(value interface{}) DistributionBucketOptions_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptions_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type DistributionBucketOptions_FieldSubPath struct {
	selector DistributionBucketOptions_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ DistributionBucketOptions_FieldPath = (*DistributionBucketOptions_FieldSubPath)(nil)

func (fps *DistributionBucketOptions_FieldSubPath) Selector() DistributionBucketOptions_FieldPathSelector {
	return fps.selector
}
func (fps *DistributionBucketOptions_FieldSubPath) AsLinearBucketsSubPath() (DistributionBucketOptionsLinear_FieldPath, bool) {
	res, ok := fps.subPath.(DistributionBucketOptionsLinear_FieldPath)
	return res, ok
}
func (fps *DistributionBucketOptions_FieldSubPath) AsExponentialBucketsSubPath() (DistributionBucketOptionsExponential_FieldPath, bool) {
	res, ok := fps.subPath.(DistributionBucketOptionsExponential_FieldPath)
	return res, ok
}
func (fps *DistributionBucketOptions_FieldSubPath) AsExplicitBucketsSubPath() (DistributionBucketOptionsExplicit_FieldPath, bool) {
	res, ok := fps.subPath.(DistributionBucketOptionsExplicit_FieldPath)
	return res, ok
}
func (fps *DistributionBucketOptions_FieldSubPath) AsDynamicBucketsSubPath() (DistributionBucketOptionsDynamic_FieldPath, bool) {
	res, ok := fps.subPath.(DistributionBucketOptionsDynamic_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *DistributionBucketOptions_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *DistributionBucketOptions_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Distribution_BucketOptions
func (fps *DistributionBucketOptions_FieldSubPath) Get(source *Distribution_BucketOptions) (values []interface{}) {
	switch fps.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		values = append(values, fps.subPath.GetRaw(source.GetLinearBuckets())...)
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		values = append(values, fps.subPath.GetRaw(source.GetExponentialBuckets())...)
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		values = append(values, fps.subPath.GetRaw(source.GetExplicitBuckets())...)
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		values = append(values, fps.subPath.GetRaw(source.GetDynamicBuckets())...)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fps.selector))
	}
	return
}

func (fps *DistributionBucketOptions_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Distribution_BucketOptions))
}

// GetSingle returns value of selected field from source Distribution_BucketOptions
func (fps *DistributionBucketOptions_FieldSubPath) GetSingle(source *Distribution_BucketOptions) (interface{}, bool) {
	switch fps.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		if source.GetLinearBuckets() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetLinearBuckets())
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		if source.GetExponentialBuckets() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetExponentialBuckets())
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		if source.GetExplicitBuckets() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetExplicitBuckets())
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		if source.GetDynamicBuckets() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetDynamicBuckets())
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fps.selector))
	}
}

func (fps *DistributionBucketOptions_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Distribution_BucketOptions))
}

// GetDefault returns a default value of the field type
func (fps *DistributionBucketOptions_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *DistributionBucketOptions_FieldSubPath) ClearValue(item *Distribution_BucketOptions) {
	if item != nil {
		switch fps.selector {
		case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
			if item.Options != nil {
				if item, ok := item.Options.(*Distribution_BucketOptions_LinearBuckets); ok {
					fps.subPath.ClearValueRaw(item.LinearBuckets)
				}
			}
		case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
			if item.Options != nil {
				if item, ok := item.Options.(*Distribution_BucketOptions_ExponentialBuckets); ok {
					fps.subPath.ClearValueRaw(item.ExponentialBuckets)
				}
			}
		case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
			if item.Options != nil {
				if item, ok := item.Options.(*Distribution_BucketOptions_ExplicitBuckets); ok {
					fps.subPath.ClearValueRaw(item.ExplicitBuckets)
				}
			}
		case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
			if item.Options != nil {
				if item, ok := item.Options.(*Distribution_BucketOptions_DynamicBuckets); ok {
					fps.subPath.ClearValueRaw(item.DynamicBuckets)
				}
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fps.selector))
		}
	}
}

func (fps *DistributionBucketOptions_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Distribution_BucketOptions))
}

// IsLeaf - whether field path is holds simple value
func (fps *DistributionBucketOptions_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *DistributionBucketOptions_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&DistributionBucketOptions_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *DistributionBucketOptions_FieldSubPath) WithIValue(value interface{}) DistributionBucketOptions_FieldPathValue {
	return &DistributionBucketOptions_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *DistributionBucketOptions_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *DistributionBucketOptions_FieldSubPath) WithIArrayOfValues(values interface{}) DistributionBucketOptions_FieldPathArrayOfValues {
	return &DistributionBucketOptions_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *DistributionBucketOptions_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *DistributionBucketOptions_FieldSubPath) WithIArrayItemValue(value interface{}) DistributionBucketOptions_FieldPathArrayItemValue {
	return &DistributionBucketOptions_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *DistributionBucketOptions_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// DistributionBucketOptions_FieldPathValue allows storing values for BucketOptions fields according to their type
type DistributionBucketOptions_FieldPathValue interface {
	DistributionBucketOptions_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Distribution_BucketOptions)
	CompareWith(*Distribution_BucketOptions) (cmp int, comparable bool)
}

func ParseDistributionBucketOptions_FieldPathValue(pathStr, valueStr string) (DistributionBucketOptions_FieldPathValue, error) {
	fp, err := ParseDistributionBucketOptions_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BucketOptions field path value from %s: %v", valueStr, err)
	}
	return fpv.(DistributionBucketOptions_FieldPathValue), nil
}

func MustParseDistributionBucketOptions_FieldPathValue(pathStr, valueStr string) DistributionBucketOptions_FieldPathValue {
	fpv, err := ParseDistributionBucketOptions_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DistributionBucketOptions_FieldTerminalPathValue struct {
	DistributionBucketOptions_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptions_FieldPathValue = (*DistributionBucketOptions_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'BucketOptions' as interface{}
func (fpv *DistributionBucketOptions_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DistributionBucketOptions_FieldTerminalPathValue) AsLinearBucketsValue() (*Distribution_BucketOptions_Linear, bool) {
	res, ok := fpv.value.(*Distribution_BucketOptions_Linear)
	return res, ok
}
func (fpv *DistributionBucketOptions_FieldTerminalPathValue) AsExponentialBucketsValue() (*Distribution_BucketOptions_Exponential, bool) {
	res, ok := fpv.value.(*Distribution_BucketOptions_Exponential)
	return res, ok
}
func (fpv *DistributionBucketOptions_FieldTerminalPathValue) AsExplicitBucketsValue() (*Distribution_BucketOptions_Explicit, bool) {
	res, ok := fpv.value.(*Distribution_BucketOptions_Explicit)
	return res, ok
}
func (fpv *DistributionBucketOptions_FieldTerminalPathValue) AsDynamicBucketsValue() (*Distribution_BucketOptions_Dynamic, bool) {
	res, ok := fpv.value.(*Distribution_BucketOptions_Dynamic)
	return res, ok
}

// SetTo stores value for selected field for object BucketOptions
func (fpv *DistributionBucketOptions_FieldTerminalPathValue) SetTo(target **Distribution_BucketOptions) {
	if *target == nil {
		*target = new(Distribution_BucketOptions)
	}
	switch fpv.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		if _, ok := (*target).Options.(*Distribution_BucketOptions_LinearBuckets); !ok {
			(*target).Options = &Distribution_BucketOptions_LinearBuckets{}
		}
		(*target).Options.(*Distribution_BucketOptions_LinearBuckets).LinearBuckets = fpv.value.(*Distribution_BucketOptions_Linear)
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		if _, ok := (*target).Options.(*Distribution_BucketOptions_ExponentialBuckets); !ok {
			(*target).Options = &Distribution_BucketOptions_ExponentialBuckets{}
		}
		(*target).Options.(*Distribution_BucketOptions_ExponentialBuckets).ExponentialBuckets = fpv.value.(*Distribution_BucketOptions_Exponential)
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		if _, ok := (*target).Options.(*Distribution_BucketOptions_ExplicitBuckets); !ok {
			(*target).Options = &Distribution_BucketOptions_ExplicitBuckets{}
		}
		(*target).Options.(*Distribution_BucketOptions_ExplicitBuckets).ExplicitBuckets = fpv.value.(*Distribution_BucketOptions_Explicit)
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		if _, ok := (*target).Options.(*Distribution_BucketOptions_DynamicBuckets); !ok {
			(*target).Options = &Distribution_BucketOptions_DynamicBuckets{}
		}
		(*target).Options.(*Distribution_BucketOptions_DynamicBuckets).DynamicBuckets = fpv.value.(*Distribution_BucketOptions_Dynamic)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptions_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution_BucketOptions)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DistributionBucketOptions_FieldTerminalPathValue' with the value under path in 'Distribution_BucketOptions'.
func (fpv *DistributionBucketOptions_FieldTerminalPathValue) CompareWith(source *Distribution_BucketOptions) (int, bool) {
	switch fpv.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		return 0, false
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		return 0, false
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		return 0, false
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptions_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Distribution_BucketOptions))
}

type DistributionBucketOptions_FieldSubPathValue struct {
	DistributionBucketOptions_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ DistributionBucketOptions_FieldPathValue = (*DistributionBucketOptions_FieldSubPathValue)(nil)

func (fpvs *DistributionBucketOptions_FieldSubPathValue) AsLinearBucketsPathValue() (DistributionBucketOptionsLinear_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(DistributionBucketOptionsLinear_FieldPathValue)
	return res, ok
}
func (fpvs *DistributionBucketOptions_FieldSubPathValue) AsExponentialBucketsPathValue() (DistributionBucketOptionsExponential_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(DistributionBucketOptionsExponential_FieldPathValue)
	return res, ok
}
func (fpvs *DistributionBucketOptions_FieldSubPathValue) AsExplicitBucketsPathValue() (DistributionBucketOptionsExplicit_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(DistributionBucketOptionsExplicit_FieldPathValue)
	return res, ok
}
func (fpvs *DistributionBucketOptions_FieldSubPathValue) AsDynamicBucketsPathValue() (DistributionBucketOptionsDynamic_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(DistributionBucketOptionsDynamic_FieldPathValue)
	return res, ok
}

func (fpvs *DistributionBucketOptions_FieldSubPathValue) SetTo(target **Distribution_BucketOptions) {
	if *target == nil {
		*target = new(Distribution_BucketOptions)
	}
	switch fpvs.Selector() {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		if _, ok := (*target).Options.(*Distribution_BucketOptions_LinearBuckets); !ok {
			(*target).Options = &Distribution_BucketOptions_LinearBuckets{}
		}
		fpvs.subPathValue.(DistributionBucketOptionsLinear_FieldPathValue).SetTo(&(*target).Options.(*Distribution_BucketOptions_LinearBuckets).LinearBuckets)
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		if _, ok := (*target).Options.(*Distribution_BucketOptions_ExponentialBuckets); !ok {
			(*target).Options = &Distribution_BucketOptions_ExponentialBuckets{}
		}
		fpvs.subPathValue.(DistributionBucketOptionsExponential_FieldPathValue).SetTo(&(*target).Options.(*Distribution_BucketOptions_ExponentialBuckets).ExponentialBuckets)
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		if _, ok := (*target).Options.(*Distribution_BucketOptions_ExplicitBuckets); !ok {
			(*target).Options = &Distribution_BucketOptions_ExplicitBuckets{}
		}
		fpvs.subPathValue.(DistributionBucketOptionsExplicit_FieldPathValue).SetTo(&(*target).Options.(*Distribution_BucketOptions_ExplicitBuckets).ExplicitBuckets)
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		if _, ok := (*target).Options.(*Distribution_BucketOptions_DynamicBuckets); !ok {
			(*target).Options = &Distribution_BucketOptions_DynamicBuckets{}
		}
		fpvs.subPathValue.(DistributionBucketOptionsDynamic_FieldPathValue).SetTo(&(*target).Options.(*Distribution_BucketOptions_DynamicBuckets).DynamicBuckets)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fpvs.Selector()))
	}
}

func (fpvs *DistributionBucketOptions_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution_BucketOptions)
	fpvs.SetTo(&typedObject)
}

func (fpvs *DistributionBucketOptions_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *DistributionBucketOptions_FieldSubPathValue) CompareWith(source *Distribution_BucketOptions) (int, bool) {
	switch fpvs.Selector() {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		return fpvs.subPathValue.(DistributionBucketOptionsLinear_FieldPathValue).CompareWith(source.GetLinearBuckets())
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		return fpvs.subPathValue.(DistributionBucketOptionsExponential_FieldPathValue).CompareWith(source.GetExponentialBuckets())
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		return fpvs.subPathValue.(DistributionBucketOptionsExplicit_FieldPathValue).CompareWith(source.GetExplicitBuckets())
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		return fpvs.subPathValue.(DistributionBucketOptionsDynamic_FieldPathValue).CompareWith(source.GetDynamicBuckets())
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fpvs.Selector()))
	}
}

func (fpvs *DistributionBucketOptions_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Distribution_BucketOptions))
}

// DistributionBucketOptions_FieldPathArrayItemValue allows storing single item in Path-specific values for BucketOptions according to their type
// Present only for array (repeated) types.
type DistributionBucketOptions_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DistributionBucketOptions_FieldPath
	ContainsValue(*Distribution_BucketOptions) bool
}

// ParseDistributionBucketOptions_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDistributionBucketOptions_FieldPathArrayItemValue(pathStr, valueStr string) (DistributionBucketOptions_FieldPathArrayItemValue, error) {
	fp, err := ParseDistributionBucketOptions_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BucketOptions field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DistributionBucketOptions_FieldPathArrayItemValue), nil
}

func MustParseDistributionBucketOptions_FieldPathArrayItemValue(pathStr, valueStr string) DistributionBucketOptions_FieldPathArrayItemValue {
	fpaiv, err := ParseDistributionBucketOptions_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DistributionBucketOptions_FieldTerminalPathArrayItemValue struct {
	DistributionBucketOptions_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptions_FieldPathArrayItemValue = (*DistributionBucketOptions_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Distribution_BucketOptions as interface{}
func (fpaiv *DistributionBucketOptions_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *DistributionBucketOptions_FieldTerminalPathArrayItemValue) GetSingle(source *Distribution_BucketOptions) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DistributionBucketOptions_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Distribution_BucketOptions))
}

// Contains returns a boolean indicating if value that is being held is present in given 'BucketOptions'
func (fpaiv *DistributionBucketOptions_FieldTerminalPathArrayItemValue) ContainsValue(source *Distribution_BucketOptions) bool {
	slice := fpaiv.DistributionBucketOptions_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type DistributionBucketOptions_FieldSubPathArrayItemValue struct {
	DistributionBucketOptions_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *DistributionBucketOptions_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *DistributionBucketOptions_FieldSubPathArrayItemValue) AsLinearBucketsPathItemValue() (DistributionBucketOptionsLinear_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(DistributionBucketOptionsLinear_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *DistributionBucketOptions_FieldSubPathArrayItemValue) AsExponentialBucketsPathItemValue() (DistributionBucketOptionsExponential_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(DistributionBucketOptionsExponential_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *DistributionBucketOptions_FieldSubPathArrayItemValue) AsExplicitBucketsPathItemValue() (DistributionBucketOptionsExplicit_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(DistributionBucketOptionsExplicit_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *DistributionBucketOptions_FieldSubPathArrayItemValue) AsDynamicBucketsPathItemValue() (DistributionBucketOptionsDynamic_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(DistributionBucketOptionsDynamic_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'BucketOptions'
func (fpaivs *DistributionBucketOptions_FieldSubPathArrayItemValue) ContainsValue(source *Distribution_BucketOptions) bool {
	switch fpaivs.Selector() {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		return fpaivs.subPathItemValue.(DistributionBucketOptionsLinear_FieldPathArrayItemValue).ContainsValue(source.GetLinearBuckets())
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		return fpaivs.subPathItemValue.(DistributionBucketOptionsExponential_FieldPathArrayItemValue).ContainsValue(source.GetExponentialBuckets())
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		return fpaivs.subPathItemValue.(DistributionBucketOptionsExplicit_FieldPathArrayItemValue).ContainsValue(source.GetExplicitBuckets())
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		return fpaivs.subPathItemValue.(DistributionBucketOptionsDynamic_FieldPathArrayItemValue).ContainsValue(source.GetDynamicBuckets())
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions: %d", fpaivs.Selector()))
	}
}

// DistributionBucketOptions_FieldPathArrayOfValues allows storing slice of values for BucketOptions fields according to their type
type DistributionBucketOptions_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DistributionBucketOptions_FieldPath
}

func ParseDistributionBucketOptions_FieldPathArrayOfValues(pathStr, valuesStr string) (DistributionBucketOptions_FieldPathArrayOfValues, error) {
	fp, err := ParseDistributionBucketOptions_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BucketOptions field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DistributionBucketOptions_FieldPathArrayOfValues), nil
}

func MustParseDistributionBucketOptions_FieldPathArrayOfValues(pathStr, valuesStr string) DistributionBucketOptions_FieldPathArrayOfValues {
	fpaov, err := ParseDistributionBucketOptions_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DistributionBucketOptions_FieldTerminalPathArrayOfValues struct {
	DistributionBucketOptions_FieldTerminalPath
	values interface{}
}

var _ DistributionBucketOptions_FieldPathArrayOfValues = (*DistributionBucketOptions_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DistributionBucketOptions_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DistributionBucketOptions_FieldPathSelectorLinearBuckets:
		for _, v := range fpaov.values.([]*Distribution_BucketOptions_Linear) {
			values = append(values, v)
		}
	case DistributionBucketOptions_FieldPathSelectorExponentialBuckets:
		for _, v := range fpaov.values.([]*Distribution_BucketOptions_Exponential) {
			values = append(values, v)
		}
	case DistributionBucketOptions_FieldPathSelectorExplicitBuckets:
		for _, v := range fpaov.values.([]*Distribution_BucketOptions_Explicit) {
			values = append(values, v)
		}
	case DistributionBucketOptions_FieldPathSelectorDynamicBuckets:
		for _, v := range fpaov.values.([]*Distribution_BucketOptions_Dynamic) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DistributionBucketOptions_FieldTerminalPathArrayOfValues) AsLinearBucketsArrayOfValues() ([]*Distribution_BucketOptions_Linear, bool) {
	res, ok := fpaov.values.([]*Distribution_BucketOptions_Linear)
	return res, ok
}
func (fpaov *DistributionBucketOptions_FieldTerminalPathArrayOfValues) AsExponentialBucketsArrayOfValues() ([]*Distribution_BucketOptions_Exponential, bool) {
	res, ok := fpaov.values.([]*Distribution_BucketOptions_Exponential)
	return res, ok
}
func (fpaov *DistributionBucketOptions_FieldTerminalPathArrayOfValues) AsExplicitBucketsArrayOfValues() ([]*Distribution_BucketOptions_Explicit, bool) {
	res, ok := fpaov.values.([]*Distribution_BucketOptions_Explicit)
	return res, ok
}
func (fpaov *DistributionBucketOptions_FieldTerminalPathArrayOfValues) AsDynamicBucketsArrayOfValues() ([]*Distribution_BucketOptions_Dynamic, bool) {
	res, ok := fpaov.values.([]*Distribution_BucketOptions_Dynamic)
	return res, ok
}

type DistributionBucketOptions_FieldSubPathArrayOfValues struct {
	DistributionBucketOptions_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ DistributionBucketOptions_FieldPathArrayOfValues = (*DistributionBucketOptions_FieldSubPathArrayOfValues)(nil)

func (fpsaov *DistributionBucketOptions_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *DistributionBucketOptions_FieldSubPathArrayOfValues) AsLinearBucketsPathArrayOfValues() (DistributionBucketOptionsLinear_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(DistributionBucketOptionsLinear_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *DistributionBucketOptions_FieldSubPathArrayOfValues) AsExponentialBucketsPathArrayOfValues() (DistributionBucketOptionsExponential_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(DistributionBucketOptionsExponential_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *DistributionBucketOptions_FieldSubPathArrayOfValues) AsExplicitBucketsPathArrayOfValues() (DistributionBucketOptionsExplicit_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(DistributionBucketOptionsExplicit_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *DistributionBucketOptions_FieldSubPathArrayOfValues) AsDynamicBucketsPathArrayOfValues() (DistributionBucketOptionsDynamic_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(DistributionBucketOptionsDynamic_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DistributionBucketOptionsLinear_FieldPath interface {
	gotenobject.FieldPath
	Selector() DistributionBucketOptionsLinear_FieldPathSelector
	Get(source *Distribution_BucketOptions_Linear) []interface{}
	GetSingle(source *Distribution_BucketOptions_Linear) (interface{}, bool)
	ClearValue(item *Distribution_BucketOptions_Linear)

	// Those methods build corresponding DistributionBucketOptionsLinear_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DistributionBucketOptionsLinear_FieldPathValue
	WithIArrayOfValues(values interface{}) DistributionBucketOptionsLinear_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DistributionBucketOptionsLinear_FieldPathArrayItemValue
}

type DistributionBucketOptionsLinear_FieldPathSelector int32

const (
	DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets DistributionBucketOptionsLinear_FieldPathSelector = 0
	DistributionBucketOptionsLinear_FieldPathSelectorWidth            DistributionBucketOptionsLinear_FieldPathSelector = 1
	DistributionBucketOptionsLinear_FieldPathSelectorOffset           DistributionBucketOptionsLinear_FieldPathSelector = 2
)

func (s DistributionBucketOptionsLinear_FieldPathSelector) String() string {
	switch s {
	case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
		return "num_finite_buckets"
	case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
		return "width"
	case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
		return "offset"
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", s))
	}
}

func BuildDistributionBucketOptionsLinear_FieldPath(fp gotenobject.RawFieldPath) (DistributionBucketOptionsLinear_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Distribution_BucketOptions_Linear")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "num_finite_buckets", "numFiniteBuckets", "num-finite-buckets":
			return &DistributionBucketOptionsLinear_FieldTerminalPath{selector: DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets}, nil
		case "width":
			return &DistributionBucketOptionsLinear_FieldTerminalPath{selector: DistributionBucketOptionsLinear_FieldPathSelectorWidth}, nil
		case "offset":
			return &DistributionBucketOptionsLinear_FieldTerminalPath{selector: DistributionBucketOptionsLinear_FieldPathSelectorOffset}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Distribution_BucketOptions_Linear", fp)
}

func ParseDistributionBucketOptionsLinear_FieldPath(rawField string) (DistributionBucketOptionsLinear_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDistributionBucketOptionsLinear_FieldPath(fp)
}

func MustParseDistributionBucketOptionsLinear_FieldPath(rawField string) DistributionBucketOptionsLinear_FieldPath {
	fp, err := ParseDistributionBucketOptionsLinear_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DistributionBucketOptionsLinear_FieldTerminalPath struct {
	selector DistributionBucketOptionsLinear_FieldPathSelector
}

var _ DistributionBucketOptionsLinear_FieldPath = (*DistributionBucketOptionsLinear_FieldTerminalPath)(nil)

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) Selector() DistributionBucketOptionsLinear_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Distribution_BucketOptions_Linear
func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) Get(source *Distribution_BucketOptions_Linear) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
			values = append(values, source.NumFiniteBuckets)
		case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
			values = append(values, source.Width)
		case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
			values = append(values, source.Offset)
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fp.selector))
		}
	}
	return
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Distribution_BucketOptions_Linear))
}

// GetSingle returns value pointed by specific field of from source Distribution_BucketOptions_Linear
func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) GetSingle(source *Distribution_BucketOptions_Linear) (interface{}, bool) {
	switch fp.selector {
	case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
		return source.GetNumFiniteBuckets(), source != nil
	case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
		return source.GetWidth(), source != nil
	case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
		return source.GetOffset(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Distribution_BucketOptions_Linear))
}

// GetDefault returns a default value of the field type
func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
		return int32(0)
	case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
		return float64(0)
	case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
		return float64(0)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) ClearValue(item *Distribution_BucketOptions_Linear) {
	if item != nil {
		switch fp.selector {
		case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
			item.NumFiniteBuckets = int32(0)
		case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
			item.Width = float64(0)
		case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
			item.Offset = float64(0)
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fp.selector))
		}
	}
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Distribution_BucketOptions_Linear))
}

// IsLeaf - whether field path is holds simple value
func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets ||
		fp.selector == DistributionBucketOptionsLinear_FieldPathSelectorWidth ||
		fp.selector == DistributionBucketOptionsLinear_FieldPathSelectorOffset
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) WithIValue(value interface{}) DistributionBucketOptionsLinear_FieldPathValue {
	switch fp.selector {
	case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
		return &DistributionBucketOptionsLinear_FieldTerminalPathValue{DistributionBucketOptionsLinear_FieldTerminalPath: *fp, value: value.(int32)}
	case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
		return &DistributionBucketOptionsLinear_FieldTerminalPathValue{DistributionBucketOptionsLinear_FieldTerminalPath: *fp, value: value.(float64)}
	case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
		return &DistributionBucketOptionsLinear_FieldTerminalPathValue{DistributionBucketOptionsLinear_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) WithIArrayOfValues(values interface{}) DistributionBucketOptionsLinear_FieldPathArrayOfValues {
	fpaov := &DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues{DistributionBucketOptionsLinear_FieldTerminalPath: *fp}
	switch fp.selector {
	case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
		return &DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues{DistributionBucketOptionsLinear_FieldTerminalPath: *fp, values: values.([]int32)}
	case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
		return &DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues{DistributionBucketOptionsLinear_FieldTerminalPath: *fp, values: values.([]float64)}
	case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
		return &DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues{DistributionBucketOptionsLinear_FieldTerminalPath: *fp, values: values.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fp.selector))
	}
	return fpaov
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) WithIArrayItemValue(value interface{}) DistributionBucketOptionsLinear_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsLinear_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DistributionBucketOptionsLinear_FieldPathValue allows storing values for Linear fields according to their type
type DistributionBucketOptionsLinear_FieldPathValue interface {
	DistributionBucketOptionsLinear_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Distribution_BucketOptions_Linear)
	CompareWith(*Distribution_BucketOptions_Linear) (cmp int, comparable bool)
}

func ParseDistributionBucketOptionsLinear_FieldPathValue(pathStr, valueStr string) (DistributionBucketOptionsLinear_FieldPathValue, error) {
	fp, err := ParseDistributionBucketOptionsLinear_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Linear field path value from %s: %v", valueStr, err)
	}
	return fpv.(DistributionBucketOptionsLinear_FieldPathValue), nil
}

func MustParseDistributionBucketOptionsLinear_FieldPathValue(pathStr, valueStr string) DistributionBucketOptionsLinear_FieldPathValue {
	fpv, err := ParseDistributionBucketOptionsLinear_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DistributionBucketOptionsLinear_FieldTerminalPathValue struct {
	DistributionBucketOptionsLinear_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptionsLinear_FieldPathValue = (*DistributionBucketOptionsLinear_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Linear' as interface{}
func (fpv *DistributionBucketOptionsLinear_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DistributionBucketOptionsLinear_FieldTerminalPathValue) AsNumFiniteBucketsValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *DistributionBucketOptionsLinear_FieldTerminalPathValue) AsWidthValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}
func (fpv *DistributionBucketOptionsLinear_FieldTerminalPathValue) AsOffsetValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}

// SetTo stores value for selected field for object Linear
func (fpv *DistributionBucketOptionsLinear_FieldTerminalPathValue) SetTo(target **Distribution_BucketOptions_Linear) {
	if *target == nil {
		*target = new(Distribution_BucketOptions_Linear)
	}
	switch fpv.selector {
	case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
		(*target).NumFiniteBuckets = fpv.value.(int32)
	case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
		(*target).Width = fpv.value.(float64)
	case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
		(*target).Offset = fpv.value.(float64)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptionsLinear_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution_BucketOptions_Linear)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DistributionBucketOptionsLinear_FieldTerminalPathValue' with the value under path in 'Distribution_BucketOptions_Linear'.
func (fpv *DistributionBucketOptionsLinear_FieldTerminalPathValue) CompareWith(source *Distribution_BucketOptions_Linear) (int, bool) {
	switch fpv.selector {
	case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
		leftValue := fpv.value.(int32)
		rightValue := source.GetNumFiniteBuckets()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
		leftValue := fpv.value.(float64)
		rightValue := source.GetWidth()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
		leftValue := fpv.value.(float64)
		rightValue := source.GetOffset()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Linear: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptionsLinear_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Distribution_BucketOptions_Linear))
}

// DistributionBucketOptionsLinear_FieldPathArrayItemValue allows storing single item in Path-specific values for Linear according to their type
// Present only for array (repeated) types.
type DistributionBucketOptionsLinear_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DistributionBucketOptionsLinear_FieldPath
	ContainsValue(*Distribution_BucketOptions_Linear) bool
}

// ParseDistributionBucketOptionsLinear_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDistributionBucketOptionsLinear_FieldPathArrayItemValue(pathStr, valueStr string) (DistributionBucketOptionsLinear_FieldPathArrayItemValue, error) {
	fp, err := ParseDistributionBucketOptionsLinear_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Linear field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DistributionBucketOptionsLinear_FieldPathArrayItemValue), nil
}

func MustParseDistributionBucketOptionsLinear_FieldPathArrayItemValue(pathStr, valueStr string) DistributionBucketOptionsLinear_FieldPathArrayItemValue {
	fpaiv, err := ParseDistributionBucketOptionsLinear_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DistributionBucketOptionsLinear_FieldTerminalPathArrayItemValue struct {
	DistributionBucketOptionsLinear_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptionsLinear_FieldPathArrayItemValue = (*DistributionBucketOptionsLinear_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Distribution_BucketOptions_Linear as interface{}
func (fpaiv *DistributionBucketOptionsLinear_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *DistributionBucketOptionsLinear_FieldTerminalPathArrayItemValue) GetSingle(source *Distribution_BucketOptions_Linear) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DistributionBucketOptionsLinear_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Distribution_BucketOptions_Linear))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Linear'
func (fpaiv *DistributionBucketOptionsLinear_FieldTerminalPathArrayItemValue) ContainsValue(source *Distribution_BucketOptions_Linear) bool {
	slice := fpaiv.DistributionBucketOptionsLinear_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DistributionBucketOptionsLinear_FieldPathArrayOfValues allows storing slice of values for Linear fields according to their type
type DistributionBucketOptionsLinear_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DistributionBucketOptionsLinear_FieldPath
}

func ParseDistributionBucketOptionsLinear_FieldPathArrayOfValues(pathStr, valuesStr string) (DistributionBucketOptionsLinear_FieldPathArrayOfValues, error) {
	fp, err := ParseDistributionBucketOptionsLinear_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Linear field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DistributionBucketOptionsLinear_FieldPathArrayOfValues), nil
}

func MustParseDistributionBucketOptionsLinear_FieldPathArrayOfValues(pathStr, valuesStr string) DistributionBucketOptionsLinear_FieldPathArrayOfValues {
	fpaov, err := ParseDistributionBucketOptionsLinear_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues struct {
	DistributionBucketOptionsLinear_FieldTerminalPath
	values interface{}
}

var _ DistributionBucketOptionsLinear_FieldPathArrayOfValues = (*DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DistributionBucketOptionsLinear_FieldPathSelectorNumFiniteBuckets:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case DistributionBucketOptionsLinear_FieldPathSelectorWidth:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	case DistributionBucketOptionsLinear_FieldPathSelectorOffset:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues) AsNumFiniteBucketsArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues) AsWidthArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}
func (fpaov *DistributionBucketOptionsLinear_FieldTerminalPathArrayOfValues) AsOffsetArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DistributionBucketOptionsExponential_FieldPath interface {
	gotenobject.FieldPath
	Selector() DistributionBucketOptionsExponential_FieldPathSelector
	Get(source *Distribution_BucketOptions_Exponential) []interface{}
	GetSingle(source *Distribution_BucketOptions_Exponential) (interface{}, bool)
	ClearValue(item *Distribution_BucketOptions_Exponential)

	// Those methods build corresponding DistributionBucketOptionsExponential_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DistributionBucketOptionsExponential_FieldPathValue
	WithIArrayOfValues(values interface{}) DistributionBucketOptionsExponential_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DistributionBucketOptionsExponential_FieldPathArrayItemValue
}

type DistributionBucketOptionsExponential_FieldPathSelector int32

const (
	DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets DistributionBucketOptionsExponential_FieldPathSelector = 0
	DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor     DistributionBucketOptionsExponential_FieldPathSelector = 1
	DistributionBucketOptionsExponential_FieldPathSelectorScale            DistributionBucketOptionsExponential_FieldPathSelector = 2
)

func (s DistributionBucketOptionsExponential_FieldPathSelector) String() string {
	switch s {
	case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
		return "num_finite_buckets"
	case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
		return "growth_factor"
	case DistributionBucketOptionsExponential_FieldPathSelectorScale:
		return "scale"
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", s))
	}
}

func BuildDistributionBucketOptionsExponential_FieldPath(fp gotenobject.RawFieldPath) (DistributionBucketOptionsExponential_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Distribution_BucketOptions_Exponential")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "num_finite_buckets", "numFiniteBuckets", "num-finite-buckets":
			return &DistributionBucketOptionsExponential_FieldTerminalPath{selector: DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets}, nil
		case "growth_factor", "growthFactor", "growth-factor":
			return &DistributionBucketOptionsExponential_FieldTerminalPath{selector: DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor}, nil
		case "scale":
			return &DistributionBucketOptionsExponential_FieldTerminalPath{selector: DistributionBucketOptionsExponential_FieldPathSelectorScale}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Distribution_BucketOptions_Exponential", fp)
}

func ParseDistributionBucketOptionsExponential_FieldPath(rawField string) (DistributionBucketOptionsExponential_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDistributionBucketOptionsExponential_FieldPath(fp)
}

func MustParseDistributionBucketOptionsExponential_FieldPath(rawField string) DistributionBucketOptionsExponential_FieldPath {
	fp, err := ParseDistributionBucketOptionsExponential_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DistributionBucketOptionsExponential_FieldTerminalPath struct {
	selector DistributionBucketOptionsExponential_FieldPathSelector
}

var _ DistributionBucketOptionsExponential_FieldPath = (*DistributionBucketOptionsExponential_FieldTerminalPath)(nil)

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) Selector() DistributionBucketOptionsExponential_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Distribution_BucketOptions_Exponential
func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) Get(source *Distribution_BucketOptions_Exponential) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
			values = append(values, source.NumFiniteBuckets)
		case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
			values = append(values, source.GrowthFactor)
		case DistributionBucketOptionsExponential_FieldPathSelectorScale:
			values = append(values, source.Scale)
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fp.selector))
		}
	}
	return
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Distribution_BucketOptions_Exponential))
}

// GetSingle returns value pointed by specific field of from source Distribution_BucketOptions_Exponential
func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) GetSingle(source *Distribution_BucketOptions_Exponential) (interface{}, bool) {
	switch fp.selector {
	case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
		return source.GetNumFiniteBuckets(), source != nil
	case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
		return source.GetGrowthFactor(), source != nil
	case DistributionBucketOptionsExponential_FieldPathSelectorScale:
		return source.GetScale(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Distribution_BucketOptions_Exponential))
}

// GetDefault returns a default value of the field type
func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
		return int32(0)
	case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
		return float64(0)
	case DistributionBucketOptionsExponential_FieldPathSelectorScale:
		return float64(0)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) ClearValue(item *Distribution_BucketOptions_Exponential) {
	if item != nil {
		switch fp.selector {
		case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
			item.NumFiniteBuckets = int32(0)
		case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
			item.GrowthFactor = float64(0)
		case DistributionBucketOptionsExponential_FieldPathSelectorScale:
			item.Scale = float64(0)
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fp.selector))
		}
	}
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Distribution_BucketOptions_Exponential))
}

// IsLeaf - whether field path is holds simple value
func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets ||
		fp.selector == DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor ||
		fp.selector == DistributionBucketOptionsExponential_FieldPathSelectorScale
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) WithIValue(value interface{}) DistributionBucketOptionsExponential_FieldPathValue {
	switch fp.selector {
	case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
		return &DistributionBucketOptionsExponential_FieldTerminalPathValue{DistributionBucketOptionsExponential_FieldTerminalPath: *fp, value: value.(int32)}
	case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
		return &DistributionBucketOptionsExponential_FieldTerminalPathValue{DistributionBucketOptionsExponential_FieldTerminalPath: *fp, value: value.(float64)}
	case DistributionBucketOptionsExponential_FieldPathSelectorScale:
		return &DistributionBucketOptionsExponential_FieldTerminalPathValue{DistributionBucketOptionsExponential_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) WithIArrayOfValues(values interface{}) DistributionBucketOptionsExponential_FieldPathArrayOfValues {
	fpaov := &DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues{DistributionBucketOptionsExponential_FieldTerminalPath: *fp}
	switch fp.selector {
	case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
		return &DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues{DistributionBucketOptionsExponential_FieldTerminalPath: *fp, values: values.([]int32)}
	case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
		return &DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues{DistributionBucketOptionsExponential_FieldTerminalPath: *fp, values: values.([]float64)}
	case DistributionBucketOptionsExponential_FieldPathSelectorScale:
		return &DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues{DistributionBucketOptionsExponential_FieldTerminalPath: *fp, values: values.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fp.selector))
	}
	return fpaov
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) WithIArrayItemValue(value interface{}) DistributionBucketOptionsExponential_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsExponential_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DistributionBucketOptionsExponential_FieldPathValue allows storing values for Exponential fields according to their type
type DistributionBucketOptionsExponential_FieldPathValue interface {
	DistributionBucketOptionsExponential_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Distribution_BucketOptions_Exponential)
	CompareWith(*Distribution_BucketOptions_Exponential) (cmp int, comparable bool)
}

func ParseDistributionBucketOptionsExponential_FieldPathValue(pathStr, valueStr string) (DistributionBucketOptionsExponential_FieldPathValue, error) {
	fp, err := ParseDistributionBucketOptionsExponential_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Exponential field path value from %s: %v", valueStr, err)
	}
	return fpv.(DistributionBucketOptionsExponential_FieldPathValue), nil
}

func MustParseDistributionBucketOptionsExponential_FieldPathValue(pathStr, valueStr string) DistributionBucketOptionsExponential_FieldPathValue {
	fpv, err := ParseDistributionBucketOptionsExponential_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DistributionBucketOptionsExponential_FieldTerminalPathValue struct {
	DistributionBucketOptionsExponential_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptionsExponential_FieldPathValue = (*DistributionBucketOptionsExponential_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Exponential' as interface{}
func (fpv *DistributionBucketOptionsExponential_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DistributionBucketOptionsExponential_FieldTerminalPathValue) AsNumFiniteBucketsValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *DistributionBucketOptionsExponential_FieldTerminalPathValue) AsGrowthFactorValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}
func (fpv *DistributionBucketOptionsExponential_FieldTerminalPathValue) AsScaleValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}

// SetTo stores value for selected field for object Exponential
func (fpv *DistributionBucketOptionsExponential_FieldTerminalPathValue) SetTo(target **Distribution_BucketOptions_Exponential) {
	if *target == nil {
		*target = new(Distribution_BucketOptions_Exponential)
	}
	switch fpv.selector {
	case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
		(*target).NumFiniteBuckets = fpv.value.(int32)
	case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
		(*target).GrowthFactor = fpv.value.(float64)
	case DistributionBucketOptionsExponential_FieldPathSelectorScale:
		(*target).Scale = fpv.value.(float64)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptionsExponential_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution_BucketOptions_Exponential)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DistributionBucketOptionsExponential_FieldTerminalPathValue' with the value under path in 'Distribution_BucketOptions_Exponential'.
func (fpv *DistributionBucketOptionsExponential_FieldTerminalPathValue) CompareWith(source *Distribution_BucketOptions_Exponential) (int, bool) {
	switch fpv.selector {
	case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
		leftValue := fpv.value.(int32)
		rightValue := source.GetNumFiniteBuckets()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
		leftValue := fpv.value.(float64)
		rightValue := source.GetGrowthFactor()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DistributionBucketOptionsExponential_FieldPathSelectorScale:
		leftValue := fpv.value.(float64)
		rightValue := source.GetScale()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Exponential: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptionsExponential_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Distribution_BucketOptions_Exponential))
}

// DistributionBucketOptionsExponential_FieldPathArrayItemValue allows storing single item in Path-specific values for Exponential according to their type
// Present only for array (repeated) types.
type DistributionBucketOptionsExponential_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DistributionBucketOptionsExponential_FieldPath
	ContainsValue(*Distribution_BucketOptions_Exponential) bool
}

// ParseDistributionBucketOptionsExponential_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDistributionBucketOptionsExponential_FieldPathArrayItemValue(pathStr, valueStr string) (DistributionBucketOptionsExponential_FieldPathArrayItemValue, error) {
	fp, err := ParseDistributionBucketOptionsExponential_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Exponential field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DistributionBucketOptionsExponential_FieldPathArrayItemValue), nil
}

func MustParseDistributionBucketOptionsExponential_FieldPathArrayItemValue(pathStr, valueStr string) DistributionBucketOptionsExponential_FieldPathArrayItemValue {
	fpaiv, err := ParseDistributionBucketOptionsExponential_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DistributionBucketOptionsExponential_FieldTerminalPathArrayItemValue struct {
	DistributionBucketOptionsExponential_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptionsExponential_FieldPathArrayItemValue = (*DistributionBucketOptionsExponential_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Distribution_BucketOptions_Exponential as interface{}
func (fpaiv *DistributionBucketOptionsExponential_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *DistributionBucketOptionsExponential_FieldTerminalPathArrayItemValue) GetSingle(source *Distribution_BucketOptions_Exponential) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DistributionBucketOptionsExponential_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Distribution_BucketOptions_Exponential))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Exponential'
func (fpaiv *DistributionBucketOptionsExponential_FieldTerminalPathArrayItemValue) ContainsValue(source *Distribution_BucketOptions_Exponential) bool {
	slice := fpaiv.DistributionBucketOptionsExponential_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DistributionBucketOptionsExponential_FieldPathArrayOfValues allows storing slice of values for Exponential fields according to their type
type DistributionBucketOptionsExponential_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DistributionBucketOptionsExponential_FieldPath
}

func ParseDistributionBucketOptionsExponential_FieldPathArrayOfValues(pathStr, valuesStr string) (DistributionBucketOptionsExponential_FieldPathArrayOfValues, error) {
	fp, err := ParseDistributionBucketOptionsExponential_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Exponential field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DistributionBucketOptionsExponential_FieldPathArrayOfValues), nil
}

func MustParseDistributionBucketOptionsExponential_FieldPathArrayOfValues(pathStr, valuesStr string) DistributionBucketOptionsExponential_FieldPathArrayOfValues {
	fpaov, err := ParseDistributionBucketOptionsExponential_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues struct {
	DistributionBucketOptionsExponential_FieldTerminalPath
	values interface{}
}

var _ DistributionBucketOptionsExponential_FieldPathArrayOfValues = (*DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DistributionBucketOptionsExponential_FieldPathSelectorNumFiniteBuckets:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case DistributionBucketOptionsExponential_FieldPathSelectorGrowthFactor:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	case DistributionBucketOptionsExponential_FieldPathSelectorScale:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues) AsNumFiniteBucketsArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues) AsGrowthFactorArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}
func (fpaov *DistributionBucketOptionsExponential_FieldTerminalPathArrayOfValues) AsScaleArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DistributionBucketOptionsExplicit_FieldPath interface {
	gotenobject.FieldPath
	Selector() DistributionBucketOptionsExplicit_FieldPathSelector
	Get(source *Distribution_BucketOptions_Explicit) []interface{}
	GetSingle(source *Distribution_BucketOptions_Explicit) (interface{}, bool)
	ClearValue(item *Distribution_BucketOptions_Explicit)

	// Those methods build corresponding DistributionBucketOptionsExplicit_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DistributionBucketOptionsExplicit_FieldPathValue
	WithIArrayOfValues(values interface{}) DistributionBucketOptionsExplicit_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DistributionBucketOptionsExplicit_FieldPathArrayItemValue
}

type DistributionBucketOptionsExplicit_FieldPathSelector int32

const (
	DistributionBucketOptionsExplicit_FieldPathSelectorBounds DistributionBucketOptionsExplicit_FieldPathSelector = 0
)

func (s DistributionBucketOptionsExplicit_FieldPathSelector) String() string {
	switch s {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		return "bounds"
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", s))
	}
}

func BuildDistributionBucketOptionsExplicit_FieldPath(fp gotenobject.RawFieldPath) (DistributionBucketOptionsExplicit_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Distribution_BucketOptions_Explicit")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "bounds":
			return &DistributionBucketOptionsExplicit_FieldTerminalPath{selector: DistributionBucketOptionsExplicit_FieldPathSelectorBounds}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Distribution_BucketOptions_Explicit", fp)
}

func ParseDistributionBucketOptionsExplicit_FieldPath(rawField string) (DistributionBucketOptionsExplicit_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDistributionBucketOptionsExplicit_FieldPath(fp)
}

func MustParseDistributionBucketOptionsExplicit_FieldPath(rawField string) DistributionBucketOptionsExplicit_FieldPath {
	fp, err := ParseDistributionBucketOptionsExplicit_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DistributionBucketOptionsExplicit_FieldTerminalPath struct {
	selector DistributionBucketOptionsExplicit_FieldPathSelector
}

var _ DistributionBucketOptionsExplicit_FieldPath = (*DistributionBucketOptionsExplicit_FieldTerminalPath)(nil)

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) Selector() DistributionBucketOptionsExplicit_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Distribution_BucketOptions_Explicit
func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) Get(source *Distribution_BucketOptions_Explicit) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
			for _, value := range source.GetBounds() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fp.selector))
		}
	}
	return
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Distribution_BucketOptions_Explicit))
}

// GetSingle returns value pointed by specific field of from source Distribution_BucketOptions_Explicit
func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) GetSingle(source *Distribution_BucketOptions_Explicit) (interface{}, bool) {
	switch fp.selector {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		res := source.GetBounds()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Distribution_BucketOptions_Explicit))
}

// GetDefault returns a default value of the field type
func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		return ([]float64)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) ClearValue(item *Distribution_BucketOptions_Explicit) {
	if item != nil {
		switch fp.selector {
		case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
			item.Bounds = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fp.selector))
		}
	}
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Distribution_BucketOptions_Explicit))
}

// IsLeaf - whether field path is holds simple value
func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DistributionBucketOptionsExplicit_FieldPathSelectorBounds
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) WithIValue(value interface{}) DistributionBucketOptionsExplicit_FieldPathValue {
	switch fp.selector {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		return &DistributionBucketOptionsExplicit_FieldTerminalPathValue{DistributionBucketOptionsExplicit_FieldTerminalPath: *fp, value: value.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) WithIArrayOfValues(values interface{}) DistributionBucketOptionsExplicit_FieldPathArrayOfValues {
	fpaov := &DistributionBucketOptionsExplicit_FieldTerminalPathArrayOfValues{DistributionBucketOptionsExplicit_FieldTerminalPath: *fp}
	switch fp.selector {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		return &DistributionBucketOptionsExplicit_FieldTerminalPathArrayOfValues{DistributionBucketOptionsExplicit_FieldTerminalPath: *fp, values: values.([][]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fp.selector))
	}
	return fpaov
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) WithIArrayItemValue(value interface{}) DistributionBucketOptionsExplicit_FieldPathArrayItemValue {
	switch fp.selector {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		return &DistributionBucketOptionsExplicit_FieldTerminalPathArrayItemValue{DistributionBucketOptionsExplicit_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsExplicit_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DistributionBucketOptionsExplicit_FieldPathValue allows storing values for Explicit fields according to their type
type DistributionBucketOptionsExplicit_FieldPathValue interface {
	DistributionBucketOptionsExplicit_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Distribution_BucketOptions_Explicit)
	CompareWith(*Distribution_BucketOptions_Explicit) (cmp int, comparable bool)
}

func ParseDistributionBucketOptionsExplicit_FieldPathValue(pathStr, valueStr string) (DistributionBucketOptionsExplicit_FieldPathValue, error) {
	fp, err := ParseDistributionBucketOptionsExplicit_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Explicit field path value from %s: %v", valueStr, err)
	}
	return fpv.(DistributionBucketOptionsExplicit_FieldPathValue), nil
}

func MustParseDistributionBucketOptionsExplicit_FieldPathValue(pathStr, valueStr string) DistributionBucketOptionsExplicit_FieldPathValue {
	fpv, err := ParseDistributionBucketOptionsExplicit_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DistributionBucketOptionsExplicit_FieldTerminalPathValue struct {
	DistributionBucketOptionsExplicit_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptionsExplicit_FieldPathValue = (*DistributionBucketOptionsExplicit_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Explicit' as interface{}
func (fpv *DistributionBucketOptionsExplicit_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DistributionBucketOptionsExplicit_FieldTerminalPathValue) AsBoundsValue() ([]float64, bool) {
	res, ok := fpv.value.([]float64)
	return res, ok
}

// SetTo stores value for selected field for object Explicit
func (fpv *DistributionBucketOptionsExplicit_FieldTerminalPathValue) SetTo(target **Distribution_BucketOptions_Explicit) {
	if *target == nil {
		*target = new(Distribution_BucketOptions_Explicit)
	}
	switch fpv.selector {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		(*target).Bounds = fpv.value.([]float64)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptionsExplicit_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution_BucketOptions_Explicit)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DistributionBucketOptionsExplicit_FieldTerminalPathValue' with the value under path in 'Distribution_BucketOptions_Explicit'.
func (fpv *DistributionBucketOptionsExplicit_FieldTerminalPathValue) CompareWith(source *Distribution_BucketOptions_Explicit) (int, bool) {
	switch fpv.selector {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Explicit: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptionsExplicit_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Distribution_BucketOptions_Explicit))
}

// DistributionBucketOptionsExplicit_FieldPathArrayItemValue allows storing single item in Path-specific values for Explicit according to their type
// Present only for array (repeated) types.
type DistributionBucketOptionsExplicit_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DistributionBucketOptionsExplicit_FieldPath
	ContainsValue(*Distribution_BucketOptions_Explicit) bool
}

// ParseDistributionBucketOptionsExplicit_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDistributionBucketOptionsExplicit_FieldPathArrayItemValue(pathStr, valueStr string) (DistributionBucketOptionsExplicit_FieldPathArrayItemValue, error) {
	fp, err := ParseDistributionBucketOptionsExplicit_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Explicit field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DistributionBucketOptionsExplicit_FieldPathArrayItemValue), nil
}

func MustParseDistributionBucketOptionsExplicit_FieldPathArrayItemValue(pathStr, valueStr string) DistributionBucketOptionsExplicit_FieldPathArrayItemValue {
	fpaiv, err := ParseDistributionBucketOptionsExplicit_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DistributionBucketOptionsExplicit_FieldTerminalPathArrayItemValue struct {
	DistributionBucketOptionsExplicit_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptionsExplicit_FieldPathArrayItemValue = (*DistributionBucketOptionsExplicit_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Distribution_BucketOptions_Explicit as interface{}
func (fpaiv *DistributionBucketOptionsExplicit_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *DistributionBucketOptionsExplicit_FieldTerminalPathArrayItemValue) AsBoundsItemValue() (float64, bool) {
	res, ok := fpaiv.value.(float64)
	return res, ok
}

func (fpaiv *DistributionBucketOptionsExplicit_FieldTerminalPathArrayItemValue) GetSingle(source *Distribution_BucketOptions_Explicit) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DistributionBucketOptionsExplicit_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Distribution_BucketOptions_Explicit))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Explicit'
func (fpaiv *DistributionBucketOptionsExplicit_FieldTerminalPathArrayItemValue) ContainsValue(source *Distribution_BucketOptions_Explicit) bool {
	slice := fpaiv.DistributionBucketOptionsExplicit_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DistributionBucketOptionsExplicit_FieldPathArrayOfValues allows storing slice of values for Explicit fields according to their type
type DistributionBucketOptionsExplicit_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DistributionBucketOptionsExplicit_FieldPath
}

func ParseDistributionBucketOptionsExplicit_FieldPathArrayOfValues(pathStr, valuesStr string) (DistributionBucketOptionsExplicit_FieldPathArrayOfValues, error) {
	fp, err := ParseDistributionBucketOptionsExplicit_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Explicit field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DistributionBucketOptionsExplicit_FieldPathArrayOfValues), nil
}

func MustParseDistributionBucketOptionsExplicit_FieldPathArrayOfValues(pathStr, valuesStr string) DistributionBucketOptionsExplicit_FieldPathArrayOfValues {
	fpaov, err := ParseDistributionBucketOptionsExplicit_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DistributionBucketOptionsExplicit_FieldTerminalPathArrayOfValues struct {
	DistributionBucketOptionsExplicit_FieldTerminalPath
	values interface{}
}

var _ DistributionBucketOptionsExplicit_FieldPathArrayOfValues = (*DistributionBucketOptionsExplicit_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DistributionBucketOptionsExplicit_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DistributionBucketOptionsExplicit_FieldPathSelectorBounds:
		for _, v := range fpaov.values.([][]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DistributionBucketOptionsExplicit_FieldTerminalPathArrayOfValues) AsBoundsArrayOfValues() ([][]float64, bool) {
	res, ok := fpaov.values.([][]float64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DistributionBucketOptionsDynamic_FieldPath interface {
	gotenobject.FieldPath
	Selector() DistributionBucketOptionsDynamic_FieldPathSelector
	Get(source *Distribution_BucketOptions_Dynamic) []interface{}
	GetSingle(source *Distribution_BucketOptions_Dynamic) (interface{}, bool)
	ClearValue(item *Distribution_BucketOptions_Dynamic)

	// Those methods build corresponding DistributionBucketOptionsDynamic_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DistributionBucketOptionsDynamic_FieldPathValue
	WithIArrayOfValues(values interface{}) DistributionBucketOptionsDynamic_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DistributionBucketOptionsDynamic_FieldPathArrayItemValue
}

type DistributionBucketOptionsDynamic_FieldPathSelector int32

const (
	DistributionBucketOptionsDynamic_FieldPathSelectorCompression DistributionBucketOptionsDynamic_FieldPathSelector = 0
	DistributionBucketOptionsDynamic_FieldPathSelectorMeans       DistributionBucketOptionsDynamic_FieldPathSelector = 1
)

func (s DistributionBucketOptionsDynamic_FieldPathSelector) String() string {
	switch s {
	case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
		return "compression"
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		return "means"
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", s))
	}
}

func BuildDistributionBucketOptionsDynamic_FieldPath(fp gotenobject.RawFieldPath) (DistributionBucketOptionsDynamic_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Distribution_BucketOptions_Dynamic")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "compression":
			return &DistributionBucketOptionsDynamic_FieldTerminalPath{selector: DistributionBucketOptionsDynamic_FieldPathSelectorCompression}, nil
		case "means":
			return &DistributionBucketOptionsDynamic_FieldTerminalPath{selector: DistributionBucketOptionsDynamic_FieldPathSelectorMeans}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Distribution_BucketOptions_Dynamic", fp)
}

func ParseDistributionBucketOptionsDynamic_FieldPath(rawField string) (DistributionBucketOptionsDynamic_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDistributionBucketOptionsDynamic_FieldPath(fp)
}

func MustParseDistributionBucketOptionsDynamic_FieldPath(rawField string) DistributionBucketOptionsDynamic_FieldPath {
	fp, err := ParseDistributionBucketOptionsDynamic_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DistributionBucketOptionsDynamic_FieldTerminalPath struct {
	selector DistributionBucketOptionsDynamic_FieldPathSelector
}

var _ DistributionBucketOptionsDynamic_FieldPath = (*DistributionBucketOptionsDynamic_FieldTerminalPath)(nil)

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) Selector() DistributionBucketOptionsDynamic_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Distribution_BucketOptions_Dynamic
func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) Get(source *Distribution_BucketOptions_Dynamic) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
			values = append(values, source.Compression)
		case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
			for _, value := range source.GetMeans() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fp.selector))
		}
	}
	return
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Distribution_BucketOptions_Dynamic))
}

// GetSingle returns value pointed by specific field of from source Distribution_BucketOptions_Dynamic
func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) GetSingle(source *Distribution_BucketOptions_Dynamic) (interface{}, bool) {
	switch fp.selector {
	case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
		return source.GetCompression(), source != nil
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		res := source.GetMeans()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Distribution_BucketOptions_Dynamic))
}

// GetDefault returns a default value of the field type
func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
		return float64(0)
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		return ([]float64)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) ClearValue(item *Distribution_BucketOptions_Dynamic) {
	if item != nil {
		switch fp.selector {
		case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
			item.Compression = float64(0)
		case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
			item.Means = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fp.selector))
		}
	}
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Distribution_BucketOptions_Dynamic))
}

// IsLeaf - whether field path is holds simple value
func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DistributionBucketOptionsDynamic_FieldPathSelectorCompression ||
		fp.selector == DistributionBucketOptionsDynamic_FieldPathSelectorMeans
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) WithIValue(value interface{}) DistributionBucketOptionsDynamic_FieldPathValue {
	switch fp.selector {
	case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
		return &DistributionBucketOptionsDynamic_FieldTerminalPathValue{DistributionBucketOptionsDynamic_FieldTerminalPath: *fp, value: value.(float64)}
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		return &DistributionBucketOptionsDynamic_FieldTerminalPathValue{DistributionBucketOptionsDynamic_FieldTerminalPath: *fp, value: value.([]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) WithIArrayOfValues(values interface{}) DistributionBucketOptionsDynamic_FieldPathArrayOfValues {
	fpaov := &DistributionBucketOptionsDynamic_FieldTerminalPathArrayOfValues{DistributionBucketOptionsDynamic_FieldTerminalPath: *fp}
	switch fp.selector {
	case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
		return &DistributionBucketOptionsDynamic_FieldTerminalPathArrayOfValues{DistributionBucketOptionsDynamic_FieldTerminalPath: *fp, values: values.([]float64)}
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		return &DistributionBucketOptionsDynamic_FieldTerminalPathArrayOfValues{DistributionBucketOptionsDynamic_FieldTerminalPath: *fp, values: values.([][]float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fp.selector))
	}
	return fpaov
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) WithIArrayItemValue(value interface{}) DistributionBucketOptionsDynamic_FieldPathArrayItemValue {
	switch fp.selector {
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		return &DistributionBucketOptionsDynamic_FieldTerminalPathArrayItemValue{DistributionBucketOptionsDynamic_FieldTerminalPath: *fp, value: value.(float64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fp.selector))
	}
}

func (fp *DistributionBucketOptionsDynamic_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DistributionBucketOptionsDynamic_FieldPathValue allows storing values for Dynamic fields according to their type
type DistributionBucketOptionsDynamic_FieldPathValue interface {
	DistributionBucketOptionsDynamic_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Distribution_BucketOptions_Dynamic)
	CompareWith(*Distribution_BucketOptions_Dynamic) (cmp int, comparable bool)
}

func ParseDistributionBucketOptionsDynamic_FieldPathValue(pathStr, valueStr string) (DistributionBucketOptionsDynamic_FieldPathValue, error) {
	fp, err := ParseDistributionBucketOptionsDynamic_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Dynamic field path value from %s: %v", valueStr, err)
	}
	return fpv.(DistributionBucketOptionsDynamic_FieldPathValue), nil
}

func MustParseDistributionBucketOptionsDynamic_FieldPathValue(pathStr, valueStr string) DistributionBucketOptionsDynamic_FieldPathValue {
	fpv, err := ParseDistributionBucketOptionsDynamic_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DistributionBucketOptionsDynamic_FieldTerminalPathValue struct {
	DistributionBucketOptionsDynamic_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptionsDynamic_FieldPathValue = (*DistributionBucketOptionsDynamic_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Dynamic' as interface{}
func (fpv *DistributionBucketOptionsDynamic_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DistributionBucketOptionsDynamic_FieldTerminalPathValue) AsCompressionValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}
func (fpv *DistributionBucketOptionsDynamic_FieldTerminalPathValue) AsMeansValue() ([]float64, bool) {
	res, ok := fpv.value.([]float64)
	return res, ok
}

// SetTo stores value for selected field for object Dynamic
func (fpv *DistributionBucketOptionsDynamic_FieldTerminalPathValue) SetTo(target **Distribution_BucketOptions_Dynamic) {
	if *target == nil {
		*target = new(Distribution_BucketOptions_Dynamic)
	}
	switch fpv.selector {
	case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
		(*target).Compression = fpv.value.(float64)
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		(*target).Means = fpv.value.([]float64)
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptionsDynamic_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Distribution_BucketOptions_Dynamic)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DistributionBucketOptionsDynamic_FieldTerminalPathValue' with the value under path in 'Distribution_BucketOptions_Dynamic'.
func (fpv *DistributionBucketOptionsDynamic_FieldTerminalPathValue) CompareWith(source *Distribution_BucketOptions_Dynamic) (int, bool) {
	switch fpv.selector {
	case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
		leftValue := fpv.value.(float64)
		rightValue := source.GetCompression()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Distribution_BucketOptions_Dynamic: %d", fpv.selector))
	}
}

func (fpv *DistributionBucketOptionsDynamic_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Distribution_BucketOptions_Dynamic))
}

// DistributionBucketOptionsDynamic_FieldPathArrayItemValue allows storing single item in Path-specific values for Dynamic according to their type
// Present only for array (repeated) types.
type DistributionBucketOptionsDynamic_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DistributionBucketOptionsDynamic_FieldPath
	ContainsValue(*Distribution_BucketOptions_Dynamic) bool
}

// ParseDistributionBucketOptionsDynamic_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDistributionBucketOptionsDynamic_FieldPathArrayItemValue(pathStr, valueStr string) (DistributionBucketOptionsDynamic_FieldPathArrayItemValue, error) {
	fp, err := ParseDistributionBucketOptionsDynamic_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Dynamic field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DistributionBucketOptionsDynamic_FieldPathArrayItemValue), nil
}

func MustParseDistributionBucketOptionsDynamic_FieldPathArrayItemValue(pathStr, valueStr string) DistributionBucketOptionsDynamic_FieldPathArrayItemValue {
	fpaiv, err := ParseDistributionBucketOptionsDynamic_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DistributionBucketOptionsDynamic_FieldTerminalPathArrayItemValue struct {
	DistributionBucketOptionsDynamic_FieldTerminalPath
	value interface{}
}

var _ DistributionBucketOptionsDynamic_FieldPathArrayItemValue = (*DistributionBucketOptionsDynamic_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Distribution_BucketOptions_Dynamic as interface{}
func (fpaiv *DistributionBucketOptionsDynamic_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *DistributionBucketOptionsDynamic_FieldTerminalPathArrayItemValue) AsMeansItemValue() (float64, bool) {
	res, ok := fpaiv.value.(float64)
	return res, ok
}

func (fpaiv *DistributionBucketOptionsDynamic_FieldTerminalPathArrayItemValue) GetSingle(source *Distribution_BucketOptions_Dynamic) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DistributionBucketOptionsDynamic_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Distribution_BucketOptions_Dynamic))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Dynamic'
func (fpaiv *DistributionBucketOptionsDynamic_FieldTerminalPathArrayItemValue) ContainsValue(source *Distribution_BucketOptions_Dynamic) bool {
	slice := fpaiv.DistributionBucketOptionsDynamic_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DistributionBucketOptionsDynamic_FieldPathArrayOfValues allows storing slice of values for Dynamic fields according to their type
type DistributionBucketOptionsDynamic_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DistributionBucketOptionsDynamic_FieldPath
}

func ParseDistributionBucketOptionsDynamic_FieldPathArrayOfValues(pathStr, valuesStr string) (DistributionBucketOptionsDynamic_FieldPathArrayOfValues, error) {
	fp, err := ParseDistributionBucketOptionsDynamic_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Dynamic field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DistributionBucketOptionsDynamic_FieldPathArrayOfValues), nil
}

func MustParseDistributionBucketOptionsDynamic_FieldPathArrayOfValues(pathStr, valuesStr string) DistributionBucketOptionsDynamic_FieldPathArrayOfValues {
	fpaov, err := ParseDistributionBucketOptionsDynamic_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DistributionBucketOptionsDynamic_FieldTerminalPathArrayOfValues struct {
	DistributionBucketOptionsDynamic_FieldTerminalPath
	values interface{}
}

var _ DistributionBucketOptionsDynamic_FieldPathArrayOfValues = (*DistributionBucketOptionsDynamic_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DistributionBucketOptionsDynamic_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DistributionBucketOptionsDynamic_FieldPathSelectorCompression:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	case DistributionBucketOptionsDynamic_FieldPathSelectorMeans:
		for _, v := range fpaov.values.([][]float64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DistributionBucketOptionsDynamic_FieldTerminalPathArrayOfValues) AsCompressionArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}
func (fpaov *DistributionBucketOptionsDynamic_FieldTerminalPathArrayOfValues) AsMeansArrayOfValues() ([][]float64, bool) {
	res, ok := fpaov.values.([][]float64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type TypedValue_FieldPath interface {
	gotenobject.FieldPath
	Selector() TypedValue_FieldPathSelector
	Get(source *TypedValue) []interface{}
	GetSingle(source *TypedValue) (interface{}, bool)
	ClearValue(item *TypedValue)

	// Those methods build corresponding TypedValue_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) TypedValue_FieldPathValue
	WithIArrayOfValues(values interface{}) TypedValue_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) TypedValue_FieldPathArrayItemValue
}

type TypedValue_FieldPathSelector int32

const (
	TypedValue_FieldPathSelectorBoolValue         TypedValue_FieldPathSelector = 0
	TypedValue_FieldPathSelectorInt64Value        TypedValue_FieldPathSelector = 1
	TypedValue_FieldPathSelectorDoubleValue       TypedValue_FieldPathSelector = 2
	TypedValue_FieldPathSelectorStringValue       TypedValue_FieldPathSelector = 3
	TypedValue_FieldPathSelectorDistributionValue TypedValue_FieldPathSelector = 4
)

func (s TypedValue_FieldPathSelector) String() string {
	switch s {
	case TypedValue_FieldPathSelectorBoolValue:
		return "bool_value"
	case TypedValue_FieldPathSelectorInt64Value:
		return "int64_value"
	case TypedValue_FieldPathSelectorDoubleValue:
		return "double_value"
	case TypedValue_FieldPathSelectorStringValue:
		return "string_value"
	case TypedValue_FieldPathSelectorDistributionValue:
		return "distribution_value"
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", s))
	}
}

func BuildTypedValue_FieldPath(fp gotenobject.RawFieldPath) (TypedValue_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object TypedValue")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "bool_value", "boolValue", "bool-value":
			return &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorBoolValue}, nil
		case "int64_value", "int64Value", "int64-value":
			return &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorInt64Value}, nil
		case "double_value", "doubleValue", "double-value":
			return &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorDoubleValue}, nil
		case "string_value", "stringValue", "string-value":
			return &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorStringValue}, nil
		case "distribution_value", "distributionValue", "distribution-value":
			return &TypedValue_FieldTerminalPath{selector: TypedValue_FieldPathSelectorDistributionValue}, nil
		}
	} else {
		switch fp[0] {
		case "distribution_value", "distributionValue", "distribution-value":
			if subpath, err := BuildDistribution_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &TypedValue_FieldSubPath{selector: TypedValue_FieldPathSelectorDistributionValue, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object TypedValue", fp)
}

func ParseTypedValue_FieldPath(rawField string) (TypedValue_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildTypedValue_FieldPath(fp)
}

func MustParseTypedValue_FieldPath(rawField string) TypedValue_FieldPath {
	fp, err := ParseTypedValue_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type TypedValue_FieldTerminalPath struct {
	selector TypedValue_FieldPathSelector
}

var _ TypedValue_FieldPath = (*TypedValue_FieldTerminalPath)(nil)

func (fp *TypedValue_FieldTerminalPath) Selector() TypedValue_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *TypedValue_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *TypedValue_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source TypedValue
func (fp *TypedValue_FieldTerminalPath) Get(source *TypedValue) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case TypedValue_FieldPathSelectorBoolValue:
			if source, ok := source.Value.(*TypedValue_BoolValue); ok && source != nil {
				values = append(values, source.BoolValue)
			}
		case TypedValue_FieldPathSelectorInt64Value:
			if source, ok := source.Value.(*TypedValue_Int64Value); ok && source != nil {
				values = append(values, source.Int64Value)
			}
		case TypedValue_FieldPathSelectorDoubleValue:
			if source, ok := source.Value.(*TypedValue_DoubleValue); ok && source != nil {
				values = append(values, source.DoubleValue)
			}
		case TypedValue_FieldPathSelectorStringValue:
			if source, ok := source.Value.(*TypedValue_StringValue); ok && source != nil {
				values = append(values, source.StringValue)
			}
		case TypedValue_FieldPathSelectorDistributionValue:
			if source, ok := source.Value.(*TypedValue_DistributionValue); ok && source != nil {
				if source.DistributionValue != nil {
					values = append(values, source.DistributionValue)
				}
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fp.selector))
		}
	}
	return
}

func (fp *TypedValue_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*TypedValue))
}

// GetSingle returns value pointed by specific field of from source TypedValue
func (fp *TypedValue_FieldTerminalPath) GetSingle(source *TypedValue) (interface{}, bool) {
	switch fp.selector {
	case TypedValue_FieldPathSelectorBoolValue:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetBoolValue(), false
		}
		_, oneOfSelected := source.Value.(*TypedValue_BoolValue)
		if !oneOfSelected {
			return source.GetBoolValue(), false // to return "type" information
		}
		return source.GetBoolValue(), source != nil
	case TypedValue_FieldPathSelectorInt64Value:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetInt64Value(), false
		}
		_, oneOfSelected := source.Value.(*TypedValue_Int64Value)
		if !oneOfSelected {
			return source.GetInt64Value(), false // to return "type" information
		}
		return source.GetInt64Value(), source != nil
	case TypedValue_FieldPathSelectorDoubleValue:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetDoubleValue(), false
		}
		_, oneOfSelected := source.Value.(*TypedValue_DoubleValue)
		if !oneOfSelected {
			return source.GetDoubleValue(), false // to return "type" information
		}
		return source.GetDoubleValue(), source != nil
	case TypedValue_FieldPathSelectorStringValue:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetStringValue(), false
		}
		_, oneOfSelected := source.Value.(*TypedValue_StringValue)
		if !oneOfSelected {
			return source.GetStringValue(), false // to return "type" information
		}
		return source.GetStringValue(), source != nil
	case TypedValue_FieldPathSelectorDistributionValue:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetDistributionValue(), false
		}
		_, oneOfSelected := source.Value.(*TypedValue_DistributionValue)
		if !oneOfSelected {
			return source.GetDistributionValue(), false // to return "type" information
		}
		res := source.GetDistributionValue()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fp.selector))
	}
}

func (fp *TypedValue_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*TypedValue))
}

// GetDefault returns a default value of the field type
func (fp *TypedValue_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case TypedValue_FieldPathSelectorBoolValue:
		return false
	case TypedValue_FieldPathSelectorInt64Value:
		return int64(0)
	case TypedValue_FieldPathSelectorDoubleValue:
		return float64(0)
	case TypedValue_FieldPathSelectorStringValue:
		return ""
	case TypedValue_FieldPathSelectorDistributionValue:
		return (*Distribution)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fp.selector))
	}
}

func (fp *TypedValue_FieldTerminalPath) ClearValue(item *TypedValue) {
	if item != nil {
		switch fp.selector {
		case TypedValue_FieldPathSelectorBoolValue:
			if item, ok := item.Value.(*TypedValue_BoolValue); ok {
				item.BoolValue = false
			}
		case TypedValue_FieldPathSelectorInt64Value:
			if item, ok := item.Value.(*TypedValue_Int64Value); ok {
				item.Int64Value = int64(0)
			}
		case TypedValue_FieldPathSelectorDoubleValue:
			if item, ok := item.Value.(*TypedValue_DoubleValue); ok {
				item.DoubleValue = float64(0)
			}
		case TypedValue_FieldPathSelectorStringValue:
			if item, ok := item.Value.(*TypedValue_StringValue); ok {
				item.StringValue = ""
			}
		case TypedValue_FieldPathSelectorDistributionValue:
			if item, ok := item.Value.(*TypedValue_DistributionValue); ok {
				item.DistributionValue = nil
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fp.selector))
		}
	}
}

func (fp *TypedValue_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*TypedValue))
}

// IsLeaf - whether field path is holds simple value
func (fp *TypedValue_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == TypedValue_FieldPathSelectorBoolValue ||
		fp.selector == TypedValue_FieldPathSelectorInt64Value ||
		fp.selector == TypedValue_FieldPathSelectorDoubleValue ||
		fp.selector == TypedValue_FieldPathSelectorStringValue
}

func (fp *TypedValue_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *TypedValue_FieldTerminalPath) WithIValue(value interface{}) TypedValue_FieldPathValue {
	switch fp.selector {
	case TypedValue_FieldPathSelectorBoolValue:
		return &TypedValue_FieldTerminalPathValue{TypedValue_FieldTerminalPath: *fp, value: value.(bool)}
	case TypedValue_FieldPathSelectorInt64Value:
		return &TypedValue_FieldTerminalPathValue{TypedValue_FieldTerminalPath: *fp, value: value.(int64)}
	case TypedValue_FieldPathSelectorDoubleValue:
		return &TypedValue_FieldTerminalPathValue{TypedValue_FieldTerminalPath: *fp, value: value.(float64)}
	case TypedValue_FieldPathSelectorStringValue:
		return &TypedValue_FieldTerminalPathValue{TypedValue_FieldTerminalPath: *fp, value: value.(string)}
	case TypedValue_FieldPathSelectorDistributionValue:
		return &TypedValue_FieldTerminalPathValue{TypedValue_FieldTerminalPath: *fp, value: value.(*Distribution)}
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fp.selector))
	}
}

func (fp *TypedValue_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *TypedValue_FieldTerminalPath) WithIArrayOfValues(values interface{}) TypedValue_FieldPathArrayOfValues {
	fpaov := &TypedValue_FieldTerminalPathArrayOfValues{TypedValue_FieldTerminalPath: *fp}
	switch fp.selector {
	case TypedValue_FieldPathSelectorBoolValue:
		return &TypedValue_FieldTerminalPathArrayOfValues{TypedValue_FieldTerminalPath: *fp, values: values.([]bool)}
	case TypedValue_FieldPathSelectorInt64Value:
		return &TypedValue_FieldTerminalPathArrayOfValues{TypedValue_FieldTerminalPath: *fp, values: values.([]int64)}
	case TypedValue_FieldPathSelectorDoubleValue:
		return &TypedValue_FieldTerminalPathArrayOfValues{TypedValue_FieldTerminalPath: *fp, values: values.([]float64)}
	case TypedValue_FieldPathSelectorStringValue:
		return &TypedValue_FieldTerminalPathArrayOfValues{TypedValue_FieldTerminalPath: *fp, values: values.([]string)}
	case TypedValue_FieldPathSelectorDistributionValue:
		return &TypedValue_FieldTerminalPathArrayOfValues{TypedValue_FieldTerminalPath: *fp, values: values.([]*Distribution)}
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fp.selector))
	}
	return fpaov
}

func (fp *TypedValue_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *TypedValue_FieldTerminalPath) WithIArrayItemValue(value interface{}) TypedValue_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fp.selector))
	}
}

func (fp *TypedValue_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type TypedValue_FieldSubPath struct {
	selector TypedValue_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ TypedValue_FieldPath = (*TypedValue_FieldSubPath)(nil)

func (fps *TypedValue_FieldSubPath) Selector() TypedValue_FieldPathSelector {
	return fps.selector
}
func (fps *TypedValue_FieldSubPath) AsDistributionValueSubPath() (Distribution_FieldPath, bool) {
	res, ok := fps.subPath.(Distribution_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *TypedValue_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *TypedValue_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source TypedValue
func (fps *TypedValue_FieldSubPath) Get(source *TypedValue) (values []interface{}) {
	switch fps.selector {
	case TypedValue_FieldPathSelectorDistributionValue:
		values = append(values, fps.subPath.GetRaw(source.GetDistributionValue())...)
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fps.selector))
	}
	return
}

func (fps *TypedValue_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*TypedValue))
}

// GetSingle returns value of selected field from source TypedValue
func (fps *TypedValue_FieldSubPath) GetSingle(source *TypedValue) (interface{}, bool) {
	switch fps.selector {
	case TypedValue_FieldPathSelectorDistributionValue:
		if source.GetDistributionValue() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetDistributionValue())
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fps.selector))
	}
}

func (fps *TypedValue_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*TypedValue))
}

// GetDefault returns a default value of the field type
func (fps *TypedValue_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *TypedValue_FieldSubPath) ClearValue(item *TypedValue) {
	if item != nil {
		switch fps.selector {
		case TypedValue_FieldPathSelectorDistributionValue:
			if item.Value != nil {
				if item, ok := item.Value.(*TypedValue_DistributionValue); ok {
					fps.subPath.ClearValueRaw(item.DistributionValue)
				}
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fps.selector))
		}
	}
}

func (fps *TypedValue_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*TypedValue))
}

// IsLeaf - whether field path is holds simple value
func (fps *TypedValue_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *TypedValue_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&TypedValue_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *TypedValue_FieldSubPath) WithIValue(value interface{}) TypedValue_FieldPathValue {
	return &TypedValue_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *TypedValue_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *TypedValue_FieldSubPath) WithIArrayOfValues(values interface{}) TypedValue_FieldPathArrayOfValues {
	return &TypedValue_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *TypedValue_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *TypedValue_FieldSubPath) WithIArrayItemValue(value interface{}) TypedValue_FieldPathArrayItemValue {
	return &TypedValue_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *TypedValue_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// TypedValue_FieldPathValue allows storing values for TypedValue fields according to their type
type TypedValue_FieldPathValue interface {
	TypedValue_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **TypedValue)
	CompareWith(*TypedValue) (cmp int, comparable bool)
}

func ParseTypedValue_FieldPathValue(pathStr, valueStr string) (TypedValue_FieldPathValue, error) {
	fp, err := ParseTypedValue_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TypedValue field path value from %s: %v", valueStr, err)
	}
	return fpv.(TypedValue_FieldPathValue), nil
}

func MustParseTypedValue_FieldPathValue(pathStr, valueStr string) TypedValue_FieldPathValue {
	fpv, err := ParseTypedValue_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type TypedValue_FieldTerminalPathValue struct {
	TypedValue_FieldTerminalPath
	value interface{}
}

var _ TypedValue_FieldPathValue = (*TypedValue_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'TypedValue' as interface{}
func (fpv *TypedValue_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *TypedValue_FieldTerminalPathValue) AsBoolValueValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *TypedValue_FieldTerminalPathValue) AsInt64ValueValue() (int64, bool) {
	res, ok := fpv.value.(int64)
	return res, ok
}
func (fpv *TypedValue_FieldTerminalPathValue) AsDoubleValueValue() (float64, bool) {
	res, ok := fpv.value.(float64)
	return res, ok
}
func (fpv *TypedValue_FieldTerminalPathValue) AsStringValueValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *TypedValue_FieldTerminalPathValue) AsDistributionValueValue() (*Distribution, bool) {
	res, ok := fpv.value.(*Distribution)
	return res, ok
}

// SetTo stores value for selected field for object TypedValue
func (fpv *TypedValue_FieldTerminalPathValue) SetTo(target **TypedValue) {
	if *target == nil {
		*target = new(TypedValue)
	}
	switch fpv.selector {
	case TypedValue_FieldPathSelectorBoolValue:
		if _, ok := (*target).Value.(*TypedValue_BoolValue); !ok {
			(*target).Value = &TypedValue_BoolValue{}
		}
		(*target).Value.(*TypedValue_BoolValue).BoolValue = fpv.value.(bool)
	case TypedValue_FieldPathSelectorInt64Value:
		if _, ok := (*target).Value.(*TypedValue_Int64Value); !ok {
			(*target).Value = &TypedValue_Int64Value{}
		}
		(*target).Value.(*TypedValue_Int64Value).Int64Value = fpv.value.(int64)
	case TypedValue_FieldPathSelectorDoubleValue:
		if _, ok := (*target).Value.(*TypedValue_DoubleValue); !ok {
			(*target).Value = &TypedValue_DoubleValue{}
		}
		(*target).Value.(*TypedValue_DoubleValue).DoubleValue = fpv.value.(float64)
	case TypedValue_FieldPathSelectorStringValue:
		if _, ok := (*target).Value.(*TypedValue_StringValue); !ok {
			(*target).Value = &TypedValue_StringValue{}
		}
		(*target).Value.(*TypedValue_StringValue).StringValue = fpv.value.(string)
	case TypedValue_FieldPathSelectorDistributionValue:
		if _, ok := (*target).Value.(*TypedValue_DistributionValue); !ok {
			(*target).Value = &TypedValue_DistributionValue{}
		}
		(*target).Value.(*TypedValue_DistributionValue).DistributionValue = fpv.value.(*Distribution)
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fpv.selector))
	}
}

func (fpv *TypedValue_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TypedValue)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'TypedValue_FieldTerminalPathValue' with the value under path in 'TypedValue'.
func (fpv *TypedValue_FieldTerminalPathValue) CompareWith(source *TypedValue) (int, bool) {
	switch fpv.selector {
	case TypedValue_FieldPathSelectorBoolValue:
		leftValue := fpv.value.(bool)
		rightValue := source.GetBoolValue()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case TypedValue_FieldPathSelectorInt64Value:
		leftValue := fpv.value.(int64)
		rightValue := source.GetInt64Value()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case TypedValue_FieldPathSelectorDoubleValue:
		leftValue := fpv.value.(float64)
		rightValue := source.GetDoubleValue()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case TypedValue_FieldPathSelectorStringValue:
		leftValue := fpv.value.(string)
		rightValue := source.GetStringValue()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case TypedValue_FieldPathSelectorDistributionValue:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fpv.selector))
	}
}

func (fpv *TypedValue_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*TypedValue))
}

type TypedValue_FieldSubPathValue struct {
	TypedValue_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ TypedValue_FieldPathValue = (*TypedValue_FieldSubPathValue)(nil)

func (fpvs *TypedValue_FieldSubPathValue) AsDistributionValuePathValue() (Distribution_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(Distribution_FieldPathValue)
	return res, ok
}

func (fpvs *TypedValue_FieldSubPathValue) SetTo(target **TypedValue) {
	if *target == nil {
		*target = new(TypedValue)
	}
	switch fpvs.Selector() {
	case TypedValue_FieldPathSelectorDistributionValue:
		if _, ok := (*target).Value.(*TypedValue_DistributionValue); !ok {
			(*target).Value = &TypedValue_DistributionValue{}
		}
		fpvs.subPathValue.(Distribution_FieldPathValue).SetTo(&(*target).Value.(*TypedValue_DistributionValue).DistributionValue)
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fpvs.Selector()))
	}
}

func (fpvs *TypedValue_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TypedValue)
	fpvs.SetTo(&typedObject)
}

func (fpvs *TypedValue_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *TypedValue_FieldSubPathValue) CompareWith(source *TypedValue) (int, bool) {
	switch fpvs.Selector() {
	case TypedValue_FieldPathSelectorDistributionValue:
		return fpvs.subPathValue.(Distribution_FieldPathValue).CompareWith(source.GetDistributionValue())
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fpvs.Selector()))
	}
}

func (fpvs *TypedValue_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*TypedValue))
}

// TypedValue_FieldPathArrayItemValue allows storing single item in Path-specific values for TypedValue according to their type
// Present only for array (repeated) types.
type TypedValue_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	TypedValue_FieldPath
	ContainsValue(*TypedValue) bool
}

// ParseTypedValue_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseTypedValue_FieldPathArrayItemValue(pathStr, valueStr string) (TypedValue_FieldPathArrayItemValue, error) {
	fp, err := ParseTypedValue_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TypedValue field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(TypedValue_FieldPathArrayItemValue), nil
}

func MustParseTypedValue_FieldPathArrayItemValue(pathStr, valueStr string) TypedValue_FieldPathArrayItemValue {
	fpaiv, err := ParseTypedValue_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type TypedValue_FieldTerminalPathArrayItemValue struct {
	TypedValue_FieldTerminalPath
	value interface{}
}

var _ TypedValue_FieldPathArrayItemValue = (*TypedValue_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object TypedValue as interface{}
func (fpaiv *TypedValue_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *TypedValue_FieldTerminalPathArrayItemValue) GetSingle(source *TypedValue) (interface{}, bool) {
	return nil, false
}

func (fpaiv *TypedValue_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*TypedValue))
}

// Contains returns a boolean indicating if value that is being held is present in given 'TypedValue'
func (fpaiv *TypedValue_FieldTerminalPathArrayItemValue) ContainsValue(source *TypedValue) bool {
	slice := fpaiv.TypedValue_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type TypedValue_FieldSubPathArrayItemValue struct {
	TypedValue_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *TypedValue_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *TypedValue_FieldSubPathArrayItemValue) AsDistributionValuePathItemValue() (Distribution_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(Distribution_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'TypedValue'
func (fpaivs *TypedValue_FieldSubPathArrayItemValue) ContainsValue(source *TypedValue) bool {
	switch fpaivs.Selector() {
	case TypedValue_FieldPathSelectorDistributionValue:
		return fpaivs.subPathItemValue.(Distribution_FieldPathArrayItemValue).ContainsValue(source.GetDistributionValue())
	default:
		panic(fmt.Sprintf("Invalid selector for TypedValue: %d", fpaivs.Selector()))
	}
}

// TypedValue_FieldPathArrayOfValues allows storing slice of values for TypedValue fields according to their type
type TypedValue_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	TypedValue_FieldPath
}

func ParseTypedValue_FieldPathArrayOfValues(pathStr, valuesStr string) (TypedValue_FieldPathArrayOfValues, error) {
	fp, err := ParseTypedValue_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TypedValue field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(TypedValue_FieldPathArrayOfValues), nil
}

func MustParseTypedValue_FieldPathArrayOfValues(pathStr, valuesStr string) TypedValue_FieldPathArrayOfValues {
	fpaov, err := ParseTypedValue_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type TypedValue_FieldTerminalPathArrayOfValues struct {
	TypedValue_FieldTerminalPath
	values interface{}
}

var _ TypedValue_FieldPathArrayOfValues = (*TypedValue_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *TypedValue_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case TypedValue_FieldPathSelectorBoolValue:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case TypedValue_FieldPathSelectorInt64Value:
		for _, v := range fpaov.values.([]int64) {
			values = append(values, v)
		}
	case TypedValue_FieldPathSelectorDoubleValue:
		for _, v := range fpaov.values.([]float64) {
			values = append(values, v)
		}
	case TypedValue_FieldPathSelectorStringValue:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case TypedValue_FieldPathSelectorDistributionValue:
		for _, v := range fpaov.values.([]*Distribution) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *TypedValue_FieldTerminalPathArrayOfValues) AsBoolValueArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *TypedValue_FieldTerminalPathArrayOfValues) AsInt64ValueArrayOfValues() ([]int64, bool) {
	res, ok := fpaov.values.([]int64)
	return res, ok
}
func (fpaov *TypedValue_FieldTerminalPathArrayOfValues) AsDoubleValueArrayOfValues() ([]float64, bool) {
	res, ok := fpaov.values.([]float64)
	return res, ok
}
func (fpaov *TypedValue_FieldTerminalPathArrayOfValues) AsStringValueArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *TypedValue_FieldTerminalPathArrayOfValues) AsDistributionValueArrayOfValues() ([]*Distribution, bool) {
	res, ok := fpaov.values.([]*Distribution)
	return res, ok
}

type TypedValue_FieldSubPathArrayOfValues struct {
	TypedValue_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ TypedValue_FieldPathArrayOfValues = (*TypedValue_FieldSubPathArrayOfValues)(nil)

func (fpsaov *TypedValue_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *TypedValue_FieldSubPathArrayOfValues) AsDistributionValuePathArrayOfValues() (Distribution_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(Distribution_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type TimeInterval_FieldPath interface {
	gotenobject.FieldPath
	Selector() TimeInterval_FieldPathSelector
	Get(source *TimeInterval) []interface{}
	GetSingle(source *TimeInterval) (interface{}, bool)
	ClearValue(item *TimeInterval)

	// Those methods build corresponding TimeInterval_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) TimeInterval_FieldPathValue
	WithIArrayOfValues(values interface{}) TimeInterval_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) TimeInterval_FieldPathArrayItemValue
}

type TimeInterval_FieldPathSelector int32

const (
	TimeInterval_FieldPathSelectorEndTime   TimeInterval_FieldPathSelector = 0
	TimeInterval_FieldPathSelectorStartTime TimeInterval_FieldPathSelector = 1
)

func (s TimeInterval_FieldPathSelector) String() string {
	switch s {
	case TimeInterval_FieldPathSelectorEndTime:
		return "end_time"
	case TimeInterval_FieldPathSelectorStartTime:
		return "start_time"
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", s))
	}
}

func BuildTimeInterval_FieldPath(fp gotenobject.RawFieldPath) (TimeInterval_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object TimeInterval")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "end_time", "endTime", "end-time":
			return &TimeInterval_FieldTerminalPath{selector: TimeInterval_FieldPathSelectorEndTime}, nil
		case "start_time", "startTime", "start-time":
			return &TimeInterval_FieldTerminalPath{selector: TimeInterval_FieldPathSelectorStartTime}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object TimeInterval", fp)
}

func ParseTimeInterval_FieldPath(rawField string) (TimeInterval_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildTimeInterval_FieldPath(fp)
}

func MustParseTimeInterval_FieldPath(rawField string) TimeInterval_FieldPath {
	fp, err := ParseTimeInterval_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type TimeInterval_FieldTerminalPath struct {
	selector TimeInterval_FieldPathSelector
}

var _ TimeInterval_FieldPath = (*TimeInterval_FieldTerminalPath)(nil)

func (fp *TimeInterval_FieldTerminalPath) Selector() TimeInterval_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *TimeInterval_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *TimeInterval_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source TimeInterval
func (fp *TimeInterval_FieldTerminalPath) Get(source *TimeInterval) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case TimeInterval_FieldPathSelectorEndTime:
			if source.EndTime != nil {
				values = append(values, source.EndTime)
			}
		case TimeInterval_FieldPathSelectorStartTime:
			if source.StartTime != nil {
				values = append(values, source.StartTime)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
		}
	}
	return
}

func (fp *TimeInterval_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*TimeInterval))
}

// GetSingle returns value pointed by specific field of from source TimeInterval
func (fp *TimeInterval_FieldTerminalPath) GetSingle(source *TimeInterval) (interface{}, bool) {
	switch fp.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		res := source.GetEndTime()
		return res, res != nil
	case TimeInterval_FieldPathSelectorStartTime:
		res := source.GetStartTime()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
}

func (fp *TimeInterval_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*TimeInterval))
}

// GetDefault returns a default value of the field type
func (fp *TimeInterval_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		return (*timestamppb.Timestamp)(nil)
	case TimeInterval_FieldPathSelectorStartTime:
		return (*timestamppb.Timestamp)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
}

func (fp *TimeInterval_FieldTerminalPath) ClearValue(item *TimeInterval) {
	if item != nil {
		switch fp.selector {
		case TimeInterval_FieldPathSelectorEndTime:
			item.EndTime = nil
		case TimeInterval_FieldPathSelectorStartTime:
			item.StartTime = nil
		default:
			panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
		}
	}
}

func (fp *TimeInterval_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*TimeInterval))
}

// IsLeaf - whether field path is holds simple value
func (fp *TimeInterval_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == TimeInterval_FieldPathSelectorEndTime ||
		fp.selector == TimeInterval_FieldPathSelectorStartTime
}

func (fp *TimeInterval_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *TimeInterval_FieldTerminalPath) WithIValue(value interface{}) TimeInterval_FieldPathValue {
	switch fp.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		return &TimeInterval_FieldTerminalPathValue{TimeInterval_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	case TimeInterval_FieldPathSelectorStartTime:
		return &TimeInterval_FieldTerminalPathValue{TimeInterval_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
}

func (fp *TimeInterval_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *TimeInterval_FieldTerminalPath) WithIArrayOfValues(values interface{}) TimeInterval_FieldPathArrayOfValues {
	fpaov := &TimeInterval_FieldTerminalPathArrayOfValues{TimeInterval_FieldTerminalPath: *fp}
	switch fp.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		return &TimeInterval_FieldTerminalPathArrayOfValues{TimeInterval_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	case TimeInterval_FieldPathSelectorStartTime:
		return &TimeInterval_FieldTerminalPathArrayOfValues{TimeInterval_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
	return fpaov
}

func (fp *TimeInterval_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *TimeInterval_FieldTerminalPath) WithIArrayItemValue(value interface{}) TimeInterval_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
}

func (fp *TimeInterval_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// TimeInterval_FieldPathValue allows storing values for TimeInterval fields according to their type
type TimeInterval_FieldPathValue interface {
	TimeInterval_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **TimeInterval)
	CompareWith(*TimeInterval) (cmp int, comparable bool)
}

func ParseTimeInterval_FieldPathValue(pathStr, valueStr string) (TimeInterval_FieldPathValue, error) {
	fp, err := ParseTimeInterval_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeInterval field path value from %s: %v", valueStr, err)
	}
	return fpv.(TimeInterval_FieldPathValue), nil
}

func MustParseTimeInterval_FieldPathValue(pathStr, valueStr string) TimeInterval_FieldPathValue {
	fpv, err := ParseTimeInterval_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type TimeInterval_FieldTerminalPathValue struct {
	TimeInterval_FieldTerminalPath
	value interface{}
}

var _ TimeInterval_FieldPathValue = (*TimeInterval_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'TimeInterval' as interface{}
func (fpv *TimeInterval_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *TimeInterval_FieldTerminalPathValue) AsEndTimeValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}
func (fpv *TimeInterval_FieldTerminalPathValue) AsStartTimeValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}

// SetTo stores value for selected field for object TimeInterval
func (fpv *TimeInterval_FieldTerminalPathValue) SetTo(target **TimeInterval) {
	if *target == nil {
		*target = new(TimeInterval)
	}
	switch fpv.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		(*target).EndTime = fpv.value.(*timestamppb.Timestamp)
	case TimeInterval_FieldPathSelectorStartTime:
		(*target).StartTime = fpv.value.(*timestamppb.Timestamp)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fpv.selector))
	}
}

func (fpv *TimeInterval_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TimeInterval)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'TimeInterval_FieldTerminalPathValue' with the value under path in 'TimeInterval'.
func (fpv *TimeInterval_FieldTerminalPathValue) CompareWith(source *TimeInterval) (int, bool) {
	switch fpv.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetEndTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case TimeInterval_FieldPathSelectorStartTime:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetStartTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fpv.selector))
	}
}

func (fpv *TimeInterval_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*TimeInterval))
}

// TimeInterval_FieldPathArrayItemValue allows storing single item in Path-specific values for TimeInterval according to their type
// Present only for array (repeated) types.
type TimeInterval_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	TimeInterval_FieldPath
	ContainsValue(*TimeInterval) bool
}

// ParseTimeInterval_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseTimeInterval_FieldPathArrayItemValue(pathStr, valueStr string) (TimeInterval_FieldPathArrayItemValue, error) {
	fp, err := ParseTimeInterval_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeInterval field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(TimeInterval_FieldPathArrayItemValue), nil
}

func MustParseTimeInterval_FieldPathArrayItemValue(pathStr, valueStr string) TimeInterval_FieldPathArrayItemValue {
	fpaiv, err := ParseTimeInterval_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type TimeInterval_FieldTerminalPathArrayItemValue struct {
	TimeInterval_FieldTerminalPath
	value interface{}
}

var _ TimeInterval_FieldPathArrayItemValue = (*TimeInterval_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object TimeInterval as interface{}
func (fpaiv *TimeInterval_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *TimeInterval_FieldTerminalPathArrayItemValue) GetSingle(source *TimeInterval) (interface{}, bool) {
	return nil, false
}

func (fpaiv *TimeInterval_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*TimeInterval))
}

// Contains returns a boolean indicating if value that is being held is present in given 'TimeInterval'
func (fpaiv *TimeInterval_FieldTerminalPathArrayItemValue) ContainsValue(source *TimeInterval) bool {
	slice := fpaiv.TimeInterval_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// TimeInterval_FieldPathArrayOfValues allows storing slice of values for TimeInterval fields according to their type
type TimeInterval_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	TimeInterval_FieldPath
}

func ParseTimeInterval_FieldPathArrayOfValues(pathStr, valuesStr string) (TimeInterval_FieldPathArrayOfValues, error) {
	fp, err := ParseTimeInterval_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeInterval field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(TimeInterval_FieldPathArrayOfValues), nil
}

func MustParseTimeInterval_FieldPathArrayOfValues(pathStr, valuesStr string) TimeInterval_FieldPathArrayOfValues {
	fpaov, err := ParseTimeInterval_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type TimeInterval_FieldTerminalPathArrayOfValues struct {
	TimeInterval_FieldTerminalPath
	values interface{}
}

var _ TimeInterval_FieldPathArrayOfValues = (*TimeInterval_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *TimeInterval_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	case TimeInterval_FieldPathSelectorStartTime:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *TimeInterval_FieldTerminalPathArrayOfValues) AsEndTimeArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}
func (fpaov *TimeInterval_FieldTerminalPathArrayOfValues) AsStartTimeArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type TimeRange_FieldPath interface {
	gotenobject.FieldPath
	Selector() TimeRange_FieldPathSelector
	Get(source *TimeRange) []interface{}
	GetSingle(source *TimeRange) (interface{}, bool)
	ClearValue(item *TimeRange)

	// Those methods build corresponding TimeRange_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) TimeRange_FieldPathValue
	WithIArrayOfValues(values interface{}) TimeRange_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) TimeRange_FieldPathArrayItemValue
}

type TimeRange_FieldPathSelector int32

const (
	TimeRange_FieldPathSelectorStartTime TimeRange_FieldPathSelector = 0
	TimeRange_FieldPathSelectorEndTime   TimeRange_FieldPathSelector = 1
)

func (s TimeRange_FieldPathSelector) String() string {
	switch s {
	case TimeRange_FieldPathSelectorStartTime:
		return "start_time"
	case TimeRange_FieldPathSelectorEndTime:
		return "end_time"
	default:
		panic(fmt.Sprintf("Invalid selector for TimeRange: %d", s))
	}
}

func BuildTimeRange_FieldPath(fp gotenobject.RawFieldPath) (TimeRange_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object TimeRange")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "start_time", "startTime", "start-time":
			return &TimeRange_FieldTerminalPath{selector: TimeRange_FieldPathSelectorStartTime}, nil
		case "end_time", "endTime", "end-time":
			return &TimeRange_FieldTerminalPath{selector: TimeRange_FieldPathSelectorEndTime}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object TimeRange", fp)
}

func ParseTimeRange_FieldPath(rawField string) (TimeRange_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildTimeRange_FieldPath(fp)
}

func MustParseTimeRange_FieldPath(rawField string) TimeRange_FieldPath {
	fp, err := ParseTimeRange_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type TimeRange_FieldTerminalPath struct {
	selector TimeRange_FieldPathSelector
}

var _ TimeRange_FieldPath = (*TimeRange_FieldTerminalPath)(nil)

func (fp *TimeRange_FieldTerminalPath) Selector() TimeRange_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *TimeRange_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *TimeRange_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source TimeRange
func (fp *TimeRange_FieldTerminalPath) Get(source *TimeRange) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case TimeRange_FieldPathSelectorStartTime:
			if source.StartTime != nil {
				values = append(values, source.StartTime)
			}
		case TimeRange_FieldPathSelectorEndTime:
			if source.EndTime != nil {
				values = append(values, source.EndTime)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fp.selector))
		}
	}
	return
}

func (fp *TimeRange_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*TimeRange))
}

// GetSingle returns value pointed by specific field of from source TimeRange
func (fp *TimeRange_FieldTerminalPath) GetSingle(source *TimeRange) (interface{}, bool) {
	switch fp.selector {
	case TimeRange_FieldPathSelectorStartTime:
		res := source.GetStartTime()
		return res, res != nil
	case TimeRange_FieldPathSelectorEndTime:
		res := source.GetEndTime()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fp.selector))
	}
}

func (fp *TimeRange_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*TimeRange))
}

// GetDefault returns a default value of the field type
func (fp *TimeRange_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case TimeRange_FieldPathSelectorStartTime:
		return (*timestamppb.Timestamp)(nil)
	case TimeRange_FieldPathSelectorEndTime:
		return (*timestamppb.Timestamp)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fp.selector))
	}
}

func (fp *TimeRange_FieldTerminalPath) ClearValue(item *TimeRange) {
	if item != nil {
		switch fp.selector {
		case TimeRange_FieldPathSelectorStartTime:
			item.StartTime = nil
		case TimeRange_FieldPathSelectorEndTime:
			item.EndTime = nil
		default:
			panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fp.selector))
		}
	}
}

func (fp *TimeRange_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*TimeRange))
}

// IsLeaf - whether field path is holds simple value
func (fp *TimeRange_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == TimeRange_FieldPathSelectorStartTime ||
		fp.selector == TimeRange_FieldPathSelectorEndTime
}

func (fp *TimeRange_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *TimeRange_FieldTerminalPath) WithIValue(value interface{}) TimeRange_FieldPathValue {
	switch fp.selector {
	case TimeRange_FieldPathSelectorStartTime:
		return &TimeRange_FieldTerminalPathValue{TimeRange_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	case TimeRange_FieldPathSelectorEndTime:
		return &TimeRange_FieldTerminalPathValue{TimeRange_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fp.selector))
	}
}

func (fp *TimeRange_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *TimeRange_FieldTerminalPath) WithIArrayOfValues(values interface{}) TimeRange_FieldPathArrayOfValues {
	fpaov := &TimeRange_FieldTerminalPathArrayOfValues{TimeRange_FieldTerminalPath: *fp}
	switch fp.selector {
	case TimeRange_FieldPathSelectorStartTime:
		return &TimeRange_FieldTerminalPathArrayOfValues{TimeRange_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	case TimeRange_FieldPathSelectorEndTime:
		return &TimeRange_FieldTerminalPathArrayOfValues{TimeRange_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fp.selector))
	}
	return fpaov
}

func (fp *TimeRange_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *TimeRange_FieldTerminalPath) WithIArrayItemValue(value interface{}) TimeRange_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fp.selector))
	}
}

func (fp *TimeRange_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// TimeRange_FieldPathValue allows storing values for TimeRange fields according to their type
type TimeRange_FieldPathValue interface {
	TimeRange_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **TimeRange)
	CompareWith(*TimeRange) (cmp int, comparable bool)
}

func ParseTimeRange_FieldPathValue(pathStr, valueStr string) (TimeRange_FieldPathValue, error) {
	fp, err := ParseTimeRange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeRange field path value from %s: %v", valueStr, err)
	}
	return fpv.(TimeRange_FieldPathValue), nil
}

func MustParseTimeRange_FieldPathValue(pathStr, valueStr string) TimeRange_FieldPathValue {
	fpv, err := ParseTimeRange_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type TimeRange_FieldTerminalPathValue struct {
	TimeRange_FieldTerminalPath
	value interface{}
}

var _ TimeRange_FieldPathValue = (*TimeRange_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'TimeRange' as interface{}
func (fpv *TimeRange_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *TimeRange_FieldTerminalPathValue) AsStartTimeValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}
func (fpv *TimeRange_FieldTerminalPathValue) AsEndTimeValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}

// SetTo stores value for selected field for object TimeRange
func (fpv *TimeRange_FieldTerminalPathValue) SetTo(target **TimeRange) {
	if *target == nil {
		*target = new(TimeRange)
	}
	switch fpv.selector {
	case TimeRange_FieldPathSelectorStartTime:
		(*target).StartTime = fpv.value.(*timestamppb.Timestamp)
	case TimeRange_FieldPathSelectorEndTime:
		(*target).EndTime = fpv.value.(*timestamppb.Timestamp)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fpv.selector))
	}
}

func (fpv *TimeRange_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TimeRange)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'TimeRange_FieldTerminalPathValue' with the value under path in 'TimeRange'.
func (fpv *TimeRange_FieldTerminalPathValue) CompareWith(source *TimeRange) (int, bool) {
	switch fpv.selector {
	case TimeRange_FieldPathSelectorStartTime:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetStartTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case TimeRange_FieldPathSelectorEndTime:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetEndTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeRange: %d", fpv.selector))
	}
}

func (fpv *TimeRange_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*TimeRange))
}

// TimeRange_FieldPathArrayItemValue allows storing single item in Path-specific values for TimeRange according to their type
// Present only for array (repeated) types.
type TimeRange_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	TimeRange_FieldPath
	ContainsValue(*TimeRange) bool
}

// ParseTimeRange_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseTimeRange_FieldPathArrayItemValue(pathStr, valueStr string) (TimeRange_FieldPathArrayItemValue, error) {
	fp, err := ParseTimeRange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeRange field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(TimeRange_FieldPathArrayItemValue), nil
}

func MustParseTimeRange_FieldPathArrayItemValue(pathStr, valueStr string) TimeRange_FieldPathArrayItemValue {
	fpaiv, err := ParseTimeRange_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type TimeRange_FieldTerminalPathArrayItemValue struct {
	TimeRange_FieldTerminalPath
	value interface{}
}

var _ TimeRange_FieldPathArrayItemValue = (*TimeRange_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object TimeRange as interface{}
func (fpaiv *TimeRange_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *TimeRange_FieldTerminalPathArrayItemValue) GetSingle(source *TimeRange) (interface{}, bool) {
	return nil, false
}

func (fpaiv *TimeRange_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*TimeRange))
}

// Contains returns a boolean indicating if value that is being held is present in given 'TimeRange'
func (fpaiv *TimeRange_FieldTerminalPathArrayItemValue) ContainsValue(source *TimeRange) bool {
	slice := fpaiv.TimeRange_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// TimeRange_FieldPathArrayOfValues allows storing slice of values for TimeRange fields according to their type
type TimeRange_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	TimeRange_FieldPath
}

func ParseTimeRange_FieldPathArrayOfValues(pathStr, valuesStr string) (TimeRange_FieldPathArrayOfValues, error) {
	fp, err := ParseTimeRange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeRange field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(TimeRange_FieldPathArrayOfValues), nil
}

func MustParseTimeRange_FieldPathArrayOfValues(pathStr, valuesStr string) TimeRange_FieldPathArrayOfValues {
	fpaov, err := ParseTimeRange_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type TimeRange_FieldTerminalPathArrayOfValues struct {
	TimeRange_FieldTerminalPath
	values interface{}
}

var _ TimeRange_FieldPathArrayOfValues = (*TimeRange_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *TimeRange_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case TimeRange_FieldPathSelectorStartTime:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	case TimeRange_FieldPathSelectorEndTime:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *TimeRange_FieldTerminalPathArrayOfValues) AsStartTimeArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}
func (fpaov *TimeRange_FieldTerminalPathArrayOfValues) AsEndTimeArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Aggregation_FieldPath interface {
	gotenobject.FieldPath
	Selector() Aggregation_FieldPathSelector
	Get(source *Aggregation) []interface{}
	GetSingle(source *Aggregation) (interface{}, bool)
	ClearValue(item *Aggregation)

	// Those methods build corresponding Aggregation_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Aggregation_FieldPathValue
	WithIArrayOfValues(values interface{}) Aggregation_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Aggregation_FieldPathArrayItemValue
}

type Aggregation_FieldPathSelector int32

const (
	Aggregation_FieldPathSelectorAlignmentPeriod    Aggregation_FieldPathSelector = 0
	Aggregation_FieldPathSelectorPerSeriesAligner   Aggregation_FieldPathSelector = 1
	Aggregation_FieldPathSelectorCrossSeriesReducer Aggregation_FieldPathSelector = 2
	Aggregation_FieldPathSelectorGroupByFields      Aggregation_FieldPathSelector = 3
)

func (s Aggregation_FieldPathSelector) String() string {
	switch s {
	case Aggregation_FieldPathSelectorAlignmentPeriod:
		return "alignment_period"
	case Aggregation_FieldPathSelectorPerSeriesAligner:
		return "per_series_aligner"
	case Aggregation_FieldPathSelectorCrossSeriesReducer:
		return "cross_series_reducer"
	case Aggregation_FieldPathSelectorGroupByFields:
		return "group_by_fields"
	default:
		panic(fmt.Sprintf("Invalid selector for Aggregation: %d", s))
	}
}

func BuildAggregation_FieldPath(fp gotenobject.RawFieldPath) (Aggregation_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Aggregation")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "alignment_period", "alignmentPeriod", "alignment-period":
			return &Aggregation_FieldTerminalPath{selector: Aggregation_FieldPathSelectorAlignmentPeriod}, nil
		case "per_series_aligner", "perSeriesAligner", "per-series-aligner":
			return &Aggregation_FieldTerminalPath{selector: Aggregation_FieldPathSelectorPerSeriesAligner}, nil
		case "cross_series_reducer", "crossSeriesReducer", "cross-series-reducer":
			return &Aggregation_FieldTerminalPath{selector: Aggregation_FieldPathSelectorCrossSeriesReducer}, nil
		case "group_by_fields", "groupByFields", "group-by-fields":
			return &Aggregation_FieldTerminalPath{selector: Aggregation_FieldPathSelectorGroupByFields}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Aggregation", fp)
}

func ParseAggregation_FieldPath(rawField string) (Aggregation_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildAggregation_FieldPath(fp)
}

func MustParseAggregation_FieldPath(rawField string) Aggregation_FieldPath {
	fp, err := ParseAggregation_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Aggregation_FieldTerminalPath struct {
	selector Aggregation_FieldPathSelector
}

var _ Aggregation_FieldPath = (*Aggregation_FieldTerminalPath)(nil)

func (fp *Aggregation_FieldTerminalPath) Selector() Aggregation_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Aggregation_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Aggregation_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Aggregation
func (fp *Aggregation_FieldTerminalPath) Get(source *Aggregation) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Aggregation_FieldPathSelectorAlignmentPeriod:
			if source.AlignmentPeriod != nil {
				values = append(values, source.AlignmentPeriod)
			}
		case Aggregation_FieldPathSelectorPerSeriesAligner:
			values = append(values, source.PerSeriesAligner)
		case Aggregation_FieldPathSelectorCrossSeriesReducer:
			values = append(values, source.CrossSeriesReducer)
		case Aggregation_FieldPathSelectorGroupByFields:
			for _, value := range source.GetGroupByFields() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fp.selector))
		}
	}
	return
}

func (fp *Aggregation_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Aggregation))
}

// GetSingle returns value pointed by specific field of from source Aggregation
func (fp *Aggregation_FieldTerminalPath) GetSingle(source *Aggregation) (interface{}, bool) {
	switch fp.selector {
	case Aggregation_FieldPathSelectorAlignmentPeriod:
		res := source.GetAlignmentPeriod()
		return res, res != nil
	case Aggregation_FieldPathSelectorPerSeriesAligner:
		return source.GetPerSeriesAligner(), source != nil
	case Aggregation_FieldPathSelectorCrossSeriesReducer:
		return source.GetCrossSeriesReducer(), source != nil
	case Aggregation_FieldPathSelectorGroupByFields:
		res := source.GetGroupByFields()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fp.selector))
	}
}

func (fp *Aggregation_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Aggregation))
}

// GetDefault returns a default value of the field type
func (fp *Aggregation_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Aggregation_FieldPathSelectorAlignmentPeriod:
		return (*durationpb.Duration)(nil)
	case Aggregation_FieldPathSelectorPerSeriesAligner:
		return Aggregation_ALIGN_NONE
	case Aggregation_FieldPathSelectorCrossSeriesReducer:
		return Aggregation_REDUCE_NONE
	case Aggregation_FieldPathSelectorGroupByFields:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fp.selector))
	}
}

func (fp *Aggregation_FieldTerminalPath) ClearValue(item *Aggregation) {
	if item != nil {
		switch fp.selector {
		case Aggregation_FieldPathSelectorAlignmentPeriod:
			item.AlignmentPeriod = nil
		case Aggregation_FieldPathSelectorPerSeriesAligner:
			item.PerSeriesAligner = Aggregation_ALIGN_NONE
		case Aggregation_FieldPathSelectorCrossSeriesReducer:
			item.CrossSeriesReducer = Aggregation_REDUCE_NONE
		case Aggregation_FieldPathSelectorGroupByFields:
			item.GroupByFields = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fp.selector))
		}
	}
}

func (fp *Aggregation_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Aggregation))
}

// IsLeaf - whether field path is holds simple value
func (fp *Aggregation_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Aggregation_FieldPathSelectorAlignmentPeriod ||
		fp.selector == Aggregation_FieldPathSelectorPerSeriesAligner ||
		fp.selector == Aggregation_FieldPathSelectorCrossSeriesReducer ||
		fp.selector == Aggregation_FieldPathSelectorGroupByFields
}

func (fp *Aggregation_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Aggregation_FieldTerminalPath) WithIValue(value interface{}) Aggregation_FieldPathValue {
	switch fp.selector {
	case Aggregation_FieldPathSelectorAlignmentPeriod:
		return &Aggregation_FieldTerminalPathValue{Aggregation_FieldTerminalPath: *fp, value: value.(*durationpb.Duration)}
	case Aggregation_FieldPathSelectorPerSeriesAligner:
		return &Aggregation_FieldTerminalPathValue{Aggregation_FieldTerminalPath: *fp, value: value.(Aggregation_Aligner)}
	case Aggregation_FieldPathSelectorCrossSeriesReducer:
		return &Aggregation_FieldTerminalPathValue{Aggregation_FieldTerminalPath: *fp, value: value.(Aggregation_Reducer)}
	case Aggregation_FieldPathSelectorGroupByFields:
		return &Aggregation_FieldTerminalPathValue{Aggregation_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fp.selector))
	}
}

func (fp *Aggregation_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Aggregation_FieldTerminalPath) WithIArrayOfValues(values interface{}) Aggregation_FieldPathArrayOfValues {
	fpaov := &Aggregation_FieldTerminalPathArrayOfValues{Aggregation_FieldTerminalPath: *fp}
	switch fp.selector {
	case Aggregation_FieldPathSelectorAlignmentPeriod:
		return &Aggregation_FieldTerminalPathArrayOfValues{Aggregation_FieldTerminalPath: *fp, values: values.([]*durationpb.Duration)}
	case Aggregation_FieldPathSelectorPerSeriesAligner:
		return &Aggregation_FieldTerminalPathArrayOfValues{Aggregation_FieldTerminalPath: *fp, values: values.([]Aggregation_Aligner)}
	case Aggregation_FieldPathSelectorCrossSeriesReducer:
		return &Aggregation_FieldTerminalPathArrayOfValues{Aggregation_FieldTerminalPath: *fp, values: values.([]Aggregation_Reducer)}
	case Aggregation_FieldPathSelectorGroupByFields:
		return &Aggregation_FieldTerminalPathArrayOfValues{Aggregation_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fp.selector))
	}
	return fpaov
}

func (fp *Aggregation_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Aggregation_FieldTerminalPath) WithIArrayItemValue(value interface{}) Aggregation_FieldPathArrayItemValue {
	switch fp.selector {
	case Aggregation_FieldPathSelectorGroupByFields:
		return &Aggregation_FieldTerminalPathArrayItemValue{Aggregation_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fp.selector))
	}
}

func (fp *Aggregation_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Aggregation_FieldPathValue allows storing values for Aggregation fields according to their type
type Aggregation_FieldPathValue interface {
	Aggregation_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Aggregation)
	CompareWith(*Aggregation) (cmp int, comparable bool)
}

func ParseAggregation_FieldPathValue(pathStr, valueStr string) (Aggregation_FieldPathValue, error) {
	fp, err := ParseAggregation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Aggregation field path value from %s: %v", valueStr, err)
	}
	return fpv.(Aggregation_FieldPathValue), nil
}

func MustParseAggregation_FieldPathValue(pathStr, valueStr string) Aggregation_FieldPathValue {
	fpv, err := ParseAggregation_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Aggregation_FieldTerminalPathValue struct {
	Aggregation_FieldTerminalPath
	value interface{}
}

var _ Aggregation_FieldPathValue = (*Aggregation_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Aggregation' as interface{}
func (fpv *Aggregation_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Aggregation_FieldTerminalPathValue) AsAlignmentPeriodValue() (*durationpb.Duration, bool) {
	res, ok := fpv.value.(*durationpb.Duration)
	return res, ok
}
func (fpv *Aggregation_FieldTerminalPathValue) AsPerSeriesAlignerValue() (Aggregation_Aligner, bool) {
	res, ok := fpv.value.(Aggregation_Aligner)
	return res, ok
}
func (fpv *Aggregation_FieldTerminalPathValue) AsCrossSeriesReducerValue() (Aggregation_Reducer, bool) {
	res, ok := fpv.value.(Aggregation_Reducer)
	return res, ok
}
func (fpv *Aggregation_FieldTerminalPathValue) AsGroupByFieldsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object Aggregation
func (fpv *Aggregation_FieldTerminalPathValue) SetTo(target **Aggregation) {
	if *target == nil {
		*target = new(Aggregation)
	}
	switch fpv.selector {
	case Aggregation_FieldPathSelectorAlignmentPeriod:
		(*target).AlignmentPeriod = fpv.value.(*durationpb.Duration)
	case Aggregation_FieldPathSelectorPerSeriesAligner:
		(*target).PerSeriesAligner = fpv.value.(Aggregation_Aligner)
	case Aggregation_FieldPathSelectorCrossSeriesReducer:
		(*target).CrossSeriesReducer = fpv.value.(Aggregation_Reducer)
	case Aggregation_FieldPathSelectorGroupByFields:
		(*target).GroupByFields = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fpv.selector))
	}
}

func (fpv *Aggregation_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Aggregation)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Aggregation_FieldTerminalPathValue' with the value under path in 'Aggregation'.
func (fpv *Aggregation_FieldTerminalPathValue) CompareWith(source *Aggregation) (int, bool) {
	switch fpv.selector {
	case Aggregation_FieldPathSelectorAlignmentPeriod:
		leftValue := fpv.value.(*durationpb.Duration)
		rightValue := source.GetAlignmentPeriod()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsDuration() == rightValue.AsDuration() {
			return 0, true
		} else if leftValue.AsDuration() < rightValue.AsDuration() {
			return -1, true
		} else {
			return 1, true
		}
	case Aggregation_FieldPathSelectorPerSeriesAligner:
		leftValue := fpv.value.(Aggregation_Aligner)
		rightValue := source.GetPerSeriesAligner()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Aggregation_FieldPathSelectorCrossSeriesReducer:
		leftValue := fpv.value.(Aggregation_Reducer)
		rightValue := source.GetCrossSeriesReducer()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Aggregation_FieldPathSelectorGroupByFields:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Aggregation: %d", fpv.selector))
	}
}

func (fpv *Aggregation_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Aggregation))
}

// Aggregation_FieldPathArrayItemValue allows storing single item in Path-specific values for Aggregation according to their type
// Present only for array (repeated) types.
type Aggregation_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Aggregation_FieldPath
	ContainsValue(*Aggregation) bool
}

// ParseAggregation_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseAggregation_FieldPathArrayItemValue(pathStr, valueStr string) (Aggregation_FieldPathArrayItemValue, error) {
	fp, err := ParseAggregation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Aggregation field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Aggregation_FieldPathArrayItemValue), nil
}

func MustParseAggregation_FieldPathArrayItemValue(pathStr, valueStr string) Aggregation_FieldPathArrayItemValue {
	fpaiv, err := ParseAggregation_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Aggregation_FieldTerminalPathArrayItemValue struct {
	Aggregation_FieldTerminalPath
	value interface{}
}

var _ Aggregation_FieldPathArrayItemValue = (*Aggregation_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Aggregation as interface{}
func (fpaiv *Aggregation_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Aggregation_FieldTerminalPathArrayItemValue) AsGroupByFieldsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *Aggregation_FieldTerminalPathArrayItemValue) GetSingle(source *Aggregation) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Aggregation_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Aggregation))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Aggregation'
func (fpaiv *Aggregation_FieldTerminalPathArrayItemValue) ContainsValue(source *Aggregation) bool {
	slice := fpaiv.Aggregation_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Aggregation_FieldPathArrayOfValues allows storing slice of values for Aggregation fields according to their type
type Aggregation_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Aggregation_FieldPath
}

func ParseAggregation_FieldPathArrayOfValues(pathStr, valuesStr string) (Aggregation_FieldPathArrayOfValues, error) {
	fp, err := ParseAggregation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Aggregation field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Aggregation_FieldPathArrayOfValues), nil
}

func MustParseAggregation_FieldPathArrayOfValues(pathStr, valuesStr string) Aggregation_FieldPathArrayOfValues {
	fpaov, err := ParseAggregation_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Aggregation_FieldTerminalPathArrayOfValues struct {
	Aggregation_FieldTerminalPath
	values interface{}
}

var _ Aggregation_FieldPathArrayOfValues = (*Aggregation_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Aggregation_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Aggregation_FieldPathSelectorAlignmentPeriod:
		for _, v := range fpaov.values.([]*durationpb.Duration) {
			values = append(values, v)
		}
	case Aggregation_FieldPathSelectorPerSeriesAligner:
		for _, v := range fpaov.values.([]Aggregation_Aligner) {
			values = append(values, v)
		}
	case Aggregation_FieldPathSelectorCrossSeriesReducer:
		for _, v := range fpaov.values.([]Aggregation_Reducer) {
			values = append(values, v)
		}
	case Aggregation_FieldPathSelectorGroupByFields:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Aggregation_FieldTerminalPathArrayOfValues) AsAlignmentPeriodArrayOfValues() ([]*durationpb.Duration, bool) {
	res, ok := fpaov.values.([]*durationpb.Duration)
	return res, ok
}
func (fpaov *Aggregation_FieldTerminalPathArrayOfValues) AsPerSeriesAlignerArrayOfValues() ([]Aggregation_Aligner, bool) {
	res, ok := fpaov.values.([]Aggregation_Aligner)
	return res, ok
}
func (fpaov *Aggregation_FieldTerminalPathArrayOfValues) AsCrossSeriesReducerArrayOfValues() ([]Aggregation_Reducer, bool) {
	res, ok := fpaov.values.([]Aggregation_Reducer)
	return res, ok
}
func (fpaov *Aggregation_FieldTerminalPathArrayOfValues) AsGroupByFieldsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Pagination_FieldPath interface {
	gotenobject.FieldPath
	Selector() Pagination_FieldPathSelector
	Get(source *Pagination) []interface{}
	GetSingle(source *Pagination) (interface{}, bool)
	ClearValue(item *Pagination)

	// Those methods build corresponding Pagination_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Pagination_FieldPathValue
	WithIArrayOfValues(values interface{}) Pagination_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Pagination_FieldPathArrayItemValue
}

type Pagination_FieldPathSelector int32

const (
	Pagination_FieldPathSelectorView            Pagination_FieldPathSelector = 0
	Pagination_FieldPathSelectorFunction        Pagination_FieldPathSelector = 1
	Pagination_FieldPathSelectorAlignmentPeriod Pagination_FieldPathSelector = 2
	Pagination_FieldPathSelectorLimit           Pagination_FieldPathSelector = 3
	Pagination_FieldPathSelectorOffset          Pagination_FieldPathSelector = 4
)

func (s Pagination_FieldPathSelector) String() string {
	switch s {
	case Pagination_FieldPathSelectorView:
		return "view"
	case Pagination_FieldPathSelectorFunction:
		return "function"
	case Pagination_FieldPathSelectorAlignmentPeriod:
		return "alignment_period"
	case Pagination_FieldPathSelectorLimit:
		return "limit"
	case Pagination_FieldPathSelectorOffset:
		return "offset"
	default:
		panic(fmt.Sprintf("Invalid selector for Pagination: %d", s))
	}
}

func BuildPagination_FieldPath(fp gotenobject.RawFieldPath) (Pagination_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Pagination")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "view":
			return &Pagination_FieldTerminalPath{selector: Pagination_FieldPathSelectorView}, nil
		case "function":
			return &Pagination_FieldTerminalPath{selector: Pagination_FieldPathSelectorFunction}, nil
		case "alignment_period", "alignmentPeriod", "alignment-period":
			return &Pagination_FieldTerminalPath{selector: Pagination_FieldPathSelectorAlignmentPeriod}, nil
		case "limit":
			return &Pagination_FieldTerminalPath{selector: Pagination_FieldPathSelectorLimit}, nil
		case "offset":
			return &Pagination_FieldTerminalPath{selector: Pagination_FieldPathSelectorOffset}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Pagination", fp)
}

func ParsePagination_FieldPath(rawField string) (Pagination_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildPagination_FieldPath(fp)
}

func MustParsePagination_FieldPath(rawField string) Pagination_FieldPath {
	fp, err := ParsePagination_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Pagination_FieldTerminalPath struct {
	selector Pagination_FieldPathSelector
}

var _ Pagination_FieldPath = (*Pagination_FieldTerminalPath)(nil)

func (fp *Pagination_FieldTerminalPath) Selector() Pagination_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Pagination_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Pagination_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Pagination
func (fp *Pagination_FieldTerminalPath) Get(source *Pagination) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Pagination_FieldPathSelectorView:
			values = append(values, source.View)
		case Pagination_FieldPathSelectorFunction:
			values = append(values, source.Function)
		case Pagination_FieldPathSelectorAlignmentPeriod:
			if source.AlignmentPeriod != nil {
				values = append(values, source.AlignmentPeriod)
			}
		case Pagination_FieldPathSelectorLimit:
			values = append(values, source.Limit)
		case Pagination_FieldPathSelectorOffset:
			values = append(values, source.Offset)
		default:
			panic(fmt.Sprintf("Invalid selector for Pagination: %d", fp.selector))
		}
	}
	return
}

func (fp *Pagination_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Pagination))
}

// GetSingle returns value pointed by specific field of from source Pagination
func (fp *Pagination_FieldTerminalPath) GetSingle(source *Pagination) (interface{}, bool) {
	switch fp.selector {
	case Pagination_FieldPathSelectorView:
		return source.GetView(), source != nil
	case Pagination_FieldPathSelectorFunction:
		return source.GetFunction(), source != nil
	case Pagination_FieldPathSelectorAlignmentPeriod:
		res := source.GetAlignmentPeriod()
		return res, res != nil
	case Pagination_FieldPathSelectorLimit:
		return source.GetLimit(), source != nil
	case Pagination_FieldPathSelectorOffset:
		return source.GetOffset(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Pagination: %d", fp.selector))
	}
}

func (fp *Pagination_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Pagination))
}

// GetDefault returns a default value of the field type
func (fp *Pagination_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Pagination_FieldPathSelectorView:
		return ""
	case Pagination_FieldPathSelectorFunction:
		return ""
	case Pagination_FieldPathSelectorAlignmentPeriod:
		return (*durationpb.Duration)(nil)
	case Pagination_FieldPathSelectorLimit:
		return int32(0)
	case Pagination_FieldPathSelectorOffset:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for Pagination: %d", fp.selector))
	}
}

func (fp *Pagination_FieldTerminalPath) ClearValue(item *Pagination) {
	if item != nil {
		switch fp.selector {
		case Pagination_FieldPathSelectorView:
			item.View = ""
		case Pagination_FieldPathSelectorFunction:
			item.Function = ""
		case Pagination_FieldPathSelectorAlignmentPeriod:
			item.AlignmentPeriod = nil
		case Pagination_FieldPathSelectorLimit:
			item.Limit = int32(0)
		case Pagination_FieldPathSelectorOffset:
			item.Offset = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for Pagination: %d", fp.selector))
		}
	}
}

func (fp *Pagination_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Pagination))
}

// IsLeaf - whether field path is holds simple value
func (fp *Pagination_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Pagination_FieldPathSelectorView ||
		fp.selector == Pagination_FieldPathSelectorFunction ||
		fp.selector == Pagination_FieldPathSelectorAlignmentPeriod ||
		fp.selector == Pagination_FieldPathSelectorLimit ||
		fp.selector == Pagination_FieldPathSelectorOffset
}

func (fp *Pagination_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Pagination_FieldTerminalPath) WithIValue(value interface{}) Pagination_FieldPathValue {
	switch fp.selector {
	case Pagination_FieldPathSelectorView:
		return &Pagination_FieldTerminalPathValue{Pagination_FieldTerminalPath: *fp, value: value.(string)}
	case Pagination_FieldPathSelectorFunction:
		return &Pagination_FieldTerminalPathValue{Pagination_FieldTerminalPath: *fp, value: value.(string)}
	case Pagination_FieldPathSelectorAlignmentPeriod:
		return &Pagination_FieldTerminalPathValue{Pagination_FieldTerminalPath: *fp, value: value.(*durationpb.Duration)}
	case Pagination_FieldPathSelectorLimit:
		return &Pagination_FieldTerminalPathValue{Pagination_FieldTerminalPath: *fp, value: value.(int32)}
	case Pagination_FieldPathSelectorOffset:
		return &Pagination_FieldTerminalPathValue{Pagination_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for Pagination: %d", fp.selector))
	}
}

func (fp *Pagination_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Pagination_FieldTerminalPath) WithIArrayOfValues(values interface{}) Pagination_FieldPathArrayOfValues {
	fpaov := &Pagination_FieldTerminalPathArrayOfValues{Pagination_FieldTerminalPath: *fp}
	switch fp.selector {
	case Pagination_FieldPathSelectorView:
		return &Pagination_FieldTerminalPathArrayOfValues{Pagination_FieldTerminalPath: *fp, values: values.([]string)}
	case Pagination_FieldPathSelectorFunction:
		return &Pagination_FieldTerminalPathArrayOfValues{Pagination_FieldTerminalPath: *fp, values: values.([]string)}
	case Pagination_FieldPathSelectorAlignmentPeriod:
		return &Pagination_FieldTerminalPathArrayOfValues{Pagination_FieldTerminalPath: *fp, values: values.([]*durationpb.Duration)}
	case Pagination_FieldPathSelectorLimit:
		return &Pagination_FieldTerminalPathArrayOfValues{Pagination_FieldTerminalPath: *fp, values: values.([]int32)}
	case Pagination_FieldPathSelectorOffset:
		return &Pagination_FieldTerminalPathArrayOfValues{Pagination_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for Pagination: %d", fp.selector))
	}
	return fpaov
}

func (fp *Pagination_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Pagination_FieldTerminalPath) WithIArrayItemValue(value interface{}) Pagination_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Pagination: %d", fp.selector))
	}
}

func (fp *Pagination_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Pagination_FieldPathValue allows storing values for Pagination fields according to their type
type Pagination_FieldPathValue interface {
	Pagination_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Pagination)
	CompareWith(*Pagination) (cmp int, comparable bool)
}

func ParsePagination_FieldPathValue(pathStr, valueStr string) (Pagination_FieldPathValue, error) {
	fp, err := ParsePagination_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Pagination field path value from %s: %v", valueStr, err)
	}
	return fpv.(Pagination_FieldPathValue), nil
}

func MustParsePagination_FieldPathValue(pathStr, valueStr string) Pagination_FieldPathValue {
	fpv, err := ParsePagination_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Pagination_FieldTerminalPathValue struct {
	Pagination_FieldTerminalPath
	value interface{}
}

var _ Pagination_FieldPathValue = (*Pagination_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Pagination' as interface{}
func (fpv *Pagination_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Pagination_FieldTerminalPathValue) AsViewValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Pagination_FieldTerminalPathValue) AsFunctionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Pagination_FieldTerminalPathValue) AsAlignmentPeriodValue() (*durationpb.Duration, bool) {
	res, ok := fpv.value.(*durationpb.Duration)
	return res, ok
}
func (fpv *Pagination_FieldTerminalPathValue) AsLimitValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *Pagination_FieldTerminalPathValue) AsOffsetValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object Pagination
func (fpv *Pagination_FieldTerminalPathValue) SetTo(target **Pagination) {
	if *target == nil {
		*target = new(Pagination)
	}
	switch fpv.selector {
	case Pagination_FieldPathSelectorView:
		(*target).View = fpv.value.(string)
	case Pagination_FieldPathSelectorFunction:
		(*target).Function = fpv.value.(string)
	case Pagination_FieldPathSelectorAlignmentPeriod:
		(*target).AlignmentPeriod = fpv.value.(*durationpb.Duration)
	case Pagination_FieldPathSelectorLimit:
		(*target).Limit = fpv.value.(int32)
	case Pagination_FieldPathSelectorOffset:
		(*target).Offset = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for Pagination: %d", fpv.selector))
	}
}

func (fpv *Pagination_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Pagination)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Pagination_FieldTerminalPathValue' with the value under path in 'Pagination'.
func (fpv *Pagination_FieldTerminalPathValue) CompareWith(source *Pagination) (int, bool) {
	switch fpv.selector {
	case Pagination_FieldPathSelectorView:
		leftValue := fpv.value.(string)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Pagination_FieldPathSelectorFunction:
		leftValue := fpv.value.(string)
		rightValue := source.GetFunction()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Pagination_FieldPathSelectorAlignmentPeriod:
		leftValue := fpv.value.(*durationpb.Duration)
		rightValue := source.GetAlignmentPeriod()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsDuration() == rightValue.AsDuration() {
			return 0, true
		} else if leftValue.AsDuration() < rightValue.AsDuration() {
			return -1, true
		} else {
			return 1, true
		}
	case Pagination_FieldPathSelectorLimit:
		leftValue := fpv.value.(int32)
		rightValue := source.GetLimit()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Pagination_FieldPathSelectorOffset:
		leftValue := fpv.value.(int32)
		rightValue := source.GetOffset()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Pagination: %d", fpv.selector))
	}
}

func (fpv *Pagination_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Pagination))
}

// Pagination_FieldPathArrayItemValue allows storing single item in Path-specific values for Pagination according to their type
// Present only for array (repeated) types.
type Pagination_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Pagination_FieldPath
	ContainsValue(*Pagination) bool
}

// ParsePagination_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParsePagination_FieldPathArrayItemValue(pathStr, valueStr string) (Pagination_FieldPathArrayItemValue, error) {
	fp, err := ParsePagination_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Pagination field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Pagination_FieldPathArrayItemValue), nil
}

func MustParsePagination_FieldPathArrayItemValue(pathStr, valueStr string) Pagination_FieldPathArrayItemValue {
	fpaiv, err := ParsePagination_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Pagination_FieldTerminalPathArrayItemValue struct {
	Pagination_FieldTerminalPath
	value interface{}
}

var _ Pagination_FieldPathArrayItemValue = (*Pagination_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Pagination as interface{}
func (fpaiv *Pagination_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Pagination_FieldTerminalPathArrayItemValue) GetSingle(source *Pagination) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Pagination_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Pagination))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Pagination'
func (fpaiv *Pagination_FieldTerminalPathArrayItemValue) ContainsValue(source *Pagination) bool {
	slice := fpaiv.Pagination_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Pagination_FieldPathArrayOfValues allows storing slice of values for Pagination fields according to their type
type Pagination_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Pagination_FieldPath
}

func ParsePagination_FieldPathArrayOfValues(pathStr, valuesStr string) (Pagination_FieldPathArrayOfValues, error) {
	fp, err := ParsePagination_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Pagination field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Pagination_FieldPathArrayOfValues), nil
}

func MustParsePagination_FieldPathArrayOfValues(pathStr, valuesStr string) Pagination_FieldPathArrayOfValues {
	fpaov, err := ParsePagination_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Pagination_FieldTerminalPathArrayOfValues struct {
	Pagination_FieldTerminalPath
	values interface{}
}

var _ Pagination_FieldPathArrayOfValues = (*Pagination_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Pagination_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Pagination_FieldPathSelectorView:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Pagination_FieldPathSelectorFunction:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Pagination_FieldPathSelectorAlignmentPeriod:
		for _, v := range fpaov.values.([]*durationpb.Duration) {
			values = append(values, v)
		}
	case Pagination_FieldPathSelectorLimit:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case Pagination_FieldPathSelectorOffset:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Pagination_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Pagination_FieldTerminalPathArrayOfValues) AsFunctionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Pagination_FieldTerminalPathArrayOfValues) AsAlignmentPeriodArrayOfValues() ([]*durationpb.Duration, bool) {
	res, ok := fpaov.values.([]*durationpb.Duration)
	return res, ok
}
func (fpaov *Pagination_FieldTerminalPathArrayOfValues) AsLimitArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *Pagination_FieldTerminalPathArrayOfValues) AsOffsetArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Metric_FieldPath interface {
	gotenobject.FieldPath
	Selector() Metric_FieldPathSelector
	Get(source *Metric) []interface{}
	GetSingle(source *Metric) (interface{}, bool)
	ClearValue(item *Metric)

	// Those methods build corresponding Metric_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Metric_FieldPathValue
	WithIArrayOfValues(values interface{}) Metric_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Metric_FieldPathArrayItemValue
}

type Metric_FieldPathSelector int32

const (
	Metric_FieldPathSelectorType          Metric_FieldPathSelector = 0
	Metric_FieldPathSelectorLabels        Metric_FieldPathSelector = 1
	Metric_FieldPathSelectorReducedLabels Metric_FieldPathSelector = 2
)

func (s Metric_FieldPathSelector) String() string {
	switch s {
	case Metric_FieldPathSelectorType:
		return "type"
	case Metric_FieldPathSelectorLabels:
		return "labels"
	case Metric_FieldPathSelectorReducedLabels:
		return "reduced_labels"
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", s))
	}
}

func BuildMetric_FieldPath(fp gotenobject.RawFieldPath) (Metric_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Metric")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "type":
			return &Metric_FieldTerminalPath{selector: Metric_FieldPathSelectorType}, nil
		case "labels":
			return &Metric_FieldTerminalPath{selector: Metric_FieldPathSelectorLabels}, nil
		case "reduced_labels", "reducedLabels", "reduced-labels":
			return &Metric_FieldTerminalPath{selector: Metric_FieldPathSelectorReducedLabels}, nil
		}
	} else {
		switch fp[0] {
		case "labels":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object Metric)", fp)
			}
			return &Metric_FieldPathMap{selector: Metric_FieldPathSelectorLabels, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Metric", fp)
}

func ParseMetric_FieldPath(rawField string) (Metric_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildMetric_FieldPath(fp)
}

func MustParseMetric_FieldPath(rawField string) Metric_FieldPath {
	fp, err := ParseMetric_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Metric_FieldTerminalPath struct {
	selector Metric_FieldPathSelector
}

var _ Metric_FieldPath = (*Metric_FieldTerminalPath)(nil)

func (fp *Metric_FieldTerminalPath) Selector() Metric_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Metric_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Metric_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Metric
func (fp *Metric_FieldTerminalPath) Get(source *Metric) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Metric_FieldPathSelectorType:
			values = append(values, source.Type)
		case Metric_FieldPathSelectorLabels:
			values = append(values, source.Labels)
		case Metric_FieldPathSelectorReducedLabels:
			for _, value := range source.GetReducedLabels() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Metric: %d", fp.selector))
		}
	}
	return
}

func (fp *Metric_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Metric))
}

// GetSingle returns value pointed by specific field of from source Metric
func (fp *Metric_FieldTerminalPath) GetSingle(source *Metric) (interface{}, bool) {
	switch fp.selector {
	case Metric_FieldPathSelectorType:
		return source.GetType(), source != nil
	case Metric_FieldPathSelectorLabels:
		res := source.GetLabels()
		return res, res != nil
	case Metric_FieldPathSelectorReducedLabels:
		res := source.GetReducedLabels()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fp.selector))
	}
}

func (fp *Metric_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Metric))
}

// GetDefault returns a default value of the field type
func (fp *Metric_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Metric_FieldPathSelectorType:
		return ""
	case Metric_FieldPathSelectorLabels:
		return (map[string]string)(nil)
	case Metric_FieldPathSelectorReducedLabels:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fp.selector))
	}
}

func (fp *Metric_FieldTerminalPath) ClearValue(item *Metric) {
	if item != nil {
		switch fp.selector {
		case Metric_FieldPathSelectorType:
			item.Type = ""
		case Metric_FieldPathSelectorLabels:
			item.Labels = nil
		case Metric_FieldPathSelectorReducedLabels:
			item.ReducedLabels = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Metric: %d", fp.selector))
		}
	}
}

func (fp *Metric_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Metric))
}

// IsLeaf - whether field path is holds simple value
func (fp *Metric_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Metric_FieldPathSelectorType ||
		fp.selector == Metric_FieldPathSelectorLabels ||
		fp.selector == Metric_FieldPathSelectorReducedLabels
}

func (fp *Metric_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Metric_FieldTerminalPath) WithIValue(value interface{}) Metric_FieldPathValue {
	switch fp.selector {
	case Metric_FieldPathSelectorType:
		return &Metric_FieldTerminalPathValue{Metric_FieldTerminalPath: *fp, value: value.(string)}
	case Metric_FieldPathSelectorLabels:
		return &Metric_FieldTerminalPathValue{Metric_FieldTerminalPath: *fp, value: value.(map[string]string)}
	case Metric_FieldPathSelectorReducedLabels:
		return &Metric_FieldTerminalPathValue{Metric_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fp.selector))
	}
}

func (fp *Metric_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Metric_FieldTerminalPath) WithIArrayOfValues(values interface{}) Metric_FieldPathArrayOfValues {
	fpaov := &Metric_FieldTerminalPathArrayOfValues{Metric_FieldTerminalPath: *fp}
	switch fp.selector {
	case Metric_FieldPathSelectorType:
		return &Metric_FieldTerminalPathArrayOfValues{Metric_FieldTerminalPath: *fp, values: values.([]string)}
	case Metric_FieldPathSelectorLabels:
		return &Metric_FieldTerminalPathArrayOfValues{Metric_FieldTerminalPath: *fp, values: values.([]map[string]string)}
	case Metric_FieldPathSelectorReducedLabels:
		return &Metric_FieldTerminalPathArrayOfValues{Metric_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fp.selector))
	}
	return fpaov
}

func (fp *Metric_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Metric_FieldTerminalPath) WithIArrayItemValue(value interface{}) Metric_FieldPathArrayItemValue {
	switch fp.selector {
	case Metric_FieldPathSelectorReducedLabels:
		return &Metric_FieldTerminalPathArrayItemValue{Metric_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fp.selector))
	}
}

func (fp *Metric_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type Metric_FieldPathMap struct {
	key      string
	selector Metric_FieldPathSelector
}

var _ Metric_FieldPath = (*Metric_FieldPathMap)(nil)

func (fpm *Metric_FieldPathMap) Selector() Metric_FieldPathSelector {
	return fpm.selector
}

func (fpm *Metric_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *Metric_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *Metric_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source Metric
func (fpm *Metric_FieldPathMap) Get(source *Metric) (values []interface{}) {
	switch fpm.selector {
	case Metric_FieldPathSelectorLabels:
		if value, ok := source.GetLabels()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpm.selector))
	}
	return
}

func (fpm *Metric_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*Metric))
}

// GetSingle returns value by selected field map key from source Metric
func (fpm *Metric_FieldPathMap) GetSingle(source *Metric) (interface{}, bool) {
	switch fpm.selector {
	case Metric_FieldPathSelectorLabels:
		res, ok := source.GetLabels()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpm.selector))
	}
}

func (fpm *Metric_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*Metric))
}

// GetDefault returns a default value of the field type
func (fpm *Metric_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case Metric_FieldPathSelectorLabels:
		var v string
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpm.selector))
	}
}

func (fpm *Metric_FieldPathMap) ClearValue(item *Metric) {
	if item != nil {
		switch fpm.selector {
		case Metric_FieldPathSelectorLabels:
			delete(item.Labels, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for Metric: %d", fpm.selector))
		}
	}
}

func (fpm *Metric_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*Metric))
}

// IsLeaf - whether field path is holds simple value
func (fpm *Metric_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case Metric_FieldPathSelectorLabels:
		return true
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpm.selector))
	}
}

func (fpm *Metric_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *Metric_FieldPathMap) WithIValue(value interface{}) Metric_FieldPathValue {
	switch fpm.selector {
	case Metric_FieldPathSelectorLabels:
		return &Metric_FieldPathMapValue{Metric_FieldPathMap: *fpm, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpm.selector))
	}
}

func (fpm *Metric_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *Metric_FieldPathMap) WithIArrayOfValues(values interface{}) Metric_FieldPathArrayOfValues {
	switch fpm.selector {
	case Metric_FieldPathSelectorLabels:
		return &Metric_FieldPathMapArrayOfValues{Metric_FieldPathMap: *fpm, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpm.selector))
	}
}

func (fpm *Metric_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *Metric_FieldPathMap) WithIArrayItemValue(value interface{}) Metric_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *Metric_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

// Metric_FieldPathValue allows storing values for Metric fields according to their type
type Metric_FieldPathValue interface {
	Metric_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Metric)
	CompareWith(*Metric) (cmp int, comparable bool)
}

func ParseMetric_FieldPathValue(pathStr, valueStr string) (Metric_FieldPathValue, error) {
	fp, err := ParseMetric_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Metric field path value from %s: %v", valueStr, err)
	}
	return fpv.(Metric_FieldPathValue), nil
}

func MustParseMetric_FieldPathValue(pathStr, valueStr string) Metric_FieldPathValue {
	fpv, err := ParseMetric_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Metric_FieldTerminalPathValue struct {
	Metric_FieldTerminalPath
	value interface{}
}

var _ Metric_FieldPathValue = (*Metric_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Metric' as interface{}
func (fpv *Metric_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Metric_FieldTerminalPathValue) AsTypeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Metric_FieldTerminalPathValue) AsLabelsValue() (map[string]string, bool) {
	res, ok := fpv.value.(map[string]string)
	return res, ok
}
func (fpv *Metric_FieldTerminalPathValue) AsReducedLabelsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object Metric
func (fpv *Metric_FieldTerminalPathValue) SetTo(target **Metric) {
	if *target == nil {
		*target = new(Metric)
	}
	switch fpv.selector {
	case Metric_FieldPathSelectorType:
		(*target).Type = fpv.value.(string)
	case Metric_FieldPathSelectorLabels:
		(*target).Labels = fpv.value.(map[string]string)
	case Metric_FieldPathSelectorReducedLabels:
		(*target).ReducedLabels = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpv.selector))
	}
}

func (fpv *Metric_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Metric)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Metric_FieldTerminalPathValue' with the value under path in 'Metric'.
func (fpv *Metric_FieldTerminalPathValue) CompareWith(source *Metric) (int, bool) {
	switch fpv.selector {
	case Metric_FieldPathSelectorType:
		leftValue := fpv.value.(string)
		rightValue := source.GetType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Metric_FieldPathSelectorLabels:
		return 0, false
	case Metric_FieldPathSelectorReducedLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpv.selector))
	}
}

func (fpv *Metric_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Metric))
}

type Metric_FieldPathMapValue struct {
	Metric_FieldPathMap
	value interface{}
}

var _ Metric_FieldPathValue = (*Metric_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in Metric as interface{}
func (fpmv *Metric_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *Metric_FieldPathMapValue) AsLabelsElementValue() (string, bool) {
	res, ok := fpmv.value.(string)
	return res, ok
}

// SetTo stores value for selected field in Metric
func (fpmv *Metric_FieldPathMapValue) SetTo(target **Metric) {
	if *target == nil {
		*target = new(Metric)
	}
	switch fpmv.selector {
	case Metric_FieldPathSelectorLabels:
		if (*target).Labels == nil {
			(*target).Labels = make(map[string]string)
		}
		(*target).Labels[fpmv.key] = fpmv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpmv.selector))
	}
}

func (fpmv *Metric_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Metric)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Metric_FieldPathMapValue' with the value under path in 'Metric'.
func (fpmv *Metric_FieldPathMapValue) CompareWith(source *Metric) (int, bool) {
	switch fpmv.selector {
	case Metric_FieldPathSelectorLabels:
		leftValue := fpmv.value.(string)
		rightValue := source.GetLabels()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Metric: %d", fpmv.selector))
	}
}

func (fpmv *Metric_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*Metric))
}

// Metric_FieldPathArrayItemValue allows storing single item in Path-specific values for Metric according to their type
// Present only for array (repeated) types.
type Metric_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Metric_FieldPath
	ContainsValue(*Metric) bool
}

// ParseMetric_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseMetric_FieldPathArrayItemValue(pathStr, valueStr string) (Metric_FieldPathArrayItemValue, error) {
	fp, err := ParseMetric_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Metric field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Metric_FieldPathArrayItemValue), nil
}

func MustParseMetric_FieldPathArrayItemValue(pathStr, valueStr string) Metric_FieldPathArrayItemValue {
	fpaiv, err := ParseMetric_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Metric_FieldTerminalPathArrayItemValue struct {
	Metric_FieldTerminalPath
	value interface{}
}

var _ Metric_FieldPathArrayItemValue = (*Metric_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Metric as interface{}
func (fpaiv *Metric_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Metric_FieldTerminalPathArrayItemValue) AsReducedLabelsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *Metric_FieldTerminalPathArrayItemValue) GetSingle(source *Metric) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Metric_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Metric))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Metric'
func (fpaiv *Metric_FieldTerminalPathArrayItemValue) ContainsValue(source *Metric) bool {
	slice := fpaiv.Metric_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Metric_FieldPathArrayOfValues allows storing slice of values for Metric fields according to their type
type Metric_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Metric_FieldPath
}

func ParseMetric_FieldPathArrayOfValues(pathStr, valuesStr string) (Metric_FieldPathArrayOfValues, error) {
	fp, err := ParseMetric_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Metric field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Metric_FieldPathArrayOfValues), nil
}

func MustParseMetric_FieldPathArrayOfValues(pathStr, valuesStr string) Metric_FieldPathArrayOfValues {
	fpaov, err := ParseMetric_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Metric_FieldTerminalPathArrayOfValues struct {
	Metric_FieldTerminalPath
	values interface{}
}

var _ Metric_FieldPathArrayOfValues = (*Metric_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Metric_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Metric_FieldPathSelectorType:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Metric_FieldPathSelectorLabels:
		for _, v := range fpaov.values.([]map[string]string) {
			values = append(values, v)
		}
	case Metric_FieldPathSelectorReducedLabels:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Metric_FieldTerminalPathArrayOfValues) AsTypeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Metric_FieldTerminalPathArrayOfValues) AsLabelsArrayOfValues() ([]map[string]string, bool) {
	res, ok := fpaov.values.([]map[string]string)
	return res, ok
}
func (fpaov *Metric_FieldTerminalPathArrayOfValues) AsReducedLabelsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

type Metric_FieldPathMapArrayOfValues struct {
	Metric_FieldPathMap
	values interface{}
}

var _ Metric_FieldPathArrayOfValues = (*Metric_FieldPathMapArrayOfValues)(nil)

func (fpmaov *Metric_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case Metric_FieldPathSelectorLabels:
		for _, v := range fpmaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *Metric_FieldPathMapArrayOfValues) AsLabelsArrayOfElementValues() ([]string, bool) {
	res, ok := fpmaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type MonitoredResource_FieldPath interface {
	gotenobject.FieldPath
	Selector() MonitoredResource_FieldPathSelector
	Get(source *MonitoredResource) []interface{}
	GetSingle(source *MonitoredResource) (interface{}, bool)
	ClearValue(item *MonitoredResource)

	// Those methods build corresponding MonitoredResource_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) MonitoredResource_FieldPathValue
	WithIArrayOfValues(values interface{}) MonitoredResource_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) MonitoredResource_FieldPathArrayItemValue
}

type MonitoredResource_FieldPathSelector int32

const (
	MonitoredResource_FieldPathSelectorType          MonitoredResource_FieldPathSelector = 0
	MonitoredResource_FieldPathSelectorLabels        MonitoredResource_FieldPathSelector = 1
	MonitoredResource_FieldPathSelectorReducedLabels MonitoredResource_FieldPathSelector = 2
)

func (s MonitoredResource_FieldPathSelector) String() string {
	switch s {
	case MonitoredResource_FieldPathSelectorType:
		return "type"
	case MonitoredResource_FieldPathSelectorLabels:
		return "labels"
	case MonitoredResource_FieldPathSelectorReducedLabels:
		return "reduced_labels"
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", s))
	}
}

func BuildMonitoredResource_FieldPath(fp gotenobject.RawFieldPath) (MonitoredResource_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object MonitoredResource")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "type":
			return &MonitoredResource_FieldTerminalPath{selector: MonitoredResource_FieldPathSelectorType}, nil
		case "labels":
			return &MonitoredResource_FieldTerminalPath{selector: MonitoredResource_FieldPathSelectorLabels}, nil
		case "reduced_labels", "reducedLabels", "reduced-labels":
			return &MonitoredResource_FieldTerminalPath{selector: MonitoredResource_FieldPathSelectorReducedLabels}, nil
		}
	} else {
		switch fp[0] {
		case "labels":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object MonitoredResource)", fp)
			}
			return &MonitoredResource_FieldPathMap{selector: MonitoredResource_FieldPathSelectorLabels, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object MonitoredResource", fp)
}

func ParseMonitoredResource_FieldPath(rawField string) (MonitoredResource_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildMonitoredResource_FieldPath(fp)
}

func MustParseMonitoredResource_FieldPath(rawField string) MonitoredResource_FieldPath {
	fp, err := ParseMonitoredResource_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type MonitoredResource_FieldTerminalPath struct {
	selector MonitoredResource_FieldPathSelector
}

var _ MonitoredResource_FieldPath = (*MonitoredResource_FieldTerminalPath)(nil)

func (fp *MonitoredResource_FieldTerminalPath) Selector() MonitoredResource_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *MonitoredResource_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *MonitoredResource_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source MonitoredResource
func (fp *MonitoredResource_FieldTerminalPath) Get(source *MonitoredResource) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case MonitoredResource_FieldPathSelectorType:
			values = append(values, source.Type)
		case MonitoredResource_FieldPathSelectorLabels:
			values = append(values, source.Labels)
		case MonitoredResource_FieldPathSelectorReducedLabels:
			for _, value := range source.GetReducedLabels() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fp.selector))
		}
	}
	return
}

func (fp *MonitoredResource_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*MonitoredResource))
}

// GetSingle returns value pointed by specific field of from source MonitoredResource
func (fp *MonitoredResource_FieldTerminalPath) GetSingle(source *MonitoredResource) (interface{}, bool) {
	switch fp.selector {
	case MonitoredResource_FieldPathSelectorType:
		return source.GetType(), source != nil
	case MonitoredResource_FieldPathSelectorLabels:
		res := source.GetLabels()
		return res, res != nil
	case MonitoredResource_FieldPathSelectorReducedLabels:
		res := source.GetReducedLabels()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fp.selector))
	}
}

func (fp *MonitoredResource_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*MonitoredResource))
}

// GetDefault returns a default value of the field type
func (fp *MonitoredResource_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case MonitoredResource_FieldPathSelectorType:
		return ""
	case MonitoredResource_FieldPathSelectorLabels:
		return (map[string]string)(nil)
	case MonitoredResource_FieldPathSelectorReducedLabels:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fp.selector))
	}
}

func (fp *MonitoredResource_FieldTerminalPath) ClearValue(item *MonitoredResource) {
	if item != nil {
		switch fp.selector {
		case MonitoredResource_FieldPathSelectorType:
			item.Type = ""
		case MonitoredResource_FieldPathSelectorLabels:
			item.Labels = nil
		case MonitoredResource_FieldPathSelectorReducedLabels:
			item.ReducedLabels = nil
		default:
			panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fp.selector))
		}
	}
}

func (fp *MonitoredResource_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*MonitoredResource))
}

// IsLeaf - whether field path is holds simple value
func (fp *MonitoredResource_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == MonitoredResource_FieldPathSelectorType ||
		fp.selector == MonitoredResource_FieldPathSelectorLabels ||
		fp.selector == MonitoredResource_FieldPathSelectorReducedLabels
}

func (fp *MonitoredResource_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *MonitoredResource_FieldTerminalPath) WithIValue(value interface{}) MonitoredResource_FieldPathValue {
	switch fp.selector {
	case MonitoredResource_FieldPathSelectorType:
		return &MonitoredResource_FieldTerminalPathValue{MonitoredResource_FieldTerminalPath: *fp, value: value.(string)}
	case MonitoredResource_FieldPathSelectorLabels:
		return &MonitoredResource_FieldTerminalPathValue{MonitoredResource_FieldTerminalPath: *fp, value: value.(map[string]string)}
	case MonitoredResource_FieldPathSelectorReducedLabels:
		return &MonitoredResource_FieldTerminalPathValue{MonitoredResource_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fp.selector))
	}
}

func (fp *MonitoredResource_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *MonitoredResource_FieldTerminalPath) WithIArrayOfValues(values interface{}) MonitoredResource_FieldPathArrayOfValues {
	fpaov := &MonitoredResource_FieldTerminalPathArrayOfValues{MonitoredResource_FieldTerminalPath: *fp}
	switch fp.selector {
	case MonitoredResource_FieldPathSelectorType:
		return &MonitoredResource_FieldTerminalPathArrayOfValues{MonitoredResource_FieldTerminalPath: *fp, values: values.([]string)}
	case MonitoredResource_FieldPathSelectorLabels:
		return &MonitoredResource_FieldTerminalPathArrayOfValues{MonitoredResource_FieldTerminalPath: *fp, values: values.([]map[string]string)}
	case MonitoredResource_FieldPathSelectorReducedLabels:
		return &MonitoredResource_FieldTerminalPathArrayOfValues{MonitoredResource_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fp.selector))
	}
	return fpaov
}

func (fp *MonitoredResource_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *MonitoredResource_FieldTerminalPath) WithIArrayItemValue(value interface{}) MonitoredResource_FieldPathArrayItemValue {
	switch fp.selector {
	case MonitoredResource_FieldPathSelectorReducedLabels:
		return &MonitoredResource_FieldTerminalPathArrayItemValue{MonitoredResource_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fp.selector))
	}
}

func (fp *MonitoredResource_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type MonitoredResource_FieldPathMap struct {
	key      string
	selector MonitoredResource_FieldPathSelector
}

var _ MonitoredResource_FieldPath = (*MonitoredResource_FieldPathMap)(nil)

func (fpm *MonitoredResource_FieldPathMap) Selector() MonitoredResource_FieldPathSelector {
	return fpm.selector
}

func (fpm *MonitoredResource_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *MonitoredResource_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *MonitoredResource_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source MonitoredResource
func (fpm *MonitoredResource_FieldPathMap) Get(source *MonitoredResource) (values []interface{}) {
	switch fpm.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		if value, ok := source.GetLabels()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpm.selector))
	}
	return
}

func (fpm *MonitoredResource_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*MonitoredResource))
}

// GetSingle returns value by selected field map key from source MonitoredResource
func (fpm *MonitoredResource_FieldPathMap) GetSingle(source *MonitoredResource) (interface{}, bool) {
	switch fpm.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		res, ok := source.GetLabels()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpm.selector))
	}
}

func (fpm *MonitoredResource_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*MonitoredResource))
}

// GetDefault returns a default value of the field type
func (fpm *MonitoredResource_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		var v string
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpm.selector))
	}
}

func (fpm *MonitoredResource_FieldPathMap) ClearValue(item *MonitoredResource) {
	if item != nil {
		switch fpm.selector {
		case MonitoredResource_FieldPathSelectorLabels:
			delete(item.Labels, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpm.selector))
		}
	}
}

func (fpm *MonitoredResource_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*MonitoredResource))
}

// IsLeaf - whether field path is holds simple value
func (fpm *MonitoredResource_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		return true
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpm.selector))
	}
}

func (fpm *MonitoredResource_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *MonitoredResource_FieldPathMap) WithIValue(value interface{}) MonitoredResource_FieldPathValue {
	switch fpm.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		return &MonitoredResource_FieldPathMapValue{MonitoredResource_FieldPathMap: *fpm, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpm.selector))
	}
}

func (fpm *MonitoredResource_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *MonitoredResource_FieldPathMap) WithIArrayOfValues(values interface{}) MonitoredResource_FieldPathArrayOfValues {
	switch fpm.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		return &MonitoredResource_FieldPathMapArrayOfValues{MonitoredResource_FieldPathMap: *fpm, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpm.selector))
	}
}

func (fpm *MonitoredResource_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *MonitoredResource_FieldPathMap) WithIArrayItemValue(value interface{}) MonitoredResource_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *MonitoredResource_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

// MonitoredResource_FieldPathValue allows storing values for MonitoredResource fields according to their type
type MonitoredResource_FieldPathValue interface {
	MonitoredResource_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **MonitoredResource)
	CompareWith(*MonitoredResource) (cmp int, comparable bool)
}

func ParseMonitoredResource_FieldPathValue(pathStr, valueStr string) (MonitoredResource_FieldPathValue, error) {
	fp, err := ParseMonitoredResource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MonitoredResource field path value from %s: %v", valueStr, err)
	}
	return fpv.(MonitoredResource_FieldPathValue), nil
}

func MustParseMonitoredResource_FieldPathValue(pathStr, valueStr string) MonitoredResource_FieldPathValue {
	fpv, err := ParseMonitoredResource_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type MonitoredResource_FieldTerminalPathValue struct {
	MonitoredResource_FieldTerminalPath
	value interface{}
}

var _ MonitoredResource_FieldPathValue = (*MonitoredResource_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'MonitoredResource' as interface{}
func (fpv *MonitoredResource_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *MonitoredResource_FieldTerminalPathValue) AsTypeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *MonitoredResource_FieldTerminalPathValue) AsLabelsValue() (map[string]string, bool) {
	res, ok := fpv.value.(map[string]string)
	return res, ok
}
func (fpv *MonitoredResource_FieldTerminalPathValue) AsReducedLabelsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object MonitoredResource
func (fpv *MonitoredResource_FieldTerminalPathValue) SetTo(target **MonitoredResource) {
	if *target == nil {
		*target = new(MonitoredResource)
	}
	switch fpv.selector {
	case MonitoredResource_FieldPathSelectorType:
		(*target).Type = fpv.value.(string)
	case MonitoredResource_FieldPathSelectorLabels:
		(*target).Labels = fpv.value.(map[string]string)
	case MonitoredResource_FieldPathSelectorReducedLabels:
		(*target).ReducedLabels = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpv.selector))
	}
}

func (fpv *MonitoredResource_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*MonitoredResource)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'MonitoredResource_FieldTerminalPathValue' with the value under path in 'MonitoredResource'.
func (fpv *MonitoredResource_FieldTerminalPathValue) CompareWith(source *MonitoredResource) (int, bool) {
	switch fpv.selector {
	case MonitoredResource_FieldPathSelectorType:
		leftValue := fpv.value.(string)
		rightValue := source.GetType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case MonitoredResource_FieldPathSelectorLabels:
		return 0, false
	case MonitoredResource_FieldPathSelectorReducedLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpv.selector))
	}
}

func (fpv *MonitoredResource_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*MonitoredResource))
}

type MonitoredResource_FieldPathMapValue struct {
	MonitoredResource_FieldPathMap
	value interface{}
}

var _ MonitoredResource_FieldPathValue = (*MonitoredResource_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in MonitoredResource as interface{}
func (fpmv *MonitoredResource_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *MonitoredResource_FieldPathMapValue) AsLabelsElementValue() (string, bool) {
	res, ok := fpmv.value.(string)
	return res, ok
}

// SetTo stores value for selected field in MonitoredResource
func (fpmv *MonitoredResource_FieldPathMapValue) SetTo(target **MonitoredResource) {
	if *target == nil {
		*target = new(MonitoredResource)
	}
	switch fpmv.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		if (*target).Labels == nil {
			(*target).Labels = make(map[string]string)
		}
		(*target).Labels[fpmv.key] = fpmv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpmv.selector))
	}
}

func (fpmv *MonitoredResource_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*MonitoredResource)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'MonitoredResource_FieldPathMapValue' with the value under path in 'MonitoredResource'.
func (fpmv *MonitoredResource_FieldPathMapValue) CompareWith(source *MonitoredResource) (int, bool) {
	switch fpmv.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		leftValue := fpmv.value.(string)
		rightValue := source.GetLabels()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResource: %d", fpmv.selector))
	}
}

func (fpmv *MonitoredResource_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*MonitoredResource))
}

// MonitoredResource_FieldPathArrayItemValue allows storing single item in Path-specific values for MonitoredResource according to their type
// Present only for array (repeated) types.
type MonitoredResource_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	MonitoredResource_FieldPath
	ContainsValue(*MonitoredResource) bool
}

// ParseMonitoredResource_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseMonitoredResource_FieldPathArrayItemValue(pathStr, valueStr string) (MonitoredResource_FieldPathArrayItemValue, error) {
	fp, err := ParseMonitoredResource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MonitoredResource field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(MonitoredResource_FieldPathArrayItemValue), nil
}

func MustParseMonitoredResource_FieldPathArrayItemValue(pathStr, valueStr string) MonitoredResource_FieldPathArrayItemValue {
	fpaiv, err := ParseMonitoredResource_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type MonitoredResource_FieldTerminalPathArrayItemValue struct {
	MonitoredResource_FieldTerminalPath
	value interface{}
}

var _ MonitoredResource_FieldPathArrayItemValue = (*MonitoredResource_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object MonitoredResource as interface{}
func (fpaiv *MonitoredResource_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *MonitoredResource_FieldTerminalPathArrayItemValue) AsReducedLabelsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *MonitoredResource_FieldTerminalPathArrayItemValue) GetSingle(source *MonitoredResource) (interface{}, bool) {
	return nil, false
}

func (fpaiv *MonitoredResource_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*MonitoredResource))
}

// Contains returns a boolean indicating if value that is being held is present in given 'MonitoredResource'
func (fpaiv *MonitoredResource_FieldTerminalPathArrayItemValue) ContainsValue(source *MonitoredResource) bool {
	slice := fpaiv.MonitoredResource_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// MonitoredResource_FieldPathArrayOfValues allows storing slice of values for MonitoredResource fields according to their type
type MonitoredResource_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	MonitoredResource_FieldPath
}

func ParseMonitoredResource_FieldPathArrayOfValues(pathStr, valuesStr string) (MonitoredResource_FieldPathArrayOfValues, error) {
	fp, err := ParseMonitoredResource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MonitoredResource field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(MonitoredResource_FieldPathArrayOfValues), nil
}

func MustParseMonitoredResource_FieldPathArrayOfValues(pathStr, valuesStr string) MonitoredResource_FieldPathArrayOfValues {
	fpaov, err := ParseMonitoredResource_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type MonitoredResource_FieldTerminalPathArrayOfValues struct {
	MonitoredResource_FieldTerminalPath
	values interface{}
}

var _ MonitoredResource_FieldPathArrayOfValues = (*MonitoredResource_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *MonitoredResource_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case MonitoredResource_FieldPathSelectorType:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case MonitoredResource_FieldPathSelectorLabels:
		for _, v := range fpaov.values.([]map[string]string) {
			values = append(values, v)
		}
	case MonitoredResource_FieldPathSelectorReducedLabels:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *MonitoredResource_FieldTerminalPathArrayOfValues) AsTypeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *MonitoredResource_FieldTerminalPathArrayOfValues) AsLabelsArrayOfValues() ([]map[string]string, bool) {
	res, ok := fpaov.values.([]map[string]string)
	return res, ok
}
func (fpaov *MonitoredResource_FieldTerminalPathArrayOfValues) AsReducedLabelsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

type MonitoredResource_FieldPathMapArrayOfValues struct {
	MonitoredResource_FieldPathMap
	values interface{}
}

var _ MonitoredResource_FieldPathArrayOfValues = (*MonitoredResource_FieldPathMapArrayOfValues)(nil)

func (fpmaov *MonitoredResource_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case MonitoredResource_FieldPathSelectorLabels:
		for _, v := range fpmaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *MonitoredResource_FieldPathMapArrayOfValues) AsLabelsArrayOfElementValues() ([]string, bool) {
	res, ok := fpmaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Strings_FieldPath interface {
	gotenobject.FieldPath
	Selector() Strings_FieldPathSelector
	Get(source *Strings) []interface{}
	GetSingle(source *Strings) (interface{}, bool)
	ClearValue(item *Strings)

	// Those methods build corresponding Strings_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Strings_FieldPathValue
	WithIArrayOfValues(values interface{}) Strings_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Strings_FieldPathArrayItemValue
}

type Strings_FieldPathSelector int32

const (
	Strings_FieldPathSelectorValues Strings_FieldPathSelector = 0
)

func (s Strings_FieldPathSelector) String() string {
	switch s {
	case Strings_FieldPathSelectorValues:
		return "values"
	default:
		panic(fmt.Sprintf("Invalid selector for Strings: %d", s))
	}
}

func BuildStrings_FieldPath(fp gotenobject.RawFieldPath) (Strings_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Strings")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "values":
			return &Strings_FieldTerminalPath{selector: Strings_FieldPathSelectorValues}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Strings", fp)
}

func ParseStrings_FieldPath(rawField string) (Strings_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildStrings_FieldPath(fp)
}

func MustParseStrings_FieldPath(rawField string) Strings_FieldPath {
	fp, err := ParseStrings_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Strings_FieldTerminalPath struct {
	selector Strings_FieldPathSelector
}

var _ Strings_FieldPath = (*Strings_FieldTerminalPath)(nil)

func (fp *Strings_FieldTerminalPath) Selector() Strings_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Strings_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Strings_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Strings
func (fp *Strings_FieldTerminalPath) Get(source *Strings) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Strings_FieldPathSelectorValues:
			for _, value := range source.GetValues() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Strings: %d", fp.selector))
		}
	}
	return
}

func (fp *Strings_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Strings))
}

// GetSingle returns value pointed by specific field of from source Strings
func (fp *Strings_FieldTerminalPath) GetSingle(source *Strings) (interface{}, bool) {
	switch fp.selector {
	case Strings_FieldPathSelectorValues:
		res := source.GetValues()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Strings: %d", fp.selector))
	}
}

func (fp *Strings_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Strings))
}

// GetDefault returns a default value of the field type
func (fp *Strings_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Strings_FieldPathSelectorValues:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Strings: %d", fp.selector))
	}
}

func (fp *Strings_FieldTerminalPath) ClearValue(item *Strings) {
	if item != nil {
		switch fp.selector {
		case Strings_FieldPathSelectorValues:
			item.Values = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Strings: %d", fp.selector))
		}
	}
}

func (fp *Strings_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Strings))
}

// IsLeaf - whether field path is holds simple value
func (fp *Strings_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Strings_FieldPathSelectorValues
}

func (fp *Strings_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Strings_FieldTerminalPath) WithIValue(value interface{}) Strings_FieldPathValue {
	switch fp.selector {
	case Strings_FieldPathSelectorValues:
		return &Strings_FieldTerminalPathValue{Strings_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Strings: %d", fp.selector))
	}
}

func (fp *Strings_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Strings_FieldTerminalPath) WithIArrayOfValues(values interface{}) Strings_FieldPathArrayOfValues {
	fpaov := &Strings_FieldTerminalPathArrayOfValues{Strings_FieldTerminalPath: *fp}
	switch fp.selector {
	case Strings_FieldPathSelectorValues:
		return &Strings_FieldTerminalPathArrayOfValues{Strings_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Strings: %d", fp.selector))
	}
	return fpaov
}

func (fp *Strings_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Strings_FieldTerminalPath) WithIArrayItemValue(value interface{}) Strings_FieldPathArrayItemValue {
	switch fp.selector {
	case Strings_FieldPathSelectorValues:
		return &Strings_FieldTerminalPathArrayItemValue{Strings_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Strings: %d", fp.selector))
	}
}

func (fp *Strings_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Strings_FieldPathValue allows storing values for Strings fields according to their type
type Strings_FieldPathValue interface {
	Strings_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Strings)
	CompareWith(*Strings) (cmp int, comparable bool)
}

func ParseStrings_FieldPathValue(pathStr, valueStr string) (Strings_FieldPathValue, error) {
	fp, err := ParseStrings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Strings field path value from %s: %v", valueStr, err)
	}
	return fpv.(Strings_FieldPathValue), nil
}

func MustParseStrings_FieldPathValue(pathStr, valueStr string) Strings_FieldPathValue {
	fpv, err := ParseStrings_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Strings_FieldTerminalPathValue struct {
	Strings_FieldTerminalPath
	value interface{}
}

var _ Strings_FieldPathValue = (*Strings_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Strings' as interface{}
func (fpv *Strings_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Strings_FieldTerminalPathValue) AsValuesValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object Strings
func (fpv *Strings_FieldTerminalPathValue) SetTo(target **Strings) {
	if *target == nil {
		*target = new(Strings)
	}
	switch fpv.selector {
	case Strings_FieldPathSelectorValues:
		(*target).Values = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for Strings: %d", fpv.selector))
	}
}

func (fpv *Strings_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Strings)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Strings_FieldTerminalPathValue' with the value under path in 'Strings'.
func (fpv *Strings_FieldTerminalPathValue) CompareWith(source *Strings) (int, bool) {
	switch fpv.selector {
	case Strings_FieldPathSelectorValues:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Strings: %d", fpv.selector))
	}
}

func (fpv *Strings_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Strings))
}

// Strings_FieldPathArrayItemValue allows storing single item in Path-specific values for Strings according to their type
// Present only for array (repeated) types.
type Strings_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Strings_FieldPath
	ContainsValue(*Strings) bool
}

// ParseStrings_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseStrings_FieldPathArrayItemValue(pathStr, valueStr string) (Strings_FieldPathArrayItemValue, error) {
	fp, err := ParseStrings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Strings field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Strings_FieldPathArrayItemValue), nil
}

func MustParseStrings_FieldPathArrayItemValue(pathStr, valueStr string) Strings_FieldPathArrayItemValue {
	fpaiv, err := ParseStrings_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Strings_FieldTerminalPathArrayItemValue struct {
	Strings_FieldTerminalPath
	value interface{}
}

var _ Strings_FieldPathArrayItemValue = (*Strings_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Strings as interface{}
func (fpaiv *Strings_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Strings_FieldTerminalPathArrayItemValue) AsValuesItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *Strings_FieldTerminalPathArrayItemValue) GetSingle(source *Strings) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Strings_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Strings))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Strings'
func (fpaiv *Strings_FieldTerminalPathArrayItemValue) ContainsValue(source *Strings) bool {
	slice := fpaiv.Strings_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Strings_FieldPathArrayOfValues allows storing slice of values for Strings fields according to their type
type Strings_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Strings_FieldPath
}

func ParseStrings_FieldPathArrayOfValues(pathStr, valuesStr string) (Strings_FieldPathArrayOfValues, error) {
	fp, err := ParseStrings_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Strings field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Strings_FieldPathArrayOfValues), nil
}

func MustParseStrings_FieldPathArrayOfValues(pathStr, valuesStr string) Strings_FieldPathArrayOfValues {
	fpaov, err := ParseStrings_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Strings_FieldTerminalPathArrayOfValues struct {
	Strings_FieldTerminalPath
	values interface{}
}

var _ Strings_FieldPathArrayOfValues = (*Strings_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Strings_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Strings_FieldPathSelectorValues:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Strings_FieldTerminalPathArrayOfValues) AsValuesArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type MonitoredResourceSelector_FieldPath interface {
	gotenobject.FieldPath
	Selector() MonitoredResourceSelector_FieldPathSelector
	Get(source *MonitoredResourceSelector) []interface{}
	GetSingle(source *MonitoredResourceSelector) (interface{}, bool)
	ClearValue(item *MonitoredResourceSelector)

	// Those methods build corresponding MonitoredResourceSelector_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) MonitoredResourceSelector_FieldPathValue
	WithIArrayOfValues(values interface{}) MonitoredResourceSelector_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) MonitoredResourceSelector_FieldPathArrayItemValue
}

type MonitoredResourceSelector_FieldPathSelector int32

const (
	MonitoredResourceSelector_FieldPathSelectorTypes  MonitoredResourceSelector_FieldPathSelector = 0
	MonitoredResourceSelector_FieldPathSelectorLabels MonitoredResourceSelector_FieldPathSelector = 1
)

func (s MonitoredResourceSelector_FieldPathSelector) String() string {
	switch s {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		return "types"
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return "labels"
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", s))
	}
}

func BuildMonitoredResourceSelector_FieldPath(fp gotenobject.RawFieldPath) (MonitoredResourceSelector_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object MonitoredResourceSelector")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "types":
			return &MonitoredResourceSelector_FieldTerminalPath{selector: MonitoredResourceSelector_FieldPathSelectorTypes}, nil
		case "labels":
			return &MonitoredResourceSelector_FieldTerminalPath{selector: MonitoredResourceSelector_FieldPathSelectorLabels}, nil
		}
	} else {
		switch fp[0] {
		case "labels":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object MonitoredResourceSelector)", fp)
			}
			return &MonitoredResourceSelector_FieldPathMap{selector: MonitoredResourceSelector_FieldPathSelectorLabels, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object MonitoredResourceSelector", fp)
}

func ParseMonitoredResourceSelector_FieldPath(rawField string) (MonitoredResourceSelector_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildMonitoredResourceSelector_FieldPath(fp)
}

func MustParseMonitoredResourceSelector_FieldPath(rawField string) MonitoredResourceSelector_FieldPath {
	fp, err := ParseMonitoredResourceSelector_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type MonitoredResourceSelector_FieldTerminalPath struct {
	selector MonitoredResourceSelector_FieldPathSelector
}

var _ MonitoredResourceSelector_FieldPath = (*MonitoredResourceSelector_FieldTerminalPath)(nil)

func (fp *MonitoredResourceSelector_FieldTerminalPath) Selector() MonitoredResourceSelector_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *MonitoredResourceSelector_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *MonitoredResourceSelector_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source MonitoredResourceSelector
func (fp *MonitoredResourceSelector_FieldTerminalPath) Get(source *MonitoredResourceSelector) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case MonitoredResourceSelector_FieldPathSelectorTypes:
			for _, value := range source.GetTypes() {
				values = append(values, value)
			}
		case MonitoredResourceSelector_FieldPathSelectorLabels:
			if source.Labels != nil {
				values = append(values, source.Labels)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fp.selector))
		}
	}
	return
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*MonitoredResourceSelector))
}

// GetSingle returns value pointed by specific field of from source MonitoredResourceSelector
func (fp *MonitoredResourceSelector_FieldTerminalPath) GetSingle(source *MonitoredResourceSelector) (interface{}, bool) {
	switch fp.selector {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		res := source.GetTypes()
		return res, res != nil
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		res := source.GetLabels()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fp.selector))
	}
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*MonitoredResourceSelector))
}

// GetDefault returns a default value of the field type
func (fp *MonitoredResourceSelector_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		return ([]string)(nil)
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return (map[string]*Strings)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fp.selector))
	}
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) ClearValue(item *MonitoredResourceSelector) {
	if item != nil {
		switch fp.selector {
		case MonitoredResourceSelector_FieldPathSelectorTypes:
			item.Types = nil
		case MonitoredResourceSelector_FieldPathSelectorLabels:
			item.Labels = nil
		default:
			panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fp.selector))
		}
	}
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*MonitoredResourceSelector))
}

// IsLeaf - whether field path is holds simple value
func (fp *MonitoredResourceSelector_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == MonitoredResourceSelector_FieldPathSelectorTypes
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) WithIValue(value interface{}) MonitoredResourceSelector_FieldPathValue {
	switch fp.selector {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		return &MonitoredResourceSelector_FieldTerminalPathValue{MonitoredResourceSelector_FieldTerminalPath: *fp, value: value.([]string)}
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return &MonitoredResourceSelector_FieldTerminalPathValue{MonitoredResourceSelector_FieldTerminalPath: *fp, value: value.(map[string]*Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fp.selector))
	}
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) WithIArrayOfValues(values interface{}) MonitoredResourceSelector_FieldPathArrayOfValues {
	fpaov := &MonitoredResourceSelector_FieldTerminalPathArrayOfValues{MonitoredResourceSelector_FieldTerminalPath: *fp}
	switch fp.selector {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		return &MonitoredResourceSelector_FieldTerminalPathArrayOfValues{MonitoredResourceSelector_FieldTerminalPath: *fp, values: values.([][]string)}
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return &MonitoredResourceSelector_FieldTerminalPathArrayOfValues{MonitoredResourceSelector_FieldTerminalPath: *fp, values: values.([]map[string]*Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fp.selector))
	}
	return fpaov
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) WithIArrayItemValue(value interface{}) MonitoredResourceSelector_FieldPathArrayItemValue {
	switch fp.selector {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		return &MonitoredResourceSelector_FieldTerminalPathArrayItemValue{MonitoredResourceSelector_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fp.selector))
	}
}

func (fp *MonitoredResourceSelector_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type MonitoredResourceSelector_FieldPathMap struct {
	key      string
	selector MonitoredResourceSelector_FieldPathSelector
}

var _ MonitoredResourceSelector_FieldPath = (*MonitoredResourceSelector_FieldPathMap)(nil)

func (fpm *MonitoredResourceSelector_FieldPathMap) Selector() MonitoredResourceSelector_FieldPathSelector {
	return fpm.selector
}

func (fpm *MonitoredResourceSelector_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *MonitoredResourceSelector_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *MonitoredResourceSelector_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source MonitoredResourceSelector
func (fpm *MonitoredResourceSelector_FieldPathMap) Get(source *MonitoredResourceSelector) (values []interface{}) {
	switch fpm.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		if value, ok := source.GetLabels()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpm.selector))
	}
	return
}

func (fpm *MonitoredResourceSelector_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*MonitoredResourceSelector))
}

// GetSingle returns value by selected field map key from source MonitoredResourceSelector
func (fpm *MonitoredResourceSelector_FieldPathMap) GetSingle(source *MonitoredResourceSelector) (interface{}, bool) {
	switch fpm.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		res, ok := source.GetLabels()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpm.selector))
	}
}

func (fpm *MonitoredResourceSelector_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*MonitoredResourceSelector))
}

// GetDefault returns a default value of the field type
func (fpm *MonitoredResourceSelector_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		var v *Strings
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpm.selector))
	}
}

func (fpm *MonitoredResourceSelector_FieldPathMap) ClearValue(item *MonitoredResourceSelector) {
	if item != nil {
		switch fpm.selector {
		case MonitoredResourceSelector_FieldPathSelectorLabels:
			delete(item.Labels, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpm.selector))
		}
	}
}

func (fpm *MonitoredResourceSelector_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*MonitoredResourceSelector))
}

// IsLeaf - whether field path is holds simple value
func (fpm *MonitoredResourceSelector_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpm.selector))
	}
}

func (fpm *MonitoredResourceSelector_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *MonitoredResourceSelector_FieldPathMap) WithIValue(value interface{}) MonitoredResourceSelector_FieldPathValue {
	switch fpm.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return &MonitoredResourceSelector_FieldPathMapValue{MonitoredResourceSelector_FieldPathMap: *fpm, value: value.(*Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpm.selector))
	}
}

func (fpm *MonitoredResourceSelector_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *MonitoredResourceSelector_FieldPathMap) WithIArrayOfValues(values interface{}) MonitoredResourceSelector_FieldPathArrayOfValues {
	switch fpm.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return &MonitoredResourceSelector_FieldPathMapArrayOfValues{MonitoredResourceSelector_FieldPathMap: *fpm, values: values.([]*Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpm.selector))
	}
}

func (fpm *MonitoredResourceSelector_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *MonitoredResourceSelector_FieldPathMap) WithIArrayItemValue(value interface{}) MonitoredResourceSelector_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *MonitoredResourceSelector_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

// MonitoredResourceSelector_FieldPathValue allows storing values for MonitoredResourceSelector fields according to their type
type MonitoredResourceSelector_FieldPathValue interface {
	MonitoredResourceSelector_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **MonitoredResourceSelector)
	CompareWith(*MonitoredResourceSelector) (cmp int, comparable bool)
}

func ParseMonitoredResourceSelector_FieldPathValue(pathStr, valueStr string) (MonitoredResourceSelector_FieldPathValue, error) {
	fp, err := ParseMonitoredResourceSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MonitoredResourceSelector field path value from %s: %v", valueStr, err)
	}
	return fpv.(MonitoredResourceSelector_FieldPathValue), nil
}

func MustParseMonitoredResourceSelector_FieldPathValue(pathStr, valueStr string) MonitoredResourceSelector_FieldPathValue {
	fpv, err := ParseMonitoredResourceSelector_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type MonitoredResourceSelector_FieldTerminalPathValue struct {
	MonitoredResourceSelector_FieldTerminalPath
	value interface{}
}

var _ MonitoredResourceSelector_FieldPathValue = (*MonitoredResourceSelector_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'MonitoredResourceSelector' as interface{}
func (fpv *MonitoredResourceSelector_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *MonitoredResourceSelector_FieldTerminalPathValue) AsTypesValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *MonitoredResourceSelector_FieldTerminalPathValue) AsLabelsValue() (map[string]*Strings, bool) {
	res, ok := fpv.value.(map[string]*Strings)
	return res, ok
}

// SetTo stores value for selected field for object MonitoredResourceSelector
func (fpv *MonitoredResourceSelector_FieldTerminalPathValue) SetTo(target **MonitoredResourceSelector) {
	if *target == nil {
		*target = new(MonitoredResourceSelector)
	}
	switch fpv.selector {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		(*target).Types = fpv.value.([]string)
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		(*target).Labels = fpv.value.(map[string]*Strings)
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpv.selector))
	}
}

func (fpv *MonitoredResourceSelector_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*MonitoredResourceSelector)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'MonitoredResourceSelector_FieldTerminalPathValue' with the value under path in 'MonitoredResourceSelector'.
func (fpv *MonitoredResourceSelector_FieldTerminalPathValue) CompareWith(source *MonitoredResourceSelector) (int, bool) {
	switch fpv.selector {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		return 0, false
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpv.selector))
	}
}

func (fpv *MonitoredResourceSelector_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*MonitoredResourceSelector))
}

type MonitoredResourceSelector_FieldPathMapValue struct {
	MonitoredResourceSelector_FieldPathMap
	value interface{}
}

var _ MonitoredResourceSelector_FieldPathValue = (*MonitoredResourceSelector_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in MonitoredResourceSelector as interface{}
func (fpmv *MonitoredResourceSelector_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *MonitoredResourceSelector_FieldPathMapValue) AsLabelsElementValue() (*Strings, bool) {
	res, ok := fpmv.value.(*Strings)
	return res, ok
}

// SetTo stores value for selected field in MonitoredResourceSelector
func (fpmv *MonitoredResourceSelector_FieldPathMapValue) SetTo(target **MonitoredResourceSelector) {
	if *target == nil {
		*target = new(MonitoredResourceSelector)
	}
	switch fpmv.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		if (*target).Labels == nil {
			(*target).Labels = make(map[string]*Strings)
		}
		(*target).Labels[fpmv.key] = fpmv.value.(*Strings)
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpmv.selector))
	}
}

func (fpmv *MonitoredResourceSelector_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*MonitoredResourceSelector)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'MonitoredResourceSelector_FieldPathMapValue' with the value under path in 'MonitoredResourceSelector'.
func (fpmv *MonitoredResourceSelector_FieldPathMapValue) CompareWith(source *MonitoredResourceSelector) (int, bool) {
	switch fpmv.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for MonitoredResourceSelector: %d", fpmv.selector))
	}
}

func (fpmv *MonitoredResourceSelector_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*MonitoredResourceSelector))
}

// MonitoredResourceSelector_FieldPathArrayItemValue allows storing single item in Path-specific values for MonitoredResourceSelector according to their type
// Present only for array (repeated) types.
type MonitoredResourceSelector_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	MonitoredResourceSelector_FieldPath
	ContainsValue(*MonitoredResourceSelector) bool
}

// ParseMonitoredResourceSelector_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseMonitoredResourceSelector_FieldPathArrayItemValue(pathStr, valueStr string) (MonitoredResourceSelector_FieldPathArrayItemValue, error) {
	fp, err := ParseMonitoredResourceSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MonitoredResourceSelector field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(MonitoredResourceSelector_FieldPathArrayItemValue), nil
}

func MustParseMonitoredResourceSelector_FieldPathArrayItemValue(pathStr, valueStr string) MonitoredResourceSelector_FieldPathArrayItemValue {
	fpaiv, err := ParseMonitoredResourceSelector_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type MonitoredResourceSelector_FieldTerminalPathArrayItemValue struct {
	MonitoredResourceSelector_FieldTerminalPath
	value interface{}
}

var _ MonitoredResourceSelector_FieldPathArrayItemValue = (*MonitoredResourceSelector_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object MonitoredResourceSelector as interface{}
func (fpaiv *MonitoredResourceSelector_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *MonitoredResourceSelector_FieldTerminalPathArrayItemValue) AsTypesItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *MonitoredResourceSelector_FieldTerminalPathArrayItemValue) GetSingle(source *MonitoredResourceSelector) (interface{}, bool) {
	return nil, false
}

func (fpaiv *MonitoredResourceSelector_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*MonitoredResourceSelector))
}

// Contains returns a boolean indicating if value that is being held is present in given 'MonitoredResourceSelector'
func (fpaiv *MonitoredResourceSelector_FieldTerminalPathArrayItemValue) ContainsValue(source *MonitoredResourceSelector) bool {
	slice := fpaiv.MonitoredResourceSelector_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// MonitoredResourceSelector_FieldPathArrayOfValues allows storing slice of values for MonitoredResourceSelector fields according to their type
type MonitoredResourceSelector_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	MonitoredResourceSelector_FieldPath
}

func ParseMonitoredResourceSelector_FieldPathArrayOfValues(pathStr, valuesStr string) (MonitoredResourceSelector_FieldPathArrayOfValues, error) {
	fp, err := ParseMonitoredResourceSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MonitoredResourceSelector field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(MonitoredResourceSelector_FieldPathArrayOfValues), nil
}

func MustParseMonitoredResourceSelector_FieldPathArrayOfValues(pathStr, valuesStr string) MonitoredResourceSelector_FieldPathArrayOfValues {
	fpaov, err := ParseMonitoredResourceSelector_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type MonitoredResourceSelector_FieldTerminalPathArrayOfValues struct {
	MonitoredResourceSelector_FieldTerminalPath
	values interface{}
}

var _ MonitoredResourceSelector_FieldPathArrayOfValues = (*MonitoredResourceSelector_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *MonitoredResourceSelector_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case MonitoredResourceSelector_FieldPathSelectorTypes:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		for _, v := range fpaov.values.([]map[string]*Strings) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *MonitoredResourceSelector_FieldTerminalPathArrayOfValues) AsTypesArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *MonitoredResourceSelector_FieldTerminalPathArrayOfValues) AsLabelsArrayOfValues() ([]map[string]*Strings, bool) {
	res, ok := fpaov.values.([]map[string]*Strings)
	return res, ok
}

type MonitoredResourceSelector_FieldPathMapArrayOfValues struct {
	MonitoredResourceSelector_FieldPathMap
	values interface{}
}

var _ MonitoredResourceSelector_FieldPathArrayOfValues = (*MonitoredResourceSelector_FieldPathMapArrayOfValues)(nil)

func (fpmaov *MonitoredResourceSelector_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case MonitoredResourceSelector_FieldPathSelectorLabels:
		for _, v := range fpmaov.values.([]*Strings) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *MonitoredResourceSelector_FieldPathMapArrayOfValues) AsLabelsArrayOfElementValues() ([]*Strings, bool) {
	res, ok := fpmaov.values.([]*Strings)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type MetricSelector_FieldPath interface {
	gotenobject.FieldPath
	Selector() MetricSelector_FieldPathSelector
	Get(source *MetricSelector) []interface{}
	GetSingle(source *MetricSelector) (interface{}, bool)
	ClearValue(item *MetricSelector)

	// Those methods build corresponding MetricSelector_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) MetricSelector_FieldPathValue
	WithIArrayOfValues(values interface{}) MetricSelector_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) MetricSelector_FieldPathArrayItemValue
}

type MetricSelector_FieldPathSelector int32

const (
	MetricSelector_FieldPathSelectorTypes  MetricSelector_FieldPathSelector = 0
	MetricSelector_FieldPathSelectorLabels MetricSelector_FieldPathSelector = 1
)

func (s MetricSelector_FieldPathSelector) String() string {
	switch s {
	case MetricSelector_FieldPathSelectorTypes:
		return "types"
	case MetricSelector_FieldPathSelectorLabels:
		return "labels"
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", s))
	}
}

func BuildMetricSelector_FieldPath(fp gotenobject.RawFieldPath) (MetricSelector_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object MetricSelector")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "types":
			return &MetricSelector_FieldTerminalPath{selector: MetricSelector_FieldPathSelectorTypes}, nil
		case "labels":
			return &MetricSelector_FieldTerminalPath{selector: MetricSelector_FieldPathSelectorLabels}, nil
		}
	} else {
		switch fp[0] {
		case "labels":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object MetricSelector)", fp)
			}
			return &MetricSelector_FieldPathMap{selector: MetricSelector_FieldPathSelectorLabels, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object MetricSelector", fp)
}

func ParseMetricSelector_FieldPath(rawField string) (MetricSelector_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildMetricSelector_FieldPath(fp)
}

func MustParseMetricSelector_FieldPath(rawField string) MetricSelector_FieldPath {
	fp, err := ParseMetricSelector_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type MetricSelector_FieldTerminalPath struct {
	selector MetricSelector_FieldPathSelector
}

var _ MetricSelector_FieldPath = (*MetricSelector_FieldTerminalPath)(nil)

func (fp *MetricSelector_FieldTerminalPath) Selector() MetricSelector_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *MetricSelector_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *MetricSelector_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source MetricSelector
func (fp *MetricSelector_FieldTerminalPath) Get(source *MetricSelector) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case MetricSelector_FieldPathSelectorTypes:
			for _, value := range source.GetTypes() {
				values = append(values, value)
			}
		case MetricSelector_FieldPathSelectorLabels:
			if source.Labels != nil {
				values = append(values, source.Labels)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fp.selector))
		}
	}
	return
}

func (fp *MetricSelector_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*MetricSelector))
}

// GetSingle returns value pointed by specific field of from source MetricSelector
func (fp *MetricSelector_FieldTerminalPath) GetSingle(source *MetricSelector) (interface{}, bool) {
	switch fp.selector {
	case MetricSelector_FieldPathSelectorTypes:
		res := source.GetTypes()
		return res, res != nil
	case MetricSelector_FieldPathSelectorLabels:
		res := source.GetLabels()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fp.selector))
	}
}

func (fp *MetricSelector_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*MetricSelector))
}

// GetDefault returns a default value of the field type
func (fp *MetricSelector_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case MetricSelector_FieldPathSelectorTypes:
		return ([]string)(nil)
	case MetricSelector_FieldPathSelectorLabels:
		return (map[string]*Strings)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fp.selector))
	}
}

func (fp *MetricSelector_FieldTerminalPath) ClearValue(item *MetricSelector) {
	if item != nil {
		switch fp.selector {
		case MetricSelector_FieldPathSelectorTypes:
			item.Types = nil
		case MetricSelector_FieldPathSelectorLabels:
			item.Labels = nil
		default:
			panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fp.selector))
		}
	}
}

func (fp *MetricSelector_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*MetricSelector))
}

// IsLeaf - whether field path is holds simple value
func (fp *MetricSelector_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == MetricSelector_FieldPathSelectorTypes
}

func (fp *MetricSelector_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *MetricSelector_FieldTerminalPath) WithIValue(value interface{}) MetricSelector_FieldPathValue {
	switch fp.selector {
	case MetricSelector_FieldPathSelectorTypes:
		return &MetricSelector_FieldTerminalPathValue{MetricSelector_FieldTerminalPath: *fp, value: value.([]string)}
	case MetricSelector_FieldPathSelectorLabels:
		return &MetricSelector_FieldTerminalPathValue{MetricSelector_FieldTerminalPath: *fp, value: value.(map[string]*Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fp.selector))
	}
}

func (fp *MetricSelector_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *MetricSelector_FieldTerminalPath) WithIArrayOfValues(values interface{}) MetricSelector_FieldPathArrayOfValues {
	fpaov := &MetricSelector_FieldTerminalPathArrayOfValues{MetricSelector_FieldTerminalPath: *fp}
	switch fp.selector {
	case MetricSelector_FieldPathSelectorTypes:
		return &MetricSelector_FieldTerminalPathArrayOfValues{MetricSelector_FieldTerminalPath: *fp, values: values.([][]string)}
	case MetricSelector_FieldPathSelectorLabels:
		return &MetricSelector_FieldTerminalPathArrayOfValues{MetricSelector_FieldTerminalPath: *fp, values: values.([]map[string]*Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fp.selector))
	}
	return fpaov
}

func (fp *MetricSelector_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *MetricSelector_FieldTerminalPath) WithIArrayItemValue(value interface{}) MetricSelector_FieldPathArrayItemValue {
	switch fp.selector {
	case MetricSelector_FieldPathSelectorTypes:
		return &MetricSelector_FieldTerminalPathArrayItemValue{MetricSelector_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fp.selector))
	}
}

func (fp *MetricSelector_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type MetricSelector_FieldPathMap struct {
	key      string
	selector MetricSelector_FieldPathSelector
}

var _ MetricSelector_FieldPath = (*MetricSelector_FieldPathMap)(nil)

func (fpm *MetricSelector_FieldPathMap) Selector() MetricSelector_FieldPathSelector {
	return fpm.selector
}

func (fpm *MetricSelector_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *MetricSelector_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *MetricSelector_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source MetricSelector
func (fpm *MetricSelector_FieldPathMap) Get(source *MetricSelector) (values []interface{}) {
	switch fpm.selector {
	case MetricSelector_FieldPathSelectorLabels:
		if value, ok := source.GetLabels()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpm.selector))
	}
	return
}

func (fpm *MetricSelector_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*MetricSelector))
}

// GetSingle returns value by selected field map key from source MetricSelector
func (fpm *MetricSelector_FieldPathMap) GetSingle(source *MetricSelector) (interface{}, bool) {
	switch fpm.selector {
	case MetricSelector_FieldPathSelectorLabels:
		res, ok := source.GetLabels()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpm.selector))
	}
}

func (fpm *MetricSelector_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*MetricSelector))
}

// GetDefault returns a default value of the field type
func (fpm *MetricSelector_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case MetricSelector_FieldPathSelectorLabels:
		var v *Strings
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpm.selector))
	}
}

func (fpm *MetricSelector_FieldPathMap) ClearValue(item *MetricSelector) {
	if item != nil {
		switch fpm.selector {
		case MetricSelector_FieldPathSelectorLabels:
			delete(item.Labels, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpm.selector))
		}
	}
}

func (fpm *MetricSelector_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*MetricSelector))
}

// IsLeaf - whether field path is holds simple value
func (fpm *MetricSelector_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case MetricSelector_FieldPathSelectorLabels:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpm.selector))
	}
}

func (fpm *MetricSelector_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *MetricSelector_FieldPathMap) WithIValue(value interface{}) MetricSelector_FieldPathValue {
	switch fpm.selector {
	case MetricSelector_FieldPathSelectorLabels:
		return &MetricSelector_FieldPathMapValue{MetricSelector_FieldPathMap: *fpm, value: value.(*Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpm.selector))
	}
}

func (fpm *MetricSelector_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *MetricSelector_FieldPathMap) WithIArrayOfValues(values interface{}) MetricSelector_FieldPathArrayOfValues {
	switch fpm.selector {
	case MetricSelector_FieldPathSelectorLabels:
		return &MetricSelector_FieldPathMapArrayOfValues{MetricSelector_FieldPathMap: *fpm, values: values.([]*Strings)}
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpm.selector))
	}
}

func (fpm *MetricSelector_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *MetricSelector_FieldPathMap) WithIArrayItemValue(value interface{}) MetricSelector_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *MetricSelector_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

// MetricSelector_FieldPathValue allows storing values for MetricSelector fields according to their type
type MetricSelector_FieldPathValue interface {
	MetricSelector_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **MetricSelector)
	CompareWith(*MetricSelector) (cmp int, comparable bool)
}

func ParseMetricSelector_FieldPathValue(pathStr, valueStr string) (MetricSelector_FieldPathValue, error) {
	fp, err := ParseMetricSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MetricSelector field path value from %s: %v", valueStr, err)
	}
	return fpv.(MetricSelector_FieldPathValue), nil
}

func MustParseMetricSelector_FieldPathValue(pathStr, valueStr string) MetricSelector_FieldPathValue {
	fpv, err := ParseMetricSelector_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type MetricSelector_FieldTerminalPathValue struct {
	MetricSelector_FieldTerminalPath
	value interface{}
}

var _ MetricSelector_FieldPathValue = (*MetricSelector_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'MetricSelector' as interface{}
func (fpv *MetricSelector_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *MetricSelector_FieldTerminalPathValue) AsTypesValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *MetricSelector_FieldTerminalPathValue) AsLabelsValue() (map[string]*Strings, bool) {
	res, ok := fpv.value.(map[string]*Strings)
	return res, ok
}

// SetTo stores value for selected field for object MetricSelector
func (fpv *MetricSelector_FieldTerminalPathValue) SetTo(target **MetricSelector) {
	if *target == nil {
		*target = new(MetricSelector)
	}
	switch fpv.selector {
	case MetricSelector_FieldPathSelectorTypes:
		(*target).Types = fpv.value.([]string)
	case MetricSelector_FieldPathSelectorLabels:
		(*target).Labels = fpv.value.(map[string]*Strings)
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpv.selector))
	}
}

func (fpv *MetricSelector_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*MetricSelector)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'MetricSelector_FieldTerminalPathValue' with the value under path in 'MetricSelector'.
func (fpv *MetricSelector_FieldTerminalPathValue) CompareWith(source *MetricSelector) (int, bool) {
	switch fpv.selector {
	case MetricSelector_FieldPathSelectorTypes:
		return 0, false
	case MetricSelector_FieldPathSelectorLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpv.selector))
	}
}

func (fpv *MetricSelector_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*MetricSelector))
}

type MetricSelector_FieldPathMapValue struct {
	MetricSelector_FieldPathMap
	value interface{}
}

var _ MetricSelector_FieldPathValue = (*MetricSelector_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in MetricSelector as interface{}
func (fpmv *MetricSelector_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *MetricSelector_FieldPathMapValue) AsLabelsElementValue() (*Strings, bool) {
	res, ok := fpmv.value.(*Strings)
	return res, ok
}

// SetTo stores value for selected field in MetricSelector
func (fpmv *MetricSelector_FieldPathMapValue) SetTo(target **MetricSelector) {
	if *target == nil {
		*target = new(MetricSelector)
	}
	switch fpmv.selector {
	case MetricSelector_FieldPathSelectorLabels:
		if (*target).Labels == nil {
			(*target).Labels = make(map[string]*Strings)
		}
		(*target).Labels[fpmv.key] = fpmv.value.(*Strings)
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpmv.selector))
	}
}

func (fpmv *MetricSelector_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*MetricSelector)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'MetricSelector_FieldPathMapValue' with the value under path in 'MetricSelector'.
func (fpmv *MetricSelector_FieldPathMapValue) CompareWith(source *MetricSelector) (int, bool) {
	switch fpmv.selector {
	case MetricSelector_FieldPathSelectorLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for MetricSelector: %d", fpmv.selector))
	}
}

func (fpmv *MetricSelector_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*MetricSelector))
}

// MetricSelector_FieldPathArrayItemValue allows storing single item in Path-specific values for MetricSelector according to their type
// Present only for array (repeated) types.
type MetricSelector_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	MetricSelector_FieldPath
	ContainsValue(*MetricSelector) bool
}

// ParseMetricSelector_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseMetricSelector_FieldPathArrayItemValue(pathStr, valueStr string) (MetricSelector_FieldPathArrayItemValue, error) {
	fp, err := ParseMetricSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MetricSelector field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(MetricSelector_FieldPathArrayItemValue), nil
}

func MustParseMetricSelector_FieldPathArrayItemValue(pathStr, valueStr string) MetricSelector_FieldPathArrayItemValue {
	fpaiv, err := ParseMetricSelector_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type MetricSelector_FieldTerminalPathArrayItemValue struct {
	MetricSelector_FieldTerminalPath
	value interface{}
}

var _ MetricSelector_FieldPathArrayItemValue = (*MetricSelector_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object MetricSelector as interface{}
func (fpaiv *MetricSelector_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *MetricSelector_FieldTerminalPathArrayItemValue) AsTypesItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *MetricSelector_FieldTerminalPathArrayItemValue) GetSingle(source *MetricSelector) (interface{}, bool) {
	return nil, false
}

func (fpaiv *MetricSelector_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*MetricSelector))
}

// Contains returns a boolean indicating if value that is being held is present in given 'MetricSelector'
func (fpaiv *MetricSelector_FieldTerminalPathArrayItemValue) ContainsValue(source *MetricSelector) bool {
	slice := fpaiv.MetricSelector_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// MetricSelector_FieldPathArrayOfValues allows storing slice of values for MetricSelector fields according to their type
type MetricSelector_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	MetricSelector_FieldPath
}

func ParseMetricSelector_FieldPathArrayOfValues(pathStr, valuesStr string) (MetricSelector_FieldPathArrayOfValues, error) {
	fp, err := ParseMetricSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing MetricSelector field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(MetricSelector_FieldPathArrayOfValues), nil
}

func MustParseMetricSelector_FieldPathArrayOfValues(pathStr, valuesStr string) MetricSelector_FieldPathArrayOfValues {
	fpaov, err := ParseMetricSelector_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type MetricSelector_FieldTerminalPathArrayOfValues struct {
	MetricSelector_FieldTerminalPath
	values interface{}
}

var _ MetricSelector_FieldPathArrayOfValues = (*MetricSelector_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *MetricSelector_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case MetricSelector_FieldPathSelectorTypes:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case MetricSelector_FieldPathSelectorLabels:
		for _, v := range fpaov.values.([]map[string]*Strings) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *MetricSelector_FieldTerminalPathArrayOfValues) AsTypesArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *MetricSelector_FieldTerminalPathArrayOfValues) AsLabelsArrayOfValues() ([]map[string]*Strings, bool) {
	res, ok := fpaov.values.([]map[string]*Strings)
	return res, ok
}

type MetricSelector_FieldPathMapArrayOfValues struct {
	MetricSelector_FieldPathMap
	values interface{}
}

var _ MetricSelector_FieldPathArrayOfValues = (*MetricSelector_FieldPathMapArrayOfValues)(nil)

func (fpmaov *MetricSelector_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case MetricSelector_FieldPathSelectorLabels:
		for _, v := range fpmaov.values.([]*Strings) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *MetricSelector_FieldPathMapArrayOfValues) AsLabelsArrayOfElementValues() ([]*Strings, bool) {
	res, ok := fpmaov.values.([]*Strings)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type TimeSeriesSelector_FieldPath interface {
	gotenobject.FieldPath
	Selector() TimeSeriesSelector_FieldPathSelector
	Get(source *TimeSeriesSelector) []interface{}
	GetSingle(source *TimeSeriesSelector) (interface{}, bool)
	ClearValue(item *TimeSeriesSelector)

	// Those methods build corresponding TimeSeriesSelector_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) TimeSeriesSelector_FieldPathValue
	WithIArrayOfValues(values interface{}) TimeSeriesSelector_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) TimeSeriesSelector_FieldPathArrayItemValue
}

type TimeSeriesSelector_FieldPathSelector int32

const (
	TimeSeriesSelector_FieldPathSelectorMetric   TimeSeriesSelector_FieldPathSelector = 0
	TimeSeriesSelector_FieldPathSelectorResource TimeSeriesSelector_FieldPathSelector = 1
)

func (s TimeSeriesSelector_FieldPathSelector) String() string {
	switch s {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		return "metric"
	case TimeSeriesSelector_FieldPathSelectorResource:
		return "resource"
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", s))
	}
}

func BuildTimeSeriesSelector_FieldPath(fp gotenobject.RawFieldPath) (TimeSeriesSelector_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object TimeSeriesSelector")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "metric":
			return &TimeSeriesSelector_FieldTerminalPath{selector: TimeSeriesSelector_FieldPathSelectorMetric}, nil
		case "resource":
			return &TimeSeriesSelector_FieldTerminalPath{selector: TimeSeriesSelector_FieldPathSelectorResource}, nil
		}
	} else {
		switch fp[0] {
		case "metric":
			if subpath, err := BuildMetricSelector_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &TimeSeriesSelector_FieldSubPath{selector: TimeSeriesSelector_FieldPathSelectorMetric, subPath: subpath}, nil
			}
		case "resource":
			if subpath, err := BuildMonitoredResourceSelector_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &TimeSeriesSelector_FieldSubPath{selector: TimeSeriesSelector_FieldPathSelectorResource, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object TimeSeriesSelector", fp)
}

func ParseTimeSeriesSelector_FieldPath(rawField string) (TimeSeriesSelector_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildTimeSeriesSelector_FieldPath(fp)
}

func MustParseTimeSeriesSelector_FieldPath(rawField string) TimeSeriesSelector_FieldPath {
	fp, err := ParseTimeSeriesSelector_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type TimeSeriesSelector_FieldTerminalPath struct {
	selector TimeSeriesSelector_FieldPathSelector
}

var _ TimeSeriesSelector_FieldPath = (*TimeSeriesSelector_FieldTerminalPath)(nil)

func (fp *TimeSeriesSelector_FieldTerminalPath) Selector() TimeSeriesSelector_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *TimeSeriesSelector_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *TimeSeriesSelector_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source TimeSeriesSelector
func (fp *TimeSeriesSelector_FieldTerminalPath) Get(source *TimeSeriesSelector) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case TimeSeriesSelector_FieldPathSelectorMetric:
			if source.Metric != nil {
				values = append(values, source.Metric)
			}
		case TimeSeriesSelector_FieldPathSelectorResource:
			if source.Resource != nil {
				values = append(values, source.Resource)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fp.selector))
		}
	}
	return
}

func (fp *TimeSeriesSelector_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*TimeSeriesSelector))
}

// GetSingle returns value pointed by specific field of from source TimeSeriesSelector
func (fp *TimeSeriesSelector_FieldTerminalPath) GetSingle(source *TimeSeriesSelector) (interface{}, bool) {
	switch fp.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		res := source.GetMetric()
		return res, res != nil
	case TimeSeriesSelector_FieldPathSelectorResource:
		res := source.GetResource()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fp.selector))
	}
}

func (fp *TimeSeriesSelector_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*TimeSeriesSelector))
}

// GetDefault returns a default value of the field type
func (fp *TimeSeriesSelector_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		return (*MetricSelector)(nil)
	case TimeSeriesSelector_FieldPathSelectorResource:
		return (*MonitoredResourceSelector)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fp.selector))
	}
}

func (fp *TimeSeriesSelector_FieldTerminalPath) ClearValue(item *TimeSeriesSelector) {
	if item != nil {
		switch fp.selector {
		case TimeSeriesSelector_FieldPathSelectorMetric:
			item.Metric = nil
		case TimeSeriesSelector_FieldPathSelectorResource:
			item.Resource = nil
		default:
			panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fp.selector))
		}
	}
}

func (fp *TimeSeriesSelector_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*TimeSeriesSelector))
}

// IsLeaf - whether field path is holds simple value
func (fp *TimeSeriesSelector_FieldTerminalPath) IsLeaf() bool {
	return false
}

func (fp *TimeSeriesSelector_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *TimeSeriesSelector_FieldTerminalPath) WithIValue(value interface{}) TimeSeriesSelector_FieldPathValue {
	switch fp.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		return &TimeSeriesSelector_FieldTerminalPathValue{TimeSeriesSelector_FieldTerminalPath: *fp, value: value.(*MetricSelector)}
	case TimeSeriesSelector_FieldPathSelectorResource:
		return &TimeSeriesSelector_FieldTerminalPathValue{TimeSeriesSelector_FieldTerminalPath: *fp, value: value.(*MonitoredResourceSelector)}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fp.selector))
	}
}

func (fp *TimeSeriesSelector_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *TimeSeriesSelector_FieldTerminalPath) WithIArrayOfValues(values interface{}) TimeSeriesSelector_FieldPathArrayOfValues {
	fpaov := &TimeSeriesSelector_FieldTerminalPathArrayOfValues{TimeSeriesSelector_FieldTerminalPath: *fp}
	switch fp.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		return &TimeSeriesSelector_FieldTerminalPathArrayOfValues{TimeSeriesSelector_FieldTerminalPath: *fp, values: values.([]*MetricSelector)}
	case TimeSeriesSelector_FieldPathSelectorResource:
		return &TimeSeriesSelector_FieldTerminalPathArrayOfValues{TimeSeriesSelector_FieldTerminalPath: *fp, values: values.([]*MonitoredResourceSelector)}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fp.selector))
	}
	return fpaov
}

func (fp *TimeSeriesSelector_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *TimeSeriesSelector_FieldTerminalPath) WithIArrayItemValue(value interface{}) TimeSeriesSelector_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fp.selector))
	}
}

func (fp *TimeSeriesSelector_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type TimeSeriesSelector_FieldSubPath struct {
	selector TimeSeriesSelector_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ TimeSeriesSelector_FieldPath = (*TimeSeriesSelector_FieldSubPath)(nil)

func (fps *TimeSeriesSelector_FieldSubPath) Selector() TimeSeriesSelector_FieldPathSelector {
	return fps.selector
}
func (fps *TimeSeriesSelector_FieldSubPath) AsMetricSubPath() (MetricSelector_FieldPath, bool) {
	res, ok := fps.subPath.(MetricSelector_FieldPath)
	return res, ok
}
func (fps *TimeSeriesSelector_FieldSubPath) AsResourceSubPath() (MonitoredResourceSelector_FieldPath, bool) {
	res, ok := fps.subPath.(MonitoredResourceSelector_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *TimeSeriesSelector_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *TimeSeriesSelector_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source TimeSeriesSelector
func (fps *TimeSeriesSelector_FieldSubPath) Get(source *TimeSeriesSelector) (values []interface{}) {
	switch fps.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		values = append(values, fps.subPath.GetRaw(source.GetMetric())...)
	case TimeSeriesSelector_FieldPathSelectorResource:
		values = append(values, fps.subPath.GetRaw(source.GetResource())...)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fps.selector))
	}
	return
}

func (fps *TimeSeriesSelector_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*TimeSeriesSelector))
}

// GetSingle returns value of selected field from source TimeSeriesSelector
func (fps *TimeSeriesSelector_FieldSubPath) GetSingle(source *TimeSeriesSelector) (interface{}, bool) {
	switch fps.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		if source.GetMetric() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetMetric())
	case TimeSeriesSelector_FieldPathSelectorResource:
		if source.GetResource() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetResource())
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fps.selector))
	}
}

func (fps *TimeSeriesSelector_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*TimeSeriesSelector))
}

// GetDefault returns a default value of the field type
func (fps *TimeSeriesSelector_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *TimeSeriesSelector_FieldSubPath) ClearValue(item *TimeSeriesSelector) {
	if item != nil {
		switch fps.selector {
		case TimeSeriesSelector_FieldPathSelectorMetric:
			fps.subPath.ClearValueRaw(item.Metric)
		case TimeSeriesSelector_FieldPathSelectorResource:
			fps.subPath.ClearValueRaw(item.Resource)
		default:
			panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fps.selector))
		}
	}
}

func (fps *TimeSeriesSelector_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*TimeSeriesSelector))
}

// IsLeaf - whether field path is holds simple value
func (fps *TimeSeriesSelector_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *TimeSeriesSelector_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&TimeSeriesSelector_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *TimeSeriesSelector_FieldSubPath) WithIValue(value interface{}) TimeSeriesSelector_FieldPathValue {
	return &TimeSeriesSelector_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *TimeSeriesSelector_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *TimeSeriesSelector_FieldSubPath) WithIArrayOfValues(values interface{}) TimeSeriesSelector_FieldPathArrayOfValues {
	return &TimeSeriesSelector_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *TimeSeriesSelector_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *TimeSeriesSelector_FieldSubPath) WithIArrayItemValue(value interface{}) TimeSeriesSelector_FieldPathArrayItemValue {
	return &TimeSeriesSelector_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *TimeSeriesSelector_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// TimeSeriesSelector_FieldPathValue allows storing values for TimeSeriesSelector fields according to their type
type TimeSeriesSelector_FieldPathValue interface {
	TimeSeriesSelector_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **TimeSeriesSelector)
	CompareWith(*TimeSeriesSelector) (cmp int, comparable bool)
}

func ParseTimeSeriesSelector_FieldPathValue(pathStr, valueStr string) (TimeSeriesSelector_FieldPathValue, error) {
	fp, err := ParseTimeSeriesSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeSeriesSelector field path value from %s: %v", valueStr, err)
	}
	return fpv.(TimeSeriesSelector_FieldPathValue), nil
}

func MustParseTimeSeriesSelector_FieldPathValue(pathStr, valueStr string) TimeSeriesSelector_FieldPathValue {
	fpv, err := ParseTimeSeriesSelector_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type TimeSeriesSelector_FieldTerminalPathValue struct {
	TimeSeriesSelector_FieldTerminalPath
	value interface{}
}

var _ TimeSeriesSelector_FieldPathValue = (*TimeSeriesSelector_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'TimeSeriesSelector' as interface{}
func (fpv *TimeSeriesSelector_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *TimeSeriesSelector_FieldTerminalPathValue) AsMetricValue() (*MetricSelector, bool) {
	res, ok := fpv.value.(*MetricSelector)
	return res, ok
}
func (fpv *TimeSeriesSelector_FieldTerminalPathValue) AsResourceValue() (*MonitoredResourceSelector, bool) {
	res, ok := fpv.value.(*MonitoredResourceSelector)
	return res, ok
}

// SetTo stores value for selected field for object TimeSeriesSelector
func (fpv *TimeSeriesSelector_FieldTerminalPathValue) SetTo(target **TimeSeriesSelector) {
	if *target == nil {
		*target = new(TimeSeriesSelector)
	}
	switch fpv.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		(*target).Metric = fpv.value.(*MetricSelector)
	case TimeSeriesSelector_FieldPathSelectorResource:
		(*target).Resource = fpv.value.(*MonitoredResourceSelector)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fpv.selector))
	}
}

func (fpv *TimeSeriesSelector_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TimeSeriesSelector)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'TimeSeriesSelector_FieldTerminalPathValue' with the value under path in 'TimeSeriesSelector'.
func (fpv *TimeSeriesSelector_FieldTerminalPathValue) CompareWith(source *TimeSeriesSelector) (int, bool) {
	switch fpv.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		return 0, false
	case TimeSeriesSelector_FieldPathSelectorResource:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fpv.selector))
	}
}

func (fpv *TimeSeriesSelector_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*TimeSeriesSelector))
}

type TimeSeriesSelector_FieldSubPathValue struct {
	TimeSeriesSelector_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ TimeSeriesSelector_FieldPathValue = (*TimeSeriesSelector_FieldSubPathValue)(nil)

func (fpvs *TimeSeriesSelector_FieldSubPathValue) AsMetricPathValue() (MetricSelector_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(MetricSelector_FieldPathValue)
	return res, ok
}
func (fpvs *TimeSeriesSelector_FieldSubPathValue) AsResourcePathValue() (MonitoredResourceSelector_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(MonitoredResourceSelector_FieldPathValue)
	return res, ok
}

func (fpvs *TimeSeriesSelector_FieldSubPathValue) SetTo(target **TimeSeriesSelector) {
	if *target == nil {
		*target = new(TimeSeriesSelector)
	}
	switch fpvs.Selector() {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		fpvs.subPathValue.(MetricSelector_FieldPathValue).SetTo(&(*target).Metric)
	case TimeSeriesSelector_FieldPathSelectorResource:
		fpvs.subPathValue.(MonitoredResourceSelector_FieldPathValue).SetTo(&(*target).Resource)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fpvs.Selector()))
	}
}

func (fpvs *TimeSeriesSelector_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TimeSeriesSelector)
	fpvs.SetTo(&typedObject)
}

func (fpvs *TimeSeriesSelector_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *TimeSeriesSelector_FieldSubPathValue) CompareWith(source *TimeSeriesSelector) (int, bool) {
	switch fpvs.Selector() {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		return fpvs.subPathValue.(MetricSelector_FieldPathValue).CompareWith(source.GetMetric())
	case TimeSeriesSelector_FieldPathSelectorResource:
		return fpvs.subPathValue.(MonitoredResourceSelector_FieldPathValue).CompareWith(source.GetResource())
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fpvs.Selector()))
	}
}

func (fpvs *TimeSeriesSelector_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*TimeSeriesSelector))
}

// TimeSeriesSelector_FieldPathArrayItemValue allows storing single item in Path-specific values for TimeSeriesSelector according to their type
// Present only for array (repeated) types.
type TimeSeriesSelector_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	TimeSeriesSelector_FieldPath
	ContainsValue(*TimeSeriesSelector) bool
}

// ParseTimeSeriesSelector_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseTimeSeriesSelector_FieldPathArrayItemValue(pathStr, valueStr string) (TimeSeriesSelector_FieldPathArrayItemValue, error) {
	fp, err := ParseTimeSeriesSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeSeriesSelector field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(TimeSeriesSelector_FieldPathArrayItemValue), nil
}

func MustParseTimeSeriesSelector_FieldPathArrayItemValue(pathStr, valueStr string) TimeSeriesSelector_FieldPathArrayItemValue {
	fpaiv, err := ParseTimeSeriesSelector_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type TimeSeriesSelector_FieldTerminalPathArrayItemValue struct {
	TimeSeriesSelector_FieldTerminalPath
	value interface{}
}

var _ TimeSeriesSelector_FieldPathArrayItemValue = (*TimeSeriesSelector_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object TimeSeriesSelector as interface{}
func (fpaiv *TimeSeriesSelector_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *TimeSeriesSelector_FieldTerminalPathArrayItemValue) GetSingle(source *TimeSeriesSelector) (interface{}, bool) {
	return nil, false
}

func (fpaiv *TimeSeriesSelector_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*TimeSeriesSelector))
}

// Contains returns a boolean indicating if value that is being held is present in given 'TimeSeriesSelector'
func (fpaiv *TimeSeriesSelector_FieldTerminalPathArrayItemValue) ContainsValue(source *TimeSeriesSelector) bool {
	slice := fpaiv.TimeSeriesSelector_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type TimeSeriesSelector_FieldSubPathArrayItemValue struct {
	TimeSeriesSelector_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *TimeSeriesSelector_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *TimeSeriesSelector_FieldSubPathArrayItemValue) AsMetricPathItemValue() (MetricSelector_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(MetricSelector_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *TimeSeriesSelector_FieldSubPathArrayItemValue) AsResourcePathItemValue() (MonitoredResourceSelector_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(MonitoredResourceSelector_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'TimeSeriesSelector'
func (fpaivs *TimeSeriesSelector_FieldSubPathArrayItemValue) ContainsValue(source *TimeSeriesSelector) bool {
	switch fpaivs.Selector() {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		return fpaivs.subPathItemValue.(MetricSelector_FieldPathArrayItemValue).ContainsValue(source.GetMetric())
	case TimeSeriesSelector_FieldPathSelectorResource:
		return fpaivs.subPathItemValue.(MonitoredResourceSelector_FieldPathArrayItemValue).ContainsValue(source.GetResource())
	default:
		panic(fmt.Sprintf("Invalid selector for TimeSeriesSelector: %d", fpaivs.Selector()))
	}
}

// TimeSeriesSelector_FieldPathArrayOfValues allows storing slice of values for TimeSeriesSelector fields according to their type
type TimeSeriesSelector_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	TimeSeriesSelector_FieldPath
}

func ParseTimeSeriesSelector_FieldPathArrayOfValues(pathStr, valuesStr string) (TimeSeriesSelector_FieldPathArrayOfValues, error) {
	fp, err := ParseTimeSeriesSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeSeriesSelector field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(TimeSeriesSelector_FieldPathArrayOfValues), nil
}

func MustParseTimeSeriesSelector_FieldPathArrayOfValues(pathStr, valuesStr string) TimeSeriesSelector_FieldPathArrayOfValues {
	fpaov, err := ParseTimeSeriesSelector_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type TimeSeriesSelector_FieldTerminalPathArrayOfValues struct {
	TimeSeriesSelector_FieldTerminalPath
	values interface{}
}

var _ TimeSeriesSelector_FieldPathArrayOfValues = (*TimeSeriesSelector_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *TimeSeriesSelector_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case TimeSeriesSelector_FieldPathSelectorMetric:
		for _, v := range fpaov.values.([]*MetricSelector) {
			values = append(values, v)
		}
	case TimeSeriesSelector_FieldPathSelectorResource:
		for _, v := range fpaov.values.([]*MonitoredResourceSelector) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *TimeSeriesSelector_FieldTerminalPathArrayOfValues) AsMetricArrayOfValues() ([]*MetricSelector, bool) {
	res, ok := fpaov.values.([]*MetricSelector)
	return res, ok
}
func (fpaov *TimeSeriesSelector_FieldTerminalPathArrayOfValues) AsResourceArrayOfValues() ([]*MonitoredResourceSelector, bool) {
	res, ok := fpaov.values.([]*MonitoredResourceSelector)
	return res, ok
}

type TimeSeriesSelector_FieldSubPathArrayOfValues struct {
	TimeSeriesSelector_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ TimeSeriesSelector_FieldPathArrayOfValues = (*TimeSeriesSelector_FieldSubPathArrayOfValues)(nil)

func (fpsaov *TimeSeriesSelector_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *TimeSeriesSelector_FieldSubPathArrayOfValues) AsMetricPathArrayOfValues() (MetricSelector_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(MetricSelector_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *TimeSeriesSelector_FieldSubPathArrayOfValues) AsResourcePathArrayOfValues() (MonitoredResourceSelector_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(MonitoredResourceSelector_FieldPathArrayOfValues)
	return res, ok
}
