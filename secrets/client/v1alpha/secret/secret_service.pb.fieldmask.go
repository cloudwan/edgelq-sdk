// Code generated by protoc-gen-goten-object
// File: edgelq/secrets/proto/v1alpha/secret_service.proto
// DO NOT EDIT!!!

package secret_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	project "github.com/cloudwan/edgelq-sdk/secrets/resources/v1alpha/project"
	secret "github.com/cloudwan/edgelq-sdk/secrets/resources/v1alpha/secret"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &project.Project{}
	_ = &secret.Secret{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetSecretRequest_FieldMask struct {
	Paths []GetSecretRequest_FieldPath
}

func FullGetSecretRequest_FieldMask() *GetSecretRequest_FieldMask {
	res := &GetSecretRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetSecretRequest_FieldTerminalPath{selector: GetSecretRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetSecretRequest_FieldTerminalPath{selector: GetSecretRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetSecretRequest_FieldTerminalPath{selector: GetSecretRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetSecretRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetSecretRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetSecretRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetSecretRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetSecretRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetSecretRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetSecretRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetSecretRequest_FieldPath(raw)
	})
}

func (fieldMask *GetSecretRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetSecretRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetSecretRequest_FieldMask) Subtract(other *GetSecretRequest_FieldMask) *GetSecretRequest_FieldMask {
	result := &GetSecretRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetSecretRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetSecretRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetSecretRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetSecretRequest_FieldMask) FilterInputFields() *GetSecretRequest_FieldMask {
	result := &GetSecretRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetSecretRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetSecretRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetSecretRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetSecretRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetSecretRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetSecretRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetSecretRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetSecretRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetSecretRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetSecretRequest_FieldMask) AppendPath(path GetSecretRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetSecretRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetSecretRequest_FieldPath))
}

func (fieldMask *GetSecretRequest_FieldMask) GetPaths() []GetSecretRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetSecretRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetSecretRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetSecretRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetSecretRequest_FieldMask) Set(target, source *GetSecretRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetSecretRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetSecretRequest), source.(*GetSecretRequest))
}

func (fieldMask *GetSecretRequest_FieldMask) Project(source *GetSecretRequest) *GetSecretRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetSecretRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetSecretRequest_FieldTerminalPath:
			switch tp.selector {
			case GetSecretRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetSecretRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetSecretRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetSecretRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetSecretRequest))
}

func (fieldMask *GetSecretRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetSecretsRequest_FieldMask struct {
	Paths []BatchGetSecretsRequest_FieldPath
}

func FullBatchGetSecretsRequest_FieldMask() *BatchGetSecretsRequest_FieldMask {
	res := &BatchGetSecretsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetSecretsRequest_FieldTerminalPath{selector: BatchGetSecretsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetSecretsRequest_FieldTerminalPath{selector: BatchGetSecretsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetSecretsRequest_FieldTerminalPath{selector: BatchGetSecretsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetSecretsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetSecretsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetSecretsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetSecretsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetSecretsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) Subtract(other *BatchGetSecretsRequest_FieldMask) *BatchGetSecretsRequest_FieldMask {
	result := &BatchGetSecretsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetSecretsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetSecretsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetSecretsRequest_FieldMask) FilterInputFields() *BatchGetSecretsRequest_FieldMask {
	result := &BatchGetSecretsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetSecretsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetSecretsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetSecretsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetSecretsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetSecretsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) AppendPath(path BatchGetSecretsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetSecretsRequest_FieldPath))
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) GetPaths() []BatchGetSecretsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetSecretsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) Set(target, source *BatchGetSecretsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetSecretsRequest), source.(*BatchGetSecretsRequest))
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) Project(source *BatchGetSecretsRequest) *BatchGetSecretsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetSecretsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetSecretsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetSecretsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetSecretsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetSecretsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetSecretsRequest))
}

func (fieldMask *BatchGetSecretsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetSecretsResponse_FieldMask struct {
	Paths []BatchGetSecretsResponse_FieldPath
}

func FullBatchGetSecretsResponse_FieldMask() *BatchGetSecretsResponse_FieldMask {
	res := &BatchGetSecretsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetSecretsResponse_FieldTerminalPath{selector: BatchGetSecretsResponse_FieldPathSelectorSecrets})
	res.Paths = append(res.Paths, &BatchGetSecretsResponse_FieldTerminalPath{selector: BatchGetSecretsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetSecretsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetSecretsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetSecretsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetSecretsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetSecretsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) Subtract(other *BatchGetSecretsResponse_FieldMask) *BatchGetSecretsResponse_FieldMask {
	result := &BatchGetSecretsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetSecretsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetSecretsResponse_FieldPathSelectorSecrets: &secret.Secret_FieldMask{},
	}
	mySubMasks := map[BatchGetSecretsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetSecretsResponse_FieldPathSelectorSecrets: &secret.Secret_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetSecretsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetSecretsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetSecretsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetSecretsResponse_FieldPathSelectorSecrets:
						mySubMasks[BatchGetSecretsResponse_FieldPathSelectorSecrets] = secret.FullSecret_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetSecretsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetSecretsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetSecretsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetSecretsResponse_FieldMask) FilterInputFields() *BatchGetSecretsResponse_FieldMask {
	result := &BatchGetSecretsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetSecretsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetSecretsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetSecretsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetSecretsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetSecretsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) AppendPath(path BatchGetSecretsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetSecretsResponse_FieldPath))
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) GetPaths() []BatchGetSecretsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetSecretsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) Set(target, source *BatchGetSecretsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetSecretsResponse), source.(*BatchGetSecretsResponse))
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) Project(source *BatchGetSecretsResponse) *BatchGetSecretsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetSecretsResponse{}
	secretsMask := &secret.Secret_FieldMask{}
	wholeSecretsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetSecretsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetSecretsResponse_FieldPathSelectorSecrets:
				result.Secrets = source.Secrets
				wholeSecretsAccepted = true
			case BatchGetSecretsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetSecretsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetSecretsResponse_FieldPathSelectorSecrets:
				secretsMask.AppendPath(tp.subPath.(secret.Secret_FieldPath))
			}
		}
	}
	if wholeSecretsAccepted == false && len(secretsMask.Paths) > 0 {
		for _, sourceItem := range source.GetSecrets() {
			result.Secrets = append(result.Secrets, secretsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetSecretsResponse))
}

func (fieldMask *BatchGetSecretsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListSecretsRequest_FieldMask struct {
	Paths []ListSecretsRequest_FieldPath
}

func FullListSecretsRequest_FieldMask() *ListSecretsRequest_FieldMask {
	res := &ListSecretsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListSecretsRequest_FieldTerminalPath{selector: ListSecretsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListSecretsRequest_FieldTerminalPath{selector: ListSecretsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListSecretsRequest_FieldTerminalPath{selector: ListSecretsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListSecretsRequest_FieldTerminalPath{selector: ListSecretsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListSecretsRequest_FieldTerminalPath{selector: ListSecretsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListSecretsRequest_FieldTerminalPath{selector: ListSecretsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListSecretsRequest_FieldTerminalPath{selector: ListSecretsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListSecretsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListSecretsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListSecretsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListSecretsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListSecretsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListSecretsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListSecretsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListSecretsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListSecretsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListSecretsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListSecretsRequest_FieldMask) Subtract(other *ListSecretsRequest_FieldMask) *ListSecretsRequest_FieldMask {
	result := &ListSecretsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListSecretsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListSecretsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListSecretsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListSecretsRequest_FieldMask) FilterInputFields() *ListSecretsRequest_FieldMask {
	result := &ListSecretsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListSecretsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListSecretsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListSecretsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListSecretsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListSecretsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListSecretsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListSecretsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListSecretsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListSecretsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListSecretsRequest_FieldMask) AppendPath(path ListSecretsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListSecretsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListSecretsRequest_FieldPath))
}

func (fieldMask *ListSecretsRequest_FieldMask) GetPaths() []ListSecretsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListSecretsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListSecretsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListSecretsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListSecretsRequest_FieldMask) Set(target, source *ListSecretsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListSecretsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListSecretsRequest), source.(*ListSecretsRequest))
}

func (fieldMask *ListSecretsRequest_FieldMask) Project(source *ListSecretsRequest) *ListSecretsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListSecretsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListSecretsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListSecretsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListSecretsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListSecretsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListSecretsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListSecretsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListSecretsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListSecretsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListSecretsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListSecretsRequest))
}

func (fieldMask *ListSecretsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListSecretsResponse_FieldMask struct {
	Paths []ListSecretsResponse_FieldPath
}

func FullListSecretsResponse_FieldMask() *ListSecretsResponse_FieldMask {
	res := &ListSecretsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListSecretsResponse_FieldTerminalPath{selector: ListSecretsResponse_FieldPathSelectorSecrets})
	res.Paths = append(res.Paths, &ListSecretsResponse_FieldTerminalPath{selector: ListSecretsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListSecretsResponse_FieldTerminalPath{selector: ListSecretsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListSecretsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListSecretsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListSecretsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListSecretsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListSecretsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListSecretsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListSecretsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListSecretsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListSecretsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListSecretsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListSecretsResponse_FieldMask) Subtract(other *ListSecretsResponse_FieldMask) *ListSecretsResponse_FieldMask {
	result := &ListSecretsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListSecretsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListSecretsResponse_FieldPathSelectorSecrets: &secret.Secret_FieldMask{},
	}
	mySubMasks := map[ListSecretsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListSecretsResponse_FieldPathSelectorSecrets: &secret.Secret_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListSecretsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListSecretsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListSecretsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListSecretsResponse_FieldPathSelectorSecrets:
						mySubMasks[ListSecretsResponse_FieldPathSelectorSecrets] = secret.FullSecret_FieldMask()
					}
				} else if tp, ok := path.(*ListSecretsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListSecretsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListSecretsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListSecretsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListSecretsResponse_FieldMask) FilterInputFields() *ListSecretsResponse_FieldMask {
	result := &ListSecretsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListSecretsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListSecretsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListSecretsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListSecretsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListSecretsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListSecretsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListSecretsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListSecretsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListSecretsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListSecretsResponse_FieldMask) AppendPath(path ListSecretsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListSecretsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListSecretsResponse_FieldPath))
}

func (fieldMask *ListSecretsResponse_FieldMask) GetPaths() []ListSecretsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListSecretsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListSecretsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListSecretsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListSecretsResponse_FieldMask) Set(target, source *ListSecretsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListSecretsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListSecretsResponse), source.(*ListSecretsResponse))
}

func (fieldMask *ListSecretsResponse_FieldMask) Project(source *ListSecretsResponse) *ListSecretsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListSecretsResponse{}
	secretsMask := &secret.Secret_FieldMask{}
	wholeSecretsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListSecretsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListSecretsResponse_FieldPathSelectorSecrets:
				result.Secrets = source.Secrets
				wholeSecretsAccepted = true
			case ListSecretsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListSecretsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListSecretsResponse_FieldSubPath:
			switch tp.selector {
			case ListSecretsResponse_FieldPathSelectorSecrets:
				secretsMask.AppendPath(tp.subPath.(secret.Secret_FieldPath))
			}
		}
	}
	if wholeSecretsAccepted == false && len(secretsMask.Paths) > 0 {
		for _, sourceItem := range source.GetSecrets() {
			result.Secrets = append(result.Secrets, secretsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListSecretsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListSecretsResponse))
}

func (fieldMask *ListSecretsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchSecretRequest_FieldMask struct {
	Paths []WatchSecretRequest_FieldPath
}

func FullWatchSecretRequest_FieldMask() *WatchSecretRequest_FieldMask {
	res := &WatchSecretRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchSecretRequest_FieldTerminalPath{selector: WatchSecretRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchSecretRequest_FieldTerminalPath{selector: WatchSecretRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchSecretRequest_FieldTerminalPath{selector: WatchSecretRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchSecretRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchSecretRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchSecretRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchSecretRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchSecretRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchSecretRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchSecretRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchSecretRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchSecretRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchSecretRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchSecretRequest_FieldMask) Subtract(other *WatchSecretRequest_FieldMask) *WatchSecretRequest_FieldMask {
	result := &WatchSecretRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchSecretRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchSecretRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchSecretRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchSecretRequest_FieldMask) FilterInputFields() *WatchSecretRequest_FieldMask {
	result := &WatchSecretRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchSecretRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchSecretRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchSecretRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchSecretRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchSecretRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchSecretRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchSecretRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchSecretRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretRequest_FieldMask) AppendPath(path WatchSecretRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchSecretRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchSecretRequest_FieldPath))
}

func (fieldMask *WatchSecretRequest_FieldMask) GetPaths() []WatchSecretRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchSecretRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchSecretRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchSecretRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchSecretRequest_FieldMask) Set(target, source *WatchSecretRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchSecretRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchSecretRequest), source.(*WatchSecretRequest))
}

func (fieldMask *WatchSecretRequest_FieldMask) Project(source *WatchSecretRequest) *WatchSecretRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchSecretRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchSecretRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchSecretRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchSecretRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchSecretRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchSecretRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchSecretRequest))
}

func (fieldMask *WatchSecretRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchSecretResponse_FieldMask struct {
	Paths []WatchSecretResponse_FieldPath
}

func FullWatchSecretResponse_FieldMask() *WatchSecretResponse_FieldMask {
	res := &WatchSecretResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchSecretResponse_FieldTerminalPath{selector: WatchSecretResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchSecretResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchSecretResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchSecretResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchSecretResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchSecretResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchSecretResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchSecretResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchSecretResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchSecretResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchSecretResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchSecretResponse_FieldMask) Subtract(other *WatchSecretResponse_FieldMask) *WatchSecretResponse_FieldMask {
	result := &WatchSecretResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchSecretResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchSecretResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchSecretResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchSecretResponse_FieldMask) FilterInputFields() *WatchSecretResponse_FieldMask {
	result := &WatchSecretResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchSecretResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchSecretResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchSecretResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchSecretResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchSecretResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchSecretResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchSecretResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchSecretResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretResponse_FieldMask) AppendPath(path WatchSecretResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchSecretResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchSecretResponse_FieldPath))
}

func (fieldMask *WatchSecretResponse_FieldMask) GetPaths() []WatchSecretResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchSecretResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchSecretResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchSecretResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchSecretResponse_FieldMask) Set(target, source *WatchSecretResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchSecretResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchSecretResponse), source.(*WatchSecretResponse))
}

func (fieldMask *WatchSecretResponse_FieldMask) Project(source *WatchSecretResponse) *WatchSecretResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchSecretResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchSecretResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchSecretResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchSecretResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchSecretResponse))
}

func (fieldMask *WatchSecretResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchSecretsRequest_FieldMask struct {
	Paths []WatchSecretsRequest_FieldPath
}

func FullWatchSecretsRequest_FieldMask() *WatchSecretsRequest_FieldMask {
	res := &WatchSecretsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchSecretsRequest_FieldTerminalPath{selector: WatchSecretsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchSecretsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchSecretsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchSecretsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchSecretsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchSecretsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchSecretsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchSecretsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchSecretsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchSecretsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchSecretsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchSecretsRequest_FieldMask) Subtract(other *WatchSecretsRequest_FieldMask) *WatchSecretsRequest_FieldMask {
	result := &WatchSecretsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchSecretsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchSecretsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchSecretsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchSecretsRequest_FieldMask) FilterInputFields() *WatchSecretsRequest_FieldMask {
	result := &WatchSecretsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchSecretsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchSecretsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchSecretsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchSecretsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchSecretsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchSecretsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchSecretsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchSecretsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretsRequest_FieldMask) AppendPath(path WatchSecretsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchSecretsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchSecretsRequest_FieldPath))
}

func (fieldMask *WatchSecretsRequest_FieldMask) GetPaths() []WatchSecretsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchSecretsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchSecretsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchSecretsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchSecretsRequest_FieldMask) Set(target, source *WatchSecretsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchSecretsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchSecretsRequest), source.(*WatchSecretsRequest))
}

func (fieldMask *WatchSecretsRequest_FieldMask) Project(source *WatchSecretsRequest) *WatchSecretsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchSecretsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchSecretsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchSecretsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchSecretsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchSecretsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchSecretsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchSecretsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchSecretsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchSecretsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchSecretsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchSecretsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchSecretsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchSecretsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchSecretsRequest))
}

func (fieldMask *WatchSecretsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchSecretsResponse_FieldMask struct {
	Paths []WatchSecretsResponse_FieldPath
}

func FullWatchSecretsResponse_FieldMask() *WatchSecretsResponse_FieldMask {
	res := &WatchSecretsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchSecretsResponse_FieldTerminalPath{selector: WatchSecretsResponse_FieldPathSelectorSecretChanges})
	res.Paths = append(res.Paths, &WatchSecretsResponse_FieldTerminalPath{selector: WatchSecretsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchSecretsResponse_FieldTerminalPath{selector: WatchSecretsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchSecretsResponse_FieldTerminalPath{selector: WatchSecretsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchSecretsResponse_FieldTerminalPath{selector: WatchSecretsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchSecretsResponse_FieldTerminalPath{selector: WatchSecretsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchSecretsResponse_FieldTerminalPath{selector: WatchSecretsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchSecretsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchSecretsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchSecretsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchSecretsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchSecretsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchSecretsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchSecretsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchSecretsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchSecretsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchSecretsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchSecretsResponse_FieldMask) Subtract(other *WatchSecretsResponse_FieldMask) *WatchSecretsResponse_FieldMask {
	result := &WatchSecretsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchSecretsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchSecretsResponse_FieldPathSelectorPageTokenChange: &WatchSecretsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchSecretsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchSecretsResponse_FieldPathSelectorPageTokenChange: &WatchSecretsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchSecretsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchSecretsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchSecretsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchSecretsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchSecretsResponse_FieldPathSelectorPageTokenChange] = FullWatchSecretsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchSecretsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchSecretsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchSecretsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchSecretsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchSecretsResponse_FieldMask) FilterInputFields() *WatchSecretsResponse_FieldMask {
	result := &WatchSecretsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchSecretsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchSecretsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchSecretsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchSecretsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchSecretsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchSecretsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchSecretsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchSecretsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretsResponse_FieldMask) AppendPath(path WatchSecretsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchSecretsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchSecretsResponse_FieldPath))
}

func (fieldMask *WatchSecretsResponse_FieldMask) GetPaths() []WatchSecretsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchSecretsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchSecretsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchSecretsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchSecretsResponse_FieldMask) Set(target, source *WatchSecretsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchSecretsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchSecretsResponse), source.(*WatchSecretsResponse))
}

func (fieldMask *WatchSecretsResponse_FieldMask) Project(source *WatchSecretsResponse) *WatchSecretsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchSecretsResponse{}
	pageTokenChangeMask := &WatchSecretsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchSecretsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchSecretsResponse_FieldPathSelectorSecretChanges:
				result.SecretChanges = source.SecretChanges
			case WatchSecretsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchSecretsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchSecretsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchSecretsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchSecretsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchSecretsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchSecretsResponse_FieldSubPath:
			switch tp.selector {
			case WatchSecretsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchSecretsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchSecretsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchSecretsResponse))
}

func (fieldMask *WatchSecretsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchSecretsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchSecretsResponsePageTokenChange_FieldPath
}

func FullWatchSecretsResponse_PageTokenChange_FieldMask() *WatchSecretsResponse_PageTokenChange_FieldMask {
	res := &WatchSecretsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchSecretsResponsePageTokenChange_FieldTerminalPath{selector: WatchSecretsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchSecretsResponsePageTokenChange_FieldTerminalPath{selector: WatchSecretsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchSecretsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchSecretsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchSecretsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) Subtract(other *WatchSecretsResponse_PageTokenChange_FieldMask) *WatchSecretsResponse_PageTokenChange_FieldMask {
	result := &WatchSecretsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchSecretsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchSecretsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchSecretsResponse_PageTokenChange_FieldMask {
	result := &WatchSecretsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchSecretsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchSecretsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchSecretsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchSecretsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) AppendPath(path WatchSecretsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchSecretsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) GetPaths() []WatchSecretsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchSecretsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) Set(target, source *WatchSecretsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchSecretsResponse_PageTokenChange), source.(*WatchSecretsResponse_PageTokenChange))
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) Project(source *WatchSecretsResponse_PageTokenChange) *WatchSecretsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchSecretsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchSecretsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchSecretsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchSecretsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchSecretsResponse_PageTokenChange))
}

func (fieldMask *WatchSecretsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateSecretRequest_FieldMask struct {
	Paths []CreateSecretRequest_FieldPath
}

func FullCreateSecretRequest_FieldMask() *CreateSecretRequest_FieldMask {
	res := &CreateSecretRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateSecretRequest_FieldTerminalPath{selector: CreateSecretRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateSecretRequest_FieldTerminalPath{selector: CreateSecretRequest_FieldPathSelectorSecret})
	return res
}

func (fieldMask *CreateSecretRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateSecretRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateSecretRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateSecretRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateSecretRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateSecretRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateSecretRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateSecretRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateSecretRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateSecretRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateSecretRequest_FieldMask) Subtract(other *CreateSecretRequest_FieldMask) *CreateSecretRequest_FieldMask {
	result := &CreateSecretRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateSecretRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateSecretRequest_FieldPathSelectorSecret: &secret.Secret_FieldMask{},
	}
	mySubMasks := map[CreateSecretRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateSecretRequest_FieldPathSelectorSecret: &secret.Secret_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateSecretRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateSecretRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateSecretRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateSecretRequest_FieldPathSelectorSecret:
						mySubMasks[CreateSecretRequest_FieldPathSelectorSecret] = secret.FullSecret_FieldMask()
					}
				} else if tp, ok := path.(*CreateSecretRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateSecretRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateSecretRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateSecretRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateSecretRequest_FieldMask) FilterInputFields() *CreateSecretRequest_FieldMask {
	result := &CreateSecretRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateSecretRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateSecretRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateSecretRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateSecretRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateSecretRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateSecretRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateSecretRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateSecretRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateSecretRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateSecretRequest_FieldMask) AppendPath(path CreateSecretRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateSecretRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateSecretRequest_FieldPath))
}

func (fieldMask *CreateSecretRequest_FieldMask) GetPaths() []CreateSecretRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateSecretRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateSecretRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateSecretRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateSecretRequest_FieldMask) Set(target, source *CreateSecretRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateSecretRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateSecretRequest), source.(*CreateSecretRequest))
}

func (fieldMask *CreateSecretRequest_FieldMask) Project(source *CreateSecretRequest) *CreateSecretRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateSecretRequest{}
	secretMask := &secret.Secret_FieldMask{}
	wholeSecretAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateSecretRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateSecretRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateSecretRequest_FieldPathSelectorSecret:
				result.Secret = source.Secret
				wholeSecretAccepted = true
			}
		case *CreateSecretRequest_FieldSubPath:
			switch tp.selector {
			case CreateSecretRequest_FieldPathSelectorSecret:
				secretMask.AppendPath(tp.subPath.(secret.Secret_FieldPath))
			}
		}
	}
	if wholeSecretAccepted == false && len(secretMask.Paths) > 0 {
		result.Secret = secretMask.Project(source.GetSecret())
	}
	return result
}

func (fieldMask *CreateSecretRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateSecretRequest))
}

func (fieldMask *CreateSecretRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateSecretRequest_FieldMask struct {
	Paths []UpdateSecretRequest_FieldPath
}

func FullUpdateSecretRequest_FieldMask() *UpdateSecretRequest_FieldMask {
	res := &UpdateSecretRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateSecretRequest_FieldTerminalPath{selector: UpdateSecretRequest_FieldPathSelectorSecret})
	res.Paths = append(res.Paths, &UpdateSecretRequest_FieldTerminalPath{selector: UpdateSecretRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateSecretRequest_FieldTerminalPath{selector: UpdateSecretRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateSecretRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateSecretRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateSecretRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateSecretRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateSecretRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateSecretRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateSecretRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateSecretRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateSecretRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateSecretRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateSecretRequest_FieldMask) Subtract(other *UpdateSecretRequest_FieldMask) *UpdateSecretRequest_FieldMask {
	result := &UpdateSecretRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateSecretRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateSecretRequest_FieldPathSelectorSecret: &secret.Secret_FieldMask{},
		UpdateSecretRequest_FieldPathSelectorCas:    &UpdateSecretRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateSecretRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateSecretRequest_FieldPathSelectorSecret: &secret.Secret_FieldMask{},
		UpdateSecretRequest_FieldPathSelectorCas:    &UpdateSecretRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateSecretRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateSecretRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateSecretRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateSecretRequest_FieldPathSelectorSecret:
						mySubMasks[UpdateSecretRequest_FieldPathSelectorSecret] = secret.FullSecret_FieldMask()
					case UpdateSecretRequest_FieldPathSelectorCas:
						mySubMasks[UpdateSecretRequest_FieldPathSelectorCas] = FullUpdateSecretRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateSecretRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateSecretRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateSecretRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateSecretRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateSecretRequest_FieldMask) FilterInputFields() *UpdateSecretRequest_FieldMask {
	result := &UpdateSecretRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateSecretRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateSecretRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateSecretRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateSecretRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateSecretRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateSecretRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateSecretRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateSecretRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateSecretRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateSecretRequest_FieldMask) AppendPath(path UpdateSecretRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateSecretRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateSecretRequest_FieldPath))
}

func (fieldMask *UpdateSecretRequest_FieldMask) GetPaths() []UpdateSecretRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateSecretRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateSecretRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateSecretRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateSecretRequest_FieldMask) Set(target, source *UpdateSecretRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateSecretRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateSecretRequest), source.(*UpdateSecretRequest))
}

func (fieldMask *UpdateSecretRequest_FieldMask) Project(source *UpdateSecretRequest) *UpdateSecretRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateSecretRequest{}
	secretMask := &secret.Secret_FieldMask{}
	wholeSecretAccepted := false
	casMask := &UpdateSecretRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateSecretRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateSecretRequest_FieldPathSelectorSecret:
				result.Secret = source.Secret
				wholeSecretAccepted = true
			case UpdateSecretRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateSecretRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateSecretRequest_FieldSubPath:
			switch tp.selector {
			case UpdateSecretRequest_FieldPathSelectorSecret:
				secretMask.AppendPath(tp.subPath.(secret.Secret_FieldPath))
			case UpdateSecretRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateSecretRequestCAS_FieldPath))
			}
		}
	}
	if wholeSecretAccepted == false && len(secretMask.Paths) > 0 {
		result.Secret = secretMask.Project(source.GetSecret())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateSecretRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateSecretRequest))
}

func (fieldMask *UpdateSecretRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateSecretRequest_CAS_FieldMask struct {
	Paths []UpdateSecretRequestCAS_FieldPath
}

func FullUpdateSecretRequest_CAS_FieldMask() *UpdateSecretRequest_CAS_FieldMask {
	res := &UpdateSecretRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateSecretRequestCAS_FieldTerminalPath{selector: UpdateSecretRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateSecretRequestCAS_FieldTerminalPath{selector: UpdateSecretRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateSecretRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateSecretRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateSecretRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateSecretRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) Subtract(other *UpdateSecretRequest_CAS_FieldMask) *UpdateSecretRequest_CAS_FieldMask {
	result := &UpdateSecretRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateSecretRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateSecretRequestCAS_FieldPathSelectorConditionalState: &secret.Secret_FieldMask{},
	}
	mySubMasks := map[UpdateSecretRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateSecretRequestCAS_FieldPathSelectorConditionalState: &secret.Secret_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateSecretRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateSecretRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateSecretRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateSecretRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateSecretRequestCAS_FieldPathSelectorConditionalState] = secret.FullSecret_FieldMask()
					}
				} else if tp, ok := path.(*UpdateSecretRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateSecretRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateSecretRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateSecretRequest_CAS_FieldMask) FilterInputFields() *UpdateSecretRequest_CAS_FieldMask {
	result := &UpdateSecretRequest_CAS_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateSecretRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateSecretRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateSecretRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateSecretRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateSecretRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) AppendPath(path UpdateSecretRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateSecretRequestCAS_FieldPath))
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) GetPaths() []UpdateSecretRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateSecretRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) Set(target, source *UpdateSecretRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateSecretRequest_CAS), source.(*UpdateSecretRequest_CAS))
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) Project(source *UpdateSecretRequest_CAS) *UpdateSecretRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateSecretRequest_CAS{}
	conditionalStateMask := &secret.Secret_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateSecretRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateSecretRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateSecretRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateSecretRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateSecretRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(secret.Secret_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateSecretRequest_CAS))
}

func (fieldMask *UpdateSecretRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteSecretRequest_FieldMask struct {
	Paths []DeleteSecretRequest_FieldPath
}

func FullDeleteSecretRequest_FieldMask() *DeleteSecretRequest_FieldMask {
	res := &DeleteSecretRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteSecretRequest_FieldTerminalPath{selector: DeleteSecretRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteSecretRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteSecretRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteSecretRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteSecretRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteSecretRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteSecretRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteSecretRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteSecretRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteSecretRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteSecretRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteSecretRequest_FieldMask) Subtract(other *DeleteSecretRequest_FieldMask) *DeleteSecretRequest_FieldMask {
	result := &DeleteSecretRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteSecretRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteSecretRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteSecretRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteSecretRequest_FieldMask) FilterInputFields() *DeleteSecretRequest_FieldMask {
	result := &DeleteSecretRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteSecretRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteSecretRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteSecretRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteSecretRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteSecretRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteSecretRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteSecretRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteSecretRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteSecretRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteSecretRequest_FieldMask) AppendPath(path DeleteSecretRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteSecretRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteSecretRequest_FieldPath))
}

func (fieldMask *DeleteSecretRequest_FieldMask) GetPaths() []DeleteSecretRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteSecretRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteSecretRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteSecretRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteSecretRequest_FieldMask) Set(target, source *DeleteSecretRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteSecretRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteSecretRequest), source.(*DeleteSecretRequest))
}

func (fieldMask *DeleteSecretRequest_FieldMask) Project(source *DeleteSecretRequest) *DeleteSecretRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteSecretRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteSecretRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteSecretRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteSecretRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteSecretRequest))
}

func (fieldMask *DeleteSecretRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
