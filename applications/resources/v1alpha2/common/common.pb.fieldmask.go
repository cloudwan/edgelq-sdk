// Code generated by protoc-gen-goten-object
// File: edgelq/applications/proto/v1alpha2/common.proto
// DO NOT EDIT!!!

package common

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	devices_device "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha2/device"
	secrets_secret "github.com/cloudwan/edgelq-sdk/secrets/resources/v1alpha2/secret"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &devices_device.Device{}
	_ = &secrets_secret.Secret{}
)

type PodSpec_FieldMask struct {
	Paths []PodSpec_FieldPath
}

func FullPodSpec_FieldMask() *PodSpec_FieldMask {
	res := &PodSpec_FieldMask{}
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorNode})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorContainers})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorHostNetwork})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorRestartPolicy})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorImagePullSecrets})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorVolumes})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorCompose})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorHostVolumeMounts})
	return res
}

func (fieldMask *PodSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PodSpec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PodSpec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PodSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PodSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodSpec_FieldPath(raw)
	})
}

func (fieldMask *PodSpec_FieldMask) ProtoMessage() {}

func (fieldMask *PodSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PodSpec_FieldMask) Subtract(other *PodSpec_FieldMask) *PodSpec_FieldMask {
	result := &PodSpec_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[PodSpec_FieldPathSelector]gotenobject.FieldMask{
		PodSpec_FieldPathSelectorContainers:       &PodSpec_Container_FieldMask{},
		PodSpec_FieldPathSelectorImagePullSecrets: &LocalObjectReferenceSecret_FieldMask{},
		PodSpec_FieldPathSelectorVolumes:          &Volume_FieldMask{},
		PodSpec_FieldPathSelectorHostVolumeMounts: &VolumeMount_FieldMask{},
	}
	mySubMasks := map[PodSpec_FieldPathSelector]gotenobject.FieldMask{
		PodSpec_FieldPathSelectorContainers:       &PodSpec_Container_FieldMask{},
		PodSpec_FieldPathSelectorImagePullSecrets: &LocalObjectReferenceSecret_FieldMask{},
		PodSpec_FieldPathSelectorVolumes:          &Volume_FieldMask{},
		PodSpec_FieldPathSelectorHostVolumeMounts: &VolumeMount_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PodSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PodSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case PodSpec_FieldPathSelectorContainers:
						mySubMasks[PodSpec_FieldPathSelectorContainers] = FullPodSpec_Container_FieldMask()
					case PodSpec_FieldPathSelectorImagePullSecrets:
						mySubMasks[PodSpec_FieldPathSelectorImagePullSecrets] = FullLocalObjectReferenceSecret_FieldMask()
					case PodSpec_FieldPathSelectorVolumes:
						mySubMasks[PodSpec_FieldPathSelectorVolumes] = FullVolume_FieldMask()
					case PodSpec_FieldPathSelectorHostVolumeMounts:
						mySubMasks[PodSpec_FieldPathSelectorHostVolumeMounts] = FullVolumeMount_FieldMask()
					}
				} else if tp, ok := path.(*PodSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PodSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PodSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PodSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PodSpec_FieldMask) FilterInputFields() *PodSpec_FieldMask {
	result := &PodSpec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PodSpec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PodSpec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PodSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PodSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PodSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PodSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PodSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PodSpec_FieldMask) AppendPath(path PodSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PodSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodSpec_FieldPath))
}

func (fieldMask *PodSpec_FieldMask) GetPaths() []PodSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PodSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PodSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PodSpec_FieldMask) Set(target, source *PodSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PodSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PodSpec), source.(*PodSpec))
}

func (fieldMask *PodSpec_FieldMask) Project(source *PodSpec) *PodSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PodSpec{}
	containersMask := &PodSpec_Container_FieldMask{}
	wholeContainersAccepted := false
	imagePullSecretsMask := &LocalObjectReferenceSecret_FieldMask{}
	wholeImagePullSecretsAccepted := false
	volumesMask := &Volume_FieldMask{}
	wholeVolumesAccepted := false
	hostVolumeMountsMask := &VolumeMount_FieldMask{}
	wholeHostVolumeMountsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodSpec_FieldTerminalPath:
			switch tp.selector {
			case PodSpec_FieldPathSelectorNode:
				result.Node = source.Node
			case PodSpec_FieldPathSelectorContainers:
				result.Containers = source.Containers
				wholeContainersAccepted = true
			case PodSpec_FieldPathSelectorHostNetwork:
				result.HostNetwork = source.HostNetwork
			case PodSpec_FieldPathSelectorRestartPolicy:
				result.RestartPolicy = source.RestartPolicy
			case PodSpec_FieldPathSelectorImagePullSecrets:
				result.ImagePullSecrets = source.ImagePullSecrets
				wholeImagePullSecretsAccepted = true
			case PodSpec_FieldPathSelectorVolumes:
				result.Volumes = source.Volumes
				wholeVolumesAccepted = true
			case PodSpec_FieldPathSelectorCompose:
				result.Compose = source.Compose
			case PodSpec_FieldPathSelectorHostVolumeMounts:
				result.HostVolumeMounts = source.HostVolumeMounts
				wholeHostVolumeMountsAccepted = true
			}
		case *PodSpec_FieldSubPath:
			switch tp.selector {
			case PodSpec_FieldPathSelectorContainers:
				containersMask.AppendPath(tp.subPath.(PodSpecContainer_FieldPath))
			case PodSpec_FieldPathSelectorImagePullSecrets:
				imagePullSecretsMask.AppendPath(tp.subPath.(LocalObjectReferenceSecret_FieldPath))
			case PodSpec_FieldPathSelectorVolumes:
				volumesMask.AppendPath(tp.subPath.(Volume_FieldPath))
			case PodSpec_FieldPathSelectorHostVolumeMounts:
				hostVolumeMountsMask.AppendPath(tp.subPath.(VolumeMount_FieldPath))
			}
		}
	}
	if wholeContainersAccepted == false && len(containersMask.Paths) > 0 {
		for _, sourceItem := range source.GetContainers() {
			result.Containers = append(result.Containers, containersMask.Project(sourceItem))
		}
	}
	if wholeImagePullSecretsAccepted == false && len(imagePullSecretsMask.Paths) > 0 {
		for _, sourceItem := range source.GetImagePullSecrets() {
			result.ImagePullSecrets = append(result.ImagePullSecrets, imagePullSecretsMask.Project(sourceItem))
		}
	}
	if wholeVolumesAccepted == false && len(volumesMask.Paths) > 0 {
		for _, sourceItem := range source.GetVolumes() {
			result.Volumes = append(result.Volumes, volumesMask.Project(sourceItem))
		}
	}
	if wholeHostVolumeMountsAccepted == false && len(hostVolumeMountsMask.Paths) > 0 {
		for _, sourceItem := range source.GetHostVolumeMounts() {
			result.HostVolumeMounts = append(result.HostVolumeMounts, hostVolumeMountsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PodSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PodSpec))
}

func (fieldMask *PodSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PodSpec_Container_FieldMask struct {
	Paths []PodSpecContainer_FieldPath
}

func FullPodSpec_Container_FieldMask() *PodSpec_Container_FieldMask {
	res := &PodSpec_Container_FieldMask{}
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorArgs})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorCommand})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorEnv})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorImage})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorImagePullPolicy})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorName})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorResources})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorSecurityContext})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorVolumeMounts})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorEnvFrom})
	return res
}

func (fieldMask *PodSpec_Container_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PodSpec_Container_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PodSpec_Container_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodSpecContainer_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PodSpec_Container_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodSpecContainer_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PodSpec_Container_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodSpecContainer_FieldPath(raw)
	})
}

func (fieldMask *PodSpec_Container_FieldMask) ProtoMessage() {}

func (fieldMask *PodSpec_Container_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PodSpec_Container_FieldMask) Subtract(other *PodSpec_Container_FieldMask) *PodSpec_Container_FieldMask {
	result := &PodSpec_Container_FieldMask{}
	removedSelectors := make([]bool, 10)
	otherSubMasks := map[PodSpecContainer_FieldPathSelector]gotenobject.FieldMask{
		PodSpecContainer_FieldPathSelectorEnv:             &EnvVar_FieldMask{},
		PodSpecContainer_FieldPathSelectorResources:       &PodSpec_Container_ResourceRequirements_FieldMask{},
		PodSpecContainer_FieldPathSelectorSecurityContext: &SecurityContext_FieldMask{},
		PodSpecContainer_FieldPathSelectorVolumeMounts:    &VolumeMount_FieldMask{},
		PodSpecContainer_FieldPathSelectorEnvFrom:         &EnvFromSource_FieldMask{},
	}
	mySubMasks := map[PodSpecContainer_FieldPathSelector]gotenobject.FieldMask{
		PodSpecContainer_FieldPathSelectorEnv:             &EnvVar_FieldMask{},
		PodSpecContainer_FieldPathSelectorResources:       &PodSpec_Container_ResourceRequirements_FieldMask{},
		PodSpecContainer_FieldPathSelectorSecurityContext: &SecurityContext_FieldMask{},
		PodSpecContainer_FieldPathSelectorVolumeMounts:    &VolumeMount_FieldMask{},
		PodSpecContainer_FieldPathSelectorEnvFrom:         &EnvFromSource_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodSpecContainer_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PodSpecContainer_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PodSpecContainer_FieldTerminalPath); ok {
					switch tp.selector {
					case PodSpecContainer_FieldPathSelectorEnv:
						mySubMasks[PodSpecContainer_FieldPathSelectorEnv] = FullEnvVar_FieldMask()
					case PodSpecContainer_FieldPathSelectorResources:
						mySubMasks[PodSpecContainer_FieldPathSelectorResources] = FullPodSpec_Container_ResourceRequirements_FieldMask()
					case PodSpecContainer_FieldPathSelectorSecurityContext:
						mySubMasks[PodSpecContainer_FieldPathSelectorSecurityContext] = FullSecurityContext_FieldMask()
					case PodSpecContainer_FieldPathSelectorVolumeMounts:
						mySubMasks[PodSpecContainer_FieldPathSelectorVolumeMounts] = FullVolumeMount_FieldMask()
					case PodSpecContainer_FieldPathSelectorEnvFrom:
						mySubMasks[PodSpecContainer_FieldPathSelectorEnvFrom] = FullEnvFromSource_FieldMask()
					}
				} else if tp, ok := path.(*PodSpecContainer_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PodSpecContainer_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PodSpec_Container_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PodSpec_Container_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PodSpec_Container_FieldMask) FilterInputFields() *PodSpec_Container_FieldMask {
	result := &PodSpec_Container_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PodSpec_Container_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PodSpec_Container_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodSpecContainer_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodSpecContainer_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PodSpec_Container_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PodSpec_Container_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PodSpec_Container_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PodSpec_Container_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PodSpec_Container_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PodSpec_Container_FieldMask) AppendPath(path PodSpecContainer_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PodSpec_Container_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodSpecContainer_FieldPath))
}

func (fieldMask *PodSpec_Container_FieldMask) GetPaths() []PodSpecContainer_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PodSpec_Container_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PodSpec_Container_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodSpecContainer_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PodSpec_Container_FieldMask) Set(target, source *PodSpec_Container) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PodSpec_Container_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PodSpec_Container), source.(*PodSpec_Container))
}

func (fieldMask *PodSpec_Container_FieldMask) Project(source *PodSpec_Container) *PodSpec_Container {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PodSpec_Container{}
	envMask := &EnvVar_FieldMask{}
	wholeEnvAccepted := false
	resourcesMask := &PodSpec_Container_ResourceRequirements_FieldMask{}
	wholeResourcesAccepted := false
	securityContextMask := &SecurityContext_FieldMask{}
	wholeSecurityContextAccepted := false
	volumeMountsMask := &VolumeMount_FieldMask{}
	wholeVolumeMountsAccepted := false
	envFromMask := &EnvFromSource_FieldMask{}
	wholeEnvFromAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodSpecContainer_FieldTerminalPath:
			switch tp.selector {
			case PodSpecContainer_FieldPathSelectorArgs:
				result.Args = source.Args
			case PodSpecContainer_FieldPathSelectorCommand:
				result.Command = source.Command
			case PodSpecContainer_FieldPathSelectorEnv:
				result.Env = source.Env
				wholeEnvAccepted = true
			case PodSpecContainer_FieldPathSelectorImage:
				result.Image = source.Image
			case PodSpecContainer_FieldPathSelectorImagePullPolicy:
				result.ImagePullPolicy = source.ImagePullPolicy
			case PodSpecContainer_FieldPathSelectorName:
				result.Name = source.Name
			case PodSpecContainer_FieldPathSelectorResources:
				result.Resources = source.Resources
				wholeResourcesAccepted = true
			case PodSpecContainer_FieldPathSelectorSecurityContext:
				result.SecurityContext = source.SecurityContext
				wholeSecurityContextAccepted = true
			case PodSpecContainer_FieldPathSelectorVolumeMounts:
				result.VolumeMounts = source.VolumeMounts
				wholeVolumeMountsAccepted = true
			case PodSpecContainer_FieldPathSelectorEnvFrom:
				result.EnvFrom = source.EnvFrom
				wholeEnvFromAccepted = true
			}
		case *PodSpecContainer_FieldSubPath:
			switch tp.selector {
			case PodSpecContainer_FieldPathSelectorEnv:
				envMask.AppendPath(tp.subPath.(EnvVar_FieldPath))
			case PodSpecContainer_FieldPathSelectorResources:
				resourcesMask.AppendPath(tp.subPath.(PodSpecContainerResourceRequirements_FieldPath))
			case PodSpecContainer_FieldPathSelectorSecurityContext:
				securityContextMask.AppendPath(tp.subPath.(SecurityContext_FieldPath))
			case PodSpecContainer_FieldPathSelectorVolumeMounts:
				volumeMountsMask.AppendPath(tp.subPath.(VolumeMount_FieldPath))
			case PodSpecContainer_FieldPathSelectorEnvFrom:
				envFromMask.AppendPath(tp.subPath.(EnvFromSource_FieldPath))
			}
		}
	}
	if wholeEnvAccepted == false && len(envMask.Paths) > 0 {
		for _, sourceItem := range source.GetEnv() {
			result.Env = append(result.Env, envMask.Project(sourceItem))
		}
	}
	if wholeResourcesAccepted == false && len(resourcesMask.Paths) > 0 {
		result.Resources = resourcesMask.Project(source.GetResources())
	}
	if wholeSecurityContextAccepted == false && len(securityContextMask.Paths) > 0 {
		result.SecurityContext = securityContextMask.Project(source.GetSecurityContext())
	}
	if wholeVolumeMountsAccepted == false && len(volumeMountsMask.Paths) > 0 {
		for _, sourceItem := range source.GetVolumeMounts() {
			result.VolumeMounts = append(result.VolumeMounts, volumeMountsMask.Project(sourceItem))
		}
	}
	if wholeEnvFromAccepted == false && len(envFromMask.Paths) > 0 {
		result.EnvFrom = envFromMask.Project(source.GetEnvFrom())
	}
	return result
}

func (fieldMask *PodSpec_Container_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PodSpec_Container))
}

func (fieldMask *PodSpec_Container_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PodSpec_Container_ResourceRequirements_FieldMask struct {
	Paths []PodSpecContainerResourceRequirements_FieldPath
}

func FullPodSpec_Container_ResourceRequirements_FieldMask() *PodSpec_Container_ResourceRequirements_FieldMask {
	res := &PodSpec_Container_ResourceRequirements_FieldMask{}
	res.Paths = append(res.Paths, &PodSpecContainerResourceRequirements_FieldTerminalPath{selector: PodSpecContainerResourceRequirements_FieldPathSelectorLimits})
	res.Paths = append(res.Paths, &PodSpecContainerResourceRequirements_FieldTerminalPath{selector: PodSpecContainerResourceRequirements_FieldPathSelectorRequests})
	return res
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodSpecContainerResourceRequirements_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodSpecContainerResourceRequirements_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodSpecContainerResourceRequirements_FieldPath(raw)
	})
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) ProtoMessage() {}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) Subtract(other *PodSpec_Container_ResourceRequirements_FieldMask) *PodSpec_Container_ResourceRequirements_FieldMask {
	result := &PodSpec_Container_ResourceRequirements_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodSpecContainerResourceRequirements_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PodSpec_Container_ResourceRequirements_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) FilterInputFields() *PodSpec_Container_ResourceRequirements_FieldMask {
	result := &PodSpec_Container_ResourceRequirements_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodSpecContainerResourceRequirements_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodSpecContainerResourceRequirements_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PodSpec_Container_ResourceRequirements_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PodSpec_Container_ResourceRequirements_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) AppendPath(path PodSpecContainerResourceRequirements_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodSpecContainerResourceRequirements_FieldPath))
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) GetPaths() []PodSpecContainerResourceRequirements_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodSpecContainerResourceRequirements_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) Set(target, source *PodSpec_Container_ResourceRequirements) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PodSpec_Container_ResourceRequirements), source.(*PodSpec_Container_ResourceRequirements))
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) Project(source *PodSpec_Container_ResourceRequirements) *PodSpec_Container_ResourceRequirements {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PodSpec_Container_ResourceRequirements{}
	var limitsMapKeys []string
	wholeLimitsAccepted := false
	var requestsMapKeys []string
	wholeRequestsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodSpecContainerResourceRequirements_FieldTerminalPath:
			switch tp.selector {
			case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
				result.Limits = source.Limits
				wholeLimitsAccepted = true
			case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
				result.Requests = source.Requests
				wholeRequestsAccepted = true
			}
		case *PodSpecContainerResourceRequirements_FieldPathMap:
			switch tp.selector {
			case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
				limitsMapKeys = append(limitsMapKeys, tp.key)
			case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
				requestsMapKeys = append(requestsMapKeys, tp.key)
			}
		}
	}
	if wholeLimitsAccepted == false && len(limitsMapKeys) > 0 && source.GetLimits() != nil {
		copiedMap := map[string]int64{}
		sourceMap := source.GetLimits()
		for _, key := range limitsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Limits = copiedMap
	}
	if wholeRequestsAccepted == false && len(requestsMapKeys) > 0 && source.GetRequests() != nil {
		copiedMap := map[string]int64{}
		sourceMap := source.GetRequests()
		for _, key := range requestsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Requests = copiedMap
	}
	return result
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PodSpec_Container_ResourceRequirements))
}

func (fieldMask *PodSpec_Container_ResourceRequirements_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type EnvFromSource_FieldMask struct {
	Paths []EnvFromSource_FieldPath
}

func FullEnvFromSource_FieldMask() *EnvFromSource_FieldMask {
	res := &EnvFromSource_FieldMask{}
	res.Paths = append(res.Paths, &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorPrefix})
	res.Paths = append(res.Paths, &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorConfigMapRef})
	res.Paths = append(res.Paths, &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorSecretRef})
	return res
}

func (fieldMask *EnvFromSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *EnvFromSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *EnvFromSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseEnvFromSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *EnvFromSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*EnvFromSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *EnvFromSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseEnvFromSource_FieldPath(raw)
	})
}

func (fieldMask *EnvFromSource_FieldMask) ProtoMessage() {}

func (fieldMask *EnvFromSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *EnvFromSource_FieldMask) Subtract(other *EnvFromSource_FieldMask) *EnvFromSource_FieldMask {
	result := &EnvFromSource_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[EnvFromSource_FieldPathSelector]gotenobject.FieldMask{
		EnvFromSource_FieldPathSelectorConfigMapRef: &ConfigMapEnvSource_FieldMask{},
		EnvFromSource_FieldPathSelectorSecretRef:    &SecretEnvSource_FieldMask{},
	}
	mySubMasks := map[EnvFromSource_FieldPathSelector]gotenobject.FieldMask{
		EnvFromSource_FieldPathSelectorConfigMapRef: &ConfigMapEnvSource_FieldMask{},
		EnvFromSource_FieldPathSelectorSecretRef:    &SecretEnvSource_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *EnvFromSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *EnvFromSource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*EnvFromSource_FieldTerminalPath); ok {
					switch tp.selector {
					case EnvFromSource_FieldPathSelectorConfigMapRef:
						mySubMasks[EnvFromSource_FieldPathSelectorConfigMapRef] = FullConfigMapEnvSource_FieldMask()
					case EnvFromSource_FieldPathSelectorSecretRef:
						mySubMasks[EnvFromSource_FieldPathSelectorSecretRef] = FullSecretEnvSource_FieldMask()
					}
				} else if tp, ok := path.(*EnvFromSource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &EnvFromSource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *EnvFromSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*EnvFromSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *EnvFromSource_FieldMask) FilterInputFields() *EnvFromSource_FieldMask {
	result := &EnvFromSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *EnvFromSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *EnvFromSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]EnvFromSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseEnvFromSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask EnvFromSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *EnvFromSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvFromSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask EnvFromSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *EnvFromSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvFromSource_FieldMask) AppendPath(path EnvFromSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *EnvFromSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(EnvFromSource_FieldPath))
}

func (fieldMask *EnvFromSource_FieldMask) GetPaths() []EnvFromSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *EnvFromSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *EnvFromSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseEnvFromSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *EnvFromSource_FieldMask) Set(target, source *EnvFromSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *EnvFromSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*EnvFromSource), source.(*EnvFromSource))
}

func (fieldMask *EnvFromSource_FieldMask) Project(source *EnvFromSource) *EnvFromSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &EnvFromSource{}
	configMapRefMask := &ConfigMapEnvSource_FieldMask{}
	wholeConfigMapRefAccepted := false
	secretRefMask := &SecretEnvSource_FieldMask{}
	wholeSecretRefAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *EnvFromSource_FieldTerminalPath:
			switch tp.selector {
			case EnvFromSource_FieldPathSelectorPrefix:
				result.Prefix = source.Prefix
			case EnvFromSource_FieldPathSelectorConfigMapRef:
				result.ConfigMapRef = source.ConfigMapRef
				wholeConfigMapRefAccepted = true
			case EnvFromSource_FieldPathSelectorSecretRef:
				result.SecretRef = source.SecretRef
				wholeSecretRefAccepted = true
			}
		case *EnvFromSource_FieldSubPath:
			switch tp.selector {
			case EnvFromSource_FieldPathSelectorConfigMapRef:
				configMapRefMask.AppendPath(tp.subPath.(ConfigMapEnvSource_FieldPath))
			case EnvFromSource_FieldPathSelectorSecretRef:
				secretRefMask.AppendPath(tp.subPath.(SecretEnvSource_FieldPath))
			}
		}
	}
	if wholeConfigMapRefAccepted == false && len(configMapRefMask.Paths) > 0 {
		result.ConfigMapRef = configMapRefMask.Project(source.GetConfigMapRef())
	}
	if wholeSecretRefAccepted == false && len(secretRefMask.Paths) > 0 {
		result.SecretRef = secretRefMask.Project(source.GetSecretRef())
	}
	return result
}

func (fieldMask *EnvFromSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*EnvFromSource))
}

func (fieldMask *EnvFromSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type EnvVar_FieldMask struct {
	Paths []EnvVar_FieldPath
}

func FullEnvVar_FieldMask() *EnvVar_FieldMask {
	res := &EnvVar_FieldMask{}
	res.Paths = append(res.Paths, &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorName})
	res.Paths = append(res.Paths, &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorValue})
	res.Paths = append(res.Paths, &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorValueFrom})
	return res
}

func (fieldMask *EnvVar_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *EnvVar_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *EnvVar_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseEnvVar_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *EnvVar_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*EnvVar_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *EnvVar_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseEnvVar_FieldPath(raw)
	})
}

func (fieldMask *EnvVar_FieldMask) ProtoMessage() {}

func (fieldMask *EnvVar_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *EnvVar_FieldMask) Subtract(other *EnvVar_FieldMask) *EnvVar_FieldMask {
	result := &EnvVar_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[EnvVar_FieldPathSelector]gotenobject.FieldMask{
		EnvVar_FieldPathSelectorValueFrom: &EnvVarSource_FieldMask{},
	}
	mySubMasks := map[EnvVar_FieldPathSelector]gotenobject.FieldMask{
		EnvVar_FieldPathSelectorValueFrom: &EnvVarSource_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *EnvVar_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *EnvVar_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*EnvVar_FieldTerminalPath); ok {
					switch tp.selector {
					case EnvVar_FieldPathSelectorValueFrom:
						mySubMasks[EnvVar_FieldPathSelectorValueFrom] = FullEnvVarSource_FieldMask()
					}
				} else if tp, ok := path.(*EnvVar_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &EnvVar_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *EnvVar_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*EnvVar_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *EnvVar_FieldMask) FilterInputFields() *EnvVar_FieldMask {
	result := &EnvVar_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *EnvVar_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *EnvVar_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]EnvVar_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseEnvVar_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask EnvVar_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *EnvVar_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvVar_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask EnvVar_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *EnvVar_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvVar_FieldMask) AppendPath(path EnvVar_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *EnvVar_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(EnvVar_FieldPath))
}

func (fieldMask *EnvVar_FieldMask) GetPaths() []EnvVar_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *EnvVar_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *EnvVar_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseEnvVar_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *EnvVar_FieldMask) Set(target, source *EnvVar) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *EnvVar_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*EnvVar), source.(*EnvVar))
}

func (fieldMask *EnvVar_FieldMask) Project(source *EnvVar) *EnvVar {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &EnvVar{}
	valueFromMask := &EnvVarSource_FieldMask{}
	wholeValueFromAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *EnvVar_FieldTerminalPath:
			switch tp.selector {
			case EnvVar_FieldPathSelectorName:
				result.Name = source.Name
			case EnvVar_FieldPathSelectorValue:
				result.Value = source.Value
			case EnvVar_FieldPathSelectorValueFrom:
				result.ValueFrom = source.ValueFrom
				wholeValueFromAccepted = true
			}
		case *EnvVar_FieldSubPath:
			switch tp.selector {
			case EnvVar_FieldPathSelectorValueFrom:
				valueFromMask.AppendPath(tp.subPath.(EnvVarSource_FieldPath))
			}
		}
	}
	if wholeValueFromAccepted == false && len(valueFromMask.Paths) > 0 {
		result.ValueFrom = valueFromMask.Project(source.GetValueFrom())
	}
	return result
}

func (fieldMask *EnvVar_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*EnvVar))
}

func (fieldMask *EnvVar_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConfigMapEnvSource_FieldMask struct {
	Paths []ConfigMapEnvSource_FieldPath
}

func FullConfigMapEnvSource_FieldMask() *ConfigMapEnvSource_FieldMask {
	res := &ConfigMapEnvSource_FieldMask{}
	res.Paths = append(res.Paths, &ConfigMapEnvSource_FieldTerminalPath{selector: ConfigMapEnvSource_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ConfigMapEnvSource_FieldTerminalPath{selector: ConfigMapEnvSource_FieldPathSelectorOptional})
	return res
}

func (fieldMask *ConfigMapEnvSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConfigMapEnvSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConfigMapEnvSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConfigMapEnvSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConfigMapEnvSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConfigMapEnvSource_FieldPath(raw)
	})
}

func (fieldMask *ConfigMapEnvSource_FieldMask) ProtoMessage() {}

func (fieldMask *ConfigMapEnvSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Subtract(other *ConfigMapEnvSource_FieldMask) *ConfigMapEnvSource_FieldMask {
	result := &ConfigMapEnvSource_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConfigMapEnvSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConfigMapEnvSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConfigMapEnvSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConfigMapEnvSource_FieldMask) FilterInputFields() *ConfigMapEnvSource_FieldMask {
	result := &ConfigMapEnvSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConfigMapEnvSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConfigMapEnvSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConfigMapEnvSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConfigMapEnvSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConfigMapEnvSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConfigMapEnvSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConfigMapEnvSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) AppendPath(path ConfigMapEnvSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConfigMapEnvSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConfigMapEnvSource_FieldPath))
}

func (fieldMask *ConfigMapEnvSource_FieldMask) GetPaths() []ConfigMapEnvSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConfigMapEnvSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConfigMapEnvSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConfigMapEnvSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Set(target, source *ConfigMapEnvSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConfigMapEnvSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConfigMapEnvSource), source.(*ConfigMapEnvSource))
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Project(source *ConfigMapEnvSource) *ConfigMapEnvSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConfigMapEnvSource{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConfigMapEnvSource_FieldTerminalPath:
			switch tp.selector {
			case ConfigMapEnvSource_FieldPathSelectorName:
				result.Name = source.Name
			case ConfigMapEnvSource_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		}
	}
	return result
}

func (fieldMask *ConfigMapEnvSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConfigMapEnvSource))
}

func (fieldMask *ConfigMapEnvSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SecretEnvSource_FieldMask struct {
	Paths []SecretEnvSource_FieldPath
}

func FullSecretEnvSource_FieldMask() *SecretEnvSource_FieldMask {
	res := &SecretEnvSource_FieldMask{}
	res.Paths = append(res.Paths, &SecretEnvSource_FieldTerminalPath{selector: SecretEnvSource_FieldPathSelectorName})
	res.Paths = append(res.Paths, &SecretEnvSource_FieldTerminalPath{selector: SecretEnvSource_FieldPathSelectorOptional})
	return res
}

func (fieldMask *SecretEnvSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SecretEnvSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SecretEnvSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSecretEnvSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SecretEnvSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SecretEnvSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SecretEnvSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSecretEnvSource_FieldPath(raw)
	})
}

func (fieldMask *SecretEnvSource_FieldMask) ProtoMessage() {}

func (fieldMask *SecretEnvSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SecretEnvSource_FieldMask) Subtract(other *SecretEnvSource_FieldMask) *SecretEnvSource_FieldMask {
	result := &SecretEnvSource_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SecretEnvSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SecretEnvSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SecretEnvSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SecretEnvSource_FieldMask) FilterInputFields() *SecretEnvSource_FieldMask {
	result := &SecretEnvSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SecretEnvSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SecretEnvSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SecretEnvSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSecretEnvSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SecretEnvSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SecretEnvSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretEnvSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SecretEnvSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SecretEnvSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretEnvSource_FieldMask) AppendPath(path SecretEnvSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SecretEnvSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SecretEnvSource_FieldPath))
}

func (fieldMask *SecretEnvSource_FieldMask) GetPaths() []SecretEnvSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SecretEnvSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SecretEnvSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSecretEnvSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SecretEnvSource_FieldMask) Set(target, source *SecretEnvSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SecretEnvSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SecretEnvSource), source.(*SecretEnvSource))
}

func (fieldMask *SecretEnvSource_FieldMask) Project(source *SecretEnvSource) *SecretEnvSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SecretEnvSource{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SecretEnvSource_FieldTerminalPath:
			switch tp.selector {
			case SecretEnvSource_FieldPathSelectorName:
				result.Name = source.Name
			case SecretEnvSource_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		}
	}
	return result
}

func (fieldMask *SecretEnvSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SecretEnvSource))
}

func (fieldMask *SecretEnvSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type EnvVarSource_FieldMask struct {
	Paths []EnvVarSource_FieldPath
}

func FullEnvVarSource_FieldMask() *EnvVarSource_FieldMask {
	res := &EnvVarSource_FieldMask{}
	res.Paths = append(res.Paths, &EnvVarSource_FieldTerminalPath{selector: EnvVarSource_FieldPathSelectorConfigMapKeyRef})
	res.Paths = append(res.Paths, &EnvVarSource_FieldTerminalPath{selector: EnvVarSource_FieldPathSelectorSecretKeyRef})
	return res
}

func (fieldMask *EnvVarSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *EnvVarSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *EnvVarSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseEnvVarSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *EnvVarSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*EnvVarSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *EnvVarSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseEnvVarSource_FieldPath(raw)
	})
}

func (fieldMask *EnvVarSource_FieldMask) ProtoMessage() {}

func (fieldMask *EnvVarSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *EnvVarSource_FieldMask) Subtract(other *EnvVarSource_FieldMask) *EnvVarSource_FieldMask {
	result := &EnvVarSource_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[EnvVarSource_FieldPathSelector]gotenobject.FieldMask{
		EnvVarSource_FieldPathSelectorConfigMapKeyRef: &ConfigMapKeySelector_FieldMask{},
		EnvVarSource_FieldPathSelectorSecretKeyRef:    &SecretKeySelector_FieldMask{},
	}
	mySubMasks := map[EnvVarSource_FieldPathSelector]gotenobject.FieldMask{
		EnvVarSource_FieldPathSelectorConfigMapKeyRef: &ConfigMapKeySelector_FieldMask{},
		EnvVarSource_FieldPathSelectorSecretKeyRef:    &SecretKeySelector_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *EnvVarSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *EnvVarSource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*EnvVarSource_FieldTerminalPath); ok {
					switch tp.selector {
					case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
						mySubMasks[EnvVarSource_FieldPathSelectorConfigMapKeyRef] = FullConfigMapKeySelector_FieldMask()
					case EnvVarSource_FieldPathSelectorSecretKeyRef:
						mySubMasks[EnvVarSource_FieldPathSelectorSecretKeyRef] = FullSecretKeySelector_FieldMask()
					}
				} else if tp, ok := path.(*EnvVarSource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &EnvVarSource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *EnvVarSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*EnvVarSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *EnvVarSource_FieldMask) FilterInputFields() *EnvVarSource_FieldMask {
	result := &EnvVarSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *EnvVarSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *EnvVarSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]EnvVarSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseEnvVarSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask EnvVarSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *EnvVarSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvVarSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask EnvVarSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *EnvVarSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvVarSource_FieldMask) AppendPath(path EnvVarSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *EnvVarSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(EnvVarSource_FieldPath))
}

func (fieldMask *EnvVarSource_FieldMask) GetPaths() []EnvVarSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *EnvVarSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *EnvVarSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseEnvVarSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *EnvVarSource_FieldMask) Set(target, source *EnvVarSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *EnvVarSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*EnvVarSource), source.(*EnvVarSource))
}

func (fieldMask *EnvVarSource_FieldMask) Project(source *EnvVarSource) *EnvVarSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &EnvVarSource{}
	configMapKeyRefMask := &ConfigMapKeySelector_FieldMask{}
	wholeConfigMapKeyRefAccepted := false
	secretKeyRefMask := &SecretKeySelector_FieldMask{}
	wholeSecretKeyRefAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *EnvVarSource_FieldTerminalPath:
			switch tp.selector {
			case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
				result.ConfigMapKeyRef = source.ConfigMapKeyRef
				wholeConfigMapKeyRefAccepted = true
			case EnvVarSource_FieldPathSelectorSecretKeyRef:
				result.SecretKeyRef = source.SecretKeyRef
				wholeSecretKeyRefAccepted = true
			}
		case *EnvVarSource_FieldSubPath:
			switch tp.selector {
			case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
				configMapKeyRefMask.AppendPath(tp.subPath.(ConfigMapKeySelector_FieldPath))
			case EnvVarSource_FieldPathSelectorSecretKeyRef:
				secretKeyRefMask.AppendPath(tp.subPath.(SecretKeySelector_FieldPath))
			}
		}
	}
	if wholeConfigMapKeyRefAccepted == false && len(configMapKeyRefMask.Paths) > 0 {
		result.ConfigMapKeyRef = configMapKeyRefMask.Project(source.GetConfigMapKeyRef())
	}
	if wholeSecretKeyRefAccepted == false && len(secretKeyRefMask.Paths) > 0 {
		result.SecretKeyRef = secretKeyRefMask.Project(source.GetSecretKeyRef())
	}
	return result
}

func (fieldMask *EnvVarSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*EnvVarSource))
}

func (fieldMask *EnvVarSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConfigMapKeySelector_FieldMask struct {
	Paths []ConfigMapKeySelector_FieldPath
}

func FullConfigMapKeySelector_FieldMask() *ConfigMapKeySelector_FieldMask {
	res := &ConfigMapKeySelector_FieldMask{}
	res.Paths = append(res.Paths, &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorOptional})
	return res
}

func (fieldMask *ConfigMapKeySelector_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConfigMapKeySelector_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConfigMapKeySelector_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConfigMapKeySelector_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConfigMapKeySelector_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConfigMapKeySelector_FieldPath(raw)
	})
}

func (fieldMask *ConfigMapKeySelector_FieldMask) ProtoMessage() {}

func (fieldMask *ConfigMapKeySelector_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Subtract(other *ConfigMapKeySelector_FieldMask) *ConfigMapKeySelector_FieldMask {
	result := &ConfigMapKeySelector_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConfigMapKeySelector_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConfigMapKeySelector_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConfigMapKeySelector_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConfigMapKeySelector_FieldMask) FilterInputFields() *ConfigMapKeySelector_FieldMask {
	result := &ConfigMapKeySelector_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConfigMapKeySelector_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConfigMapKeySelector_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConfigMapKeySelector_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConfigMapKeySelector_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConfigMapKeySelector_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConfigMapKeySelector_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConfigMapKeySelector_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) AppendPath(path ConfigMapKeySelector_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConfigMapKeySelector_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConfigMapKeySelector_FieldPath))
}

func (fieldMask *ConfigMapKeySelector_FieldMask) GetPaths() []ConfigMapKeySelector_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConfigMapKeySelector_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConfigMapKeySelector_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConfigMapKeySelector_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Set(target, source *ConfigMapKeySelector) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConfigMapKeySelector_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConfigMapKeySelector), source.(*ConfigMapKeySelector))
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Project(source *ConfigMapKeySelector) *ConfigMapKeySelector {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConfigMapKeySelector{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConfigMapKeySelector_FieldTerminalPath:
			switch tp.selector {
			case ConfigMapKeySelector_FieldPathSelectorName:
				result.Name = source.Name
			case ConfigMapKeySelector_FieldPathSelectorKey:
				result.Key = source.Key
			case ConfigMapKeySelector_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		}
	}
	return result
}

func (fieldMask *ConfigMapKeySelector_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConfigMapKeySelector))
}

func (fieldMask *ConfigMapKeySelector_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SecretKeySelector_FieldMask struct {
	Paths []SecretKeySelector_FieldPath
}

func FullSecretKeySelector_FieldMask() *SecretKeySelector_FieldMask {
	res := &SecretKeySelector_FieldMask{}
	res.Paths = append(res.Paths, &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorName})
	res.Paths = append(res.Paths, &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorOptional})
	return res
}

func (fieldMask *SecretKeySelector_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SecretKeySelector_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SecretKeySelector_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSecretKeySelector_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SecretKeySelector_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SecretKeySelector_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SecretKeySelector_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSecretKeySelector_FieldPath(raw)
	})
}

func (fieldMask *SecretKeySelector_FieldMask) ProtoMessage() {}

func (fieldMask *SecretKeySelector_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SecretKeySelector_FieldMask) Subtract(other *SecretKeySelector_FieldMask) *SecretKeySelector_FieldMask {
	result := &SecretKeySelector_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SecretKeySelector_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SecretKeySelector_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SecretKeySelector_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SecretKeySelector_FieldMask) FilterInputFields() *SecretKeySelector_FieldMask {
	result := &SecretKeySelector_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SecretKeySelector_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SecretKeySelector_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SecretKeySelector_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSecretKeySelector_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SecretKeySelector_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SecretKeySelector_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretKeySelector_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SecretKeySelector_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SecretKeySelector_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretKeySelector_FieldMask) AppendPath(path SecretKeySelector_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SecretKeySelector_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SecretKeySelector_FieldPath))
}

func (fieldMask *SecretKeySelector_FieldMask) GetPaths() []SecretKeySelector_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SecretKeySelector_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SecretKeySelector_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSecretKeySelector_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SecretKeySelector_FieldMask) Set(target, source *SecretKeySelector) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SecretKeySelector_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SecretKeySelector), source.(*SecretKeySelector))
}

func (fieldMask *SecretKeySelector_FieldMask) Project(source *SecretKeySelector) *SecretKeySelector {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SecretKeySelector{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SecretKeySelector_FieldTerminalPath:
			switch tp.selector {
			case SecretKeySelector_FieldPathSelectorName:
				result.Name = source.Name
			case SecretKeySelector_FieldPathSelectorKey:
				result.Key = source.Key
			case SecretKeySelector_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		}
	}
	return result
}

func (fieldMask *SecretKeySelector_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SecretKeySelector))
}

func (fieldMask *SecretKeySelector_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type LocalObjectReferenceSecret_FieldMask struct {
	Paths []LocalObjectReferenceSecret_FieldPath
}

func FullLocalObjectReferenceSecret_FieldMask() *LocalObjectReferenceSecret_FieldMask {
	res := &LocalObjectReferenceSecret_FieldMask{}
	res.Paths = append(res.Paths, &LocalObjectReferenceSecret_FieldTerminalPath{selector: LocalObjectReferenceSecret_FieldPathSelectorName})
	return res
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *LocalObjectReferenceSecret_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseLocalObjectReferenceSecret_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LocalObjectReferenceSecret_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLocalObjectReferenceSecret_FieldPath(raw)
	})
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) ProtoMessage() {}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Subtract(other *LocalObjectReferenceSecret_FieldMask) *LocalObjectReferenceSecret_FieldMask {
	result := &LocalObjectReferenceSecret_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LocalObjectReferenceSecret_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LocalObjectReferenceSecret_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LocalObjectReferenceSecret_FieldMask) FilterInputFields() *LocalObjectReferenceSecret_FieldMask {
	result := &LocalObjectReferenceSecret_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LocalObjectReferenceSecret_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LocalObjectReferenceSecret_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLocalObjectReferenceSecret_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LocalObjectReferenceSecret_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LocalObjectReferenceSecret_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) AppendPath(path LocalObjectReferenceSecret_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LocalObjectReferenceSecret_FieldPath))
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) GetPaths() []LocalObjectReferenceSecret_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLocalObjectReferenceSecret_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Set(target, source *LocalObjectReferenceSecret) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LocalObjectReferenceSecret), source.(*LocalObjectReferenceSecret))
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Project(source *LocalObjectReferenceSecret) *LocalObjectReferenceSecret {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LocalObjectReferenceSecret{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LocalObjectReferenceSecret_FieldTerminalPath:
			switch tp.selector {
			case LocalObjectReferenceSecret_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LocalObjectReferenceSecret))
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SecurityContext_FieldMask struct {
	Paths []SecurityContext_FieldPath
}

func FullSecurityContext_FieldMask() *SecurityContext_FieldMask {
	res := &SecurityContext_FieldMask{}
	res.Paths = append(res.Paths, &SecurityContext_FieldTerminalPath{selector: SecurityContext_FieldPathSelectorPrivileged})
	return res
}

func (fieldMask *SecurityContext_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SecurityContext_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SecurityContext_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSecurityContext_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SecurityContext_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SecurityContext_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SecurityContext_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSecurityContext_FieldPath(raw)
	})
}

func (fieldMask *SecurityContext_FieldMask) ProtoMessage() {}

func (fieldMask *SecurityContext_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SecurityContext_FieldMask) Subtract(other *SecurityContext_FieldMask) *SecurityContext_FieldMask {
	result := &SecurityContext_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SecurityContext_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SecurityContext_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SecurityContext_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SecurityContext_FieldMask) FilterInputFields() *SecurityContext_FieldMask {
	result := &SecurityContext_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SecurityContext_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SecurityContext_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SecurityContext_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSecurityContext_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SecurityContext_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SecurityContext_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecurityContext_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SecurityContext_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SecurityContext_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecurityContext_FieldMask) AppendPath(path SecurityContext_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SecurityContext_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SecurityContext_FieldPath))
}

func (fieldMask *SecurityContext_FieldMask) GetPaths() []SecurityContext_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SecurityContext_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SecurityContext_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSecurityContext_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SecurityContext_FieldMask) Set(target, source *SecurityContext) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SecurityContext_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SecurityContext), source.(*SecurityContext))
}

func (fieldMask *SecurityContext_FieldMask) Project(source *SecurityContext) *SecurityContext {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SecurityContext{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SecurityContext_FieldTerminalPath:
			switch tp.selector {
			case SecurityContext_FieldPathSelectorPrivileged:
				result.Privileged = source.Privileged
			}
		}
	}
	return result
}

func (fieldMask *SecurityContext_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SecurityContext))
}

func (fieldMask *SecurityContext_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Volume_FieldMask struct {
	Paths []Volume_FieldPath
}

func FullVolume_FieldMask() *Volume_FieldMask {
	res := &Volume_FieldMask{}
	res.Paths = append(res.Paths, &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorHostPath})
	res.Paths = append(res.Paths, &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorSecret})
	res.Paths = append(res.Paths, &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorConfigMap})
	return res
}

func (fieldMask *Volume_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Volume_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Volume_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseVolume_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Volume_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Volume_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Volume_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseVolume_FieldPath(raw)
	})
}

func (fieldMask *Volume_FieldMask) ProtoMessage() {}

func (fieldMask *Volume_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Volume_FieldMask) Subtract(other *Volume_FieldMask) *Volume_FieldMask {
	result := &Volume_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[Volume_FieldPathSelector]gotenobject.FieldMask{
		Volume_FieldPathSelectorHostPath:  &HostPathVolumeSource_FieldMask{},
		Volume_FieldPathSelectorSecret:    &SecretVolumeSource_FieldMask{},
		Volume_FieldPathSelectorConfigMap: &ConfigMapVolumeSource_FieldMask{},
	}
	mySubMasks := map[Volume_FieldPathSelector]gotenobject.FieldMask{
		Volume_FieldPathSelectorHostPath:  &HostPathVolumeSource_FieldMask{},
		Volume_FieldPathSelectorSecret:    &SecretVolumeSource_FieldMask{},
		Volume_FieldPathSelectorConfigMap: &ConfigMapVolumeSource_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Volume_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Volume_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Volume_FieldTerminalPath); ok {
					switch tp.selector {
					case Volume_FieldPathSelectorHostPath:
						mySubMasks[Volume_FieldPathSelectorHostPath] = FullHostPathVolumeSource_FieldMask()
					case Volume_FieldPathSelectorSecret:
						mySubMasks[Volume_FieldPathSelectorSecret] = FullSecretVolumeSource_FieldMask()
					case Volume_FieldPathSelectorConfigMap:
						mySubMasks[Volume_FieldPathSelectorConfigMap] = FullConfigMapVolumeSource_FieldMask()
					}
				} else if tp, ok := path.(*Volume_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Volume_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Volume_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Volume_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Volume_FieldMask) FilterInputFields() *Volume_FieldMask {
	result := &Volume_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Volume_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Volume_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Volume_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseVolume_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Volume_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Volume_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Volume_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Volume_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Volume_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Volume_FieldMask) AppendPath(path Volume_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Volume_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Volume_FieldPath))
}

func (fieldMask *Volume_FieldMask) GetPaths() []Volume_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Volume_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Volume_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseVolume_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Volume_FieldMask) Set(target, source *Volume) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Volume_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Volume), source.(*Volume))
}

func (fieldMask *Volume_FieldMask) Project(source *Volume) *Volume {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Volume{}
	hostPathMask := &HostPathVolumeSource_FieldMask{}
	wholeHostPathAccepted := false
	secretMask := &SecretVolumeSource_FieldMask{}
	wholeSecretAccepted := false
	configMapMask := &ConfigMapVolumeSource_FieldMask{}
	wholeConfigMapAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Volume_FieldTerminalPath:
			switch tp.selector {
			case Volume_FieldPathSelectorName:
				result.Name = source.Name
			case Volume_FieldPathSelectorHostPath:
				result.HostPath = source.HostPath
				wholeHostPathAccepted = true
			case Volume_FieldPathSelectorSecret:
				result.Secret = source.Secret
				wholeSecretAccepted = true
			case Volume_FieldPathSelectorConfigMap:
				result.ConfigMap = source.ConfigMap
				wholeConfigMapAccepted = true
			}
		case *Volume_FieldSubPath:
			switch tp.selector {
			case Volume_FieldPathSelectorHostPath:
				hostPathMask.AppendPath(tp.subPath.(HostPathVolumeSource_FieldPath))
			case Volume_FieldPathSelectorSecret:
				secretMask.AppendPath(tp.subPath.(SecretVolumeSource_FieldPath))
			case Volume_FieldPathSelectorConfigMap:
				configMapMask.AppendPath(tp.subPath.(ConfigMapVolumeSource_FieldPath))
			}
		}
	}
	if wholeHostPathAccepted == false && len(hostPathMask.Paths) > 0 {
		result.HostPath = hostPathMask.Project(source.GetHostPath())
	}
	if wholeSecretAccepted == false && len(secretMask.Paths) > 0 {
		result.Secret = secretMask.Project(source.GetSecret())
	}
	if wholeConfigMapAccepted == false && len(configMapMask.Paths) > 0 {
		result.ConfigMap = configMapMask.Project(source.GetConfigMap())
	}
	return result
}

func (fieldMask *Volume_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Volume))
}

func (fieldMask *Volume_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type VolumeMount_FieldMask struct {
	Paths []VolumeMount_FieldPath
}

func FullVolumeMount_FieldMask() *VolumeMount_FieldMask {
	res := &VolumeMount_FieldMask{}
	res.Paths = append(res.Paths, &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorName})
	res.Paths = append(res.Paths, &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorReadOnly})
	res.Paths = append(res.Paths, &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorMountPath})
	res.Paths = append(res.Paths, &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorSubPath})
	return res
}

func (fieldMask *VolumeMount_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *VolumeMount_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *VolumeMount_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseVolumeMount_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *VolumeMount_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*VolumeMount_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *VolumeMount_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseVolumeMount_FieldPath(raw)
	})
}

func (fieldMask *VolumeMount_FieldMask) ProtoMessage() {}

func (fieldMask *VolumeMount_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *VolumeMount_FieldMask) Subtract(other *VolumeMount_FieldMask) *VolumeMount_FieldMask {
	result := &VolumeMount_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *VolumeMount_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *VolumeMount_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*VolumeMount_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *VolumeMount_FieldMask) FilterInputFields() *VolumeMount_FieldMask {
	result := &VolumeMount_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *VolumeMount_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *VolumeMount_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]VolumeMount_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseVolumeMount_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask VolumeMount_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *VolumeMount_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *VolumeMount_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask VolumeMount_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *VolumeMount_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *VolumeMount_FieldMask) AppendPath(path VolumeMount_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *VolumeMount_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(VolumeMount_FieldPath))
}

func (fieldMask *VolumeMount_FieldMask) GetPaths() []VolumeMount_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *VolumeMount_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *VolumeMount_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseVolumeMount_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *VolumeMount_FieldMask) Set(target, source *VolumeMount) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *VolumeMount_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*VolumeMount), source.(*VolumeMount))
}

func (fieldMask *VolumeMount_FieldMask) Project(source *VolumeMount) *VolumeMount {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &VolumeMount{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *VolumeMount_FieldTerminalPath:
			switch tp.selector {
			case VolumeMount_FieldPathSelectorName:
				result.Name = source.Name
			case VolumeMount_FieldPathSelectorReadOnly:
				result.ReadOnly = source.ReadOnly
			case VolumeMount_FieldPathSelectorMountPath:
				result.MountPath = source.MountPath
			case VolumeMount_FieldPathSelectorSubPath:
				result.SubPath = source.SubPath
			}
		}
	}
	return result
}

func (fieldMask *VolumeMount_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*VolumeMount))
}

func (fieldMask *VolumeMount_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type HostPathVolumeSource_FieldMask struct {
	Paths []HostPathVolumeSource_FieldPath
}

func FullHostPathVolumeSource_FieldMask() *HostPathVolumeSource_FieldMask {
	res := &HostPathVolumeSource_FieldMask{}
	res.Paths = append(res.Paths, &HostPathVolumeSource_FieldTerminalPath{selector: HostPathVolumeSource_FieldPathSelectorPath})
	res.Paths = append(res.Paths, &HostPathVolumeSource_FieldTerminalPath{selector: HostPathVolumeSource_FieldPathSelectorType})
	return res
}

func (fieldMask *HostPathVolumeSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *HostPathVolumeSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseHostPathVolumeSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*HostPathVolumeSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *HostPathVolumeSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseHostPathVolumeSource_FieldPath(raw)
	})
}

func (fieldMask *HostPathVolumeSource_FieldMask) ProtoMessage() {}

func (fieldMask *HostPathVolumeSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *HostPathVolumeSource_FieldMask) Subtract(other *HostPathVolumeSource_FieldMask) *HostPathVolumeSource_FieldMask {
	result := &HostPathVolumeSource_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *HostPathVolumeSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *HostPathVolumeSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*HostPathVolumeSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *HostPathVolumeSource_FieldMask) FilterInputFields() *HostPathVolumeSource_FieldMask {
	result := &HostPathVolumeSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *HostPathVolumeSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *HostPathVolumeSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]HostPathVolumeSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseHostPathVolumeSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask HostPathVolumeSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *HostPathVolumeSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask HostPathVolumeSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *HostPathVolumeSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) AppendPath(path HostPathVolumeSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *HostPathVolumeSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(HostPathVolumeSource_FieldPath))
}

func (fieldMask *HostPathVolumeSource_FieldMask) GetPaths() []HostPathVolumeSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *HostPathVolumeSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *HostPathVolumeSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseHostPathVolumeSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) Set(target, source *HostPathVolumeSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *HostPathVolumeSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*HostPathVolumeSource), source.(*HostPathVolumeSource))
}

func (fieldMask *HostPathVolumeSource_FieldMask) Project(source *HostPathVolumeSource) *HostPathVolumeSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &HostPathVolumeSource{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *HostPathVolumeSource_FieldTerminalPath:
			switch tp.selector {
			case HostPathVolumeSource_FieldPathSelectorPath:
				result.Path = source.Path
			case HostPathVolumeSource_FieldPathSelectorType:
				result.Type = source.Type
			}
		}
	}
	return result
}

func (fieldMask *HostPathVolumeSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*HostPathVolumeSource))
}

func (fieldMask *HostPathVolumeSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SecretVolumeSource_FieldMask struct {
	Paths []SecretVolumeSource_FieldPath
}

func FullSecretVolumeSource_FieldMask() *SecretVolumeSource_FieldMask {
	res := &SecretVolumeSource_FieldMask{}
	res.Paths = append(res.Paths, &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorSecretName})
	res.Paths = append(res.Paths, &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorItems})
	res.Paths = append(res.Paths, &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorDefaultMode})
	res.Paths = append(res.Paths, &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorOptional})
	return res
}

func (fieldMask *SecretVolumeSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SecretVolumeSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SecretVolumeSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSecretVolumeSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SecretVolumeSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SecretVolumeSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SecretVolumeSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSecretVolumeSource_FieldPath(raw)
	})
}

func (fieldMask *SecretVolumeSource_FieldMask) ProtoMessage() {}

func (fieldMask *SecretVolumeSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SecretVolumeSource_FieldMask) Subtract(other *SecretVolumeSource_FieldMask) *SecretVolumeSource_FieldMask {
	result := &SecretVolumeSource_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[SecretVolumeSource_FieldPathSelector]gotenobject.FieldMask{
		SecretVolumeSource_FieldPathSelectorItems: &KeyToPath_FieldMask{},
	}
	mySubMasks := map[SecretVolumeSource_FieldPathSelector]gotenobject.FieldMask{
		SecretVolumeSource_FieldPathSelectorItems: &KeyToPath_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SecretVolumeSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *SecretVolumeSource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*SecretVolumeSource_FieldTerminalPath); ok {
					switch tp.selector {
					case SecretVolumeSource_FieldPathSelectorItems:
						mySubMasks[SecretVolumeSource_FieldPathSelectorItems] = FullKeyToPath_FieldMask()
					}
				} else if tp, ok := path.(*SecretVolumeSource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &SecretVolumeSource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SecretVolumeSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SecretVolumeSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SecretVolumeSource_FieldMask) FilterInputFields() *SecretVolumeSource_FieldMask {
	result := &SecretVolumeSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SecretVolumeSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SecretVolumeSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SecretVolumeSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSecretVolumeSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SecretVolumeSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SecretVolumeSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretVolumeSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SecretVolumeSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SecretVolumeSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretVolumeSource_FieldMask) AppendPath(path SecretVolumeSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SecretVolumeSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SecretVolumeSource_FieldPath))
}

func (fieldMask *SecretVolumeSource_FieldMask) GetPaths() []SecretVolumeSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SecretVolumeSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SecretVolumeSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSecretVolumeSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SecretVolumeSource_FieldMask) Set(target, source *SecretVolumeSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SecretVolumeSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SecretVolumeSource), source.(*SecretVolumeSource))
}

func (fieldMask *SecretVolumeSource_FieldMask) Project(source *SecretVolumeSource) *SecretVolumeSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SecretVolumeSource{}
	itemsMask := &KeyToPath_FieldMask{}
	wholeItemsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SecretVolumeSource_FieldTerminalPath:
			switch tp.selector {
			case SecretVolumeSource_FieldPathSelectorSecretName:
				result.SecretName = source.SecretName
			case SecretVolumeSource_FieldPathSelectorItems:
				result.Items = source.Items
				wholeItemsAccepted = true
			case SecretVolumeSource_FieldPathSelectorDefaultMode:
				result.DefaultMode = source.DefaultMode
			case SecretVolumeSource_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		case *SecretVolumeSource_FieldSubPath:
			switch tp.selector {
			case SecretVolumeSource_FieldPathSelectorItems:
				itemsMask.AppendPath(tp.subPath.(KeyToPath_FieldPath))
			}
		}
	}
	if wholeItemsAccepted == false && len(itemsMask.Paths) > 0 {
		for _, sourceItem := range source.GetItems() {
			result.Items = append(result.Items, itemsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *SecretVolumeSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SecretVolumeSource))
}

func (fieldMask *SecretVolumeSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type KeyToPath_FieldMask struct {
	Paths []KeyToPath_FieldPath
}

func FullKeyToPath_FieldMask() *KeyToPath_FieldMask {
	res := &KeyToPath_FieldMask{}
	res.Paths = append(res.Paths, &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorPath})
	res.Paths = append(res.Paths, &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorMode})
	return res
}

func (fieldMask *KeyToPath_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *KeyToPath_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *KeyToPath_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseKeyToPath_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *KeyToPath_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*KeyToPath_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *KeyToPath_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseKeyToPath_FieldPath(raw)
	})
}

func (fieldMask *KeyToPath_FieldMask) ProtoMessage() {}

func (fieldMask *KeyToPath_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *KeyToPath_FieldMask) Subtract(other *KeyToPath_FieldMask) *KeyToPath_FieldMask {
	result := &KeyToPath_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *KeyToPath_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *KeyToPath_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*KeyToPath_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *KeyToPath_FieldMask) FilterInputFields() *KeyToPath_FieldMask {
	result := &KeyToPath_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *KeyToPath_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *KeyToPath_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]KeyToPath_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseKeyToPath_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask KeyToPath_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *KeyToPath_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *KeyToPath_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask KeyToPath_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *KeyToPath_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *KeyToPath_FieldMask) AppendPath(path KeyToPath_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *KeyToPath_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(KeyToPath_FieldPath))
}

func (fieldMask *KeyToPath_FieldMask) GetPaths() []KeyToPath_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *KeyToPath_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *KeyToPath_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseKeyToPath_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *KeyToPath_FieldMask) Set(target, source *KeyToPath) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *KeyToPath_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*KeyToPath), source.(*KeyToPath))
}

func (fieldMask *KeyToPath_FieldMask) Project(source *KeyToPath) *KeyToPath {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &KeyToPath{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *KeyToPath_FieldTerminalPath:
			switch tp.selector {
			case KeyToPath_FieldPathSelectorKey:
				result.Key = source.Key
			case KeyToPath_FieldPathSelectorPath:
				result.Path = source.Path
			case KeyToPath_FieldPathSelectorMode:
				result.Mode = source.Mode
			}
		}
	}
	return result
}

func (fieldMask *KeyToPath_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*KeyToPath))
}

func (fieldMask *KeyToPath_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConfigMapVolumeSource_FieldMask struct {
	Paths []ConfigMapVolumeSource_FieldPath
}

func FullConfigMapVolumeSource_FieldMask() *ConfigMapVolumeSource_FieldMask {
	res := &ConfigMapVolumeSource_FieldMask{}
	res.Paths = append(res.Paths, &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorItems})
	res.Paths = append(res.Paths, &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorDefaultMode})
	res.Paths = append(res.Paths, &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorOptional})
	return res
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConfigMapVolumeSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConfigMapVolumeSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConfigMapVolumeSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConfigMapVolumeSource_FieldPath(raw)
	})
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) ProtoMessage() {}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Subtract(other *ConfigMapVolumeSource_FieldMask) *ConfigMapVolumeSource_FieldMask {
	result := &ConfigMapVolumeSource_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[ConfigMapVolumeSource_FieldPathSelector]gotenobject.FieldMask{
		ConfigMapVolumeSource_FieldPathSelectorItems: &KeyToPath_FieldMask{},
	}
	mySubMasks := map[ConfigMapVolumeSource_FieldPathSelector]gotenobject.FieldMask{
		ConfigMapVolumeSource_FieldPathSelectorItems: &KeyToPath_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConfigMapVolumeSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConfigMapVolumeSource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConfigMapVolumeSource_FieldTerminalPath); ok {
					switch tp.selector {
					case ConfigMapVolumeSource_FieldPathSelectorItems:
						mySubMasks[ConfigMapVolumeSource_FieldPathSelectorItems] = FullKeyToPath_FieldMask()
					}
				} else if tp, ok := path.(*ConfigMapVolumeSource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConfigMapVolumeSource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConfigMapVolumeSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConfigMapVolumeSource_FieldMask) FilterInputFields() *ConfigMapVolumeSource_FieldMask {
	result := &ConfigMapVolumeSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConfigMapVolumeSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConfigMapVolumeSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConfigMapVolumeSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConfigMapVolumeSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConfigMapVolumeSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) AppendPath(path ConfigMapVolumeSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConfigMapVolumeSource_FieldPath))
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) GetPaths() []ConfigMapVolumeSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConfigMapVolumeSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Set(target, source *ConfigMapVolumeSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConfigMapVolumeSource), source.(*ConfigMapVolumeSource))
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Project(source *ConfigMapVolumeSource) *ConfigMapVolumeSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConfigMapVolumeSource{}
	itemsMask := &KeyToPath_FieldMask{}
	wholeItemsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConfigMapVolumeSource_FieldTerminalPath:
			switch tp.selector {
			case ConfigMapVolumeSource_FieldPathSelectorName:
				result.Name = source.Name
			case ConfigMapVolumeSource_FieldPathSelectorItems:
				result.Items = source.Items
				wholeItemsAccepted = true
			case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
				result.DefaultMode = source.DefaultMode
			case ConfigMapVolumeSource_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		case *ConfigMapVolumeSource_FieldSubPath:
			switch tp.selector {
			case ConfigMapVolumeSource_FieldPathSelectorItems:
				itemsMask.AppendPath(tp.subPath.(KeyToPath_FieldPath))
			}
		}
	}
	if wholeItemsAccepted == false && len(itemsMask.Paths) > 0 {
		for _, sourceItem := range source.GetItems() {
			result.Items = append(result.Items, itemsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConfigMapVolumeSource))
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
