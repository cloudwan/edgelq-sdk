// Code generated by protoc-gen-goten-object
// File: edgelq/applications/proto/v1alpha2/pod.proto
// DO NOT EDIT!!!

package pod

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	project "github.com/cloudwan/edgelq-sdk/applications/resources/v1alpha2/project"
	ntt_meta "github.com/cloudwan/edgelq-sdk/common/types/meta"
	devices_device "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha2/device"
	secrets_secret "github.com/cloudwan/edgelq-sdk/secrets/resources/v1alpha2/secret"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &project.Project{}
	_ = &ntt_meta.Meta{}
	_ = &devices_device.Device{}
	_ = &secrets_secret.Secret{}
	_ = &timestamp.Timestamp{}
)

type Pod_FieldMask struct {
	Paths []Pod_FieldPath
}

func FullPod_FieldMask() *Pod_FieldMask {
	res := &Pod_FieldMask{}
	res.Paths = append(res.Paths, &Pod_FieldTerminalPath{selector: Pod_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Pod_FieldTerminalPath{selector: Pod_FieldPathSelectorDisplayName})
	res.Paths = append(res.Paths, &Pod_FieldTerminalPath{selector: Pod_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &Pod_FieldTerminalPath{selector: Pod_FieldPathSelectorSpec})
	res.Paths = append(res.Paths, &Pod_FieldTerminalPath{selector: Pod_FieldPathSelectorStatus})
	return res
}

func (fieldMask *Pod_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePod_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Pod_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePod_FieldPath(raw)
	})
}

func (fieldMask *Pod_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_FieldMask) Subtract(other *Pod_FieldMask) *Pod_FieldMask {
	result := &Pod_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[Pod_FieldPathSelector]gotenobject.FieldMask{
		Pod_FieldPathSelectorMetadata: &ntt_meta.Meta_FieldMask{},
		Pod_FieldPathSelectorSpec:     &Pod_Spec_FieldMask{},
		Pod_FieldPathSelectorStatus:   &Pod_Status_FieldMask{},
	}
	mySubMasks := map[Pod_FieldPathSelector]gotenobject.FieldMask{
		Pod_FieldPathSelectorMetadata: &ntt_meta.Meta_FieldMask{},
		Pod_FieldPathSelectorSpec:     &Pod_Spec_FieldMask{},
		Pod_FieldPathSelectorStatus:   &Pod_Status_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Pod_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Pod_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Pod_FieldTerminalPath); ok {
					switch tp.selector {
					case Pod_FieldPathSelectorMetadata:
						mySubMasks[Pod_FieldPathSelectorMetadata] = ntt_meta.FullMeta_FieldMask()
					case Pod_FieldPathSelectorSpec:
						mySubMasks[Pod_FieldPathSelectorSpec] = FullPod_Spec_FieldMask()
					case Pod_FieldPathSelectorStatus:
						mySubMasks[Pod_FieldPathSelectorStatus] = FullPod_Status_FieldMask()
					}
				} else if tp, ok := path.(*Pod_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Pod_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_FieldMask) FilterInputFields() *Pod_FieldMask {
	result := &Pod_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case Pod_FieldPathSelectorMetadata:
			if _, ok := path.(*Pod_FieldTerminalPath); ok {
				for _, subpath := range ntt_meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Pod_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Pod_FieldSubPath); ok {
				selectedMask := &ntt_meta.Meta_FieldMask{
					Paths: []ntt_meta.Meta_FieldPath{sub.subPath.(ntt_meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Pod_FieldSubPath{selector: Pod_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Pod_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePod_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_FieldMask) AppendPath(path Pod_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Pod_FieldPath))
}

func (fieldMask *Pod_FieldMask) GetPaths() []Pod_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePod_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_FieldMask) Set(target, source *Pod) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod), source.(*Pod))
}

func (fieldMask *Pod_FieldMask) Project(source *Pod) *Pod {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod{}
	metadataMask := &ntt_meta.Meta_FieldMask{}
	wholeMetadataAccepted := false
	specMask := &Pod_Spec_FieldMask{}
	wholeSpecAccepted := false
	statusMask := &Pod_Status_FieldMask{}
	wholeStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Pod_FieldTerminalPath:
			switch tp.selector {
			case Pod_FieldPathSelectorName:
				result.Name = source.Name
			case Pod_FieldPathSelectorDisplayName:
				result.DisplayName = source.DisplayName
			case Pod_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case Pod_FieldPathSelectorSpec:
				result.Spec = source.Spec
				wholeSpecAccepted = true
			case Pod_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			}
		case *Pod_FieldSubPath:
			switch tp.selector {
			case Pod_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(ntt_meta.Meta_FieldPath))
			case Pod_FieldPathSelectorSpec:
				specMask.AppendPath(tp.subPath.(PodSpec_FieldPath))
			case Pod_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(PodStatus_FieldPath))
			}
		}
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	if wholeSpecAccepted == false && len(specMask.Paths) > 0 {
		result.Spec = specMask.Project(source.GetSpec())
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	return result
}

func (fieldMask *Pod_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod))
}

func (fieldMask *Pod_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Pod_Spec_FieldMask struct {
	Paths []PodSpec_FieldPath
}

func FullPod_Spec_FieldMask() *Pod_Spec_FieldMask {
	res := &Pod_Spec_FieldMask{}
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorNode})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorContainers})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorHostNetwork})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorRestartPolicy})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorImagePullSecrets})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorVolumes})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorCompose})
	res.Paths = append(res.Paths, &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorHostVolumeMounts})
	return res
}

func (fieldMask *Pod_Spec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_Spec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_Spec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_Spec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_Spec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodSpec_FieldPath(raw)
	})
}

func (fieldMask *Pod_Spec_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_Spec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_Spec_FieldMask) Subtract(other *Pod_Spec_FieldMask) *Pod_Spec_FieldMask {
	result := &Pod_Spec_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[PodSpec_FieldPathSelector]gotenobject.FieldMask{
		PodSpec_FieldPathSelectorContainers:       &Pod_Spec_Container_FieldMask{},
		PodSpec_FieldPathSelectorImagePullSecrets: &LocalObjectReferenceSecret_FieldMask{},
		PodSpec_FieldPathSelectorVolumes:          &Volume_FieldMask{},
		PodSpec_FieldPathSelectorHostVolumeMounts: &VolumeMount_FieldMask{},
	}
	mySubMasks := map[PodSpec_FieldPathSelector]gotenobject.FieldMask{
		PodSpec_FieldPathSelectorContainers:       &Pod_Spec_Container_FieldMask{},
		PodSpec_FieldPathSelectorImagePullSecrets: &LocalObjectReferenceSecret_FieldMask{},
		PodSpec_FieldPathSelectorVolumes:          &Volume_FieldMask{},
		PodSpec_FieldPathSelectorHostVolumeMounts: &VolumeMount_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PodSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PodSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case PodSpec_FieldPathSelectorContainers:
						mySubMasks[PodSpec_FieldPathSelectorContainers] = FullPod_Spec_Container_FieldMask()
					case PodSpec_FieldPathSelectorImagePullSecrets:
						mySubMasks[PodSpec_FieldPathSelectorImagePullSecrets] = FullLocalObjectReferenceSecret_FieldMask()
					case PodSpec_FieldPathSelectorVolumes:
						mySubMasks[PodSpec_FieldPathSelectorVolumes] = FullVolume_FieldMask()
					case PodSpec_FieldPathSelectorHostVolumeMounts:
						mySubMasks[PodSpec_FieldPathSelectorHostVolumeMounts] = FullVolumeMount_FieldMask()
					}
				} else if tp, ok := path.(*PodSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PodSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_Spec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_Spec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_Spec_FieldMask) FilterInputFields() *Pod_Spec_FieldMask {
	result := &Pod_Spec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_Spec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_Spec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_Spec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_Spec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Spec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_Spec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_Spec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Spec_FieldMask) AppendPath(path PodSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_Spec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodSpec_FieldPath))
}

func (fieldMask *Pod_Spec_FieldMask) GetPaths() []PodSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_Spec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_Spec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_Spec_FieldMask) Set(target, source *Pod_Spec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_Spec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod_Spec), source.(*Pod_Spec))
}

func (fieldMask *Pod_Spec_FieldMask) Project(source *Pod_Spec) *Pod_Spec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod_Spec{}
	containersMask := &Pod_Spec_Container_FieldMask{}
	wholeContainersAccepted := false
	imagePullSecretsMask := &LocalObjectReferenceSecret_FieldMask{}
	wholeImagePullSecretsAccepted := false
	volumesMask := &Volume_FieldMask{}
	wholeVolumesAccepted := false
	hostVolumeMountsMask := &VolumeMount_FieldMask{}
	wholeHostVolumeMountsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodSpec_FieldTerminalPath:
			switch tp.selector {
			case PodSpec_FieldPathSelectorNode:
				result.Node = source.Node
			case PodSpec_FieldPathSelectorContainers:
				result.Containers = source.Containers
				wholeContainersAccepted = true
			case PodSpec_FieldPathSelectorHostNetwork:
				result.HostNetwork = source.HostNetwork
			case PodSpec_FieldPathSelectorRestartPolicy:
				result.RestartPolicy = source.RestartPolicy
			case PodSpec_FieldPathSelectorImagePullSecrets:
				result.ImagePullSecrets = source.ImagePullSecrets
				wholeImagePullSecretsAccepted = true
			case PodSpec_FieldPathSelectorVolumes:
				result.Volumes = source.Volumes
				wholeVolumesAccepted = true
			case PodSpec_FieldPathSelectorCompose:
				result.Compose = source.Compose
			case PodSpec_FieldPathSelectorHostVolumeMounts:
				result.HostVolumeMounts = source.HostVolumeMounts
				wholeHostVolumeMountsAccepted = true
			}
		case *PodSpec_FieldSubPath:
			switch tp.selector {
			case PodSpec_FieldPathSelectorContainers:
				containersMask.AppendPath(tp.subPath.(PodSpecContainer_FieldPath))
			case PodSpec_FieldPathSelectorImagePullSecrets:
				imagePullSecretsMask.AppendPath(tp.subPath.(LocalObjectReferenceSecret_FieldPath))
			case PodSpec_FieldPathSelectorVolumes:
				volumesMask.AppendPath(tp.subPath.(Volume_FieldPath))
			case PodSpec_FieldPathSelectorHostVolumeMounts:
				hostVolumeMountsMask.AppendPath(tp.subPath.(VolumeMount_FieldPath))
			}
		}
	}
	if wholeContainersAccepted == false && len(containersMask.Paths) > 0 {
		for _, sourceItem := range source.GetContainers() {
			result.Containers = append(result.Containers, containersMask.Project(sourceItem))
		}
	}
	if wholeImagePullSecretsAccepted == false && len(imagePullSecretsMask.Paths) > 0 {
		for _, sourceItem := range source.GetImagePullSecrets() {
			result.ImagePullSecrets = append(result.ImagePullSecrets, imagePullSecretsMask.Project(sourceItem))
		}
	}
	if wholeVolumesAccepted == false && len(volumesMask.Paths) > 0 {
		for _, sourceItem := range source.GetVolumes() {
			result.Volumes = append(result.Volumes, volumesMask.Project(sourceItem))
		}
	}
	if wholeHostVolumeMountsAccepted == false && len(hostVolumeMountsMask.Paths) > 0 {
		for _, sourceItem := range source.GetHostVolumeMounts() {
			result.HostVolumeMounts = append(result.HostVolumeMounts, hostVolumeMountsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Pod_Spec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod_Spec))
}

func (fieldMask *Pod_Spec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Pod_Status_FieldMask struct {
	Paths []PodStatus_FieldPath
}

func FullPod_Status_FieldMask() *Pod_Status_FieldMask {
	res := &Pod_Status_FieldMask{}
	res.Paths = append(res.Paths, &PodStatus_FieldTerminalPath{selector: PodStatus_FieldPathSelectorPhase})
	res.Paths = append(res.Paths, &PodStatus_FieldTerminalPath{selector: PodStatus_FieldPathSelectorContainerStatuses})
	return res
}

func (fieldMask *Pod_Status_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_Status_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_Status_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_Status_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_Status_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodStatus_FieldPath(raw)
	})
}

func (fieldMask *Pod_Status_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_Status_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_Status_FieldMask) Subtract(other *Pod_Status_FieldMask) *Pod_Status_FieldMask {
	result := &Pod_Status_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[PodStatus_FieldPathSelector]gotenobject.FieldMask{
		PodStatus_FieldPathSelectorContainerStatuses: &Pod_Status_Container_FieldMask{},
	}
	mySubMasks := map[PodStatus_FieldPathSelector]gotenobject.FieldMask{
		PodStatus_FieldPathSelectorContainerStatuses: &Pod_Status_Container_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PodStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PodStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case PodStatus_FieldPathSelectorContainerStatuses:
						mySubMasks[PodStatus_FieldPathSelectorContainerStatuses] = FullPod_Status_Container_FieldMask()
					}
				} else if tp, ok := path.(*PodStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PodStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_Status_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_Status_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_Status_FieldMask) FilterInputFields() *Pod_Status_FieldMask {
	result := &Pod_Status_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_Status_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_Status_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_Status_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_Status_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_Status_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_Status_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_FieldMask) AppendPath(path PodStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_Status_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodStatus_FieldPath))
}

func (fieldMask *Pod_Status_FieldMask) GetPaths() []PodStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_Status_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_Status_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_Status_FieldMask) Set(target, source *Pod_Status) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_Status_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod_Status), source.(*Pod_Status))
}

func (fieldMask *Pod_Status_FieldMask) Project(source *Pod_Status) *Pod_Status {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod_Status{}
	containerStatusesMask := &Pod_Status_Container_FieldMask{}
	wholeContainerStatusesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodStatus_FieldTerminalPath:
			switch tp.selector {
			case PodStatus_FieldPathSelectorPhase:
				result.Phase = source.Phase
			case PodStatus_FieldPathSelectorContainerStatuses:
				result.ContainerStatuses = source.ContainerStatuses
				wholeContainerStatusesAccepted = true
			}
		case *PodStatus_FieldSubPath:
			switch tp.selector {
			case PodStatus_FieldPathSelectorContainerStatuses:
				containerStatusesMask.AppendPath(tp.subPath.(PodStatusContainer_FieldPath))
			}
		}
	}
	if wholeContainerStatusesAccepted == false && len(containerStatusesMask.Paths) > 0 {
		for _, sourceItem := range source.GetContainerStatuses() {
			result.ContainerStatuses = append(result.ContainerStatuses, containerStatusesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Pod_Status_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod_Status))
}

func (fieldMask *Pod_Status_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Pod_Spec_Container_FieldMask struct {
	Paths []PodSpecContainer_FieldPath
}

func FullPod_Spec_Container_FieldMask() *Pod_Spec_Container_FieldMask {
	res := &Pod_Spec_Container_FieldMask{}
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorArgs})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorCommand})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorEnv})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorImage})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorImagePullPolicy})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorName})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorResources})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorSecurityContext})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorVolumeMounts})
	res.Paths = append(res.Paths, &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorEnvFrom})
	return res
}

func (fieldMask *Pod_Spec_Container_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_Spec_Container_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_Spec_Container_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodSpecContainer_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_Spec_Container_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodSpecContainer_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_Spec_Container_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodSpecContainer_FieldPath(raw)
	})
}

func (fieldMask *Pod_Spec_Container_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_Spec_Container_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_Spec_Container_FieldMask) Subtract(other *Pod_Spec_Container_FieldMask) *Pod_Spec_Container_FieldMask {
	result := &Pod_Spec_Container_FieldMask{}
	removedSelectors := make([]bool, 10)
	otherSubMasks := map[PodSpecContainer_FieldPathSelector]gotenobject.FieldMask{
		PodSpecContainer_FieldPathSelectorEnv:             &EnvVar_FieldMask{},
		PodSpecContainer_FieldPathSelectorResources:       &Pod_Spec_Container_ResourceRequirements_FieldMask{},
		PodSpecContainer_FieldPathSelectorSecurityContext: &SecurityContext_FieldMask{},
		PodSpecContainer_FieldPathSelectorVolumeMounts:    &VolumeMount_FieldMask{},
		PodSpecContainer_FieldPathSelectorEnvFrom:         &EnvFromSource_FieldMask{},
	}
	mySubMasks := map[PodSpecContainer_FieldPathSelector]gotenobject.FieldMask{
		PodSpecContainer_FieldPathSelectorEnv:             &EnvVar_FieldMask{},
		PodSpecContainer_FieldPathSelectorResources:       &Pod_Spec_Container_ResourceRequirements_FieldMask{},
		PodSpecContainer_FieldPathSelectorSecurityContext: &SecurityContext_FieldMask{},
		PodSpecContainer_FieldPathSelectorVolumeMounts:    &VolumeMount_FieldMask{},
		PodSpecContainer_FieldPathSelectorEnvFrom:         &EnvFromSource_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodSpecContainer_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PodSpecContainer_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PodSpecContainer_FieldTerminalPath); ok {
					switch tp.selector {
					case PodSpecContainer_FieldPathSelectorEnv:
						mySubMasks[PodSpecContainer_FieldPathSelectorEnv] = FullEnvVar_FieldMask()
					case PodSpecContainer_FieldPathSelectorResources:
						mySubMasks[PodSpecContainer_FieldPathSelectorResources] = FullPod_Spec_Container_ResourceRequirements_FieldMask()
					case PodSpecContainer_FieldPathSelectorSecurityContext:
						mySubMasks[PodSpecContainer_FieldPathSelectorSecurityContext] = FullSecurityContext_FieldMask()
					case PodSpecContainer_FieldPathSelectorVolumeMounts:
						mySubMasks[PodSpecContainer_FieldPathSelectorVolumeMounts] = FullVolumeMount_FieldMask()
					case PodSpecContainer_FieldPathSelectorEnvFrom:
						mySubMasks[PodSpecContainer_FieldPathSelectorEnvFrom] = FullEnvFromSource_FieldMask()
					}
				} else if tp, ok := path.(*PodSpecContainer_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PodSpecContainer_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_Spec_Container_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_Spec_Container_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_Spec_Container_FieldMask) FilterInputFields() *Pod_Spec_Container_FieldMask {
	result := &Pod_Spec_Container_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_Spec_Container_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_Spec_Container_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodSpecContainer_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodSpecContainer_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_Spec_Container_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_Spec_Container_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Spec_Container_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_Spec_Container_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_Spec_Container_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Spec_Container_FieldMask) AppendPath(path PodSpecContainer_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_Spec_Container_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodSpecContainer_FieldPath))
}

func (fieldMask *Pod_Spec_Container_FieldMask) GetPaths() []PodSpecContainer_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_Spec_Container_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_Spec_Container_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodSpecContainer_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_Spec_Container_FieldMask) Set(target, source *Pod_Spec_Container) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_Spec_Container_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod_Spec_Container), source.(*Pod_Spec_Container))
}

func (fieldMask *Pod_Spec_Container_FieldMask) Project(source *Pod_Spec_Container) *Pod_Spec_Container {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod_Spec_Container{}
	envMask := &EnvVar_FieldMask{}
	wholeEnvAccepted := false
	resourcesMask := &Pod_Spec_Container_ResourceRequirements_FieldMask{}
	wholeResourcesAccepted := false
	securityContextMask := &SecurityContext_FieldMask{}
	wholeSecurityContextAccepted := false
	volumeMountsMask := &VolumeMount_FieldMask{}
	wholeVolumeMountsAccepted := false
	envFromMask := &EnvFromSource_FieldMask{}
	wholeEnvFromAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodSpecContainer_FieldTerminalPath:
			switch tp.selector {
			case PodSpecContainer_FieldPathSelectorArgs:
				result.Args = source.Args
			case PodSpecContainer_FieldPathSelectorCommand:
				result.Command = source.Command
			case PodSpecContainer_FieldPathSelectorEnv:
				result.Env = source.Env
				wholeEnvAccepted = true
			case PodSpecContainer_FieldPathSelectorImage:
				result.Image = source.Image
			case PodSpecContainer_FieldPathSelectorImagePullPolicy:
				result.ImagePullPolicy = source.ImagePullPolicy
			case PodSpecContainer_FieldPathSelectorName:
				result.Name = source.Name
			case PodSpecContainer_FieldPathSelectorResources:
				result.Resources = source.Resources
				wholeResourcesAccepted = true
			case PodSpecContainer_FieldPathSelectorSecurityContext:
				result.SecurityContext = source.SecurityContext
				wholeSecurityContextAccepted = true
			case PodSpecContainer_FieldPathSelectorVolumeMounts:
				result.VolumeMounts = source.VolumeMounts
				wholeVolumeMountsAccepted = true
			case PodSpecContainer_FieldPathSelectorEnvFrom:
				result.EnvFrom = source.EnvFrom
				wholeEnvFromAccepted = true
			}
		case *PodSpecContainer_FieldSubPath:
			switch tp.selector {
			case PodSpecContainer_FieldPathSelectorEnv:
				envMask.AppendPath(tp.subPath.(EnvVar_FieldPath))
			case PodSpecContainer_FieldPathSelectorResources:
				resourcesMask.AppendPath(tp.subPath.(PodSpecContainerResourceRequirements_FieldPath))
			case PodSpecContainer_FieldPathSelectorSecurityContext:
				securityContextMask.AppendPath(tp.subPath.(SecurityContext_FieldPath))
			case PodSpecContainer_FieldPathSelectorVolumeMounts:
				volumeMountsMask.AppendPath(tp.subPath.(VolumeMount_FieldPath))
			case PodSpecContainer_FieldPathSelectorEnvFrom:
				envFromMask.AppendPath(tp.subPath.(EnvFromSource_FieldPath))
			}
		}
	}
	if wholeEnvAccepted == false && len(envMask.Paths) > 0 {
		for _, sourceItem := range source.GetEnv() {
			result.Env = append(result.Env, envMask.Project(sourceItem))
		}
	}
	if wholeResourcesAccepted == false && len(resourcesMask.Paths) > 0 {
		result.Resources = resourcesMask.Project(source.GetResources())
	}
	if wholeSecurityContextAccepted == false && len(securityContextMask.Paths) > 0 {
		result.SecurityContext = securityContextMask.Project(source.GetSecurityContext())
	}
	if wholeVolumeMountsAccepted == false && len(volumeMountsMask.Paths) > 0 {
		for _, sourceItem := range source.GetVolumeMounts() {
			result.VolumeMounts = append(result.VolumeMounts, volumeMountsMask.Project(sourceItem))
		}
	}
	if wholeEnvFromAccepted == false && len(envFromMask.Paths) > 0 {
		result.EnvFrom = envFromMask.Project(source.GetEnvFrom())
	}
	return result
}

func (fieldMask *Pod_Spec_Container_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod_Spec_Container))
}

func (fieldMask *Pod_Spec_Container_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Pod_Spec_Container_ResourceRequirements_FieldMask struct {
	Paths []PodSpecContainerResourceRequirements_FieldPath
}

func FullPod_Spec_Container_ResourceRequirements_FieldMask() *Pod_Spec_Container_ResourceRequirements_FieldMask {
	res := &Pod_Spec_Container_ResourceRequirements_FieldMask{}
	res.Paths = append(res.Paths, &PodSpecContainerResourceRequirements_FieldTerminalPath{selector: PodSpecContainerResourceRequirements_FieldPathSelectorLimits})
	res.Paths = append(res.Paths, &PodSpecContainerResourceRequirements_FieldTerminalPath{selector: PodSpecContainerResourceRequirements_FieldPathSelectorRequests})
	return res
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodSpecContainerResourceRequirements_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodSpecContainerResourceRequirements_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodSpecContainerResourceRequirements_FieldPath(raw)
	})
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) Subtract(other *Pod_Spec_Container_ResourceRequirements_FieldMask) *Pod_Spec_Container_ResourceRequirements_FieldMask {
	result := &Pod_Spec_Container_ResourceRequirements_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodSpecContainerResourceRequirements_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_Spec_Container_ResourceRequirements_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) FilterInputFields() *Pod_Spec_Container_ResourceRequirements_FieldMask {
	result := &Pod_Spec_Container_ResourceRequirements_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodSpecContainerResourceRequirements_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodSpecContainerResourceRequirements_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_Spec_Container_ResourceRequirements_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_Spec_Container_ResourceRequirements_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) AppendPath(path PodSpecContainerResourceRequirements_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodSpecContainerResourceRequirements_FieldPath))
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) GetPaths() []PodSpecContainerResourceRequirements_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodSpecContainerResourceRequirements_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) Set(target, source *Pod_Spec_Container_ResourceRequirements) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod_Spec_Container_ResourceRequirements), source.(*Pod_Spec_Container_ResourceRequirements))
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) Project(source *Pod_Spec_Container_ResourceRequirements) *Pod_Spec_Container_ResourceRequirements {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod_Spec_Container_ResourceRequirements{}
	var limitsMapKeys []string
	wholeLimitsAccepted := false
	var requestsMapKeys []string
	wholeRequestsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodSpecContainerResourceRequirements_FieldTerminalPath:
			switch tp.selector {
			case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
				result.Limits = source.Limits
				wholeLimitsAccepted = true
			case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
				result.Requests = source.Requests
				wholeRequestsAccepted = true
			}
		case *PodSpecContainerResourceRequirements_FieldPathMap:
			switch tp.selector {
			case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
				limitsMapKeys = append(limitsMapKeys, tp.key)
			case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
				requestsMapKeys = append(requestsMapKeys, tp.key)
			}
		}
	}
	if wholeLimitsAccepted == false && len(limitsMapKeys) > 0 && source.GetLimits() != nil {
		copiedMap := map[string]int64{}
		sourceMap := source.GetLimits()
		for _, key := range limitsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Limits = copiedMap
	}
	if wholeRequestsAccepted == false && len(requestsMapKeys) > 0 && source.GetRequests() != nil {
		copiedMap := map[string]int64{}
		sourceMap := source.GetRequests()
		for _, key := range requestsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Requests = copiedMap
	}
	return result
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod_Spec_Container_ResourceRequirements))
}

func (fieldMask *Pod_Spec_Container_ResourceRequirements_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Pod_Status_Container_FieldMask struct {
	Paths []PodStatusContainer_FieldPath
}

func FullPod_Status_Container_FieldMask() *Pod_Status_Container_FieldMask {
	res := &Pod_Status_Container_FieldMask{}
	res.Paths = append(res.Paths, &PodStatusContainer_FieldTerminalPath{selector: PodStatusContainer_FieldPathSelectorName})
	res.Paths = append(res.Paths, &PodStatusContainer_FieldTerminalPath{selector: PodStatusContainer_FieldPathSelectorState})
	res.Paths = append(res.Paths, &PodStatusContainer_FieldTerminalPath{selector: PodStatusContainer_FieldPathSelectorWaiting})
	res.Paths = append(res.Paths, &PodStatusContainer_FieldTerminalPath{selector: PodStatusContainer_FieldPathSelectorRunning})
	res.Paths = append(res.Paths, &PodStatusContainer_FieldTerminalPath{selector: PodStatusContainer_FieldPathSelectorTerminated})
	return res
}

func (fieldMask *Pod_Status_Container_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_Status_Container_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_Status_Container_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodStatusContainer_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_Status_Container_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodStatusContainer_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_Status_Container_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodStatusContainer_FieldPath(raw)
	})
}

func (fieldMask *Pod_Status_Container_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_Status_Container_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_Status_Container_FieldMask) Subtract(other *Pod_Status_Container_FieldMask) *Pod_Status_Container_FieldMask {
	result := &Pod_Status_Container_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[PodStatusContainer_FieldPathSelector]gotenobject.FieldMask{
		PodStatusContainer_FieldPathSelectorWaiting:    &Pod_Status_Container_StateWaiting_FieldMask{},
		PodStatusContainer_FieldPathSelectorRunning:    &Pod_Status_Container_StateRunning_FieldMask{},
		PodStatusContainer_FieldPathSelectorTerminated: &Pod_Status_Container_StateTerminated_FieldMask{},
	}
	mySubMasks := map[PodStatusContainer_FieldPathSelector]gotenobject.FieldMask{
		PodStatusContainer_FieldPathSelectorWaiting:    &Pod_Status_Container_StateWaiting_FieldMask{},
		PodStatusContainer_FieldPathSelectorRunning:    &Pod_Status_Container_StateRunning_FieldMask{},
		PodStatusContainer_FieldPathSelectorTerminated: &Pod_Status_Container_StateTerminated_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodStatusContainer_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PodStatusContainer_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PodStatusContainer_FieldTerminalPath); ok {
					switch tp.selector {
					case PodStatusContainer_FieldPathSelectorWaiting:
						mySubMasks[PodStatusContainer_FieldPathSelectorWaiting] = FullPod_Status_Container_StateWaiting_FieldMask()
					case PodStatusContainer_FieldPathSelectorRunning:
						mySubMasks[PodStatusContainer_FieldPathSelectorRunning] = FullPod_Status_Container_StateRunning_FieldMask()
					case PodStatusContainer_FieldPathSelectorTerminated:
						mySubMasks[PodStatusContainer_FieldPathSelectorTerminated] = FullPod_Status_Container_StateTerminated_FieldMask()
					}
				} else if tp, ok := path.(*PodStatusContainer_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PodStatusContainer_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_Status_Container_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_Status_Container_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_Status_Container_FieldMask) FilterInputFields() *Pod_Status_Container_FieldMask {
	result := &Pod_Status_Container_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_Status_Container_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_Status_Container_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodStatusContainer_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodStatusContainer_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_Status_Container_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_Status_Container_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_Container_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_Status_Container_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_Status_Container_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_Container_FieldMask) AppendPath(path PodStatusContainer_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_Status_Container_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodStatusContainer_FieldPath))
}

func (fieldMask *Pod_Status_Container_FieldMask) GetPaths() []PodStatusContainer_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_Status_Container_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_Status_Container_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodStatusContainer_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_Status_Container_FieldMask) Set(target, source *Pod_Status_Container) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_Status_Container_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod_Status_Container), source.(*Pod_Status_Container))
}

func (fieldMask *Pod_Status_Container_FieldMask) Project(source *Pod_Status_Container) *Pod_Status_Container {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod_Status_Container{}
	waitingMask := &Pod_Status_Container_StateWaiting_FieldMask{}
	wholeWaitingAccepted := false
	runningMask := &Pod_Status_Container_StateRunning_FieldMask{}
	wholeRunningAccepted := false
	terminatedMask := &Pod_Status_Container_StateTerminated_FieldMask{}
	wholeTerminatedAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodStatusContainer_FieldTerminalPath:
			switch tp.selector {
			case PodStatusContainer_FieldPathSelectorName:
				result.Name = source.Name
			case PodStatusContainer_FieldPathSelectorState:
				result.State = source.State
			case PodStatusContainer_FieldPathSelectorWaiting:
				result.Waiting = source.Waiting
				wholeWaitingAccepted = true
			case PodStatusContainer_FieldPathSelectorRunning:
				result.Running = source.Running
				wholeRunningAccepted = true
			case PodStatusContainer_FieldPathSelectorTerminated:
				result.Terminated = source.Terminated
				wholeTerminatedAccepted = true
			}
		case *PodStatusContainer_FieldSubPath:
			switch tp.selector {
			case PodStatusContainer_FieldPathSelectorWaiting:
				waitingMask.AppendPath(tp.subPath.(PodStatusContainerStateWaiting_FieldPath))
			case PodStatusContainer_FieldPathSelectorRunning:
				runningMask.AppendPath(tp.subPath.(PodStatusContainerStateRunning_FieldPath))
			case PodStatusContainer_FieldPathSelectorTerminated:
				terminatedMask.AppendPath(tp.subPath.(PodStatusContainerStateTerminated_FieldPath))
			}
		}
	}
	if wholeWaitingAccepted == false && len(waitingMask.Paths) > 0 {
		result.Waiting = waitingMask.Project(source.GetWaiting())
	}
	if wholeRunningAccepted == false && len(runningMask.Paths) > 0 {
		result.Running = runningMask.Project(source.GetRunning())
	}
	if wholeTerminatedAccepted == false && len(terminatedMask.Paths) > 0 {
		result.Terminated = terminatedMask.Project(source.GetTerminated())
	}
	return result
}

func (fieldMask *Pod_Status_Container_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod_Status_Container))
}

func (fieldMask *Pod_Status_Container_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Pod_Status_Container_StateWaiting_FieldMask struct {
	Paths []PodStatusContainerStateWaiting_FieldPath
}

func FullPod_Status_Container_StateWaiting_FieldMask() *Pod_Status_Container_StateWaiting_FieldMask {
	res := &Pod_Status_Container_StateWaiting_FieldMask{}
	res.Paths = append(res.Paths, &PodStatusContainerStateWaiting_FieldTerminalPath{selector: PodStatusContainerStateWaiting_FieldPathSelectorReason})
	res.Paths = append(res.Paths, &PodStatusContainerStateWaiting_FieldTerminalPath{selector: PodStatusContainerStateWaiting_FieldPathSelectorMessage})
	return res
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodStatusContainerStateWaiting_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodStatusContainerStateWaiting_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodStatusContainerStateWaiting_FieldPath(raw)
	})
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) Subtract(other *Pod_Status_Container_StateWaiting_FieldMask) *Pod_Status_Container_StateWaiting_FieldMask {
	result := &Pod_Status_Container_StateWaiting_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodStatusContainerStateWaiting_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_Status_Container_StateWaiting_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) FilterInputFields() *Pod_Status_Container_StateWaiting_FieldMask {
	result := &Pod_Status_Container_StateWaiting_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodStatusContainerStateWaiting_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodStatusContainerStateWaiting_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_Status_Container_StateWaiting_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_Status_Container_StateWaiting_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) AppendPath(path PodStatusContainerStateWaiting_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodStatusContainerStateWaiting_FieldPath))
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) GetPaths() []PodStatusContainerStateWaiting_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodStatusContainerStateWaiting_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) Set(target, source *Pod_Status_Container_StateWaiting) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod_Status_Container_StateWaiting), source.(*Pod_Status_Container_StateWaiting))
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) Project(source *Pod_Status_Container_StateWaiting) *Pod_Status_Container_StateWaiting {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod_Status_Container_StateWaiting{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodStatusContainerStateWaiting_FieldTerminalPath:
			switch tp.selector {
			case PodStatusContainerStateWaiting_FieldPathSelectorReason:
				result.Reason = source.Reason
			case PodStatusContainerStateWaiting_FieldPathSelectorMessage:
				result.Message = source.Message
			}
		}
	}
	return result
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod_Status_Container_StateWaiting))
}

func (fieldMask *Pod_Status_Container_StateWaiting_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Pod_Status_Container_StateRunning_FieldMask struct {
	Paths []PodStatusContainerStateRunning_FieldPath
}

func FullPod_Status_Container_StateRunning_FieldMask() *Pod_Status_Container_StateRunning_FieldMask {
	res := &Pod_Status_Container_StateRunning_FieldMask{}
	res.Paths = append(res.Paths, &PodStatusContainerStateRunning_FieldTerminalPath{selector: PodStatusContainerStateRunning_FieldPathSelectorStartedAt})
	return res
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodStatusContainerStateRunning_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodStatusContainerStateRunning_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodStatusContainerStateRunning_FieldPath(raw)
	})
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) Subtract(other *Pod_Status_Container_StateRunning_FieldMask) *Pod_Status_Container_StateRunning_FieldMask {
	result := &Pod_Status_Container_StateRunning_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodStatusContainerStateRunning_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_Status_Container_StateRunning_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) FilterInputFields() *Pod_Status_Container_StateRunning_FieldMask {
	result := &Pod_Status_Container_StateRunning_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodStatusContainerStateRunning_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodStatusContainerStateRunning_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_Status_Container_StateRunning_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_Status_Container_StateRunning_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) AppendPath(path PodStatusContainerStateRunning_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodStatusContainerStateRunning_FieldPath))
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) GetPaths() []PodStatusContainerStateRunning_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodStatusContainerStateRunning_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) Set(target, source *Pod_Status_Container_StateRunning) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod_Status_Container_StateRunning), source.(*Pod_Status_Container_StateRunning))
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) Project(source *Pod_Status_Container_StateRunning) *Pod_Status_Container_StateRunning {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod_Status_Container_StateRunning{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodStatusContainerStateRunning_FieldTerminalPath:
			switch tp.selector {
			case PodStatusContainerStateRunning_FieldPathSelectorStartedAt:
				result.StartedAt = source.StartedAt
			}
		}
	}
	return result
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod_Status_Container_StateRunning))
}

func (fieldMask *Pod_Status_Container_StateRunning_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Pod_Status_Container_StateTerminated_FieldMask struct {
	Paths []PodStatusContainerStateTerminated_FieldPath
}

func FullPod_Status_Container_StateTerminated_FieldMask() *Pod_Status_Container_StateTerminated_FieldMask {
	res := &Pod_Status_Container_StateTerminated_FieldMask{}
	res.Paths = append(res.Paths, &PodStatusContainerStateTerminated_FieldTerminalPath{selector: PodStatusContainerStateTerminated_FieldPathSelectorExitCode})
	res.Paths = append(res.Paths, &PodStatusContainerStateTerminated_FieldTerminalPath{selector: PodStatusContainerStateTerminated_FieldPathSelectorSignal})
	res.Paths = append(res.Paths, &PodStatusContainerStateTerminated_FieldTerminalPath{selector: PodStatusContainerStateTerminated_FieldPathSelectorReason})
	res.Paths = append(res.Paths, &PodStatusContainerStateTerminated_FieldTerminalPath{selector: PodStatusContainerStateTerminated_FieldPathSelectorMessage})
	res.Paths = append(res.Paths, &PodStatusContainerStateTerminated_FieldTerminalPath{selector: PodStatusContainerStateTerminated_FieldPathSelectorStartedAt})
	res.Paths = append(res.Paths, &PodStatusContainerStateTerminated_FieldTerminalPath{selector: PodStatusContainerStateTerminated_FieldPathSelectorFinishedAt})
	res.Paths = append(res.Paths, &PodStatusContainerStateTerminated_FieldTerminalPath{selector: PodStatusContainerStateTerminated_FieldPathSelectorContainerId})
	return res
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePodStatusContainerStateTerminated_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PodStatusContainerStateTerminated_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePodStatusContainerStateTerminated_FieldPath(raw)
	})
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) ProtoMessage() {}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) Subtract(other *Pod_Status_Container_StateTerminated_FieldMask) *Pod_Status_Container_StateTerminated_FieldMask {
	result := &Pod_Status_Container_StateTerminated_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PodStatusContainerStateTerminated_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Pod_Status_Container_StateTerminated_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) FilterInputFields() *Pod_Status_Container_StateTerminated_FieldMask {
	result := &Pod_Status_Container_StateTerminated_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PodStatusContainerStateTerminated_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePodStatusContainerStateTerminated_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Pod_Status_Container_StateTerminated_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Pod_Status_Container_StateTerminated_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) AppendPath(path PodStatusContainerStateTerminated_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PodStatusContainerStateTerminated_FieldPath))
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) GetPaths() []PodStatusContainerStateTerminated_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePodStatusContainerStateTerminated_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) Set(target, source *Pod_Status_Container_StateTerminated) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Pod_Status_Container_StateTerminated), source.(*Pod_Status_Container_StateTerminated))
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) Project(source *Pod_Status_Container_StateTerminated) *Pod_Status_Container_StateTerminated {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Pod_Status_Container_StateTerminated{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PodStatusContainerStateTerminated_FieldTerminalPath:
			switch tp.selector {
			case PodStatusContainerStateTerminated_FieldPathSelectorExitCode:
				result.ExitCode = source.ExitCode
			case PodStatusContainerStateTerminated_FieldPathSelectorSignal:
				result.Signal = source.Signal
			case PodStatusContainerStateTerminated_FieldPathSelectorReason:
				result.Reason = source.Reason
			case PodStatusContainerStateTerminated_FieldPathSelectorMessage:
				result.Message = source.Message
			case PodStatusContainerStateTerminated_FieldPathSelectorStartedAt:
				result.StartedAt = source.StartedAt
			case PodStatusContainerStateTerminated_FieldPathSelectorFinishedAt:
				result.FinishedAt = source.FinishedAt
			case PodStatusContainerStateTerminated_FieldPathSelectorContainerId:
				result.ContainerId = source.ContainerId
			}
		}
	}
	return result
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Pod_Status_Container_StateTerminated))
}

func (fieldMask *Pod_Status_Container_StateTerminated_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type EnvFromSource_FieldMask struct {
	Paths []EnvFromSource_FieldPath
}

func FullEnvFromSource_FieldMask() *EnvFromSource_FieldMask {
	res := &EnvFromSource_FieldMask{}
	res.Paths = append(res.Paths, &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorPrefix})
	res.Paths = append(res.Paths, &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorConfigMapRef})
	res.Paths = append(res.Paths, &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorSecretRef})
	return res
}

func (fieldMask *EnvFromSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *EnvFromSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *EnvFromSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseEnvFromSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *EnvFromSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*EnvFromSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *EnvFromSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseEnvFromSource_FieldPath(raw)
	})
}

func (fieldMask *EnvFromSource_FieldMask) ProtoMessage() {}

func (fieldMask *EnvFromSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *EnvFromSource_FieldMask) Subtract(other *EnvFromSource_FieldMask) *EnvFromSource_FieldMask {
	result := &EnvFromSource_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[EnvFromSource_FieldPathSelector]gotenobject.FieldMask{
		EnvFromSource_FieldPathSelectorConfigMapRef: &ConfigMapEnvSource_FieldMask{},
		EnvFromSource_FieldPathSelectorSecretRef:    &SecretEnvSource_FieldMask{},
	}
	mySubMasks := map[EnvFromSource_FieldPathSelector]gotenobject.FieldMask{
		EnvFromSource_FieldPathSelectorConfigMapRef: &ConfigMapEnvSource_FieldMask{},
		EnvFromSource_FieldPathSelectorSecretRef:    &SecretEnvSource_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *EnvFromSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *EnvFromSource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*EnvFromSource_FieldTerminalPath); ok {
					switch tp.selector {
					case EnvFromSource_FieldPathSelectorConfigMapRef:
						mySubMasks[EnvFromSource_FieldPathSelectorConfigMapRef] = FullConfigMapEnvSource_FieldMask()
					case EnvFromSource_FieldPathSelectorSecretRef:
						mySubMasks[EnvFromSource_FieldPathSelectorSecretRef] = FullSecretEnvSource_FieldMask()
					}
				} else if tp, ok := path.(*EnvFromSource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &EnvFromSource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *EnvFromSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*EnvFromSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *EnvFromSource_FieldMask) FilterInputFields() *EnvFromSource_FieldMask {
	result := &EnvFromSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *EnvFromSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *EnvFromSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]EnvFromSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseEnvFromSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask EnvFromSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *EnvFromSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvFromSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask EnvFromSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *EnvFromSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvFromSource_FieldMask) AppendPath(path EnvFromSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *EnvFromSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(EnvFromSource_FieldPath))
}

func (fieldMask *EnvFromSource_FieldMask) GetPaths() []EnvFromSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *EnvFromSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *EnvFromSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseEnvFromSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *EnvFromSource_FieldMask) Set(target, source *EnvFromSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *EnvFromSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*EnvFromSource), source.(*EnvFromSource))
}

func (fieldMask *EnvFromSource_FieldMask) Project(source *EnvFromSource) *EnvFromSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &EnvFromSource{}
	configMapRefMask := &ConfigMapEnvSource_FieldMask{}
	wholeConfigMapRefAccepted := false
	secretRefMask := &SecretEnvSource_FieldMask{}
	wholeSecretRefAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *EnvFromSource_FieldTerminalPath:
			switch tp.selector {
			case EnvFromSource_FieldPathSelectorPrefix:
				result.Prefix = source.Prefix
			case EnvFromSource_FieldPathSelectorConfigMapRef:
				result.ConfigMapRef = source.ConfigMapRef
				wholeConfigMapRefAccepted = true
			case EnvFromSource_FieldPathSelectorSecretRef:
				result.SecretRef = source.SecretRef
				wholeSecretRefAccepted = true
			}
		case *EnvFromSource_FieldSubPath:
			switch tp.selector {
			case EnvFromSource_FieldPathSelectorConfigMapRef:
				configMapRefMask.AppendPath(tp.subPath.(ConfigMapEnvSource_FieldPath))
			case EnvFromSource_FieldPathSelectorSecretRef:
				secretRefMask.AppendPath(tp.subPath.(SecretEnvSource_FieldPath))
			}
		}
	}
	if wholeConfigMapRefAccepted == false && len(configMapRefMask.Paths) > 0 {
		result.ConfigMapRef = configMapRefMask.Project(source.GetConfigMapRef())
	}
	if wholeSecretRefAccepted == false && len(secretRefMask.Paths) > 0 {
		result.SecretRef = secretRefMask.Project(source.GetSecretRef())
	}
	return result
}

func (fieldMask *EnvFromSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*EnvFromSource))
}

func (fieldMask *EnvFromSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type EnvVar_FieldMask struct {
	Paths []EnvVar_FieldPath
}

func FullEnvVar_FieldMask() *EnvVar_FieldMask {
	res := &EnvVar_FieldMask{}
	res.Paths = append(res.Paths, &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorName})
	res.Paths = append(res.Paths, &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorValue})
	res.Paths = append(res.Paths, &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorValueFrom})
	return res
}

func (fieldMask *EnvVar_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *EnvVar_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *EnvVar_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseEnvVar_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *EnvVar_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*EnvVar_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *EnvVar_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseEnvVar_FieldPath(raw)
	})
}

func (fieldMask *EnvVar_FieldMask) ProtoMessage() {}

func (fieldMask *EnvVar_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *EnvVar_FieldMask) Subtract(other *EnvVar_FieldMask) *EnvVar_FieldMask {
	result := &EnvVar_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[EnvVar_FieldPathSelector]gotenobject.FieldMask{
		EnvVar_FieldPathSelectorValueFrom: &EnvVarSource_FieldMask{},
	}
	mySubMasks := map[EnvVar_FieldPathSelector]gotenobject.FieldMask{
		EnvVar_FieldPathSelectorValueFrom: &EnvVarSource_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *EnvVar_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *EnvVar_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*EnvVar_FieldTerminalPath); ok {
					switch tp.selector {
					case EnvVar_FieldPathSelectorValueFrom:
						mySubMasks[EnvVar_FieldPathSelectorValueFrom] = FullEnvVarSource_FieldMask()
					}
				} else if tp, ok := path.(*EnvVar_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &EnvVar_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *EnvVar_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*EnvVar_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *EnvVar_FieldMask) FilterInputFields() *EnvVar_FieldMask {
	result := &EnvVar_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *EnvVar_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *EnvVar_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]EnvVar_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseEnvVar_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask EnvVar_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *EnvVar_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvVar_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask EnvVar_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *EnvVar_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvVar_FieldMask) AppendPath(path EnvVar_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *EnvVar_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(EnvVar_FieldPath))
}

func (fieldMask *EnvVar_FieldMask) GetPaths() []EnvVar_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *EnvVar_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *EnvVar_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseEnvVar_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *EnvVar_FieldMask) Set(target, source *EnvVar) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *EnvVar_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*EnvVar), source.(*EnvVar))
}

func (fieldMask *EnvVar_FieldMask) Project(source *EnvVar) *EnvVar {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &EnvVar{}
	valueFromMask := &EnvVarSource_FieldMask{}
	wholeValueFromAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *EnvVar_FieldTerminalPath:
			switch tp.selector {
			case EnvVar_FieldPathSelectorName:
				result.Name = source.Name
			case EnvVar_FieldPathSelectorValue:
				result.Value = source.Value
			case EnvVar_FieldPathSelectorValueFrom:
				result.ValueFrom = source.ValueFrom
				wholeValueFromAccepted = true
			}
		case *EnvVar_FieldSubPath:
			switch tp.selector {
			case EnvVar_FieldPathSelectorValueFrom:
				valueFromMask.AppendPath(tp.subPath.(EnvVarSource_FieldPath))
			}
		}
	}
	if wholeValueFromAccepted == false && len(valueFromMask.Paths) > 0 {
		result.ValueFrom = valueFromMask.Project(source.GetValueFrom())
	}
	return result
}

func (fieldMask *EnvVar_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*EnvVar))
}

func (fieldMask *EnvVar_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConfigMapEnvSource_FieldMask struct {
	Paths []ConfigMapEnvSource_FieldPath
}

func FullConfigMapEnvSource_FieldMask() *ConfigMapEnvSource_FieldMask {
	res := &ConfigMapEnvSource_FieldMask{}
	res.Paths = append(res.Paths, &ConfigMapEnvSource_FieldTerminalPath{selector: ConfigMapEnvSource_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ConfigMapEnvSource_FieldTerminalPath{selector: ConfigMapEnvSource_FieldPathSelectorOptional})
	return res
}

func (fieldMask *ConfigMapEnvSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConfigMapEnvSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConfigMapEnvSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConfigMapEnvSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConfigMapEnvSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConfigMapEnvSource_FieldPath(raw)
	})
}

func (fieldMask *ConfigMapEnvSource_FieldMask) ProtoMessage() {}

func (fieldMask *ConfigMapEnvSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Subtract(other *ConfigMapEnvSource_FieldMask) *ConfigMapEnvSource_FieldMask {
	result := &ConfigMapEnvSource_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConfigMapEnvSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConfigMapEnvSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConfigMapEnvSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConfigMapEnvSource_FieldMask) FilterInputFields() *ConfigMapEnvSource_FieldMask {
	result := &ConfigMapEnvSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConfigMapEnvSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConfigMapEnvSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConfigMapEnvSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConfigMapEnvSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConfigMapEnvSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConfigMapEnvSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConfigMapEnvSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) AppendPath(path ConfigMapEnvSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConfigMapEnvSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConfigMapEnvSource_FieldPath))
}

func (fieldMask *ConfigMapEnvSource_FieldMask) GetPaths() []ConfigMapEnvSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConfigMapEnvSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConfigMapEnvSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConfigMapEnvSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Set(target, source *ConfigMapEnvSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConfigMapEnvSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConfigMapEnvSource), source.(*ConfigMapEnvSource))
}

func (fieldMask *ConfigMapEnvSource_FieldMask) Project(source *ConfigMapEnvSource) *ConfigMapEnvSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConfigMapEnvSource{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConfigMapEnvSource_FieldTerminalPath:
			switch tp.selector {
			case ConfigMapEnvSource_FieldPathSelectorName:
				result.Name = source.Name
			case ConfigMapEnvSource_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		}
	}
	return result
}

func (fieldMask *ConfigMapEnvSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConfigMapEnvSource))
}

func (fieldMask *ConfigMapEnvSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SecretEnvSource_FieldMask struct {
	Paths []SecretEnvSource_FieldPath
}

func FullSecretEnvSource_FieldMask() *SecretEnvSource_FieldMask {
	res := &SecretEnvSource_FieldMask{}
	res.Paths = append(res.Paths, &SecretEnvSource_FieldTerminalPath{selector: SecretEnvSource_FieldPathSelectorName})
	res.Paths = append(res.Paths, &SecretEnvSource_FieldTerminalPath{selector: SecretEnvSource_FieldPathSelectorOptional})
	return res
}

func (fieldMask *SecretEnvSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SecretEnvSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SecretEnvSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSecretEnvSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SecretEnvSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SecretEnvSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SecretEnvSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSecretEnvSource_FieldPath(raw)
	})
}

func (fieldMask *SecretEnvSource_FieldMask) ProtoMessage() {}

func (fieldMask *SecretEnvSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SecretEnvSource_FieldMask) Subtract(other *SecretEnvSource_FieldMask) *SecretEnvSource_FieldMask {
	result := &SecretEnvSource_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SecretEnvSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SecretEnvSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SecretEnvSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SecretEnvSource_FieldMask) FilterInputFields() *SecretEnvSource_FieldMask {
	result := &SecretEnvSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SecretEnvSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SecretEnvSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SecretEnvSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSecretEnvSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SecretEnvSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SecretEnvSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretEnvSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SecretEnvSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SecretEnvSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretEnvSource_FieldMask) AppendPath(path SecretEnvSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SecretEnvSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SecretEnvSource_FieldPath))
}

func (fieldMask *SecretEnvSource_FieldMask) GetPaths() []SecretEnvSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SecretEnvSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SecretEnvSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSecretEnvSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SecretEnvSource_FieldMask) Set(target, source *SecretEnvSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SecretEnvSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SecretEnvSource), source.(*SecretEnvSource))
}

func (fieldMask *SecretEnvSource_FieldMask) Project(source *SecretEnvSource) *SecretEnvSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SecretEnvSource{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SecretEnvSource_FieldTerminalPath:
			switch tp.selector {
			case SecretEnvSource_FieldPathSelectorName:
				result.Name = source.Name
			case SecretEnvSource_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		}
	}
	return result
}

func (fieldMask *SecretEnvSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SecretEnvSource))
}

func (fieldMask *SecretEnvSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type EnvVarSource_FieldMask struct {
	Paths []EnvVarSource_FieldPath
}

func FullEnvVarSource_FieldMask() *EnvVarSource_FieldMask {
	res := &EnvVarSource_FieldMask{}
	res.Paths = append(res.Paths, &EnvVarSource_FieldTerminalPath{selector: EnvVarSource_FieldPathSelectorConfigMapKeyRef})
	res.Paths = append(res.Paths, &EnvVarSource_FieldTerminalPath{selector: EnvVarSource_FieldPathSelectorSecretKeyRef})
	return res
}

func (fieldMask *EnvVarSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *EnvVarSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *EnvVarSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseEnvVarSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *EnvVarSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*EnvVarSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *EnvVarSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseEnvVarSource_FieldPath(raw)
	})
}

func (fieldMask *EnvVarSource_FieldMask) ProtoMessage() {}

func (fieldMask *EnvVarSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *EnvVarSource_FieldMask) Subtract(other *EnvVarSource_FieldMask) *EnvVarSource_FieldMask {
	result := &EnvVarSource_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[EnvVarSource_FieldPathSelector]gotenobject.FieldMask{
		EnvVarSource_FieldPathSelectorConfigMapKeyRef: &ConfigMapKeySelector_FieldMask{},
		EnvVarSource_FieldPathSelectorSecretKeyRef:    &SecretKeySelector_FieldMask{},
	}
	mySubMasks := map[EnvVarSource_FieldPathSelector]gotenobject.FieldMask{
		EnvVarSource_FieldPathSelectorConfigMapKeyRef: &ConfigMapKeySelector_FieldMask{},
		EnvVarSource_FieldPathSelectorSecretKeyRef:    &SecretKeySelector_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *EnvVarSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *EnvVarSource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*EnvVarSource_FieldTerminalPath); ok {
					switch tp.selector {
					case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
						mySubMasks[EnvVarSource_FieldPathSelectorConfigMapKeyRef] = FullConfigMapKeySelector_FieldMask()
					case EnvVarSource_FieldPathSelectorSecretKeyRef:
						mySubMasks[EnvVarSource_FieldPathSelectorSecretKeyRef] = FullSecretKeySelector_FieldMask()
					}
				} else if tp, ok := path.(*EnvVarSource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &EnvVarSource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *EnvVarSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*EnvVarSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *EnvVarSource_FieldMask) FilterInputFields() *EnvVarSource_FieldMask {
	result := &EnvVarSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *EnvVarSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *EnvVarSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]EnvVarSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseEnvVarSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask EnvVarSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *EnvVarSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvVarSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask EnvVarSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *EnvVarSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *EnvVarSource_FieldMask) AppendPath(path EnvVarSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *EnvVarSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(EnvVarSource_FieldPath))
}

func (fieldMask *EnvVarSource_FieldMask) GetPaths() []EnvVarSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *EnvVarSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *EnvVarSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseEnvVarSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *EnvVarSource_FieldMask) Set(target, source *EnvVarSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *EnvVarSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*EnvVarSource), source.(*EnvVarSource))
}

func (fieldMask *EnvVarSource_FieldMask) Project(source *EnvVarSource) *EnvVarSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &EnvVarSource{}
	configMapKeyRefMask := &ConfigMapKeySelector_FieldMask{}
	wholeConfigMapKeyRefAccepted := false
	secretKeyRefMask := &SecretKeySelector_FieldMask{}
	wholeSecretKeyRefAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *EnvVarSource_FieldTerminalPath:
			switch tp.selector {
			case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
				result.ConfigMapKeyRef = source.ConfigMapKeyRef
				wholeConfigMapKeyRefAccepted = true
			case EnvVarSource_FieldPathSelectorSecretKeyRef:
				result.SecretKeyRef = source.SecretKeyRef
				wholeSecretKeyRefAccepted = true
			}
		case *EnvVarSource_FieldSubPath:
			switch tp.selector {
			case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
				configMapKeyRefMask.AppendPath(tp.subPath.(ConfigMapKeySelector_FieldPath))
			case EnvVarSource_FieldPathSelectorSecretKeyRef:
				secretKeyRefMask.AppendPath(tp.subPath.(SecretKeySelector_FieldPath))
			}
		}
	}
	if wholeConfigMapKeyRefAccepted == false && len(configMapKeyRefMask.Paths) > 0 {
		result.ConfigMapKeyRef = configMapKeyRefMask.Project(source.GetConfigMapKeyRef())
	}
	if wholeSecretKeyRefAccepted == false && len(secretKeyRefMask.Paths) > 0 {
		result.SecretKeyRef = secretKeyRefMask.Project(source.GetSecretKeyRef())
	}
	return result
}

func (fieldMask *EnvVarSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*EnvVarSource))
}

func (fieldMask *EnvVarSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConfigMapKeySelector_FieldMask struct {
	Paths []ConfigMapKeySelector_FieldPath
}

func FullConfigMapKeySelector_FieldMask() *ConfigMapKeySelector_FieldMask {
	res := &ConfigMapKeySelector_FieldMask{}
	res.Paths = append(res.Paths, &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorOptional})
	return res
}

func (fieldMask *ConfigMapKeySelector_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConfigMapKeySelector_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConfigMapKeySelector_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConfigMapKeySelector_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConfigMapKeySelector_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConfigMapKeySelector_FieldPath(raw)
	})
}

func (fieldMask *ConfigMapKeySelector_FieldMask) ProtoMessage() {}

func (fieldMask *ConfigMapKeySelector_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Subtract(other *ConfigMapKeySelector_FieldMask) *ConfigMapKeySelector_FieldMask {
	result := &ConfigMapKeySelector_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConfigMapKeySelector_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConfigMapKeySelector_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConfigMapKeySelector_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConfigMapKeySelector_FieldMask) FilterInputFields() *ConfigMapKeySelector_FieldMask {
	result := &ConfigMapKeySelector_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConfigMapKeySelector_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConfigMapKeySelector_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConfigMapKeySelector_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConfigMapKeySelector_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConfigMapKeySelector_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConfigMapKeySelector_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConfigMapKeySelector_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) AppendPath(path ConfigMapKeySelector_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConfigMapKeySelector_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConfigMapKeySelector_FieldPath))
}

func (fieldMask *ConfigMapKeySelector_FieldMask) GetPaths() []ConfigMapKeySelector_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConfigMapKeySelector_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConfigMapKeySelector_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConfigMapKeySelector_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Set(target, source *ConfigMapKeySelector) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConfigMapKeySelector_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConfigMapKeySelector), source.(*ConfigMapKeySelector))
}

func (fieldMask *ConfigMapKeySelector_FieldMask) Project(source *ConfigMapKeySelector) *ConfigMapKeySelector {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConfigMapKeySelector{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConfigMapKeySelector_FieldTerminalPath:
			switch tp.selector {
			case ConfigMapKeySelector_FieldPathSelectorName:
				result.Name = source.Name
			case ConfigMapKeySelector_FieldPathSelectorKey:
				result.Key = source.Key
			case ConfigMapKeySelector_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		}
	}
	return result
}

func (fieldMask *ConfigMapKeySelector_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConfigMapKeySelector))
}

func (fieldMask *ConfigMapKeySelector_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SecretKeySelector_FieldMask struct {
	Paths []SecretKeySelector_FieldPath
}

func FullSecretKeySelector_FieldMask() *SecretKeySelector_FieldMask {
	res := &SecretKeySelector_FieldMask{}
	res.Paths = append(res.Paths, &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorName})
	res.Paths = append(res.Paths, &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorOptional})
	return res
}

func (fieldMask *SecretKeySelector_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SecretKeySelector_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SecretKeySelector_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSecretKeySelector_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SecretKeySelector_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SecretKeySelector_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SecretKeySelector_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSecretKeySelector_FieldPath(raw)
	})
}

func (fieldMask *SecretKeySelector_FieldMask) ProtoMessage() {}

func (fieldMask *SecretKeySelector_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SecretKeySelector_FieldMask) Subtract(other *SecretKeySelector_FieldMask) *SecretKeySelector_FieldMask {
	result := &SecretKeySelector_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SecretKeySelector_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SecretKeySelector_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SecretKeySelector_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SecretKeySelector_FieldMask) FilterInputFields() *SecretKeySelector_FieldMask {
	result := &SecretKeySelector_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SecretKeySelector_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SecretKeySelector_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SecretKeySelector_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSecretKeySelector_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SecretKeySelector_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SecretKeySelector_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretKeySelector_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SecretKeySelector_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SecretKeySelector_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretKeySelector_FieldMask) AppendPath(path SecretKeySelector_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SecretKeySelector_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SecretKeySelector_FieldPath))
}

func (fieldMask *SecretKeySelector_FieldMask) GetPaths() []SecretKeySelector_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SecretKeySelector_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SecretKeySelector_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSecretKeySelector_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SecretKeySelector_FieldMask) Set(target, source *SecretKeySelector) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SecretKeySelector_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SecretKeySelector), source.(*SecretKeySelector))
}

func (fieldMask *SecretKeySelector_FieldMask) Project(source *SecretKeySelector) *SecretKeySelector {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SecretKeySelector{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SecretKeySelector_FieldTerminalPath:
			switch tp.selector {
			case SecretKeySelector_FieldPathSelectorName:
				result.Name = source.Name
			case SecretKeySelector_FieldPathSelectorKey:
				result.Key = source.Key
			case SecretKeySelector_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		}
	}
	return result
}

func (fieldMask *SecretKeySelector_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SecretKeySelector))
}

func (fieldMask *SecretKeySelector_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type LocalObjectReferenceSecret_FieldMask struct {
	Paths []LocalObjectReferenceSecret_FieldPath
}

func FullLocalObjectReferenceSecret_FieldMask() *LocalObjectReferenceSecret_FieldMask {
	res := &LocalObjectReferenceSecret_FieldMask{}
	res.Paths = append(res.Paths, &LocalObjectReferenceSecret_FieldTerminalPath{selector: LocalObjectReferenceSecret_FieldPathSelectorName})
	return res
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *LocalObjectReferenceSecret_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseLocalObjectReferenceSecret_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LocalObjectReferenceSecret_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLocalObjectReferenceSecret_FieldPath(raw)
	})
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) ProtoMessage() {}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Subtract(other *LocalObjectReferenceSecret_FieldMask) *LocalObjectReferenceSecret_FieldMask {
	result := &LocalObjectReferenceSecret_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LocalObjectReferenceSecret_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LocalObjectReferenceSecret_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LocalObjectReferenceSecret_FieldMask) FilterInputFields() *LocalObjectReferenceSecret_FieldMask {
	result := &LocalObjectReferenceSecret_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LocalObjectReferenceSecret_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LocalObjectReferenceSecret_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLocalObjectReferenceSecret_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LocalObjectReferenceSecret_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LocalObjectReferenceSecret_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) AppendPath(path LocalObjectReferenceSecret_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LocalObjectReferenceSecret_FieldPath))
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) GetPaths() []LocalObjectReferenceSecret_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLocalObjectReferenceSecret_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Set(target, source *LocalObjectReferenceSecret) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LocalObjectReferenceSecret), source.(*LocalObjectReferenceSecret))
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) Project(source *LocalObjectReferenceSecret) *LocalObjectReferenceSecret {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LocalObjectReferenceSecret{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LocalObjectReferenceSecret_FieldTerminalPath:
			switch tp.selector {
			case LocalObjectReferenceSecret_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LocalObjectReferenceSecret))
}

func (fieldMask *LocalObjectReferenceSecret_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SecurityContext_FieldMask struct {
	Paths []SecurityContext_FieldPath
}

func FullSecurityContext_FieldMask() *SecurityContext_FieldMask {
	res := &SecurityContext_FieldMask{}
	res.Paths = append(res.Paths, &SecurityContext_FieldTerminalPath{selector: SecurityContext_FieldPathSelectorPrivileged})
	return res
}

func (fieldMask *SecurityContext_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SecurityContext_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SecurityContext_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSecurityContext_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SecurityContext_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SecurityContext_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SecurityContext_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSecurityContext_FieldPath(raw)
	})
}

func (fieldMask *SecurityContext_FieldMask) ProtoMessage() {}

func (fieldMask *SecurityContext_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SecurityContext_FieldMask) Subtract(other *SecurityContext_FieldMask) *SecurityContext_FieldMask {
	result := &SecurityContext_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SecurityContext_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SecurityContext_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SecurityContext_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SecurityContext_FieldMask) FilterInputFields() *SecurityContext_FieldMask {
	result := &SecurityContext_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SecurityContext_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SecurityContext_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SecurityContext_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSecurityContext_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SecurityContext_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SecurityContext_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecurityContext_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SecurityContext_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SecurityContext_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecurityContext_FieldMask) AppendPath(path SecurityContext_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SecurityContext_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SecurityContext_FieldPath))
}

func (fieldMask *SecurityContext_FieldMask) GetPaths() []SecurityContext_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SecurityContext_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SecurityContext_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSecurityContext_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SecurityContext_FieldMask) Set(target, source *SecurityContext) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SecurityContext_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SecurityContext), source.(*SecurityContext))
}

func (fieldMask *SecurityContext_FieldMask) Project(source *SecurityContext) *SecurityContext {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SecurityContext{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SecurityContext_FieldTerminalPath:
			switch tp.selector {
			case SecurityContext_FieldPathSelectorPrivileged:
				result.Privileged = source.Privileged
			}
		}
	}
	return result
}

func (fieldMask *SecurityContext_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SecurityContext))
}

func (fieldMask *SecurityContext_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Volume_FieldMask struct {
	Paths []Volume_FieldPath
}

func FullVolume_FieldMask() *Volume_FieldMask {
	res := &Volume_FieldMask{}
	res.Paths = append(res.Paths, &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorHostPath})
	res.Paths = append(res.Paths, &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorSecret})
	res.Paths = append(res.Paths, &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorConfigMap})
	return res
}

func (fieldMask *Volume_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Volume_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Volume_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseVolume_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Volume_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Volume_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Volume_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseVolume_FieldPath(raw)
	})
}

func (fieldMask *Volume_FieldMask) ProtoMessage() {}

func (fieldMask *Volume_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Volume_FieldMask) Subtract(other *Volume_FieldMask) *Volume_FieldMask {
	result := &Volume_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[Volume_FieldPathSelector]gotenobject.FieldMask{
		Volume_FieldPathSelectorHostPath:  &HostPathVolumeSource_FieldMask{},
		Volume_FieldPathSelectorSecret:    &SecretVolumeSource_FieldMask{},
		Volume_FieldPathSelectorConfigMap: &ConfigMapVolumeSource_FieldMask{},
	}
	mySubMasks := map[Volume_FieldPathSelector]gotenobject.FieldMask{
		Volume_FieldPathSelectorHostPath:  &HostPathVolumeSource_FieldMask{},
		Volume_FieldPathSelectorSecret:    &SecretVolumeSource_FieldMask{},
		Volume_FieldPathSelectorConfigMap: &ConfigMapVolumeSource_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Volume_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Volume_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Volume_FieldTerminalPath); ok {
					switch tp.selector {
					case Volume_FieldPathSelectorHostPath:
						mySubMasks[Volume_FieldPathSelectorHostPath] = FullHostPathVolumeSource_FieldMask()
					case Volume_FieldPathSelectorSecret:
						mySubMasks[Volume_FieldPathSelectorSecret] = FullSecretVolumeSource_FieldMask()
					case Volume_FieldPathSelectorConfigMap:
						mySubMasks[Volume_FieldPathSelectorConfigMap] = FullConfigMapVolumeSource_FieldMask()
					}
				} else if tp, ok := path.(*Volume_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Volume_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Volume_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Volume_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Volume_FieldMask) FilterInputFields() *Volume_FieldMask {
	result := &Volume_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Volume_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Volume_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Volume_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseVolume_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Volume_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Volume_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Volume_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Volume_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Volume_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Volume_FieldMask) AppendPath(path Volume_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Volume_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Volume_FieldPath))
}

func (fieldMask *Volume_FieldMask) GetPaths() []Volume_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Volume_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Volume_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseVolume_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Volume_FieldMask) Set(target, source *Volume) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Volume_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Volume), source.(*Volume))
}

func (fieldMask *Volume_FieldMask) Project(source *Volume) *Volume {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Volume{}
	hostPathMask := &HostPathVolumeSource_FieldMask{}
	wholeHostPathAccepted := false
	secretMask := &SecretVolumeSource_FieldMask{}
	wholeSecretAccepted := false
	configMapMask := &ConfigMapVolumeSource_FieldMask{}
	wholeConfigMapAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Volume_FieldTerminalPath:
			switch tp.selector {
			case Volume_FieldPathSelectorName:
				result.Name = source.Name
			case Volume_FieldPathSelectorHostPath:
				result.HostPath = source.HostPath
				wholeHostPathAccepted = true
			case Volume_FieldPathSelectorSecret:
				result.Secret = source.Secret
				wholeSecretAccepted = true
			case Volume_FieldPathSelectorConfigMap:
				result.ConfigMap = source.ConfigMap
				wholeConfigMapAccepted = true
			}
		case *Volume_FieldSubPath:
			switch tp.selector {
			case Volume_FieldPathSelectorHostPath:
				hostPathMask.AppendPath(tp.subPath.(HostPathVolumeSource_FieldPath))
			case Volume_FieldPathSelectorSecret:
				secretMask.AppendPath(tp.subPath.(SecretVolumeSource_FieldPath))
			case Volume_FieldPathSelectorConfigMap:
				configMapMask.AppendPath(tp.subPath.(ConfigMapVolumeSource_FieldPath))
			}
		}
	}
	if wholeHostPathAccepted == false && len(hostPathMask.Paths) > 0 {
		result.HostPath = hostPathMask.Project(source.GetHostPath())
	}
	if wholeSecretAccepted == false && len(secretMask.Paths) > 0 {
		result.Secret = secretMask.Project(source.GetSecret())
	}
	if wholeConfigMapAccepted == false && len(configMapMask.Paths) > 0 {
		result.ConfigMap = configMapMask.Project(source.GetConfigMap())
	}
	return result
}

func (fieldMask *Volume_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Volume))
}

func (fieldMask *Volume_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type VolumeMount_FieldMask struct {
	Paths []VolumeMount_FieldPath
}

func FullVolumeMount_FieldMask() *VolumeMount_FieldMask {
	res := &VolumeMount_FieldMask{}
	res.Paths = append(res.Paths, &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorName})
	res.Paths = append(res.Paths, &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorReadOnly})
	res.Paths = append(res.Paths, &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorMountPath})
	res.Paths = append(res.Paths, &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorSubPath})
	return res
}

func (fieldMask *VolumeMount_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *VolumeMount_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *VolumeMount_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseVolumeMount_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *VolumeMount_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*VolumeMount_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *VolumeMount_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseVolumeMount_FieldPath(raw)
	})
}

func (fieldMask *VolumeMount_FieldMask) ProtoMessage() {}

func (fieldMask *VolumeMount_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *VolumeMount_FieldMask) Subtract(other *VolumeMount_FieldMask) *VolumeMount_FieldMask {
	result := &VolumeMount_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *VolumeMount_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *VolumeMount_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*VolumeMount_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *VolumeMount_FieldMask) FilterInputFields() *VolumeMount_FieldMask {
	result := &VolumeMount_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *VolumeMount_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *VolumeMount_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]VolumeMount_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseVolumeMount_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask VolumeMount_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *VolumeMount_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *VolumeMount_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask VolumeMount_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *VolumeMount_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *VolumeMount_FieldMask) AppendPath(path VolumeMount_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *VolumeMount_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(VolumeMount_FieldPath))
}

func (fieldMask *VolumeMount_FieldMask) GetPaths() []VolumeMount_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *VolumeMount_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *VolumeMount_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseVolumeMount_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *VolumeMount_FieldMask) Set(target, source *VolumeMount) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *VolumeMount_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*VolumeMount), source.(*VolumeMount))
}

func (fieldMask *VolumeMount_FieldMask) Project(source *VolumeMount) *VolumeMount {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &VolumeMount{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *VolumeMount_FieldTerminalPath:
			switch tp.selector {
			case VolumeMount_FieldPathSelectorName:
				result.Name = source.Name
			case VolumeMount_FieldPathSelectorReadOnly:
				result.ReadOnly = source.ReadOnly
			case VolumeMount_FieldPathSelectorMountPath:
				result.MountPath = source.MountPath
			case VolumeMount_FieldPathSelectorSubPath:
				result.SubPath = source.SubPath
			}
		}
	}
	return result
}

func (fieldMask *VolumeMount_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*VolumeMount))
}

func (fieldMask *VolumeMount_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type HostPathVolumeSource_FieldMask struct {
	Paths []HostPathVolumeSource_FieldPath
}

func FullHostPathVolumeSource_FieldMask() *HostPathVolumeSource_FieldMask {
	res := &HostPathVolumeSource_FieldMask{}
	res.Paths = append(res.Paths, &HostPathVolumeSource_FieldTerminalPath{selector: HostPathVolumeSource_FieldPathSelectorPath})
	res.Paths = append(res.Paths, &HostPathVolumeSource_FieldTerminalPath{selector: HostPathVolumeSource_FieldPathSelectorType})
	return res
}

func (fieldMask *HostPathVolumeSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *HostPathVolumeSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseHostPathVolumeSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*HostPathVolumeSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *HostPathVolumeSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseHostPathVolumeSource_FieldPath(raw)
	})
}

func (fieldMask *HostPathVolumeSource_FieldMask) ProtoMessage() {}

func (fieldMask *HostPathVolumeSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *HostPathVolumeSource_FieldMask) Subtract(other *HostPathVolumeSource_FieldMask) *HostPathVolumeSource_FieldMask {
	result := &HostPathVolumeSource_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *HostPathVolumeSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *HostPathVolumeSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*HostPathVolumeSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *HostPathVolumeSource_FieldMask) FilterInputFields() *HostPathVolumeSource_FieldMask {
	result := &HostPathVolumeSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *HostPathVolumeSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *HostPathVolumeSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]HostPathVolumeSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseHostPathVolumeSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask HostPathVolumeSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *HostPathVolumeSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask HostPathVolumeSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *HostPathVolumeSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) AppendPath(path HostPathVolumeSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *HostPathVolumeSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(HostPathVolumeSource_FieldPath))
}

func (fieldMask *HostPathVolumeSource_FieldMask) GetPaths() []HostPathVolumeSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *HostPathVolumeSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *HostPathVolumeSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseHostPathVolumeSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *HostPathVolumeSource_FieldMask) Set(target, source *HostPathVolumeSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *HostPathVolumeSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*HostPathVolumeSource), source.(*HostPathVolumeSource))
}

func (fieldMask *HostPathVolumeSource_FieldMask) Project(source *HostPathVolumeSource) *HostPathVolumeSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &HostPathVolumeSource{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *HostPathVolumeSource_FieldTerminalPath:
			switch tp.selector {
			case HostPathVolumeSource_FieldPathSelectorPath:
				result.Path = source.Path
			case HostPathVolumeSource_FieldPathSelectorType:
				result.Type = source.Type
			}
		}
	}
	return result
}

func (fieldMask *HostPathVolumeSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*HostPathVolumeSource))
}

func (fieldMask *HostPathVolumeSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type SecretVolumeSource_FieldMask struct {
	Paths []SecretVolumeSource_FieldPath
}

func FullSecretVolumeSource_FieldMask() *SecretVolumeSource_FieldMask {
	res := &SecretVolumeSource_FieldMask{}
	res.Paths = append(res.Paths, &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorSecretName})
	res.Paths = append(res.Paths, &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorItems})
	res.Paths = append(res.Paths, &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorDefaultMode})
	res.Paths = append(res.Paths, &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorOptional})
	return res
}

func (fieldMask *SecretVolumeSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *SecretVolumeSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *SecretVolumeSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseSecretVolumeSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *SecretVolumeSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*SecretVolumeSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *SecretVolumeSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseSecretVolumeSource_FieldPath(raw)
	})
}

func (fieldMask *SecretVolumeSource_FieldMask) ProtoMessage() {}

func (fieldMask *SecretVolumeSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *SecretVolumeSource_FieldMask) Subtract(other *SecretVolumeSource_FieldMask) *SecretVolumeSource_FieldMask {
	result := &SecretVolumeSource_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[SecretVolumeSource_FieldPathSelector]gotenobject.FieldMask{
		SecretVolumeSource_FieldPathSelectorItems: &KeyToPath_FieldMask{},
	}
	mySubMasks := map[SecretVolumeSource_FieldPathSelector]gotenobject.FieldMask{
		SecretVolumeSource_FieldPathSelectorItems: &KeyToPath_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *SecretVolumeSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *SecretVolumeSource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*SecretVolumeSource_FieldTerminalPath); ok {
					switch tp.selector {
					case SecretVolumeSource_FieldPathSelectorItems:
						mySubMasks[SecretVolumeSource_FieldPathSelectorItems] = FullKeyToPath_FieldMask()
					}
				} else if tp, ok := path.(*SecretVolumeSource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &SecretVolumeSource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *SecretVolumeSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*SecretVolumeSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *SecretVolumeSource_FieldMask) FilterInputFields() *SecretVolumeSource_FieldMask {
	result := &SecretVolumeSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *SecretVolumeSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *SecretVolumeSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]SecretVolumeSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseSecretVolumeSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask SecretVolumeSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *SecretVolumeSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretVolumeSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask SecretVolumeSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *SecretVolumeSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *SecretVolumeSource_FieldMask) AppendPath(path SecretVolumeSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *SecretVolumeSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(SecretVolumeSource_FieldPath))
}

func (fieldMask *SecretVolumeSource_FieldMask) GetPaths() []SecretVolumeSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *SecretVolumeSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *SecretVolumeSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseSecretVolumeSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *SecretVolumeSource_FieldMask) Set(target, source *SecretVolumeSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *SecretVolumeSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*SecretVolumeSource), source.(*SecretVolumeSource))
}

func (fieldMask *SecretVolumeSource_FieldMask) Project(source *SecretVolumeSource) *SecretVolumeSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &SecretVolumeSource{}
	itemsMask := &KeyToPath_FieldMask{}
	wholeItemsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *SecretVolumeSource_FieldTerminalPath:
			switch tp.selector {
			case SecretVolumeSource_FieldPathSelectorSecretName:
				result.SecretName = source.SecretName
			case SecretVolumeSource_FieldPathSelectorItems:
				result.Items = source.Items
				wholeItemsAccepted = true
			case SecretVolumeSource_FieldPathSelectorDefaultMode:
				result.DefaultMode = source.DefaultMode
			case SecretVolumeSource_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		case *SecretVolumeSource_FieldSubPath:
			switch tp.selector {
			case SecretVolumeSource_FieldPathSelectorItems:
				itemsMask.AppendPath(tp.subPath.(KeyToPath_FieldPath))
			}
		}
	}
	if wholeItemsAccepted == false && len(itemsMask.Paths) > 0 {
		for _, sourceItem := range source.GetItems() {
			result.Items = append(result.Items, itemsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *SecretVolumeSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*SecretVolumeSource))
}

func (fieldMask *SecretVolumeSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type KeyToPath_FieldMask struct {
	Paths []KeyToPath_FieldPath
}

func FullKeyToPath_FieldMask() *KeyToPath_FieldMask {
	res := &KeyToPath_FieldMask{}
	res.Paths = append(res.Paths, &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorPath})
	res.Paths = append(res.Paths, &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorMode})
	return res
}

func (fieldMask *KeyToPath_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *KeyToPath_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *KeyToPath_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseKeyToPath_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *KeyToPath_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*KeyToPath_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *KeyToPath_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseKeyToPath_FieldPath(raw)
	})
}

func (fieldMask *KeyToPath_FieldMask) ProtoMessage() {}

func (fieldMask *KeyToPath_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *KeyToPath_FieldMask) Subtract(other *KeyToPath_FieldMask) *KeyToPath_FieldMask {
	result := &KeyToPath_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *KeyToPath_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *KeyToPath_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*KeyToPath_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *KeyToPath_FieldMask) FilterInputFields() *KeyToPath_FieldMask {
	result := &KeyToPath_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *KeyToPath_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *KeyToPath_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]KeyToPath_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseKeyToPath_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask KeyToPath_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *KeyToPath_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *KeyToPath_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask KeyToPath_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *KeyToPath_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *KeyToPath_FieldMask) AppendPath(path KeyToPath_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *KeyToPath_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(KeyToPath_FieldPath))
}

func (fieldMask *KeyToPath_FieldMask) GetPaths() []KeyToPath_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *KeyToPath_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *KeyToPath_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseKeyToPath_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *KeyToPath_FieldMask) Set(target, source *KeyToPath) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *KeyToPath_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*KeyToPath), source.(*KeyToPath))
}

func (fieldMask *KeyToPath_FieldMask) Project(source *KeyToPath) *KeyToPath {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &KeyToPath{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *KeyToPath_FieldTerminalPath:
			switch tp.selector {
			case KeyToPath_FieldPathSelectorKey:
				result.Key = source.Key
			case KeyToPath_FieldPathSelectorPath:
				result.Path = source.Path
			case KeyToPath_FieldPathSelectorMode:
				result.Mode = source.Mode
			}
		}
	}
	return result
}

func (fieldMask *KeyToPath_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*KeyToPath))
}

func (fieldMask *KeyToPath_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConfigMapVolumeSource_FieldMask struct {
	Paths []ConfigMapVolumeSource_FieldPath
}

func FullConfigMapVolumeSource_FieldMask() *ConfigMapVolumeSource_FieldMask {
	res := &ConfigMapVolumeSource_FieldMask{}
	res.Paths = append(res.Paths, &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorItems})
	res.Paths = append(res.Paths, &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorDefaultMode})
	res.Paths = append(res.Paths, &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorOptional})
	return res
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConfigMapVolumeSource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConfigMapVolumeSource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConfigMapVolumeSource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConfigMapVolumeSource_FieldPath(raw)
	})
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) ProtoMessage() {}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Subtract(other *ConfigMapVolumeSource_FieldMask) *ConfigMapVolumeSource_FieldMask {
	result := &ConfigMapVolumeSource_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[ConfigMapVolumeSource_FieldPathSelector]gotenobject.FieldMask{
		ConfigMapVolumeSource_FieldPathSelectorItems: &KeyToPath_FieldMask{},
	}
	mySubMasks := map[ConfigMapVolumeSource_FieldPathSelector]gotenobject.FieldMask{
		ConfigMapVolumeSource_FieldPathSelectorItems: &KeyToPath_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConfigMapVolumeSource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConfigMapVolumeSource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConfigMapVolumeSource_FieldTerminalPath); ok {
					switch tp.selector {
					case ConfigMapVolumeSource_FieldPathSelectorItems:
						mySubMasks[ConfigMapVolumeSource_FieldPathSelectorItems] = FullKeyToPath_FieldMask()
					}
				} else if tp, ok := path.(*ConfigMapVolumeSource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConfigMapVolumeSource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConfigMapVolumeSource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConfigMapVolumeSource_FieldMask) FilterInputFields() *ConfigMapVolumeSource_FieldMask {
	result := &ConfigMapVolumeSource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConfigMapVolumeSource_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConfigMapVolumeSource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConfigMapVolumeSource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConfigMapVolumeSource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConfigMapVolumeSource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) AppendPath(path ConfigMapVolumeSource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConfigMapVolumeSource_FieldPath))
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) GetPaths() []ConfigMapVolumeSource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConfigMapVolumeSource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Set(target, source *ConfigMapVolumeSource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConfigMapVolumeSource), source.(*ConfigMapVolumeSource))
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) Project(source *ConfigMapVolumeSource) *ConfigMapVolumeSource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConfigMapVolumeSource{}
	itemsMask := &KeyToPath_FieldMask{}
	wholeItemsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConfigMapVolumeSource_FieldTerminalPath:
			switch tp.selector {
			case ConfigMapVolumeSource_FieldPathSelectorName:
				result.Name = source.Name
			case ConfigMapVolumeSource_FieldPathSelectorItems:
				result.Items = source.Items
				wholeItemsAccepted = true
			case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
				result.DefaultMode = source.DefaultMode
			case ConfigMapVolumeSource_FieldPathSelectorOptional:
				result.Optional = source.Optional
			}
		case *ConfigMapVolumeSource_FieldSubPath:
			switch tp.selector {
			case ConfigMapVolumeSource_FieldPathSelectorItems:
				itemsMask.AppendPath(tp.subPath.(KeyToPath_FieldPath))
			}
		}
	}
	if wholeItemsAccepted == false && len(itemsMask.Paths) > 0 {
		for _, sourceItem := range source.GetItems() {
			result.Items = append(result.Items, itemsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConfigMapVolumeSource))
}

func (fieldMask *ConfigMapVolumeSource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
