// Code generated by protoc-gen-goten-object
// File: edgelq/applications/proto/v1/common.proto
// DO NOT EDIT!!!

package common

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
	"github.com/cloudwan/goten-sdk/runtime/strcase"
)

// proto imports
import (
	devices_device "github.com/cloudwan/edgelq-sdk/devices/resources/v1/device"
	secrets_secret "github.com/cloudwan/edgelq-sdk/secrets/resources/v1/secret"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &devices_device.Device{}
	_ = &secrets_secret.Secret{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type PodSpec_FieldPath interface {
	gotenobject.FieldPath
	Selector() PodSpec_FieldPathSelector
	Get(source *PodSpec) []interface{}
	GetSingle(source *PodSpec) (interface{}, bool)
	ClearValue(item *PodSpec)

	// Those methods build corresponding PodSpec_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) PodSpec_FieldPathValue
	WithIArrayOfValues(values interface{}) PodSpec_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) PodSpec_FieldPathArrayItemValue
}

type PodSpec_FieldPathSelector int32

const (
	PodSpec_FieldPathSelectorNode             PodSpec_FieldPathSelector = 0
	PodSpec_FieldPathSelectorContainers       PodSpec_FieldPathSelector = 1
	PodSpec_FieldPathSelectorHostNetwork      PodSpec_FieldPathSelector = 2
	PodSpec_FieldPathSelectorRestartPolicy    PodSpec_FieldPathSelector = 3
	PodSpec_FieldPathSelectorImagePullSecrets PodSpec_FieldPathSelector = 4
	PodSpec_FieldPathSelectorVolumes          PodSpec_FieldPathSelector = 5
	PodSpec_FieldPathSelectorCompose          PodSpec_FieldPathSelector = 6
	PodSpec_FieldPathSelectorHostVolumeMounts PodSpec_FieldPathSelector = 7
)

func (s PodSpec_FieldPathSelector) String() string {
	switch s {
	case PodSpec_FieldPathSelectorNode:
		return "node"
	case PodSpec_FieldPathSelectorContainers:
		return "containers"
	case PodSpec_FieldPathSelectorHostNetwork:
		return "host_network"
	case PodSpec_FieldPathSelectorRestartPolicy:
		return "restart_policy"
	case PodSpec_FieldPathSelectorImagePullSecrets:
		return "image_pull_secrets"
	case PodSpec_FieldPathSelectorVolumes:
		return "volumes"
	case PodSpec_FieldPathSelectorCompose:
		return "compose"
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		return "host_volume_mounts"
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", s))
	}
}

func BuildPodSpec_FieldPath(fp gotenobject.RawFieldPath) (PodSpec_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object PodSpec")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "node":
			return &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorNode}, nil
		case "containers":
			return &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorContainers}, nil
		case "host_network", "hostNetwork", "host-network":
			return &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorHostNetwork}, nil
		case "restart_policy", "restartPolicy", "restart-policy":
			return &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorRestartPolicy}, nil
		case "image_pull_secrets", "imagePullSecrets", "image-pull-secrets":
			return &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorImagePullSecrets}, nil
		case "volumes":
			return &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorVolumes}, nil
		case "compose":
			return &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorCompose}, nil
		case "host_volume_mounts", "hostVolumeMounts", "host-volume-mounts":
			return &PodSpec_FieldTerminalPath{selector: PodSpec_FieldPathSelectorHostVolumeMounts}, nil
		}
	} else {
		switch fp[0] {
		case "containers":
			if subpath, err := BuildPodSpecContainer_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpec_FieldSubPath{selector: PodSpec_FieldPathSelectorContainers, subPath: subpath}, nil
			}
		case "image_pull_secrets", "imagePullSecrets", "image-pull-secrets":
			if subpath, err := BuildLocalObjectReferenceSecret_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpec_FieldSubPath{selector: PodSpec_FieldPathSelectorImagePullSecrets, subPath: subpath}, nil
			}
		case "volumes":
			if subpath, err := BuildVolume_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpec_FieldSubPath{selector: PodSpec_FieldPathSelectorVolumes, subPath: subpath}, nil
			}
		case "host_volume_mounts", "hostVolumeMounts", "host-volume-mounts":
			if subpath, err := BuildVolumeMount_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpec_FieldSubPath{selector: PodSpec_FieldPathSelectorHostVolumeMounts, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object PodSpec", fp)
}

func ParsePodSpec_FieldPath(rawField string) (PodSpec_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildPodSpec_FieldPath(fp)
}

func MustParsePodSpec_FieldPath(rawField string) PodSpec_FieldPath {
	fp, err := ParsePodSpec_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type PodSpec_FieldTerminalPath struct {
	selector PodSpec_FieldPathSelector
}

var _ PodSpec_FieldPath = (*PodSpec_FieldTerminalPath)(nil)

func (fp *PodSpec_FieldTerminalPath) Selector() PodSpec_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *PodSpec_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *PodSpec_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source PodSpec
func (fp *PodSpec_FieldTerminalPath) Get(source *PodSpec) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case PodSpec_FieldPathSelectorNode:
			if source.Node != nil {
				values = append(values, source.Node)
			}
		case PodSpec_FieldPathSelectorContainers:
			for _, value := range source.GetContainers() {
				values = append(values, value)
			}
		case PodSpec_FieldPathSelectorHostNetwork:
			values = append(values, source.HostNetwork)
		case PodSpec_FieldPathSelectorRestartPolicy:
			values = append(values, source.RestartPolicy)
		case PodSpec_FieldPathSelectorImagePullSecrets:
			for _, value := range source.GetImagePullSecrets() {
				values = append(values, value)
			}
		case PodSpec_FieldPathSelectorVolumes:
			for _, value := range source.GetVolumes() {
				values = append(values, value)
			}
		case PodSpec_FieldPathSelectorCompose:
			values = append(values, source.Compose)
		case PodSpec_FieldPathSelectorHostVolumeMounts:
			for _, value := range source.GetHostVolumeMounts() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fp.selector))
		}
	}
	return
}

func (fp *PodSpec_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*PodSpec))
}

// GetSingle returns value pointed by specific field of from source PodSpec
func (fp *PodSpec_FieldTerminalPath) GetSingle(source *PodSpec) (interface{}, bool) {
	switch fp.selector {
	case PodSpec_FieldPathSelectorNode:
		res := source.GetNode()
		return res, res != nil
	case PodSpec_FieldPathSelectorContainers:
		res := source.GetContainers()
		return res, res != nil
	case PodSpec_FieldPathSelectorHostNetwork:
		return source.GetHostNetwork(), source != nil
	case PodSpec_FieldPathSelectorRestartPolicy:
		return source.GetRestartPolicy(), source != nil
	case PodSpec_FieldPathSelectorImagePullSecrets:
		res := source.GetImagePullSecrets()
		return res, res != nil
	case PodSpec_FieldPathSelectorVolumes:
		res := source.GetVolumes()
		return res, res != nil
	case PodSpec_FieldPathSelectorCompose:
		return source.GetCompose(), source != nil
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		res := source.GetHostVolumeMounts()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fp.selector))
	}
}

func (fp *PodSpec_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*PodSpec))
}

// GetDefault returns a default value of the field type
func (fp *PodSpec_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case PodSpec_FieldPathSelectorNode:
		return (*devices_device.Reference)(nil)
	case PodSpec_FieldPathSelectorContainers:
		return ([]*PodSpec_Container)(nil)
	case PodSpec_FieldPathSelectorHostNetwork:
		return false
	case PodSpec_FieldPathSelectorRestartPolicy:
		return PodSpec_RESTART_POLICY_UNSPECIFIED
	case PodSpec_FieldPathSelectorImagePullSecrets:
		return ([]*LocalObjectReferenceSecret)(nil)
	case PodSpec_FieldPathSelectorVolumes:
		return ([]*Volume)(nil)
	case PodSpec_FieldPathSelectorCompose:
		return ""
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		return ([]*VolumeMount)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fp.selector))
	}
}

func (fp *PodSpec_FieldTerminalPath) ClearValue(item *PodSpec) {
	if item != nil {
		switch fp.selector {
		case PodSpec_FieldPathSelectorNode:
			item.Node = nil
		case PodSpec_FieldPathSelectorContainers:
			item.Containers = nil
		case PodSpec_FieldPathSelectorHostNetwork:
			item.HostNetwork = false
		case PodSpec_FieldPathSelectorRestartPolicy:
			item.RestartPolicy = PodSpec_RESTART_POLICY_UNSPECIFIED
		case PodSpec_FieldPathSelectorImagePullSecrets:
			item.ImagePullSecrets = nil
		case PodSpec_FieldPathSelectorVolumes:
			item.Volumes = nil
		case PodSpec_FieldPathSelectorCompose:
			item.Compose = ""
		case PodSpec_FieldPathSelectorHostVolumeMounts:
			item.HostVolumeMounts = nil
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fp.selector))
		}
	}
}

func (fp *PodSpec_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*PodSpec))
}

// IsLeaf - whether field path is holds simple value
func (fp *PodSpec_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == PodSpec_FieldPathSelectorNode ||
		fp.selector == PodSpec_FieldPathSelectorHostNetwork ||
		fp.selector == PodSpec_FieldPathSelectorRestartPolicy ||
		fp.selector == PodSpec_FieldPathSelectorCompose
}

func (fp *PodSpec_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *PodSpec_FieldTerminalPath) WithIValue(value interface{}) PodSpec_FieldPathValue {
	switch fp.selector {
	case PodSpec_FieldPathSelectorNode:
		return &PodSpec_FieldTerminalPathValue{PodSpec_FieldTerminalPath: *fp, value: value.(*devices_device.Reference)}
	case PodSpec_FieldPathSelectorContainers:
		return &PodSpec_FieldTerminalPathValue{PodSpec_FieldTerminalPath: *fp, value: value.([]*PodSpec_Container)}
	case PodSpec_FieldPathSelectorHostNetwork:
		return &PodSpec_FieldTerminalPathValue{PodSpec_FieldTerminalPath: *fp, value: value.(bool)}
	case PodSpec_FieldPathSelectorRestartPolicy:
		return &PodSpec_FieldTerminalPathValue{PodSpec_FieldTerminalPath: *fp, value: value.(PodSpec_RestartPolicy)}
	case PodSpec_FieldPathSelectorImagePullSecrets:
		return &PodSpec_FieldTerminalPathValue{PodSpec_FieldTerminalPath: *fp, value: value.([]*LocalObjectReferenceSecret)}
	case PodSpec_FieldPathSelectorVolumes:
		return &PodSpec_FieldTerminalPathValue{PodSpec_FieldTerminalPath: *fp, value: value.([]*Volume)}
	case PodSpec_FieldPathSelectorCompose:
		return &PodSpec_FieldTerminalPathValue{PodSpec_FieldTerminalPath: *fp, value: value.(string)}
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		return &PodSpec_FieldTerminalPathValue{PodSpec_FieldTerminalPath: *fp, value: value.([]*VolumeMount)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fp.selector))
	}
}

func (fp *PodSpec_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *PodSpec_FieldTerminalPath) WithIArrayOfValues(values interface{}) PodSpec_FieldPathArrayOfValues {
	fpaov := &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp}
	switch fp.selector {
	case PodSpec_FieldPathSelectorNode:
		return &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp, values: values.([]*devices_device.Reference)}
	case PodSpec_FieldPathSelectorContainers:
		return &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp, values: values.([][]*PodSpec_Container)}
	case PodSpec_FieldPathSelectorHostNetwork:
		return &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp, values: values.([]bool)}
	case PodSpec_FieldPathSelectorRestartPolicy:
		return &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp, values: values.([]PodSpec_RestartPolicy)}
	case PodSpec_FieldPathSelectorImagePullSecrets:
		return &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp, values: values.([][]*LocalObjectReferenceSecret)}
	case PodSpec_FieldPathSelectorVolumes:
		return &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp, values: values.([][]*Volume)}
	case PodSpec_FieldPathSelectorCompose:
		return &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp, values: values.([]string)}
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		return &PodSpec_FieldTerminalPathArrayOfValues{PodSpec_FieldTerminalPath: *fp, values: values.([][]*VolumeMount)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fp.selector))
	}
	return fpaov
}

func (fp *PodSpec_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *PodSpec_FieldTerminalPath) WithIArrayItemValue(value interface{}) PodSpec_FieldPathArrayItemValue {
	switch fp.selector {
	case PodSpec_FieldPathSelectorContainers:
		return &PodSpec_FieldTerminalPathArrayItemValue{PodSpec_FieldTerminalPath: *fp, value: value.(*PodSpec_Container)}
	case PodSpec_FieldPathSelectorImagePullSecrets:
		return &PodSpec_FieldTerminalPathArrayItemValue{PodSpec_FieldTerminalPath: *fp, value: value.(*LocalObjectReferenceSecret)}
	case PodSpec_FieldPathSelectorVolumes:
		return &PodSpec_FieldTerminalPathArrayItemValue{PodSpec_FieldTerminalPath: *fp, value: value.(*Volume)}
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		return &PodSpec_FieldTerminalPathArrayItemValue{PodSpec_FieldTerminalPath: *fp, value: value.(*VolumeMount)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fp.selector))
	}
}

func (fp *PodSpec_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type PodSpec_FieldSubPath struct {
	selector PodSpec_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ PodSpec_FieldPath = (*PodSpec_FieldSubPath)(nil)

func (fps *PodSpec_FieldSubPath) Selector() PodSpec_FieldPathSelector {
	return fps.selector
}
func (fps *PodSpec_FieldSubPath) AsContainersSubPath() (PodSpecContainer_FieldPath, bool) {
	res, ok := fps.subPath.(PodSpecContainer_FieldPath)
	return res, ok
}
func (fps *PodSpec_FieldSubPath) AsImagePullSecretsSubPath() (LocalObjectReferenceSecret_FieldPath, bool) {
	res, ok := fps.subPath.(LocalObjectReferenceSecret_FieldPath)
	return res, ok
}
func (fps *PodSpec_FieldSubPath) AsVolumesSubPath() (Volume_FieldPath, bool) {
	res, ok := fps.subPath.(Volume_FieldPath)
	return res, ok
}
func (fps *PodSpec_FieldSubPath) AsHostVolumeMountsSubPath() (VolumeMount_FieldPath, bool) {
	res, ok := fps.subPath.(VolumeMount_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *PodSpec_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *PodSpec_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source PodSpec
func (fps *PodSpec_FieldSubPath) Get(source *PodSpec) (values []interface{}) {
	switch fps.selector {
	case PodSpec_FieldPathSelectorContainers:
		for _, item := range source.GetContainers() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case PodSpec_FieldPathSelectorImagePullSecrets:
		for _, item := range source.GetImagePullSecrets() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case PodSpec_FieldPathSelectorVolumes:
		for _, item := range source.GetVolumes() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		for _, item := range source.GetHostVolumeMounts() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fps.selector))
	}
	return
}

func (fps *PodSpec_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*PodSpec))
}

// GetSingle returns value of selected field from source PodSpec
func (fps *PodSpec_FieldSubPath) GetSingle(source *PodSpec) (interface{}, bool) {
	switch fps.selector {
	case PodSpec_FieldPathSelectorContainers:
		if len(source.GetContainers()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetContainers()[0])
	case PodSpec_FieldPathSelectorImagePullSecrets:
		if len(source.GetImagePullSecrets()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetImagePullSecrets()[0])
	case PodSpec_FieldPathSelectorVolumes:
		if len(source.GetVolumes()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetVolumes()[0])
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		if len(source.GetHostVolumeMounts()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetHostVolumeMounts()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fps.selector))
	}
}

func (fps *PodSpec_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*PodSpec))
}

// GetDefault returns a default value of the field type
func (fps *PodSpec_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *PodSpec_FieldSubPath) ClearValue(item *PodSpec) {
	if item != nil {
		switch fps.selector {
		case PodSpec_FieldPathSelectorContainers:
			for _, subItem := range item.Containers {
				fps.subPath.ClearValueRaw(subItem)
			}
		case PodSpec_FieldPathSelectorImagePullSecrets:
			for _, subItem := range item.ImagePullSecrets {
				fps.subPath.ClearValueRaw(subItem)
			}
		case PodSpec_FieldPathSelectorVolumes:
			for _, subItem := range item.Volumes {
				fps.subPath.ClearValueRaw(subItem)
			}
		case PodSpec_FieldPathSelectorHostVolumeMounts:
			for _, subItem := range item.HostVolumeMounts {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fps.selector))
		}
	}
}

func (fps *PodSpec_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*PodSpec))
}

// IsLeaf - whether field path is holds simple value
func (fps *PodSpec_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *PodSpec_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&PodSpec_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *PodSpec_FieldSubPath) WithIValue(value interface{}) PodSpec_FieldPathValue {
	return &PodSpec_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *PodSpec_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *PodSpec_FieldSubPath) WithIArrayOfValues(values interface{}) PodSpec_FieldPathArrayOfValues {
	return &PodSpec_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *PodSpec_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *PodSpec_FieldSubPath) WithIArrayItemValue(value interface{}) PodSpec_FieldPathArrayItemValue {
	return &PodSpec_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *PodSpec_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// PodSpec_FieldPathValue allows storing values for PodSpec fields according to their type
type PodSpec_FieldPathValue interface {
	PodSpec_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **PodSpec)
	CompareWith(*PodSpec) (cmp int, comparable bool)
}

func ParsePodSpec_FieldPathValue(pathStr, valueStr string) (PodSpec_FieldPathValue, error) {
	fp, err := ParsePodSpec_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PodSpec field path value from %s: %v", valueStr, err)
	}
	return fpv.(PodSpec_FieldPathValue), nil
}

func MustParsePodSpec_FieldPathValue(pathStr, valueStr string) PodSpec_FieldPathValue {
	fpv, err := ParsePodSpec_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type PodSpec_FieldTerminalPathValue struct {
	PodSpec_FieldTerminalPath
	value interface{}
}

var _ PodSpec_FieldPathValue = (*PodSpec_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'PodSpec' as interface{}
func (fpv *PodSpec_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *PodSpec_FieldTerminalPathValue) AsNodeValue() (*devices_device.Reference, bool) {
	res, ok := fpv.value.(*devices_device.Reference)
	return res, ok
}
func (fpv *PodSpec_FieldTerminalPathValue) AsContainersValue() ([]*PodSpec_Container, bool) {
	res, ok := fpv.value.([]*PodSpec_Container)
	return res, ok
}
func (fpv *PodSpec_FieldTerminalPathValue) AsHostNetworkValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *PodSpec_FieldTerminalPathValue) AsRestartPolicyValue() (PodSpec_RestartPolicy, bool) {
	res, ok := fpv.value.(PodSpec_RestartPolicy)
	return res, ok
}
func (fpv *PodSpec_FieldTerminalPathValue) AsImagePullSecretsValue() ([]*LocalObjectReferenceSecret, bool) {
	res, ok := fpv.value.([]*LocalObjectReferenceSecret)
	return res, ok
}
func (fpv *PodSpec_FieldTerminalPathValue) AsVolumesValue() ([]*Volume, bool) {
	res, ok := fpv.value.([]*Volume)
	return res, ok
}
func (fpv *PodSpec_FieldTerminalPathValue) AsComposeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *PodSpec_FieldTerminalPathValue) AsHostVolumeMountsValue() ([]*VolumeMount, bool) {
	res, ok := fpv.value.([]*VolumeMount)
	return res, ok
}

// SetTo stores value for selected field for object PodSpec
func (fpv *PodSpec_FieldTerminalPathValue) SetTo(target **PodSpec) {
	if *target == nil {
		*target = new(PodSpec)
	}
	switch fpv.selector {
	case PodSpec_FieldPathSelectorNode:
		(*target).Node = fpv.value.(*devices_device.Reference)
	case PodSpec_FieldPathSelectorContainers:
		(*target).Containers = fpv.value.([]*PodSpec_Container)
	case PodSpec_FieldPathSelectorHostNetwork:
		(*target).HostNetwork = fpv.value.(bool)
	case PodSpec_FieldPathSelectorRestartPolicy:
		(*target).RestartPolicy = fpv.value.(PodSpec_RestartPolicy)
	case PodSpec_FieldPathSelectorImagePullSecrets:
		(*target).ImagePullSecrets = fpv.value.([]*LocalObjectReferenceSecret)
	case PodSpec_FieldPathSelectorVolumes:
		(*target).Volumes = fpv.value.([]*Volume)
	case PodSpec_FieldPathSelectorCompose:
		(*target).Compose = fpv.value.(string)
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		(*target).HostVolumeMounts = fpv.value.([]*VolumeMount)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fpv.selector))
	}
}

func (fpv *PodSpec_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*PodSpec)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'PodSpec_FieldTerminalPathValue' with the value under path in 'PodSpec'.
func (fpv *PodSpec_FieldTerminalPathValue) CompareWith(source *PodSpec) (int, bool) {
	switch fpv.selector {
	case PodSpec_FieldPathSelectorNode:
		leftValue := fpv.value.(*devices_device.Reference)
		rightValue := source.GetNode()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case PodSpec_FieldPathSelectorContainers:
		return 0, false
	case PodSpec_FieldPathSelectorHostNetwork:
		leftValue := fpv.value.(bool)
		rightValue := source.GetHostNetwork()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PodSpec_FieldPathSelectorRestartPolicy:
		leftValue := fpv.value.(PodSpec_RestartPolicy)
		rightValue := source.GetRestartPolicy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PodSpec_FieldPathSelectorImagePullSecrets:
		return 0, false
	case PodSpec_FieldPathSelectorVolumes:
		return 0, false
	case PodSpec_FieldPathSelectorCompose:
		leftValue := fpv.value.(string)
		rightValue := source.GetCompose()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fpv.selector))
	}
}

func (fpv *PodSpec_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*PodSpec))
}

type PodSpec_FieldSubPathValue struct {
	PodSpec_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ PodSpec_FieldPathValue = (*PodSpec_FieldSubPathValue)(nil)

func (fpvs *PodSpec_FieldSubPathValue) AsContainersPathValue() (PodSpecContainer_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(PodSpecContainer_FieldPathValue)
	return res, ok
}
func (fpvs *PodSpec_FieldSubPathValue) AsImagePullSecretsPathValue() (LocalObjectReferenceSecret_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(LocalObjectReferenceSecret_FieldPathValue)
	return res, ok
}
func (fpvs *PodSpec_FieldSubPathValue) AsVolumesPathValue() (Volume_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(Volume_FieldPathValue)
	return res, ok
}
func (fpvs *PodSpec_FieldSubPathValue) AsHostVolumeMountsPathValue() (VolumeMount_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(VolumeMount_FieldPathValue)
	return res, ok
}

func (fpvs *PodSpec_FieldSubPathValue) SetTo(target **PodSpec) {
	if *target == nil {
		*target = new(PodSpec)
	}
	switch fpvs.Selector() {
	case PodSpec_FieldPathSelectorContainers:
		panic("FieldPath setter is unsupported for array subpaths")
	case PodSpec_FieldPathSelectorImagePullSecrets:
		panic("FieldPath setter is unsupported for array subpaths")
	case PodSpec_FieldPathSelectorVolumes:
		panic("FieldPath setter is unsupported for array subpaths")
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fpvs.Selector()))
	}
}

func (fpvs *PodSpec_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*PodSpec)
	fpvs.SetTo(&typedObject)
}

func (fpvs *PodSpec_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *PodSpec_FieldSubPathValue) CompareWith(source *PodSpec) (int, bool) {
	switch fpvs.Selector() {
	case PodSpec_FieldPathSelectorContainers:
		return 0, false // repeated field
	case PodSpec_FieldPathSelectorImagePullSecrets:
		return 0, false // repeated field
	case PodSpec_FieldPathSelectorVolumes:
		return 0, false // repeated field
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fpvs.Selector()))
	}
}

func (fpvs *PodSpec_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*PodSpec))
}

// PodSpec_FieldPathArrayItemValue allows storing single item in Path-specific values for PodSpec according to their type
// Present only for array (repeated) types.
type PodSpec_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	PodSpec_FieldPath
	ContainsValue(*PodSpec) bool
}

// ParsePodSpec_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParsePodSpec_FieldPathArrayItemValue(pathStr, valueStr string) (PodSpec_FieldPathArrayItemValue, error) {
	fp, err := ParsePodSpec_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PodSpec field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(PodSpec_FieldPathArrayItemValue), nil
}

func MustParsePodSpec_FieldPathArrayItemValue(pathStr, valueStr string) PodSpec_FieldPathArrayItemValue {
	fpaiv, err := ParsePodSpec_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type PodSpec_FieldTerminalPathArrayItemValue struct {
	PodSpec_FieldTerminalPath
	value interface{}
}

var _ PodSpec_FieldPathArrayItemValue = (*PodSpec_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object PodSpec as interface{}
func (fpaiv *PodSpec_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *PodSpec_FieldTerminalPathArrayItemValue) AsContainersItemValue() (*PodSpec_Container, bool) {
	res, ok := fpaiv.value.(*PodSpec_Container)
	return res, ok
}
func (fpaiv *PodSpec_FieldTerminalPathArrayItemValue) AsImagePullSecretsItemValue() (*LocalObjectReferenceSecret, bool) {
	res, ok := fpaiv.value.(*LocalObjectReferenceSecret)
	return res, ok
}
func (fpaiv *PodSpec_FieldTerminalPathArrayItemValue) AsVolumesItemValue() (*Volume, bool) {
	res, ok := fpaiv.value.(*Volume)
	return res, ok
}
func (fpaiv *PodSpec_FieldTerminalPathArrayItemValue) AsHostVolumeMountsItemValue() (*VolumeMount, bool) {
	res, ok := fpaiv.value.(*VolumeMount)
	return res, ok
}

func (fpaiv *PodSpec_FieldTerminalPathArrayItemValue) GetSingle(source *PodSpec) (interface{}, bool) {
	return nil, false
}

func (fpaiv *PodSpec_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*PodSpec))
}

// Contains returns a boolean indicating if value that is being held is present in given 'PodSpec'
func (fpaiv *PodSpec_FieldTerminalPathArrayItemValue) ContainsValue(source *PodSpec) bool {
	slice := fpaiv.PodSpec_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type PodSpec_FieldSubPathArrayItemValue struct {
	PodSpec_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *PodSpec_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *PodSpec_FieldSubPathArrayItemValue) AsContainersPathItemValue() (PodSpecContainer_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(PodSpecContainer_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *PodSpec_FieldSubPathArrayItemValue) AsImagePullSecretsPathItemValue() (LocalObjectReferenceSecret_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(LocalObjectReferenceSecret_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *PodSpec_FieldSubPathArrayItemValue) AsVolumesPathItemValue() (Volume_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(Volume_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *PodSpec_FieldSubPathArrayItemValue) AsHostVolumeMountsPathItemValue() (VolumeMount_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(VolumeMount_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'PodSpec'
func (fpaivs *PodSpec_FieldSubPathArrayItemValue) ContainsValue(source *PodSpec) bool {
	switch fpaivs.Selector() {
	case PodSpec_FieldPathSelectorContainers:
		return false // repeated/map field
	case PodSpec_FieldPathSelectorImagePullSecrets:
		return false // repeated/map field
	case PodSpec_FieldPathSelectorVolumes:
		return false // repeated/map field
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec: %d", fpaivs.Selector()))
	}
}

// PodSpec_FieldPathArrayOfValues allows storing slice of values for PodSpec fields according to their type
type PodSpec_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	PodSpec_FieldPath
}

func ParsePodSpec_FieldPathArrayOfValues(pathStr, valuesStr string) (PodSpec_FieldPathArrayOfValues, error) {
	fp, err := ParsePodSpec_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PodSpec field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(PodSpec_FieldPathArrayOfValues), nil
}

func MustParsePodSpec_FieldPathArrayOfValues(pathStr, valuesStr string) PodSpec_FieldPathArrayOfValues {
	fpaov, err := ParsePodSpec_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type PodSpec_FieldTerminalPathArrayOfValues struct {
	PodSpec_FieldTerminalPath
	values interface{}
}

var _ PodSpec_FieldPathArrayOfValues = (*PodSpec_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case PodSpec_FieldPathSelectorNode:
		for _, v := range fpaov.values.([]*devices_device.Reference) {
			values = append(values, v)
		}
	case PodSpec_FieldPathSelectorContainers:
		for _, v := range fpaov.values.([][]*PodSpec_Container) {
			values = append(values, v)
		}
	case PodSpec_FieldPathSelectorHostNetwork:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case PodSpec_FieldPathSelectorRestartPolicy:
		for _, v := range fpaov.values.([]PodSpec_RestartPolicy) {
			values = append(values, v)
		}
	case PodSpec_FieldPathSelectorImagePullSecrets:
		for _, v := range fpaov.values.([][]*LocalObjectReferenceSecret) {
			values = append(values, v)
		}
	case PodSpec_FieldPathSelectorVolumes:
		for _, v := range fpaov.values.([][]*Volume) {
			values = append(values, v)
		}
	case PodSpec_FieldPathSelectorCompose:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case PodSpec_FieldPathSelectorHostVolumeMounts:
		for _, v := range fpaov.values.([][]*VolumeMount) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) AsNodeArrayOfValues() ([]*devices_device.Reference, bool) {
	res, ok := fpaov.values.([]*devices_device.Reference)
	return res, ok
}
func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) AsContainersArrayOfValues() ([][]*PodSpec_Container, bool) {
	res, ok := fpaov.values.([][]*PodSpec_Container)
	return res, ok
}
func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) AsHostNetworkArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) AsRestartPolicyArrayOfValues() ([]PodSpec_RestartPolicy, bool) {
	res, ok := fpaov.values.([]PodSpec_RestartPolicy)
	return res, ok
}
func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) AsImagePullSecretsArrayOfValues() ([][]*LocalObjectReferenceSecret, bool) {
	res, ok := fpaov.values.([][]*LocalObjectReferenceSecret)
	return res, ok
}
func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) AsVolumesArrayOfValues() ([][]*Volume, bool) {
	res, ok := fpaov.values.([][]*Volume)
	return res, ok
}
func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) AsComposeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *PodSpec_FieldTerminalPathArrayOfValues) AsHostVolumeMountsArrayOfValues() ([][]*VolumeMount, bool) {
	res, ok := fpaov.values.([][]*VolumeMount)
	return res, ok
}

type PodSpec_FieldSubPathArrayOfValues struct {
	PodSpec_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ PodSpec_FieldPathArrayOfValues = (*PodSpec_FieldSubPathArrayOfValues)(nil)

func (fpsaov *PodSpec_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *PodSpec_FieldSubPathArrayOfValues) AsContainersPathArrayOfValues() (PodSpecContainer_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(PodSpecContainer_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *PodSpec_FieldSubPathArrayOfValues) AsImagePullSecretsPathArrayOfValues() (LocalObjectReferenceSecret_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(LocalObjectReferenceSecret_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *PodSpec_FieldSubPathArrayOfValues) AsVolumesPathArrayOfValues() (Volume_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(Volume_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *PodSpec_FieldSubPathArrayOfValues) AsHostVolumeMountsPathArrayOfValues() (VolumeMount_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(VolumeMount_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type PodSpecContainer_FieldPath interface {
	gotenobject.FieldPath
	Selector() PodSpecContainer_FieldPathSelector
	Get(source *PodSpec_Container) []interface{}
	GetSingle(source *PodSpec_Container) (interface{}, bool)
	ClearValue(item *PodSpec_Container)

	// Those methods build corresponding PodSpecContainer_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) PodSpecContainer_FieldPathValue
	WithIArrayOfValues(values interface{}) PodSpecContainer_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) PodSpecContainer_FieldPathArrayItemValue
}

type PodSpecContainer_FieldPathSelector int32

const (
	PodSpecContainer_FieldPathSelectorArgs            PodSpecContainer_FieldPathSelector = 0
	PodSpecContainer_FieldPathSelectorCommand         PodSpecContainer_FieldPathSelector = 1
	PodSpecContainer_FieldPathSelectorEnv             PodSpecContainer_FieldPathSelector = 2
	PodSpecContainer_FieldPathSelectorImage           PodSpecContainer_FieldPathSelector = 3
	PodSpecContainer_FieldPathSelectorImagePullPolicy PodSpecContainer_FieldPathSelector = 4
	PodSpecContainer_FieldPathSelectorName            PodSpecContainer_FieldPathSelector = 5
	PodSpecContainer_FieldPathSelectorResources       PodSpecContainer_FieldPathSelector = 6
	PodSpecContainer_FieldPathSelectorSecurityContext PodSpecContainer_FieldPathSelector = 7
	PodSpecContainer_FieldPathSelectorVolumeMounts    PodSpecContainer_FieldPathSelector = 8
	PodSpecContainer_FieldPathSelectorEnvFrom         PodSpecContainer_FieldPathSelector = 9
)

func (s PodSpecContainer_FieldPathSelector) String() string {
	switch s {
	case PodSpecContainer_FieldPathSelectorArgs:
		return "args"
	case PodSpecContainer_FieldPathSelectorCommand:
		return "command"
	case PodSpecContainer_FieldPathSelectorEnv:
		return "env"
	case PodSpecContainer_FieldPathSelectorImage:
		return "image"
	case PodSpecContainer_FieldPathSelectorImagePullPolicy:
		return "image_pull_policy"
	case PodSpecContainer_FieldPathSelectorName:
		return "name"
	case PodSpecContainer_FieldPathSelectorResources:
		return "resources"
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		return "security_context"
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		return "volume_mounts"
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		return "env_from"
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", s))
	}
}

func BuildPodSpecContainer_FieldPath(fp gotenobject.RawFieldPath) (PodSpecContainer_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object PodSpec_Container")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "args":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorArgs}, nil
		case "command":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorCommand}, nil
		case "env":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorEnv}, nil
		case "image":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorImage}, nil
		case "image_pull_policy", "imagePullPolicy", "image-pull-policy":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorImagePullPolicy}, nil
		case "name":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorName}, nil
		case "resources":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorResources}, nil
		case "security_context", "securityContext", "security-context":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorSecurityContext}, nil
		case "volume_mounts", "volumeMounts", "volume-mounts":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorVolumeMounts}, nil
		case "env_from", "envFrom", "env-from":
			return &PodSpecContainer_FieldTerminalPath{selector: PodSpecContainer_FieldPathSelectorEnvFrom}, nil
		}
	} else {
		switch fp[0] {
		case "env":
			if subpath, err := BuildEnvVar_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpecContainer_FieldSubPath{selector: PodSpecContainer_FieldPathSelectorEnv, subPath: subpath}, nil
			}
		case "resources":
			if subpath, err := BuildPodSpecContainerResourceRequirements_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpecContainer_FieldSubPath{selector: PodSpecContainer_FieldPathSelectorResources, subPath: subpath}, nil
			}
		case "security_context", "securityContext", "security-context":
			if subpath, err := BuildSecurityContext_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpecContainer_FieldSubPath{selector: PodSpecContainer_FieldPathSelectorSecurityContext, subPath: subpath}, nil
			}
		case "volume_mounts", "volumeMounts", "volume-mounts":
			if subpath, err := BuildVolumeMount_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpecContainer_FieldSubPath{selector: PodSpecContainer_FieldPathSelectorVolumeMounts, subPath: subpath}, nil
			}
		case "env_from", "envFrom", "env-from":
			if subpath, err := BuildEnvFromSource_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &PodSpecContainer_FieldSubPath{selector: PodSpecContainer_FieldPathSelectorEnvFrom, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object PodSpec_Container", fp)
}

func ParsePodSpecContainer_FieldPath(rawField string) (PodSpecContainer_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildPodSpecContainer_FieldPath(fp)
}

func MustParsePodSpecContainer_FieldPath(rawField string) PodSpecContainer_FieldPath {
	fp, err := ParsePodSpecContainer_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type PodSpecContainer_FieldTerminalPath struct {
	selector PodSpecContainer_FieldPathSelector
}

var _ PodSpecContainer_FieldPath = (*PodSpecContainer_FieldTerminalPath)(nil)

func (fp *PodSpecContainer_FieldTerminalPath) Selector() PodSpecContainer_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *PodSpecContainer_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *PodSpecContainer_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source PodSpec_Container
func (fp *PodSpecContainer_FieldTerminalPath) Get(source *PodSpec_Container) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case PodSpecContainer_FieldPathSelectorArgs:
			for _, value := range source.GetArgs() {
				values = append(values, value)
			}
		case PodSpecContainer_FieldPathSelectorCommand:
			for _, value := range source.GetCommand() {
				values = append(values, value)
			}
		case PodSpecContainer_FieldPathSelectorEnv:
			for _, value := range source.GetEnv() {
				values = append(values, value)
			}
		case PodSpecContainer_FieldPathSelectorImage:
			values = append(values, source.Image)
		case PodSpecContainer_FieldPathSelectorImagePullPolicy:
			values = append(values, source.ImagePullPolicy)
		case PodSpecContainer_FieldPathSelectorName:
			values = append(values, source.Name)
		case PodSpecContainer_FieldPathSelectorResources:
			if source.Resources != nil {
				values = append(values, source.Resources)
			}
		case PodSpecContainer_FieldPathSelectorSecurityContext:
			if source.SecurityContext != nil {
				values = append(values, source.SecurityContext)
			}
		case PodSpecContainer_FieldPathSelectorVolumeMounts:
			for _, value := range source.GetVolumeMounts() {
				values = append(values, value)
			}
		case PodSpecContainer_FieldPathSelectorEnvFrom:
			if source.EnvFrom != nil {
				values = append(values, source.EnvFrom)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fp.selector))
		}
	}
	return
}

func (fp *PodSpecContainer_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*PodSpec_Container))
}

// GetSingle returns value pointed by specific field of from source PodSpec_Container
func (fp *PodSpecContainer_FieldTerminalPath) GetSingle(source *PodSpec_Container) (interface{}, bool) {
	switch fp.selector {
	case PodSpecContainer_FieldPathSelectorArgs:
		res := source.GetArgs()
		return res, res != nil
	case PodSpecContainer_FieldPathSelectorCommand:
		res := source.GetCommand()
		return res, res != nil
	case PodSpecContainer_FieldPathSelectorEnv:
		res := source.GetEnv()
		return res, res != nil
	case PodSpecContainer_FieldPathSelectorImage:
		return source.GetImage(), source != nil
	case PodSpecContainer_FieldPathSelectorImagePullPolicy:
		return source.GetImagePullPolicy(), source != nil
	case PodSpecContainer_FieldPathSelectorName:
		return source.GetName(), source != nil
	case PodSpecContainer_FieldPathSelectorResources:
		res := source.GetResources()
		return res, res != nil
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		res := source.GetSecurityContext()
		return res, res != nil
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		res := source.GetVolumeMounts()
		return res, res != nil
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		res := source.GetEnvFrom()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fp.selector))
	}
}

func (fp *PodSpecContainer_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*PodSpec_Container))
}

// GetDefault returns a default value of the field type
func (fp *PodSpecContainer_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case PodSpecContainer_FieldPathSelectorArgs:
		return ([]string)(nil)
	case PodSpecContainer_FieldPathSelectorCommand:
		return ([]string)(nil)
	case PodSpecContainer_FieldPathSelectorEnv:
		return ([]*EnvVar)(nil)
	case PodSpecContainer_FieldPathSelectorImage:
		return ""
	case PodSpecContainer_FieldPathSelectorImagePullPolicy:
		return ""
	case PodSpecContainer_FieldPathSelectorName:
		return ""
	case PodSpecContainer_FieldPathSelectorResources:
		return (*PodSpec_Container_ResourceRequirements)(nil)
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		return (*SecurityContext)(nil)
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		return ([]*VolumeMount)(nil)
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		return (*EnvFromSource)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fp.selector))
	}
}

func (fp *PodSpecContainer_FieldTerminalPath) ClearValue(item *PodSpec_Container) {
	if item != nil {
		switch fp.selector {
		case PodSpecContainer_FieldPathSelectorArgs:
			item.Args = nil
		case PodSpecContainer_FieldPathSelectorCommand:
			item.Command = nil
		case PodSpecContainer_FieldPathSelectorEnv:
			item.Env = nil
		case PodSpecContainer_FieldPathSelectorImage:
			item.Image = ""
		case PodSpecContainer_FieldPathSelectorImagePullPolicy:
			item.ImagePullPolicy = ""
		case PodSpecContainer_FieldPathSelectorName:
			item.Name = ""
		case PodSpecContainer_FieldPathSelectorResources:
			item.Resources = nil
		case PodSpecContainer_FieldPathSelectorSecurityContext:
			item.SecurityContext = nil
		case PodSpecContainer_FieldPathSelectorVolumeMounts:
			item.VolumeMounts = nil
		case PodSpecContainer_FieldPathSelectorEnvFrom:
			item.EnvFrom = nil
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fp.selector))
		}
	}
}

func (fp *PodSpecContainer_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*PodSpec_Container))
}

// IsLeaf - whether field path is holds simple value
func (fp *PodSpecContainer_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == PodSpecContainer_FieldPathSelectorArgs ||
		fp.selector == PodSpecContainer_FieldPathSelectorCommand ||
		fp.selector == PodSpecContainer_FieldPathSelectorImage ||
		fp.selector == PodSpecContainer_FieldPathSelectorImagePullPolicy ||
		fp.selector == PodSpecContainer_FieldPathSelectorName
}

func (fp *PodSpecContainer_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *PodSpecContainer_FieldTerminalPath) WithIValue(value interface{}) PodSpecContainer_FieldPathValue {
	switch fp.selector {
	case PodSpecContainer_FieldPathSelectorArgs:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.([]string)}
	case PodSpecContainer_FieldPathSelectorCommand:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.([]string)}
	case PodSpecContainer_FieldPathSelectorEnv:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.([]*EnvVar)}
	case PodSpecContainer_FieldPathSelectorImage:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(string)}
	case PodSpecContainer_FieldPathSelectorImagePullPolicy:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(string)}
	case PodSpecContainer_FieldPathSelectorName:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(string)}
	case PodSpecContainer_FieldPathSelectorResources:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(*PodSpec_Container_ResourceRequirements)}
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(*SecurityContext)}
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.([]*VolumeMount)}
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		return &PodSpecContainer_FieldTerminalPathValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(*EnvFromSource)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fp.selector))
	}
}

func (fp *PodSpecContainer_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *PodSpecContainer_FieldTerminalPath) WithIArrayOfValues(values interface{}) PodSpecContainer_FieldPathArrayOfValues {
	fpaov := &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp}
	switch fp.selector {
	case PodSpecContainer_FieldPathSelectorArgs:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([][]string)}
	case PodSpecContainer_FieldPathSelectorCommand:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([][]string)}
	case PodSpecContainer_FieldPathSelectorEnv:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([][]*EnvVar)}
	case PodSpecContainer_FieldPathSelectorImage:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([]string)}
	case PodSpecContainer_FieldPathSelectorImagePullPolicy:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([]string)}
	case PodSpecContainer_FieldPathSelectorName:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([]string)}
	case PodSpecContainer_FieldPathSelectorResources:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([]*PodSpec_Container_ResourceRequirements)}
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([]*SecurityContext)}
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([][]*VolumeMount)}
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		return &PodSpecContainer_FieldTerminalPathArrayOfValues{PodSpecContainer_FieldTerminalPath: *fp, values: values.([]*EnvFromSource)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fp.selector))
	}
	return fpaov
}

func (fp *PodSpecContainer_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *PodSpecContainer_FieldTerminalPath) WithIArrayItemValue(value interface{}) PodSpecContainer_FieldPathArrayItemValue {
	switch fp.selector {
	case PodSpecContainer_FieldPathSelectorArgs:
		return &PodSpecContainer_FieldTerminalPathArrayItemValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(string)}
	case PodSpecContainer_FieldPathSelectorCommand:
		return &PodSpecContainer_FieldTerminalPathArrayItemValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(string)}
	case PodSpecContainer_FieldPathSelectorEnv:
		return &PodSpecContainer_FieldTerminalPathArrayItemValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(*EnvVar)}
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		return &PodSpecContainer_FieldTerminalPathArrayItemValue{PodSpecContainer_FieldTerminalPath: *fp, value: value.(*VolumeMount)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fp.selector))
	}
}

func (fp *PodSpecContainer_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type PodSpecContainer_FieldSubPath struct {
	selector PodSpecContainer_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ PodSpecContainer_FieldPath = (*PodSpecContainer_FieldSubPath)(nil)

func (fps *PodSpecContainer_FieldSubPath) Selector() PodSpecContainer_FieldPathSelector {
	return fps.selector
}
func (fps *PodSpecContainer_FieldSubPath) AsEnvSubPath() (EnvVar_FieldPath, bool) {
	res, ok := fps.subPath.(EnvVar_FieldPath)
	return res, ok
}
func (fps *PodSpecContainer_FieldSubPath) AsResourcesSubPath() (PodSpecContainerResourceRequirements_FieldPath, bool) {
	res, ok := fps.subPath.(PodSpecContainerResourceRequirements_FieldPath)
	return res, ok
}
func (fps *PodSpecContainer_FieldSubPath) AsSecurityContextSubPath() (SecurityContext_FieldPath, bool) {
	res, ok := fps.subPath.(SecurityContext_FieldPath)
	return res, ok
}
func (fps *PodSpecContainer_FieldSubPath) AsVolumeMountsSubPath() (VolumeMount_FieldPath, bool) {
	res, ok := fps.subPath.(VolumeMount_FieldPath)
	return res, ok
}
func (fps *PodSpecContainer_FieldSubPath) AsEnvFromSubPath() (EnvFromSource_FieldPath, bool) {
	res, ok := fps.subPath.(EnvFromSource_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *PodSpecContainer_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *PodSpecContainer_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source PodSpec_Container
func (fps *PodSpecContainer_FieldSubPath) Get(source *PodSpec_Container) (values []interface{}) {
	switch fps.selector {
	case PodSpecContainer_FieldPathSelectorEnv:
		for _, item := range source.GetEnv() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case PodSpecContainer_FieldPathSelectorResources:
		values = append(values, fps.subPath.GetRaw(source.GetResources())...)
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		values = append(values, fps.subPath.GetRaw(source.GetSecurityContext())...)
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		for _, item := range source.GetVolumeMounts() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		values = append(values, fps.subPath.GetRaw(source.GetEnvFrom())...)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fps.selector))
	}
	return
}

func (fps *PodSpecContainer_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*PodSpec_Container))
}

// GetSingle returns value of selected field from source PodSpec_Container
func (fps *PodSpecContainer_FieldSubPath) GetSingle(source *PodSpec_Container) (interface{}, bool) {
	switch fps.selector {
	case PodSpecContainer_FieldPathSelectorEnv:
		if len(source.GetEnv()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetEnv()[0])
	case PodSpecContainer_FieldPathSelectorResources:
		if source.GetResources() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetResources())
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		if source.GetSecurityContext() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetSecurityContext())
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		if len(source.GetVolumeMounts()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetVolumeMounts()[0])
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		if source.GetEnvFrom() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetEnvFrom())
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fps.selector))
	}
}

func (fps *PodSpecContainer_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*PodSpec_Container))
}

// GetDefault returns a default value of the field type
func (fps *PodSpecContainer_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *PodSpecContainer_FieldSubPath) ClearValue(item *PodSpec_Container) {
	if item != nil {
		switch fps.selector {
		case PodSpecContainer_FieldPathSelectorEnv:
			for _, subItem := range item.Env {
				fps.subPath.ClearValueRaw(subItem)
			}
		case PodSpecContainer_FieldPathSelectorResources:
			fps.subPath.ClearValueRaw(item.Resources)
		case PodSpecContainer_FieldPathSelectorSecurityContext:
			fps.subPath.ClearValueRaw(item.SecurityContext)
		case PodSpecContainer_FieldPathSelectorVolumeMounts:
			for _, subItem := range item.VolumeMounts {
				fps.subPath.ClearValueRaw(subItem)
			}
		case PodSpecContainer_FieldPathSelectorEnvFrom:
			fps.subPath.ClearValueRaw(item.EnvFrom)
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fps.selector))
		}
	}
}

func (fps *PodSpecContainer_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*PodSpec_Container))
}

// IsLeaf - whether field path is holds simple value
func (fps *PodSpecContainer_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *PodSpecContainer_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&PodSpecContainer_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *PodSpecContainer_FieldSubPath) WithIValue(value interface{}) PodSpecContainer_FieldPathValue {
	return &PodSpecContainer_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *PodSpecContainer_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *PodSpecContainer_FieldSubPath) WithIArrayOfValues(values interface{}) PodSpecContainer_FieldPathArrayOfValues {
	return &PodSpecContainer_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *PodSpecContainer_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *PodSpecContainer_FieldSubPath) WithIArrayItemValue(value interface{}) PodSpecContainer_FieldPathArrayItemValue {
	return &PodSpecContainer_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *PodSpecContainer_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// PodSpecContainer_FieldPathValue allows storing values for Container fields according to their type
type PodSpecContainer_FieldPathValue interface {
	PodSpecContainer_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **PodSpec_Container)
	CompareWith(*PodSpec_Container) (cmp int, comparable bool)
}

func ParsePodSpecContainer_FieldPathValue(pathStr, valueStr string) (PodSpecContainer_FieldPathValue, error) {
	fp, err := ParsePodSpecContainer_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Container field path value from %s: %v", valueStr, err)
	}
	return fpv.(PodSpecContainer_FieldPathValue), nil
}

func MustParsePodSpecContainer_FieldPathValue(pathStr, valueStr string) PodSpecContainer_FieldPathValue {
	fpv, err := ParsePodSpecContainer_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type PodSpecContainer_FieldTerminalPathValue struct {
	PodSpecContainer_FieldTerminalPath
	value interface{}
}

var _ PodSpecContainer_FieldPathValue = (*PodSpecContainer_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Container' as interface{}
func (fpv *PodSpecContainer_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsArgsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsCommandValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsEnvValue() ([]*EnvVar, bool) {
	res, ok := fpv.value.([]*EnvVar)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsImageValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsImagePullPolicyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsResourcesValue() (*PodSpec_Container_ResourceRequirements, bool) {
	res, ok := fpv.value.(*PodSpec_Container_ResourceRequirements)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsSecurityContextValue() (*SecurityContext, bool) {
	res, ok := fpv.value.(*SecurityContext)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsVolumeMountsValue() ([]*VolumeMount, bool) {
	res, ok := fpv.value.([]*VolumeMount)
	return res, ok
}
func (fpv *PodSpecContainer_FieldTerminalPathValue) AsEnvFromValue() (*EnvFromSource, bool) {
	res, ok := fpv.value.(*EnvFromSource)
	return res, ok
}

// SetTo stores value for selected field for object Container
func (fpv *PodSpecContainer_FieldTerminalPathValue) SetTo(target **PodSpec_Container) {
	if *target == nil {
		*target = new(PodSpec_Container)
	}
	switch fpv.selector {
	case PodSpecContainer_FieldPathSelectorArgs:
		(*target).Args = fpv.value.([]string)
	case PodSpecContainer_FieldPathSelectorCommand:
		(*target).Command = fpv.value.([]string)
	case PodSpecContainer_FieldPathSelectorEnv:
		(*target).Env = fpv.value.([]*EnvVar)
	case PodSpecContainer_FieldPathSelectorImage:
		(*target).Image = fpv.value.(string)
	case PodSpecContainer_FieldPathSelectorImagePullPolicy:
		(*target).ImagePullPolicy = fpv.value.(string)
	case PodSpecContainer_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case PodSpecContainer_FieldPathSelectorResources:
		(*target).Resources = fpv.value.(*PodSpec_Container_ResourceRequirements)
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		(*target).SecurityContext = fpv.value.(*SecurityContext)
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		(*target).VolumeMounts = fpv.value.([]*VolumeMount)
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		(*target).EnvFrom = fpv.value.(*EnvFromSource)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fpv.selector))
	}
}

func (fpv *PodSpecContainer_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*PodSpec_Container)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'PodSpecContainer_FieldTerminalPathValue' with the value under path in 'PodSpec_Container'.
func (fpv *PodSpecContainer_FieldTerminalPathValue) CompareWith(source *PodSpec_Container) (int, bool) {
	switch fpv.selector {
	case PodSpecContainer_FieldPathSelectorArgs:
		return 0, false
	case PodSpecContainer_FieldPathSelectorCommand:
		return 0, false
	case PodSpecContainer_FieldPathSelectorEnv:
		return 0, false
	case PodSpecContainer_FieldPathSelectorImage:
		leftValue := fpv.value.(string)
		rightValue := source.GetImage()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PodSpecContainer_FieldPathSelectorImagePullPolicy:
		leftValue := fpv.value.(string)
		rightValue := source.GetImagePullPolicy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PodSpecContainer_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PodSpecContainer_FieldPathSelectorResources:
		return 0, false
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		return 0, false
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		return 0, false
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fpv.selector))
	}
}

func (fpv *PodSpecContainer_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*PodSpec_Container))
}

type PodSpecContainer_FieldSubPathValue struct {
	PodSpecContainer_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ PodSpecContainer_FieldPathValue = (*PodSpecContainer_FieldSubPathValue)(nil)

func (fpvs *PodSpecContainer_FieldSubPathValue) AsEnvPathValue() (EnvVar_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(EnvVar_FieldPathValue)
	return res, ok
}
func (fpvs *PodSpecContainer_FieldSubPathValue) AsResourcesPathValue() (PodSpecContainerResourceRequirements_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(PodSpecContainerResourceRequirements_FieldPathValue)
	return res, ok
}
func (fpvs *PodSpecContainer_FieldSubPathValue) AsSecurityContextPathValue() (SecurityContext_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(SecurityContext_FieldPathValue)
	return res, ok
}
func (fpvs *PodSpecContainer_FieldSubPathValue) AsVolumeMountsPathValue() (VolumeMount_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(VolumeMount_FieldPathValue)
	return res, ok
}
func (fpvs *PodSpecContainer_FieldSubPathValue) AsEnvFromPathValue() (EnvFromSource_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(EnvFromSource_FieldPathValue)
	return res, ok
}

func (fpvs *PodSpecContainer_FieldSubPathValue) SetTo(target **PodSpec_Container) {
	if *target == nil {
		*target = new(PodSpec_Container)
	}
	switch fpvs.Selector() {
	case PodSpecContainer_FieldPathSelectorEnv:
		panic("FieldPath setter is unsupported for array subpaths")
	case PodSpecContainer_FieldPathSelectorResources:
		fpvs.subPathValue.(PodSpecContainerResourceRequirements_FieldPathValue).SetTo(&(*target).Resources)
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		fpvs.subPathValue.(SecurityContext_FieldPathValue).SetTo(&(*target).SecurityContext)
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		panic("FieldPath setter is unsupported for array subpaths")
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		fpvs.subPathValue.(EnvFromSource_FieldPathValue).SetTo(&(*target).EnvFrom)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fpvs.Selector()))
	}
}

func (fpvs *PodSpecContainer_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*PodSpec_Container)
	fpvs.SetTo(&typedObject)
}

func (fpvs *PodSpecContainer_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *PodSpecContainer_FieldSubPathValue) CompareWith(source *PodSpec_Container) (int, bool) {
	switch fpvs.Selector() {
	case PodSpecContainer_FieldPathSelectorEnv:
		return 0, false // repeated field
	case PodSpecContainer_FieldPathSelectorResources:
		return fpvs.subPathValue.(PodSpecContainerResourceRequirements_FieldPathValue).CompareWith(source.GetResources())
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		return fpvs.subPathValue.(SecurityContext_FieldPathValue).CompareWith(source.GetSecurityContext())
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		return 0, false // repeated field
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		return fpvs.subPathValue.(EnvFromSource_FieldPathValue).CompareWith(source.GetEnvFrom())
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fpvs.Selector()))
	}
}

func (fpvs *PodSpecContainer_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*PodSpec_Container))
}

// PodSpecContainer_FieldPathArrayItemValue allows storing single item in Path-specific values for Container according to their type
// Present only for array (repeated) types.
type PodSpecContainer_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	PodSpecContainer_FieldPath
	ContainsValue(*PodSpec_Container) bool
}

// ParsePodSpecContainer_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParsePodSpecContainer_FieldPathArrayItemValue(pathStr, valueStr string) (PodSpecContainer_FieldPathArrayItemValue, error) {
	fp, err := ParsePodSpecContainer_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Container field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(PodSpecContainer_FieldPathArrayItemValue), nil
}

func MustParsePodSpecContainer_FieldPathArrayItemValue(pathStr, valueStr string) PodSpecContainer_FieldPathArrayItemValue {
	fpaiv, err := ParsePodSpecContainer_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type PodSpecContainer_FieldTerminalPathArrayItemValue struct {
	PodSpecContainer_FieldTerminalPath
	value interface{}
}

var _ PodSpecContainer_FieldPathArrayItemValue = (*PodSpecContainer_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object PodSpec_Container as interface{}
func (fpaiv *PodSpecContainer_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *PodSpecContainer_FieldTerminalPathArrayItemValue) AsArgsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}
func (fpaiv *PodSpecContainer_FieldTerminalPathArrayItemValue) AsCommandItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}
func (fpaiv *PodSpecContainer_FieldTerminalPathArrayItemValue) AsEnvItemValue() (*EnvVar, bool) {
	res, ok := fpaiv.value.(*EnvVar)
	return res, ok
}
func (fpaiv *PodSpecContainer_FieldTerminalPathArrayItemValue) AsVolumeMountsItemValue() (*VolumeMount, bool) {
	res, ok := fpaiv.value.(*VolumeMount)
	return res, ok
}

func (fpaiv *PodSpecContainer_FieldTerminalPathArrayItemValue) GetSingle(source *PodSpec_Container) (interface{}, bool) {
	return nil, false
}

func (fpaiv *PodSpecContainer_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*PodSpec_Container))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Container'
func (fpaiv *PodSpecContainer_FieldTerminalPathArrayItemValue) ContainsValue(source *PodSpec_Container) bool {
	slice := fpaiv.PodSpecContainer_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type PodSpecContainer_FieldSubPathArrayItemValue struct {
	PodSpecContainer_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *PodSpecContainer_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *PodSpecContainer_FieldSubPathArrayItemValue) AsEnvPathItemValue() (EnvVar_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(EnvVar_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *PodSpecContainer_FieldSubPathArrayItemValue) AsResourcesPathItemValue() (PodSpecContainerResourceRequirements_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(PodSpecContainerResourceRequirements_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *PodSpecContainer_FieldSubPathArrayItemValue) AsSecurityContextPathItemValue() (SecurityContext_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(SecurityContext_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *PodSpecContainer_FieldSubPathArrayItemValue) AsVolumeMountsPathItemValue() (VolumeMount_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(VolumeMount_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *PodSpecContainer_FieldSubPathArrayItemValue) AsEnvFromPathItemValue() (EnvFromSource_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(EnvFromSource_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'Container'
func (fpaivs *PodSpecContainer_FieldSubPathArrayItemValue) ContainsValue(source *PodSpec_Container) bool {
	switch fpaivs.Selector() {
	case PodSpecContainer_FieldPathSelectorEnv:
		return false // repeated/map field
	case PodSpecContainer_FieldPathSelectorResources:
		return fpaivs.subPathItemValue.(PodSpecContainerResourceRequirements_FieldPathArrayItemValue).ContainsValue(source.GetResources())
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		return fpaivs.subPathItemValue.(SecurityContext_FieldPathArrayItemValue).ContainsValue(source.GetSecurityContext())
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		return false // repeated/map field
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		return fpaivs.subPathItemValue.(EnvFromSource_FieldPathArrayItemValue).ContainsValue(source.GetEnvFrom())
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container: %d", fpaivs.Selector()))
	}
}

// PodSpecContainer_FieldPathArrayOfValues allows storing slice of values for Container fields according to their type
type PodSpecContainer_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	PodSpecContainer_FieldPath
}

func ParsePodSpecContainer_FieldPathArrayOfValues(pathStr, valuesStr string) (PodSpecContainer_FieldPathArrayOfValues, error) {
	fp, err := ParsePodSpecContainer_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Container field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(PodSpecContainer_FieldPathArrayOfValues), nil
}

func MustParsePodSpecContainer_FieldPathArrayOfValues(pathStr, valuesStr string) PodSpecContainer_FieldPathArrayOfValues {
	fpaov, err := ParsePodSpecContainer_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type PodSpecContainer_FieldTerminalPathArrayOfValues struct {
	PodSpecContainer_FieldTerminalPath
	values interface{}
}

var _ PodSpecContainer_FieldPathArrayOfValues = (*PodSpecContainer_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case PodSpecContainer_FieldPathSelectorArgs:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorCommand:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorEnv:
		for _, v := range fpaov.values.([][]*EnvVar) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorImage:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorImagePullPolicy:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorResources:
		for _, v := range fpaov.values.([]*PodSpec_Container_ResourceRequirements) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorSecurityContext:
		for _, v := range fpaov.values.([]*SecurityContext) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorVolumeMounts:
		for _, v := range fpaov.values.([][]*VolumeMount) {
			values = append(values, v)
		}
	case PodSpecContainer_FieldPathSelectorEnvFrom:
		for _, v := range fpaov.values.([]*EnvFromSource) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsArgsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsCommandArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsEnvArrayOfValues() ([][]*EnvVar, bool) {
	res, ok := fpaov.values.([][]*EnvVar)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsImageArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsImagePullPolicyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsResourcesArrayOfValues() ([]*PodSpec_Container_ResourceRequirements, bool) {
	res, ok := fpaov.values.([]*PodSpec_Container_ResourceRequirements)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsSecurityContextArrayOfValues() ([]*SecurityContext, bool) {
	res, ok := fpaov.values.([]*SecurityContext)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsVolumeMountsArrayOfValues() ([][]*VolumeMount, bool) {
	res, ok := fpaov.values.([][]*VolumeMount)
	return res, ok
}
func (fpaov *PodSpecContainer_FieldTerminalPathArrayOfValues) AsEnvFromArrayOfValues() ([]*EnvFromSource, bool) {
	res, ok := fpaov.values.([]*EnvFromSource)
	return res, ok
}

type PodSpecContainer_FieldSubPathArrayOfValues struct {
	PodSpecContainer_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ PodSpecContainer_FieldPathArrayOfValues = (*PodSpecContainer_FieldSubPathArrayOfValues)(nil)

func (fpsaov *PodSpecContainer_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *PodSpecContainer_FieldSubPathArrayOfValues) AsEnvPathArrayOfValues() (EnvVar_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(EnvVar_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *PodSpecContainer_FieldSubPathArrayOfValues) AsResourcesPathArrayOfValues() (PodSpecContainerResourceRequirements_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(PodSpecContainerResourceRequirements_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *PodSpecContainer_FieldSubPathArrayOfValues) AsSecurityContextPathArrayOfValues() (SecurityContext_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(SecurityContext_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *PodSpecContainer_FieldSubPathArrayOfValues) AsVolumeMountsPathArrayOfValues() (VolumeMount_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(VolumeMount_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *PodSpecContainer_FieldSubPathArrayOfValues) AsEnvFromPathArrayOfValues() (EnvFromSource_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(EnvFromSource_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type PodSpecContainerResourceRequirements_FieldPath interface {
	gotenobject.FieldPath
	Selector() PodSpecContainerResourceRequirements_FieldPathSelector
	Get(source *PodSpec_Container_ResourceRequirements) []interface{}
	GetSingle(source *PodSpec_Container_ResourceRequirements) (interface{}, bool)
	ClearValue(item *PodSpec_Container_ResourceRequirements)

	// Those methods build corresponding PodSpecContainerResourceRequirements_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) PodSpecContainerResourceRequirements_FieldPathValue
	WithIArrayOfValues(values interface{}) PodSpecContainerResourceRequirements_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) PodSpecContainerResourceRequirements_FieldPathArrayItemValue
}

type PodSpecContainerResourceRequirements_FieldPathSelector int32

const (
	PodSpecContainerResourceRequirements_FieldPathSelectorLimits   PodSpecContainerResourceRequirements_FieldPathSelector = 0
	PodSpecContainerResourceRequirements_FieldPathSelectorRequests PodSpecContainerResourceRequirements_FieldPathSelector = 1
)

func (s PodSpecContainerResourceRequirements_FieldPathSelector) String() string {
	switch s {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		return "limits"
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		return "requests"
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", s))
	}
}

func BuildPodSpecContainerResourceRequirements_FieldPath(fp gotenobject.RawFieldPath) (PodSpecContainerResourceRequirements_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object PodSpec_Container_ResourceRequirements")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limits":
			return &PodSpecContainerResourceRequirements_FieldTerminalPath{selector: PodSpecContainerResourceRequirements_FieldPathSelectorLimits}, nil
		case "requests":
			return &PodSpecContainerResourceRequirements_FieldTerminalPath{selector: PodSpecContainerResourceRequirements_FieldPathSelectorRequests}, nil
		}
	} else {
		switch fp[0] {
		case "limits":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object PodSpec_Container_ResourceRequirements)", fp)
			}
			return &PodSpecContainerResourceRequirements_FieldPathMap{selector: PodSpecContainerResourceRequirements_FieldPathSelectorLimits, key: fp[1]}, nil
		case "requests":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object PodSpec_Container_ResourceRequirements)", fp)
			}
			return &PodSpecContainerResourceRequirements_FieldPathMap{selector: PodSpecContainerResourceRequirements_FieldPathSelectorRequests, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object PodSpec_Container_ResourceRequirements", fp)
}

func ParsePodSpecContainerResourceRequirements_FieldPath(rawField string) (PodSpecContainerResourceRequirements_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildPodSpecContainerResourceRequirements_FieldPath(fp)
}

func MustParsePodSpecContainerResourceRequirements_FieldPath(rawField string) PodSpecContainerResourceRequirements_FieldPath {
	fp, err := ParsePodSpecContainerResourceRequirements_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type PodSpecContainerResourceRequirements_FieldTerminalPath struct {
	selector PodSpecContainerResourceRequirements_FieldPathSelector
}

var _ PodSpecContainerResourceRequirements_FieldPath = (*PodSpecContainerResourceRequirements_FieldTerminalPath)(nil)

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) Selector() PodSpecContainerResourceRequirements_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source PodSpec_Container_ResourceRequirements
func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) Get(source *PodSpec_Container_ResourceRequirements) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
			values = append(values, source.Limits)
		case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
			values = append(values, source.Requests)
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fp.selector))
		}
	}
	return
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*PodSpec_Container_ResourceRequirements))
}

// GetSingle returns value pointed by specific field of from source PodSpec_Container_ResourceRequirements
func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) GetSingle(source *PodSpec_Container_ResourceRequirements) (interface{}, bool) {
	switch fp.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		res := source.GetLimits()
		return res, res != nil
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		res := source.GetRequests()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fp.selector))
	}
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*PodSpec_Container_ResourceRequirements))
}

// GetDefault returns a default value of the field type
func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		return (map[string]int64)(nil)
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		return (map[string]int64)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fp.selector))
	}
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) ClearValue(item *PodSpec_Container_ResourceRequirements) {
	if item != nil {
		switch fp.selector {
		case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
			item.Limits = nil
		case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
			item.Requests = nil
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fp.selector))
		}
	}
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*PodSpec_Container_ResourceRequirements))
}

// IsLeaf - whether field path is holds simple value
func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == PodSpecContainerResourceRequirements_FieldPathSelectorLimits ||
		fp.selector == PodSpecContainerResourceRequirements_FieldPathSelectorRequests
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) WithIValue(value interface{}) PodSpecContainerResourceRequirements_FieldPathValue {
	switch fp.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		return &PodSpecContainerResourceRequirements_FieldTerminalPathValue{PodSpecContainerResourceRequirements_FieldTerminalPath: *fp, value: value.(map[string]int64)}
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		return &PodSpecContainerResourceRequirements_FieldTerminalPathValue{PodSpecContainerResourceRequirements_FieldTerminalPath: *fp, value: value.(map[string]int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fp.selector))
	}
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) WithIArrayOfValues(values interface{}) PodSpecContainerResourceRequirements_FieldPathArrayOfValues {
	fpaov := &PodSpecContainerResourceRequirements_FieldTerminalPathArrayOfValues{PodSpecContainerResourceRequirements_FieldTerminalPath: *fp}
	switch fp.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		return &PodSpecContainerResourceRequirements_FieldTerminalPathArrayOfValues{PodSpecContainerResourceRequirements_FieldTerminalPath: *fp, values: values.([]map[string]int64)}
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		return &PodSpecContainerResourceRequirements_FieldTerminalPathArrayOfValues{PodSpecContainerResourceRequirements_FieldTerminalPath: *fp, values: values.([]map[string]int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fp.selector))
	}
	return fpaov
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) WithIArrayItemValue(value interface{}) PodSpecContainerResourceRequirements_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fp.selector))
	}
}

func (fp *PodSpecContainerResourceRequirements_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type PodSpecContainerResourceRequirements_FieldPathMap struct {
	key      string
	selector PodSpecContainerResourceRequirements_FieldPathSelector
}

var _ PodSpecContainerResourceRequirements_FieldPath = (*PodSpecContainerResourceRequirements_FieldPathMap)(nil)

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) Selector() PodSpecContainerResourceRequirements_FieldPathSelector {
	return fpm.selector
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source PodSpec_Container_ResourceRequirements
func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) Get(source *PodSpec_Container_ResourceRequirements) (values []interface{}) {
	switch fpm.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		if value, ok := source.GetLimits()[fpm.key]; ok {
			values = append(values, value)
		}
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		if value, ok := source.GetRequests()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpm.selector))
	}
	return
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*PodSpec_Container_ResourceRequirements))
}

// GetSingle returns value by selected field map key from source PodSpec_Container_ResourceRequirements
func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) GetSingle(source *PodSpec_Container_ResourceRequirements) (interface{}, bool) {
	switch fpm.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		res, ok := source.GetLimits()[fpm.key]
		return res, ok
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		res, ok := source.GetRequests()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpm.selector))
	}
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*PodSpec_Container_ResourceRequirements))
}

// GetDefault returns a default value of the field type
func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		var v int64
		return v
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		var v int64
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpm.selector))
	}
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) ClearValue(item *PodSpec_Container_ResourceRequirements) {
	if item != nil {
		switch fpm.selector {
		case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
			delete(item.Limits, fpm.key)
		case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
			delete(item.Requests, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpm.selector))
		}
	}
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*PodSpec_Container_ResourceRequirements))
}

// IsLeaf - whether field path is holds simple value
func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		return true
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		return true
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpm.selector))
	}
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) WithIValue(value interface{}) PodSpecContainerResourceRequirements_FieldPathValue {
	switch fpm.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		return &PodSpecContainerResourceRequirements_FieldPathMapValue{PodSpecContainerResourceRequirements_FieldPathMap: *fpm, value: value.(int64)}
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		return &PodSpecContainerResourceRequirements_FieldPathMapValue{PodSpecContainerResourceRequirements_FieldPathMap: *fpm, value: value.(int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpm.selector))
	}
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) WithIArrayOfValues(values interface{}) PodSpecContainerResourceRequirements_FieldPathArrayOfValues {
	switch fpm.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		return &PodSpecContainerResourceRequirements_FieldPathMapArrayOfValues{PodSpecContainerResourceRequirements_FieldPathMap: *fpm, values: values.([]int64)}
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		return &PodSpecContainerResourceRequirements_FieldPathMapArrayOfValues{PodSpecContainerResourceRequirements_FieldPathMap: *fpm, values: values.([]int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpm.selector))
	}
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) WithIArrayItemValue(value interface{}) PodSpecContainerResourceRequirements_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *PodSpecContainerResourceRequirements_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

// PodSpecContainerResourceRequirements_FieldPathValue allows storing values for ResourceRequirements fields according to their type
type PodSpecContainerResourceRequirements_FieldPathValue interface {
	PodSpecContainerResourceRequirements_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **PodSpec_Container_ResourceRequirements)
	CompareWith(*PodSpec_Container_ResourceRequirements) (cmp int, comparable bool)
}

func ParsePodSpecContainerResourceRequirements_FieldPathValue(pathStr, valueStr string) (PodSpecContainerResourceRequirements_FieldPathValue, error) {
	fp, err := ParsePodSpecContainerResourceRequirements_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResourceRequirements field path value from %s: %v", valueStr, err)
	}
	return fpv.(PodSpecContainerResourceRequirements_FieldPathValue), nil
}

func MustParsePodSpecContainerResourceRequirements_FieldPathValue(pathStr, valueStr string) PodSpecContainerResourceRequirements_FieldPathValue {
	fpv, err := ParsePodSpecContainerResourceRequirements_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type PodSpecContainerResourceRequirements_FieldTerminalPathValue struct {
	PodSpecContainerResourceRequirements_FieldTerminalPath
	value interface{}
}

var _ PodSpecContainerResourceRequirements_FieldPathValue = (*PodSpecContainerResourceRequirements_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ResourceRequirements' as interface{}
func (fpv *PodSpecContainerResourceRequirements_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *PodSpecContainerResourceRequirements_FieldTerminalPathValue) AsLimitsValue() (map[string]int64, bool) {
	res, ok := fpv.value.(map[string]int64)
	return res, ok
}
func (fpv *PodSpecContainerResourceRequirements_FieldTerminalPathValue) AsRequestsValue() (map[string]int64, bool) {
	res, ok := fpv.value.(map[string]int64)
	return res, ok
}

// SetTo stores value for selected field for object ResourceRequirements
func (fpv *PodSpecContainerResourceRequirements_FieldTerminalPathValue) SetTo(target **PodSpec_Container_ResourceRequirements) {
	if *target == nil {
		*target = new(PodSpec_Container_ResourceRequirements)
	}
	switch fpv.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		(*target).Limits = fpv.value.(map[string]int64)
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		(*target).Requests = fpv.value.(map[string]int64)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpv.selector))
	}
}

func (fpv *PodSpecContainerResourceRequirements_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*PodSpec_Container_ResourceRequirements)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'PodSpecContainerResourceRequirements_FieldTerminalPathValue' with the value under path in 'PodSpec_Container_ResourceRequirements'.
func (fpv *PodSpecContainerResourceRequirements_FieldTerminalPathValue) CompareWith(source *PodSpec_Container_ResourceRequirements) (int, bool) {
	switch fpv.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		return 0, false
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpv.selector))
	}
}

func (fpv *PodSpecContainerResourceRequirements_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*PodSpec_Container_ResourceRequirements))
}

type PodSpecContainerResourceRequirements_FieldPathMapValue struct {
	PodSpecContainerResourceRequirements_FieldPathMap
	value interface{}
}

var _ PodSpecContainerResourceRequirements_FieldPathValue = (*PodSpecContainerResourceRequirements_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in ResourceRequirements as interface{}
func (fpmv *PodSpecContainerResourceRequirements_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *PodSpecContainerResourceRequirements_FieldPathMapValue) AsLimitsElementValue() (int64, bool) {
	res, ok := fpmv.value.(int64)
	return res, ok
}
func (fpmv *PodSpecContainerResourceRequirements_FieldPathMapValue) AsRequestsElementValue() (int64, bool) {
	res, ok := fpmv.value.(int64)
	return res, ok
}

// SetTo stores value for selected field in ResourceRequirements
func (fpmv *PodSpecContainerResourceRequirements_FieldPathMapValue) SetTo(target **PodSpec_Container_ResourceRequirements) {
	if *target == nil {
		*target = new(PodSpec_Container_ResourceRequirements)
	}
	switch fpmv.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		if (*target).Limits == nil {
			(*target).Limits = make(map[string]int64)
		}
		(*target).Limits[fpmv.key] = fpmv.value.(int64)
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		if (*target).Requests == nil {
			(*target).Requests = make(map[string]int64)
		}
		(*target).Requests[fpmv.key] = fpmv.value.(int64)
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpmv.selector))
	}
}

func (fpmv *PodSpecContainerResourceRequirements_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*PodSpec_Container_ResourceRequirements)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'PodSpecContainerResourceRequirements_FieldPathMapValue' with the value under path in 'PodSpec_Container_ResourceRequirements'.
func (fpmv *PodSpecContainerResourceRequirements_FieldPathMapValue) CompareWith(source *PodSpec_Container_ResourceRequirements) (int, bool) {
	switch fpmv.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		leftValue := fpmv.value.(int64)
		rightValue := source.GetLimits()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		leftValue := fpmv.value.(int64)
		rightValue := source.GetRequests()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for PodSpec_Container_ResourceRequirements: %d", fpmv.selector))
	}
}

func (fpmv *PodSpecContainerResourceRequirements_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*PodSpec_Container_ResourceRequirements))
}

// PodSpecContainerResourceRequirements_FieldPathArrayItemValue allows storing single item in Path-specific values for ResourceRequirements according to their type
// Present only for array (repeated) types.
type PodSpecContainerResourceRequirements_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	PodSpecContainerResourceRequirements_FieldPath
	ContainsValue(*PodSpec_Container_ResourceRequirements) bool
}

// ParsePodSpecContainerResourceRequirements_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParsePodSpecContainerResourceRequirements_FieldPathArrayItemValue(pathStr, valueStr string) (PodSpecContainerResourceRequirements_FieldPathArrayItemValue, error) {
	fp, err := ParsePodSpecContainerResourceRequirements_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResourceRequirements field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(PodSpecContainerResourceRequirements_FieldPathArrayItemValue), nil
}

func MustParsePodSpecContainerResourceRequirements_FieldPathArrayItemValue(pathStr, valueStr string) PodSpecContainerResourceRequirements_FieldPathArrayItemValue {
	fpaiv, err := ParsePodSpecContainerResourceRequirements_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type PodSpecContainerResourceRequirements_FieldTerminalPathArrayItemValue struct {
	PodSpecContainerResourceRequirements_FieldTerminalPath
	value interface{}
}

var _ PodSpecContainerResourceRequirements_FieldPathArrayItemValue = (*PodSpecContainerResourceRequirements_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object PodSpec_Container_ResourceRequirements as interface{}
func (fpaiv *PodSpecContainerResourceRequirements_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *PodSpecContainerResourceRequirements_FieldTerminalPathArrayItemValue) GetSingle(source *PodSpec_Container_ResourceRequirements) (interface{}, bool) {
	return nil, false
}

func (fpaiv *PodSpecContainerResourceRequirements_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*PodSpec_Container_ResourceRequirements))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ResourceRequirements'
func (fpaiv *PodSpecContainerResourceRequirements_FieldTerminalPathArrayItemValue) ContainsValue(source *PodSpec_Container_ResourceRequirements) bool {
	slice := fpaiv.PodSpecContainerResourceRequirements_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// PodSpecContainerResourceRequirements_FieldPathArrayOfValues allows storing slice of values for ResourceRequirements fields according to their type
type PodSpecContainerResourceRequirements_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	PodSpecContainerResourceRequirements_FieldPath
}

func ParsePodSpecContainerResourceRequirements_FieldPathArrayOfValues(pathStr, valuesStr string) (PodSpecContainerResourceRequirements_FieldPathArrayOfValues, error) {
	fp, err := ParsePodSpecContainerResourceRequirements_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ResourceRequirements field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(PodSpecContainerResourceRequirements_FieldPathArrayOfValues), nil
}

func MustParsePodSpecContainerResourceRequirements_FieldPathArrayOfValues(pathStr, valuesStr string) PodSpecContainerResourceRequirements_FieldPathArrayOfValues {
	fpaov, err := ParsePodSpecContainerResourceRequirements_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type PodSpecContainerResourceRequirements_FieldTerminalPathArrayOfValues struct {
	PodSpecContainerResourceRequirements_FieldTerminalPath
	values interface{}
}

var _ PodSpecContainerResourceRequirements_FieldPathArrayOfValues = (*PodSpecContainerResourceRequirements_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *PodSpecContainerResourceRequirements_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		for _, v := range fpaov.values.([]map[string]int64) {
			values = append(values, v)
		}
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		for _, v := range fpaov.values.([]map[string]int64) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *PodSpecContainerResourceRequirements_FieldTerminalPathArrayOfValues) AsLimitsArrayOfValues() ([]map[string]int64, bool) {
	res, ok := fpaov.values.([]map[string]int64)
	return res, ok
}
func (fpaov *PodSpecContainerResourceRequirements_FieldTerminalPathArrayOfValues) AsRequestsArrayOfValues() ([]map[string]int64, bool) {
	res, ok := fpaov.values.([]map[string]int64)
	return res, ok
}

type PodSpecContainerResourceRequirements_FieldPathMapArrayOfValues struct {
	PodSpecContainerResourceRequirements_FieldPathMap
	values interface{}
}

var _ PodSpecContainerResourceRequirements_FieldPathArrayOfValues = (*PodSpecContainerResourceRequirements_FieldPathMapArrayOfValues)(nil)

func (fpmaov *PodSpecContainerResourceRequirements_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case PodSpecContainerResourceRequirements_FieldPathSelectorLimits:
		for _, v := range fpmaov.values.([]int64) {
			values = append(values, v)
		}
	case PodSpecContainerResourceRequirements_FieldPathSelectorRequests:
		for _, v := range fpmaov.values.([]int64) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *PodSpecContainerResourceRequirements_FieldPathMapArrayOfValues) AsLimitsArrayOfElementValues() ([]int64, bool) {
	res, ok := fpmaov.values.([]int64)
	return res, ok
}
func (fpmaov *PodSpecContainerResourceRequirements_FieldPathMapArrayOfValues) AsRequestsArrayOfElementValues() ([]int64, bool) {
	res, ok := fpmaov.values.([]int64)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type EnvFromSource_FieldPath interface {
	gotenobject.FieldPath
	Selector() EnvFromSource_FieldPathSelector
	Get(source *EnvFromSource) []interface{}
	GetSingle(source *EnvFromSource) (interface{}, bool)
	ClearValue(item *EnvFromSource)

	// Those methods build corresponding EnvFromSource_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) EnvFromSource_FieldPathValue
	WithIArrayOfValues(values interface{}) EnvFromSource_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) EnvFromSource_FieldPathArrayItemValue
}

type EnvFromSource_FieldPathSelector int32

const (
	EnvFromSource_FieldPathSelectorPrefix       EnvFromSource_FieldPathSelector = 0
	EnvFromSource_FieldPathSelectorConfigMapRef EnvFromSource_FieldPathSelector = 1
	EnvFromSource_FieldPathSelectorSecretRef    EnvFromSource_FieldPathSelector = 2
)

func (s EnvFromSource_FieldPathSelector) String() string {
	switch s {
	case EnvFromSource_FieldPathSelectorPrefix:
		return "prefix"
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		return "config_map_ref"
	case EnvFromSource_FieldPathSelectorSecretRef:
		return "secret_ref"
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", s))
	}
}

func BuildEnvFromSource_FieldPath(fp gotenobject.RawFieldPath) (EnvFromSource_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object EnvFromSource")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "prefix":
			return &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorPrefix}, nil
		case "config_map_ref", "configMapRef", "config-map-ref":
			return &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorConfigMapRef}, nil
		case "secret_ref", "secretRef", "secret-ref":
			return &EnvFromSource_FieldTerminalPath{selector: EnvFromSource_FieldPathSelectorSecretRef}, nil
		}
	} else {
		switch fp[0] {
		case "config_map_ref", "configMapRef", "config-map-ref":
			if subpath, err := BuildConfigMapEnvSource_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &EnvFromSource_FieldSubPath{selector: EnvFromSource_FieldPathSelectorConfigMapRef, subPath: subpath}, nil
			}
		case "secret_ref", "secretRef", "secret-ref":
			if subpath, err := BuildSecretEnvSource_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &EnvFromSource_FieldSubPath{selector: EnvFromSource_FieldPathSelectorSecretRef, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object EnvFromSource", fp)
}

func ParseEnvFromSource_FieldPath(rawField string) (EnvFromSource_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildEnvFromSource_FieldPath(fp)
}

func MustParseEnvFromSource_FieldPath(rawField string) EnvFromSource_FieldPath {
	fp, err := ParseEnvFromSource_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type EnvFromSource_FieldTerminalPath struct {
	selector EnvFromSource_FieldPathSelector
}

var _ EnvFromSource_FieldPath = (*EnvFromSource_FieldTerminalPath)(nil)

func (fp *EnvFromSource_FieldTerminalPath) Selector() EnvFromSource_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *EnvFromSource_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *EnvFromSource_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source EnvFromSource
func (fp *EnvFromSource_FieldTerminalPath) Get(source *EnvFromSource) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case EnvFromSource_FieldPathSelectorPrefix:
			values = append(values, source.Prefix)
		case EnvFromSource_FieldPathSelectorConfigMapRef:
			if source.ConfigMapRef != nil {
				values = append(values, source.ConfigMapRef)
			}
		case EnvFromSource_FieldPathSelectorSecretRef:
			if source.SecretRef != nil {
				values = append(values, source.SecretRef)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fp.selector))
		}
	}
	return
}

func (fp *EnvFromSource_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*EnvFromSource))
}

// GetSingle returns value pointed by specific field of from source EnvFromSource
func (fp *EnvFromSource_FieldTerminalPath) GetSingle(source *EnvFromSource) (interface{}, bool) {
	switch fp.selector {
	case EnvFromSource_FieldPathSelectorPrefix:
		return source.GetPrefix(), source != nil
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		res := source.GetConfigMapRef()
		return res, res != nil
	case EnvFromSource_FieldPathSelectorSecretRef:
		res := source.GetSecretRef()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fp.selector))
	}
}

func (fp *EnvFromSource_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*EnvFromSource))
}

// GetDefault returns a default value of the field type
func (fp *EnvFromSource_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case EnvFromSource_FieldPathSelectorPrefix:
		return ""
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		return (*ConfigMapEnvSource)(nil)
	case EnvFromSource_FieldPathSelectorSecretRef:
		return (*SecretEnvSource)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fp.selector))
	}
}

func (fp *EnvFromSource_FieldTerminalPath) ClearValue(item *EnvFromSource) {
	if item != nil {
		switch fp.selector {
		case EnvFromSource_FieldPathSelectorPrefix:
			item.Prefix = ""
		case EnvFromSource_FieldPathSelectorConfigMapRef:
			item.ConfigMapRef = nil
		case EnvFromSource_FieldPathSelectorSecretRef:
			item.SecretRef = nil
		default:
			panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fp.selector))
		}
	}
}

func (fp *EnvFromSource_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*EnvFromSource))
}

// IsLeaf - whether field path is holds simple value
func (fp *EnvFromSource_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == EnvFromSource_FieldPathSelectorPrefix
}

func (fp *EnvFromSource_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *EnvFromSource_FieldTerminalPath) WithIValue(value interface{}) EnvFromSource_FieldPathValue {
	switch fp.selector {
	case EnvFromSource_FieldPathSelectorPrefix:
		return &EnvFromSource_FieldTerminalPathValue{EnvFromSource_FieldTerminalPath: *fp, value: value.(string)}
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		return &EnvFromSource_FieldTerminalPathValue{EnvFromSource_FieldTerminalPath: *fp, value: value.(*ConfigMapEnvSource)}
	case EnvFromSource_FieldPathSelectorSecretRef:
		return &EnvFromSource_FieldTerminalPathValue{EnvFromSource_FieldTerminalPath: *fp, value: value.(*SecretEnvSource)}
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fp.selector))
	}
}

func (fp *EnvFromSource_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *EnvFromSource_FieldTerminalPath) WithIArrayOfValues(values interface{}) EnvFromSource_FieldPathArrayOfValues {
	fpaov := &EnvFromSource_FieldTerminalPathArrayOfValues{EnvFromSource_FieldTerminalPath: *fp}
	switch fp.selector {
	case EnvFromSource_FieldPathSelectorPrefix:
		return &EnvFromSource_FieldTerminalPathArrayOfValues{EnvFromSource_FieldTerminalPath: *fp, values: values.([]string)}
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		return &EnvFromSource_FieldTerminalPathArrayOfValues{EnvFromSource_FieldTerminalPath: *fp, values: values.([]*ConfigMapEnvSource)}
	case EnvFromSource_FieldPathSelectorSecretRef:
		return &EnvFromSource_FieldTerminalPathArrayOfValues{EnvFromSource_FieldTerminalPath: *fp, values: values.([]*SecretEnvSource)}
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fp.selector))
	}
	return fpaov
}

func (fp *EnvFromSource_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *EnvFromSource_FieldTerminalPath) WithIArrayItemValue(value interface{}) EnvFromSource_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fp.selector))
	}
}

func (fp *EnvFromSource_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type EnvFromSource_FieldSubPath struct {
	selector EnvFromSource_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ EnvFromSource_FieldPath = (*EnvFromSource_FieldSubPath)(nil)

func (fps *EnvFromSource_FieldSubPath) Selector() EnvFromSource_FieldPathSelector {
	return fps.selector
}
func (fps *EnvFromSource_FieldSubPath) AsConfigMapRefSubPath() (ConfigMapEnvSource_FieldPath, bool) {
	res, ok := fps.subPath.(ConfigMapEnvSource_FieldPath)
	return res, ok
}
func (fps *EnvFromSource_FieldSubPath) AsSecretRefSubPath() (SecretEnvSource_FieldPath, bool) {
	res, ok := fps.subPath.(SecretEnvSource_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *EnvFromSource_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *EnvFromSource_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source EnvFromSource
func (fps *EnvFromSource_FieldSubPath) Get(source *EnvFromSource) (values []interface{}) {
	switch fps.selector {
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		values = append(values, fps.subPath.GetRaw(source.GetConfigMapRef())...)
	case EnvFromSource_FieldPathSelectorSecretRef:
		values = append(values, fps.subPath.GetRaw(source.GetSecretRef())...)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fps.selector))
	}
	return
}

func (fps *EnvFromSource_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*EnvFromSource))
}

// GetSingle returns value of selected field from source EnvFromSource
func (fps *EnvFromSource_FieldSubPath) GetSingle(source *EnvFromSource) (interface{}, bool) {
	switch fps.selector {
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		if source.GetConfigMapRef() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetConfigMapRef())
	case EnvFromSource_FieldPathSelectorSecretRef:
		if source.GetSecretRef() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetSecretRef())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fps.selector))
	}
}

func (fps *EnvFromSource_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*EnvFromSource))
}

// GetDefault returns a default value of the field type
func (fps *EnvFromSource_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *EnvFromSource_FieldSubPath) ClearValue(item *EnvFromSource) {
	if item != nil {
		switch fps.selector {
		case EnvFromSource_FieldPathSelectorConfigMapRef:
			fps.subPath.ClearValueRaw(item.ConfigMapRef)
		case EnvFromSource_FieldPathSelectorSecretRef:
			fps.subPath.ClearValueRaw(item.SecretRef)
		default:
			panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fps.selector))
		}
	}
}

func (fps *EnvFromSource_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*EnvFromSource))
}

// IsLeaf - whether field path is holds simple value
func (fps *EnvFromSource_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *EnvFromSource_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&EnvFromSource_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *EnvFromSource_FieldSubPath) WithIValue(value interface{}) EnvFromSource_FieldPathValue {
	return &EnvFromSource_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *EnvFromSource_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *EnvFromSource_FieldSubPath) WithIArrayOfValues(values interface{}) EnvFromSource_FieldPathArrayOfValues {
	return &EnvFromSource_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *EnvFromSource_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *EnvFromSource_FieldSubPath) WithIArrayItemValue(value interface{}) EnvFromSource_FieldPathArrayItemValue {
	return &EnvFromSource_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *EnvFromSource_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// EnvFromSource_FieldPathValue allows storing values for EnvFromSource fields according to their type
type EnvFromSource_FieldPathValue interface {
	EnvFromSource_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **EnvFromSource)
	CompareWith(*EnvFromSource) (cmp int, comparable bool)
}

func ParseEnvFromSource_FieldPathValue(pathStr, valueStr string) (EnvFromSource_FieldPathValue, error) {
	fp, err := ParseEnvFromSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvFromSource field path value from %s: %v", valueStr, err)
	}
	return fpv.(EnvFromSource_FieldPathValue), nil
}

func MustParseEnvFromSource_FieldPathValue(pathStr, valueStr string) EnvFromSource_FieldPathValue {
	fpv, err := ParseEnvFromSource_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type EnvFromSource_FieldTerminalPathValue struct {
	EnvFromSource_FieldTerminalPath
	value interface{}
}

var _ EnvFromSource_FieldPathValue = (*EnvFromSource_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'EnvFromSource' as interface{}
func (fpv *EnvFromSource_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *EnvFromSource_FieldTerminalPathValue) AsPrefixValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *EnvFromSource_FieldTerminalPathValue) AsConfigMapRefValue() (*ConfigMapEnvSource, bool) {
	res, ok := fpv.value.(*ConfigMapEnvSource)
	return res, ok
}
func (fpv *EnvFromSource_FieldTerminalPathValue) AsSecretRefValue() (*SecretEnvSource, bool) {
	res, ok := fpv.value.(*SecretEnvSource)
	return res, ok
}

// SetTo stores value for selected field for object EnvFromSource
func (fpv *EnvFromSource_FieldTerminalPathValue) SetTo(target **EnvFromSource) {
	if *target == nil {
		*target = new(EnvFromSource)
	}
	switch fpv.selector {
	case EnvFromSource_FieldPathSelectorPrefix:
		(*target).Prefix = fpv.value.(string)
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		(*target).ConfigMapRef = fpv.value.(*ConfigMapEnvSource)
	case EnvFromSource_FieldPathSelectorSecretRef:
		(*target).SecretRef = fpv.value.(*SecretEnvSource)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fpv.selector))
	}
}

func (fpv *EnvFromSource_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*EnvFromSource)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'EnvFromSource_FieldTerminalPathValue' with the value under path in 'EnvFromSource'.
func (fpv *EnvFromSource_FieldTerminalPathValue) CompareWith(source *EnvFromSource) (int, bool) {
	switch fpv.selector {
	case EnvFromSource_FieldPathSelectorPrefix:
		leftValue := fpv.value.(string)
		rightValue := source.GetPrefix()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		return 0, false
	case EnvFromSource_FieldPathSelectorSecretRef:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fpv.selector))
	}
}

func (fpv *EnvFromSource_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*EnvFromSource))
}

type EnvFromSource_FieldSubPathValue struct {
	EnvFromSource_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ EnvFromSource_FieldPathValue = (*EnvFromSource_FieldSubPathValue)(nil)

func (fpvs *EnvFromSource_FieldSubPathValue) AsConfigMapRefPathValue() (ConfigMapEnvSource_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ConfigMapEnvSource_FieldPathValue)
	return res, ok
}
func (fpvs *EnvFromSource_FieldSubPathValue) AsSecretRefPathValue() (SecretEnvSource_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(SecretEnvSource_FieldPathValue)
	return res, ok
}

func (fpvs *EnvFromSource_FieldSubPathValue) SetTo(target **EnvFromSource) {
	if *target == nil {
		*target = new(EnvFromSource)
	}
	switch fpvs.Selector() {
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		fpvs.subPathValue.(ConfigMapEnvSource_FieldPathValue).SetTo(&(*target).ConfigMapRef)
	case EnvFromSource_FieldPathSelectorSecretRef:
		fpvs.subPathValue.(SecretEnvSource_FieldPathValue).SetTo(&(*target).SecretRef)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fpvs.Selector()))
	}
}

func (fpvs *EnvFromSource_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*EnvFromSource)
	fpvs.SetTo(&typedObject)
}

func (fpvs *EnvFromSource_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *EnvFromSource_FieldSubPathValue) CompareWith(source *EnvFromSource) (int, bool) {
	switch fpvs.Selector() {
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		return fpvs.subPathValue.(ConfigMapEnvSource_FieldPathValue).CompareWith(source.GetConfigMapRef())
	case EnvFromSource_FieldPathSelectorSecretRef:
		return fpvs.subPathValue.(SecretEnvSource_FieldPathValue).CompareWith(source.GetSecretRef())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fpvs.Selector()))
	}
}

func (fpvs *EnvFromSource_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*EnvFromSource))
}

// EnvFromSource_FieldPathArrayItemValue allows storing single item in Path-specific values for EnvFromSource according to their type
// Present only for array (repeated) types.
type EnvFromSource_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	EnvFromSource_FieldPath
	ContainsValue(*EnvFromSource) bool
}

// ParseEnvFromSource_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseEnvFromSource_FieldPathArrayItemValue(pathStr, valueStr string) (EnvFromSource_FieldPathArrayItemValue, error) {
	fp, err := ParseEnvFromSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvFromSource field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(EnvFromSource_FieldPathArrayItemValue), nil
}

func MustParseEnvFromSource_FieldPathArrayItemValue(pathStr, valueStr string) EnvFromSource_FieldPathArrayItemValue {
	fpaiv, err := ParseEnvFromSource_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type EnvFromSource_FieldTerminalPathArrayItemValue struct {
	EnvFromSource_FieldTerminalPath
	value interface{}
}

var _ EnvFromSource_FieldPathArrayItemValue = (*EnvFromSource_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object EnvFromSource as interface{}
func (fpaiv *EnvFromSource_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *EnvFromSource_FieldTerminalPathArrayItemValue) GetSingle(source *EnvFromSource) (interface{}, bool) {
	return nil, false
}

func (fpaiv *EnvFromSource_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*EnvFromSource))
}

// Contains returns a boolean indicating if value that is being held is present in given 'EnvFromSource'
func (fpaiv *EnvFromSource_FieldTerminalPathArrayItemValue) ContainsValue(source *EnvFromSource) bool {
	slice := fpaiv.EnvFromSource_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type EnvFromSource_FieldSubPathArrayItemValue struct {
	EnvFromSource_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *EnvFromSource_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *EnvFromSource_FieldSubPathArrayItemValue) AsConfigMapRefPathItemValue() (ConfigMapEnvSource_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ConfigMapEnvSource_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *EnvFromSource_FieldSubPathArrayItemValue) AsSecretRefPathItemValue() (SecretEnvSource_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(SecretEnvSource_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'EnvFromSource'
func (fpaivs *EnvFromSource_FieldSubPathArrayItemValue) ContainsValue(source *EnvFromSource) bool {
	switch fpaivs.Selector() {
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		return fpaivs.subPathItemValue.(ConfigMapEnvSource_FieldPathArrayItemValue).ContainsValue(source.GetConfigMapRef())
	case EnvFromSource_FieldPathSelectorSecretRef:
		return fpaivs.subPathItemValue.(SecretEnvSource_FieldPathArrayItemValue).ContainsValue(source.GetSecretRef())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvFromSource: %d", fpaivs.Selector()))
	}
}

// EnvFromSource_FieldPathArrayOfValues allows storing slice of values for EnvFromSource fields according to their type
type EnvFromSource_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	EnvFromSource_FieldPath
}

func ParseEnvFromSource_FieldPathArrayOfValues(pathStr, valuesStr string) (EnvFromSource_FieldPathArrayOfValues, error) {
	fp, err := ParseEnvFromSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvFromSource field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(EnvFromSource_FieldPathArrayOfValues), nil
}

func MustParseEnvFromSource_FieldPathArrayOfValues(pathStr, valuesStr string) EnvFromSource_FieldPathArrayOfValues {
	fpaov, err := ParseEnvFromSource_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type EnvFromSource_FieldTerminalPathArrayOfValues struct {
	EnvFromSource_FieldTerminalPath
	values interface{}
}

var _ EnvFromSource_FieldPathArrayOfValues = (*EnvFromSource_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *EnvFromSource_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case EnvFromSource_FieldPathSelectorPrefix:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case EnvFromSource_FieldPathSelectorConfigMapRef:
		for _, v := range fpaov.values.([]*ConfigMapEnvSource) {
			values = append(values, v)
		}
	case EnvFromSource_FieldPathSelectorSecretRef:
		for _, v := range fpaov.values.([]*SecretEnvSource) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *EnvFromSource_FieldTerminalPathArrayOfValues) AsPrefixArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *EnvFromSource_FieldTerminalPathArrayOfValues) AsConfigMapRefArrayOfValues() ([]*ConfigMapEnvSource, bool) {
	res, ok := fpaov.values.([]*ConfigMapEnvSource)
	return res, ok
}
func (fpaov *EnvFromSource_FieldTerminalPathArrayOfValues) AsSecretRefArrayOfValues() ([]*SecretEnvSource, bool) {
	res, ok := fpaov.values.([]*SecretEnvSource)
	return res, ok
}

type EnvFromSource_FieldSubPathArrayOfValues struct {
	EnvFromSource_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ EnvFromSource_FieldPathArrayOfValues = (*EnvFromSource_FieldSubPathArrayOfValues)(nil)

func (fpsaov *EnvFromSource_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *EnvFromSource_FieldSubPathArrayOfValues) AsConfigMapRefPathArrayOfValues() (ConfigMapEnvSource_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ConfigMapEnvSource_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *EnvFromSource_FieldSubPathArrayOfValues) AsSecretRefPathArrayOfValues() (SecretEnvSource_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(SecretEnvSource_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type EnvVar_FieldPath interface {
	gotenobject.FieldPath
	Selector() EnvVar_FieldPathSelector
	Get(source *EnvVar) []interface{}
	GetSingle(source *EnvVar) (interface{}, bool)
	ClearValue(item *EnvVar)

	// Those methods build corresponding EnvVar_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) EnvVar_FieldPathValue
	WithIArrayOfValues(values interface{}) EnvVar_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) EnvVar_FieldPathArrayItemValue
}

type EnvVar_FieldPathSelector int32

const (
	EnvVar_FieldPathSelectorName      EnvVar_FieldPathSelector = 0
	EnvVar_FieldPathSelectorValue     EnvVar_FieldPathSelector = 1
	EnvVar_FieldPathSelectorValueFrom EnvVar_FieldPathSelector = 2
)

func (s EnvVar_FieldPathSelector) String() string {
	switch s {
	case EnvVar_FieldPathSelectorName:
		return "name"
	case EnvVar_FieldPathSelectorValue:
		return "value"
	case EnvVar_FieldPathSelectorValueFrom:
		return "value_from"
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", s))
	}
}

func BuildEnvVar_FieldPath(fp gotenobject.RawFieldPath) (EnvVar_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object EnvVar")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorName}, nil
		case "value":
			return &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorValue}, nil
		case "value_from", "valueFrom", "value-from":
			return &EnvVar_FieldTerminalPath{selector: EnvVar_FieldPathSelectorValueFrom}, nil
		}
	} else {
		switch fp[0] {
		case "value_from", "valueFrom", "value-from":
			if subpath, err := BuildEnvVarSource_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &EnvVar_FieldSubPath{selector: EnvVar_FieldPathSelectorValueFrom, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object EnvVar", fp)
}

func ParseEnvVar_FieldPath(rawField string) (EnvVar_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildEnvVar_FieldPath(fp)
}

func MustParseEnvVar_FieldPath(rawField string) EnvVar_FieldPath {
	fp, err := ParseEnvVar_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type EnvVar_FieldTerminalPath struct {
	selector EnvVar_FieldPathSelector
}

var _ EnvVar_FieldPath = (*EnvVar_FieldTerminalPath)(nil)

func (fp *EnvVar_FieldTerminalPath) Selector() EnvVar_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *EnvVar_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *EnvVar_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source EnvVar
func (fp *EnvVar_FieldTerminalPath) Get(source *EnvVar) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case EnvVar_FieldPathSelectorName:
			values = append(values, source.Name)
		case EnvVar_FieldPathSelectorValue:
			values = append(values, source.Value)
		case EnvVar_FieldPathSelectorValueFrom:
			if source.ValueFrom != nil {
				values = append(values, source.ValueFrom)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fp.selector))
		}
	}
	return
}

func (fp *EnvVar_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*EnvVar))
}

// GetSingle returns value pointed by specific field of from source EnvVar
func (fp *EnvVar_FieldTerminalPath) GetSingle(source *EnvVar) (interface{}, bool) {
	switch fp.selector {
	case EnvVar_FieldPathSelectorName:
		return source.GetName(), source != nil
	case EnvVar_FieldPathSelectorValue:
		return source.GetValue(), source != nil
	case EnvVar_FieldPathSelectorValueFrom:
		res := source.GetValueFrom()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fp.selector))
	}
}

func (fp *EnvVar_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*EnvVar))
}

// GetDefault returns a default value of the field type
func (fp *EnvVar_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case EnvVar_FieldPathSelectorName:
		return ""
	case EnvVar_FieldPathSelectorValue:
		return ""
	case EnvVar_FieldPathSelectorValueFrom:
		return (*EnvVarSource)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fp.selector))
	}
}

func (fp *EnvVar_FieldTerminalPath) ClearValue(item *EnvVar) {
	if item != nil {
		switch fp.selector {
		case EnvVar_FieldPathSelectorName:
			item.Name = ""
		case EnvVar_FieldPathSelectorValue:
			item.Value = ""
		case EnvVar_FieldPathSelectorValueFrom:
			item.ValueFrom = nil
		default:
			panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fp.selector))
		}
	}
}

func (fp *EnvVar_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*EnvVar))
}

// IsLeaf - whether field path is holds simple value
func (fp *EnvVar_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == EnvVar_FieldPathSelectorName ||
		fp.selector == EnvVar_FieldPathSelectorValue
}

func (fp *EnvVar_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *EnvVar_FieldTerminalPath) WithIValue(value interface{}) EnvVar_FieldPathValue {
	switch fp.selector {
	case EnvVar_FieldPathSelectorName:
		return &EnvVar_FieldTerminalPathValue{EnvVar_FieldTerminalPath: *fp, value: value.(string)}
	case EnvVar_FieldPathSelectorValue:
		return &EnvVar_FieldTerminalPathValue{EnvVar_FieldTerminalPath: *fp, value: value.(string)}
	case EnvVar_FieldPathSelectorValueFrom:
		return &EnvVar_FieldTerminalPathValue{EnvVar_FieldTerminalPath: *fp, value: value.(*EnvVarSource)}
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fp.selector))
	}
}

func (fp *EnvVar_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *EnvVar_FieldTerminalPath) WithIArrayOfValues(values interface{}) EnvVar_FieldPathArrayOfValues {
	fpaov := &EnvVar_FieldTerminalPathArrayOfValues{EnvVar_FieldTerminalPath: *fp}
	switch fp.selector {
	case EnvVar_FieldPathSelectorName:
		return &EnvVar_FieldTerminalPathArrayOfValues{EnvVar_FieldTerminalPath: *fp, values: values.([]string)}
	case EnvVar_FieldPathSelectorValue:
		return &EnvVar_FieldTerminalPathArrayOfValues{EnvVar_FieldTerminalPath: *fp, values: values.([]string)}
	case EnvVar_FieldPathSelectorValueFrom:
		return &EnvVar_FieldTerminalPathArrayOfValues{EnvVar_FieldTerminalPath: *fp, values: values.([]*EnvVarSource)}
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fp.selector))
	}
	return fpaov
}

func (fp *EnvVar_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *EnvVar_FieldTerminalPath) WithIArrayItemValue(value interface{}) EnvVar_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fp.selector))
	}
}

func (fp *EnvVar_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type EnvVar_FieldSubPath struct {
	selector EnvVar_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ EnvVar_FieldPath = (*EnvVar_FieldSubPath)(nil)

func (fps *EnvVar_FieldSubPath) Selector() EnvVar_FieldPathSelector {
	return fps.selector
}
func (fps *EnvVar_FieldSubPath) AsValueFromSubPath() (EnvVarSource_FieldPath, bool) {
	res, ok := fps.subPath.(EnvVarSource_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *EnvVar_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *EnvVar_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source EnvVar
func (fps *EnvVar_FieldSubPath) Get(source *EnvVar) (values []interface{}) {
	switch fps.selector {
	case EnvVar_FieldPathSelectorValueFrom:
		values = append(values, fps.subPath.GetRaw(source.GetValueFrom())...)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fps.selector))
	}
	return
}

func (fps *EnvVar_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*EnvVar))
}

// GetSingle returns value of selected field from source EnvVar
func (fps *EnvVar_FieldSubPath) GetSingle(source *EnvVar) (interface{}, bool) {
	switch fps.selector {
	case EnvVar_FieldPathSelectorValueFrom:
		if source.GetValueFrom() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetValueFrom())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fps.selector))
	}
}

func (fps *EnvVar_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*EnvVar))
}

// GetDefault returns a default value of the field type
func (fps *EnvVar_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *EnvVar_FieldSubPath) ClearValue(item *EnvVar) {
	if item != nil {
		switch fps.selector {
		case EnvVar_FieldPathSelectorValueFrom:
			fps.subPath.ClearValueRaw(item.ValueFrom)
		default:
			panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fps.selector))
		}
	}
}

func (fps *EnvVar_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*EnvVar))
}

// IsLeaf - whether field path is holds simple value
func (fps *EnvVar_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *EnvVar_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&EnvVar_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *EnvVar_FieldSubPath) WithIValue(value interface{}) EnvVar_FieldPathValue {
	return &EnvVar_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *EnvVar_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *EnvVar_FieldSubPath) WithIArrayOfValues(values interface{}) EnvVar_FieldPathArrayOfValues {
	return &EnvVar_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *EnvVar_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *EnvVar_FieldSubPath) WithIArrayItemValue(value interface{}) EnvVar_FieldPathArrayItemValue {
	return &EnvVar_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *EnvVar_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// EnvVar_FieldPathValue allows storing values for EnvVar fields according to their type
type EnvVar_FieldPathValue interface {
	EnvVar_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **EnvVar)
	CompareWith(*EnvVar) (cmp int, comparable bool)
}

func ParseEnvVar_FieldPathValue(pathStr, valueStr string) (EnvVar_FieldPathValue, error) {
	fp, err := ParseEnvVar_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvVar field path value from %s: %v", valueStr, err)
	}
	return fpv.(EnvVar_FieldPathValue), nil
}

func MustParseEnvVar_FieldPathValue(pathStr, valueStr string) EnvVar_FieldPathValue {
	fpv, err := ParseEnvVar_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type EnvVar_FieldTerminalPathValue struct {
	EnvVar_FieldTerminalPath
	value interface{}
}

var _ EnvVar_FieldPathValue = (*EnvVar_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'EnvVar' as interface{}
func (fpv *EnvVar_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *EnvVar_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *EnvVar_FieldTerminalPathValue) AsValueValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *EnvVar_FieldTerminalPathValue) AsValueFromValue() (*EnvVarSource, bool) {
	res, ok := fpv.value.(*EnvVarSource)
	return res, ok
}

// SetTo stores value for selected field for object EnvVar
func (fpv *EnvVar_FieldTerminalPathValue) SetTo(target **EnvVar) {
	if *target == nil {
		*target = new(EnvVar)
	}
	switch fpv.selector {
	case EnvVar_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case EnvVar_FieldPathSelectorValue:
		(*target).Value = fpv.value.(string)
	case EnvVar_FieldPathSelectorValueFrom:
		(*target).ValueFrom = fpv.value.(*EnvVarSource)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fpv.selector))
	}
}

func (fpv *EnvVar_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*EnvVar)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'EnvVar_FieldTerminalPathValue' with the value under path in 'EnvVar'.
func (fpv *EnvVar_FieldTerminalPathValue) CompareWith(source *EnvVar) (int, bool) {
	switch fpv.selector {
	case EnvVar_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case EnvVar_FieldPathSelectorValue:
		leftValue := fpv.value.(string)
		rightValue := source.GetValue()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case EnvVar_FieldPathSelectorValueFrom:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fpv.selector))
	}
}

func (fpv *EnvVar_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*EnvVar))
}

type EnvVar_FieldSubPathValue struct {
	EnvVar_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ EnvVar_FieldPathValue = (*EnvVar_FieldSubPathValue)(nil)

func (fpvs *EnvVar_FieldSubPathValue) AsValueFromPathValue() (EnvVarSource_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(EnvVarSource_FieldPathValue)
	return res, ok
}

func (fpvs *EnvVar_FieldSubPathValue) SetTo(target **EnvVar) {
	if *target == nil {
		*target = new(EnvVar)
	}
	switch fpvs.Selector() {
	case EnvVar_FieldPathSelectorValueFrom:
		fpvs.subPathValue.(EnvVarSource_FieldPathValue).SetTo(&(*target).ValueFrom)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fpvs.Selector()))
	}
}

func (fpvs *EnvVar_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*EnvVar)
	fpvs.SetTo(&typedObject)
}

func (fpvs *EnvVar_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *EnvVar_FieldSubPathValue) CompareWith(source *EnvVar) (int, bool) {
	switch fpvs.Selector() {
	case EnvVar_FieldPathSelectorValueFrom:
		return fpvs.subPathValue.(EnvVarSource_FieldPathValue).CompareWith(source.GetValueFrom())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fpvs.Selector()))
	}
}

func (fpvs *EnvVar_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*EnvVar))
}

// EnvVar_FieldPathArrayItemValue allows storing single item in Path-specific values for EnvVar according to their type
// Present only for array (repeated) types.
type EnvVar_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	EnvVar_FieldPath
	ContainsValue(*EnvVar) bool
}

// ParseEnvVar_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseEnvVar_FieldPathArrayItemValue(pathStr, valueStr string) (EnvVar_FieldPathArrayItemValue, error) {
	fp, err := ParseEnvVar_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvVar field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(EnvVar_FieldPathArrayItemValue), nil
}

func MustParseEnvVar_FieldPathArrayItemValue(pathStr, valueStr string) EnvVar_FieldPathArrayItemValue {
	fpaiv, err := ParseEnvVar_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type EnvVar_FieldTerminalPathArrayItemValue struct {
	EnvVar_FieldTerminalPath
	value interface{}
}

var _ EnvVar_FieldPathArrayItemValue = (*EnvVar_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object EnvVar as interface{}
func (fpaiv *EnvVar_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *EnvVar_FieldTerminalPathArrayItemValue) GetSingle(source *EnvVar) (interface{}, bool) {
	return nil, false
}

func (fpaiv *EnvVar_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*EnvVar))
}

// Contains returns a boolean indicating if value that is being held is present in given 'EnvVar'
func (fpaiv *EnvVar_FieldTerminalPathArrayItemValue) ContainsValue(source *EnvVar) bool {
	slice := fpaiv.EnvVar_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type EnvVar_FieldSubPathArrayItemValue struct {
	EnvVar_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *EnvVar_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *EnvVar_FieldSubPathArrayItemValue) AsValueFromPathItemValue() (EnvVarSource_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(EnvVarSource_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'EnvVar'
func (fpaivs *EnvVar_FieldSubPathArrayItemValue) ContainsValue(source *EnvVar) bool {
	switch fpaivs.Selector() {
	case EnvVar_FieldPathSelectorValueFrom:
		return fpaivs.subPathItemValue.(EnvVarSource_FieldPathArrayItemValue).ContainsValue(source.GetValueFrom())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVar: %d", fpaivs.Selector()))
	}
}

// EnvVar_FieldPathArrayOfValues allows storing slice of values for EnvVar fields according to their type
type EnvVar_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	EnvVar_FieldPath
}

func ParseEnvVar_FieldPathArrayOfValues(pathStr, valuesStr string) (EnvVar_FieldPathArrayOfValues, error) {
	fp, err := ParseEnvVar_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvVar field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(EnvVar_FieldPathArrayOfValues), nil
}

func MustParseEnvVar_FieldPathArrayOfValues(pathStr, valuesStr string) EnvVar_FieldPathArrayOfValues {
	fpaov, err := ParseEnvVar_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type EnvVar_FieldTerminalPathArrayOfValues struct {
	EnvVar_FieldTerminalPath
	values interface{}
}

var _ EnvVar_FieldPathArrayOfValues = (*EnvVar_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *EnvVar_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case EnvVar_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case EnvVar_FieldPathSelectorValue:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case EnvVar_FieldPathSelectorValueFrom:
		for _, v := range fpaov.values.([]*EnvVarSource) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *EnvVar_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *EnvVar_FieldTerminalPathArrayOfValues) AsValueArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *EnvVar_FieldTerminalPathArrayOfValues) AsValueFromArrayOfValues() ([]*EnvVarSource, bool) {
	res, ok := fpaov.values.([]*EnvVarSource)
	return res, ok
}

type EnvVar_FieldSubPathArrayOfValues struct {
	EnvVar_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ EnvVar_FieldPathArrayOfValues = (*EnvVar_FieldSubPathArrayOfValues)(nil)

func (fpsaov *EnvVar_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *EnvVar_FieldSubPathArrayOfValues) AsValueFromPathArrayOfValues() (EnvVarSource_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(EnvVarSource_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ConfigMapEnvSource_FieldPath interface {
	gotenobject.FieldPath
	Selector() ConfigMapEnvSource_FieldPathSelector
	Get(source *ConfigMapEnvSource) []interface{}
	GetSingle(source *ConfigMapEnvSource) (interface{}, bool)
	ClearValue(item *ConfigMapEnvSource)

	// Those methods build corresponding ConfigMapEnvSource_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ConfigMapEnvSource_FieldPathValue
	WithIArrayOfValues(values interface{}) ConfigMapEnvSource_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ConfigMapEnvSource_FieldPathArrayItemValue
}

type ConfigMapEnvSource_FieldPathSelector int32

const (
	ConfigMapEnvSource_FieldPathSelectorName     ConfigMapEnvSource_FieldPathSelector = 0
	ConfigMapEnvSource_FieldPathSelectorOptional ConfigMapEnvSource_FieldPathSelector = 1
)

func (s ConfigMapEnvSource_FieldPathSelector) String() string {
	switch s {
	case ConfigMapEnvSource_FieldPathSelectorName:
		return "name"
	case ConfigMapEnvSource_FieldPathSelectorOptional:
		return "optional"
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", s))
	}
}

func BuildConfigMapEnvSource_FieldPath(fp gotenobject.RawFieldPath) (ConfigMapEnvSource_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ConfigMapEnvSource")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &ConfigMapEnvSource_FieldTerminalPath{selector: ConfigMapEnvSource_FieldPathSelectorName}, nil
		case "optional":
			return &ConfigMapEnvSource_FieldTerminalPath{selector: ConfigMapEnvSource_FieldPathSelectorOptional}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ConfigMapEnvSource", fp)
}

func ParseConfigMapEnvSource_FieldPath(rawField string) (ConfigMapEnvSource_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildConfigMapEnvSource_FieldPath(fp)
}

func MustParseConfigMapEnvSource_FieldPath(rawField string) ConfigMapEnvSource_FieldPath {
	fp, err := ParseConfigMapEnvSource_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ConfigMapEnvSource_FieldTerminalPath struct {
	selector ConfigMapEnvSource_FieldPathSelector
}

var _ ConfigMapEnvSource_FieldPath = (*ConfigMapEnvSource_FieldTerminalPath)(nil)

func (fp *ConfigMapEnvSource_FieldTerminalPath) Selector() ConfigMapEnvSource_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ConfigMapEnvSource_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ConfigMapEnvSource_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ConfigMapEnvSource
func (fp *ConfigMapEnvSource_FieldTerminalPath) Get(source *ConfigMapEnvSource) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ConfigMapEnvSource_FieldPathSelectorName:
			values = append(values, source.Name)
		case ConfigMapEnvSource_FieldPathSelectorOptional:
			values = append(values, source.Optional)
		default:
			panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fp.selector))
		}
	}
	return
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ConfigMapEnvSource))
}

// GetSingle returns value pointed by specific field of from source ConfigMapEnvSource
func (fp *ConfigMapEnvSource_FieldTerminalPath) GetSingle(source *ConfigMapEnvSource) (interface{}, bool) {
	switch fp.selector {
	case ConfigMapEnvSource_FieldPathSelectorName:
		return source.GetName(), source != nil
	case ConfigMapEnvSource_FieldPathSelectorOptional:
		return source.GetOptional(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fp.selector))
	}
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ConfigMapEnvSource))
}

// GetDefault returns a default value of the field type
func (fp *ConfigMapEnvSource_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ConfigMapEnvSource_FieldPathSelectorName:
		return ""
	case ConfigMapEnvSource_FieldPathSelectorOptional:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fp.selector))
	}
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) ClearValue(item *ConfigMapEnvSource) {
	if item != nil {
		switch fp.selector {
		case ConfigMapEnvSource_FieldPathSelectorName:
			item.Name = ""
		case ConfigMapEnvSource_FieldPathSelectorOptional:
			item.Optional = false
		default:
			panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fp.selector))
		}
	}
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ConfigMapEnvSource))
}

// IsLeaf - whether field path is holds simple value
func (fp *ConfigMapEnvSource_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ConfigMapEnvSource_FieldPathSelectorName ||
		fp.selector == ConfigMapEnvSource_FieldPathSelectorOptional
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) WithIValue(value interface{}) ConfigMapEnvSource_FieldPathValue {
	switch fp.selector {
	case ConfigMapEnvSource_FieldPathSelectorName:
		return &ConfigMapEnvSource_FieldTerminalPathValue{ConfigMapEnvSource_FieldTerminalPath: *fp, value: value.(string)}
	case ConfigMapEnvSource_FieldPathSelectorOptional:
		return &ConfigMapEnvSource_FieldTerminalPathValue{ConfigMapEnvSource_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fp.selector))
	}
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) WithIArrayOfValues(values interface{}) ConfigMapEnvSource_FieldPathArrayOfValues {
	fpaov := &ConfigMapEnvSource_FieldTerminalPathArrayOfValues{ConfigMapEnvSource_FieldTerminalPath: *fp}
	switch fp.selector {
	case ConfigMapEnvSource_FieldPathSelectorName:
		return &ConfigMapEnvSource_FieldTerminalPathArrayOfValues{ConfigMapEnvSource_FieldTerminalPath: *fp, values: values.([]string)}
	case ConfigMapEnvSource_FieldPathSelectorOptional:
		return &ConfigMapEnvSource_FieldTerminalPathArrayOfValues{ConfigMapEnvSource_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fp.selector))
	}
	return fpaov
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) WithIArrayItemValue(value interface{}) ConfigMapEnvSource_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fp.selector))
	}
}

func (fp *ConfigMapEnvSource_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ConfigMapEnvSource_FieldPathValue allows storing values for ConfigMapEnvSource fields according to their type
type ConfigMapEnvSource_FieldPathValue interface {
	ConfigMapEnvSource_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ConfigMapEnvSource)
	CompareWith(*ConfigMapEnvSource) (cmp int, comparable bool)
}

func ParseConfigMapEnvSource_FieldPathValue(pathStr, valueStr string) (ConfigMapEnvSource_FieldPathValue, error) {
	fp, err := ParseConfigMapEnvSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapEnvSource field path value from %s: %v", valueStr, err)
	}
	return fpv.(ConfigMapEnvSource_FieldPathValue), nil
}

func MustParseConfigMapEnvSource_FieldPathValue(pathStr, valueStr string) ConfigMapEnvSource_FieldPathValue {
	fpv, err := ParseConfigMapEnvSource_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ConfigMapEnvSource_FieldTerminalPathValue struct {
	ConfigMapEnvSource_FieldTerminalPath
	value interface{}
}

var _ ConfigMapEnvSource_FieldPathValue = (*ConfigMapEnvSource_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ConfigMapEnvSource' as interface{}
func (fpv *ConfigMapEnvSource_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ConfigMapEnvSource_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ConfigMapEnvSource_FieldTerminalPathValue) AsOptionalValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object ConfigMapEnvSource
func (fpv *ConfigMapEnvSource_FieldTerminalPathValue) SetTo(target **ConfigMapEnvSource) {
	if *target == nil {
		*target = new(ConfigMapEnvSource)
	}
	switch fpv.selector {
	case ConfigMapEnvSource_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case ConfigMapEnvSource_FieldPathSelectorOptional:
		(*target).Optional = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fpv.selector))
	}
}

func (fpv *ConfigMapEnvSource_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ConfigMapEnvSource)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ConfigMapEnvSource_FieldTerminalPathValue' with the value under path in 'ConfigMapEnvSource'.
func (fpv *ConfigMapEnvSource_FieldTerminalPathValue) CompareWith(source *ConfigMapEnvSource) (int, bool) {
	switch fpv.selector {
	case ConfigMapEnvSource_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ConfigMapEnvSource_FieldPathSelectorOptional:
		leftValue := fpv.value.(bool)
		rightValue := source.GetOptional()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapEnvSource: %d", fpv.selector))
	}
}

func (fpv *ConfigMapEnvSource_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ConfigMapEnvSource))
}

// ConfigMapEnvSource_FieldPathArrayItemValue allows storing single item in Path-specific values for ConfigMapEnvSource according to their type
// Present only for array (repeated) types.
type ConfigMapEnvSource_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ConfigMapEnvSource_FieldPath
	ContainsValue(*ConfigMapEnvSource) bool
}

// ParseConfigMapEnvSource_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseConfigMapEnvSource_FieldPathArrayItemValue(pathStr, valueStr string) (ConfigMapEnvSource_FieldPathArrayItemValue, error) {
	fp, err := ParseConfigMapEnvSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapEnvSource field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ConfigMapEnvSource_FieldPathArrayItemValue), nil
}

func MustParseConfigMapEnvSource_FieldPathArrayItemValue(pathStr, valueStr string) ConfigMapEnvSource_FieldPathArrayItemValue {
	fpaiv, err := ParseConfigMapEnvSource_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ConfigMapEnvSource_FieldTerminalPathArrayItemValue struct {
	ConfigMapEnvSource_FieldTerminalPath
	value interface{}
}

var _ ConfigMapEnvSource_FieldPathArrayItemValue = (*ConfigMapEnvSource_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ConfigMapEnvSource as interface{}
func (fpaiv *ConfigMapEnvSource_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ConfigMapEnvSource_FieldTerminalPathArrayItemValue) GetSingle(source *ConfigMapEnvSource) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ConfigMapEnvSource_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ConfigMapEnvSource))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ConfigMapEnvSource'
func (fpaiv *ConfigMapEnvSource_FieldTerminalPathArrayItemValue) ContainsValue(source *ConfigMapEnvSource) bool {
	slice := fpaiv.ConfigMapEnvSource_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ConfigMapEnvSource_FieldPathArrayOfValues allows storing slice of values for ConfigMapEnvSource fields according to their type
type ConfigMapEnvSource_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ConfigMapEnvSource_FieldPath
}

func ParseConfigMapEnvSource_FieldPathArrayOfValues(pathStr, valuesStr string) (ConfigMapEnvSource_FieldPathArrayOfValues, error) {
	fp, err := ParseConfigMapEnvSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapEnvSource field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ConfigMapEnvSource_FieldPathArrayOfValues), nil
}

func MustParseConfigMapEnvSource_FieldPathArrayOfValues(pathStr, valuesStr string) ConfigMapEnvSource_FieldPathArrayOfValues {
	fpaov, err := ParseConfigMapEnvSource_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ConfigMapEnvSource_FieldTerminalPathArrayOfValues struct {
	ConfigMapEnvSource_FieldTerminalPath
	values interface{}
}

var _ ConfigMapEnvSource_FieldPathArrayOfValues = (*ConfigMapEnvSource_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ConfigMapEnvSource_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ConfigMapEnvSource_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ConfigMapEnvSource_FieldPathSelectorOptional:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ConfigMapEnvSource_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ConfigMapEnvSource_FieldTerminalPathArrayOfValues) AsOptionalArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type SecretEnvSource_FieldPath interface {
	gotenobject.FieldPath
	Selector() SecretEnvSource_FieldPathSelector
	Get(source *SecretEnvSource) []interface{}
	GetSingle(source *SecretEnvSource) (interface{}, bool)
	ClearValue(item *SecretEnvSource)

	// Those methods build corresponding SecretEnvSource_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) SecretEnvSource_FieldPathValue
	WithIArrayOfValues(values interface{}) SecretEnvSource_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) SecretEnvSource_FieldPathArrayItemValue
}

type SecretEnvSource_FieldPathSelector int32

const (
	SecretEnvSource_FieldPathSelectorName     SecretEnvSource_FieldPathSelector = 0
	SecretEnvSource_FieldPathSelectorOptional SecretEnvSource_FieldPathSelector = 1
)

func (s SecretEnvSource_FieldPathSelector) String() string {
	switch s {
	case SecretEnvSource_FieldPathSelectorName:
		return "name"
	case SecretEnvSource_FieldPathSelectorOptional:
		return "optional"
	default:
		panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", s))
	}
}

func BuildSecretEnvSource_FieldPath(fp gotenobject.RawFieldPath) (SecretEnvSource_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object SecretEnvSource")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &SecretEnvSource_FieldTerminalPath{selector: SecretEnvSource_FieldPathSelectorName}, nil
		case "optional":
			return &SecretEnvSource_FieldTerminalPath{selector: SecretEnvSource_FieldPathSelectorOptional}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object SecretEnvSource", fp)
}

func ParseSecretEnvSource_FieldPath(rawField string) (SecretEnvSource_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildSecretEnvSource_FieldPath(fp)
}

func MustParseSecretEnvSource_FieldPath(rawField string) SecretEnvSource_FieldPath {
	fp, err := ParseSecretEnvSource_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type SecretEnvSource_FieldTerminalPath struct {
	selector SecretEnvSource_FieldPathSelector
}

var _ SecretEnvSource_FieldPath = (*SecretEnvSource_FieldTerminalPath)(nil)

func (fp *SecretEnvSource_FieldTerminalPath) Selector() SecretEnvSource_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *SecretEnvSource_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *SecretEnvSource_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source SecretEnvSource
func (fp *SecretEnvSource_FieldTerminalPath) Get(source *SecretEnvSource) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case SecretEnvSource_FieldPathSelectorName:
			values = append(values, source.Name)
		case SecretEnvSource_FieldPathSelectorOptional:
			values = append(values, source.Optional)
		default:
			panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fp.selector))
		}
	}
	return
}

func (fp *SecretEnvSource_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*SecretEnvSource))
}

// GetSingle returns value pointed by specific field of from source SecretEnvSource
func (fp *SecretEnvSource_FieldTerminalPath) GetSingle(source *SecretEnvSource) (interface{}, bool) {
	switch fp.selector {
	case SecretEnvSource_FieldPathSelectorName:
		return source.GetName(), source != nil
	case SecretEnvSource_FieldPathSelectorOptional:
		return source.GetOptional(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fp.selector))
	}
}

func (fp *SecretEnvSource_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*SecretEnvSource))
}

// GetDefault returns a default value of the field type
func (fp *SecretEnvSource_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case SecretEnvSource_FieldPathSelectorName:
		return ""
	case SecretEnvSource_FieldPathSelectorOptional:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fp.selector))
	}
}

func (fp *SecretEnvSource_FieldTerminalPath) ClearValue(item *SecretEnvSource) {
	if item != nil {
		switch fp.selector {
		case SecretEnvSource_FieldPathSelectorName:
			item.Name = ""
		case SecretEnvSource_FieldPathSelectorOptional:
			item.Optional = false
		default:
			panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fp.selector))
		}
	}
}

func (fp *SecretEnvSource_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*SecretEnvSource))
}

// IsLeaf - whether field path is holds simple value
func (fp *SecretEnvSource_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == SecretEnvSource_FieldPathSelectorName ||
		fp.selector == SecretEnvSource_FieldPathSelectorOptional
}

func (fp *SecretEnvSource_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *SecretEnvSource_FieldTerminalPath) WithIValue(value interface{}) SecretEnvSource_FieldPathValue {
	switch fp.selector {
	case SecretEnvSource_FieldPathSelectorName:
		return &SecretEnvSource_FieldTerminalPathValue{SecretEnvSource_FieldTerminalPath: *fp, value: value.(string)}
	case SecretEnvSource_FieldPathSelectorOptional:
		return &SecretEnvSource_FieldTerminalPathValue{SecretEnvSource_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fp.selector))
	}
}

func (fp *SecretEnvSource_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *SecretEnvSource_FieldTerminalPath) WithIArrayOfValues(values interface{}) SecretEnvSource_FieldPathArrayOfValues {
	fpaov := &SecretEnvSource_FieldTerminalPathArrayOfValues{SecretEnvSource_FieldTerminalPath: *fp}
	switch fp.selector {
	case SecretEnvSource_FieldPathSelectorName:
		return &SecretEnvSource_FieldTerminalPathArrayOfValues{SecretEnvSource_FieldTerminalPath: *fp, values: values.([]string)}
	case SecretEnvSource_FieldPathSelectorOptional:
		return &SecretEnvSource_FieldTerminalPathArrayOfValues{SecretEnvSource_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fp.selector))
	}
	return fpaov
}

func (fp *SecretEnvSource_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *SecretEnvSource_FieldTerminalPath) WithIArrayItemValue(value interface{}) SecretEnvSource_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fp.selector))
	}
}

func (fp *SecretEnvSource_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// SecretEnvSource_FieldPathValue allows storing values for SecretEnvSource fields according to their type
type SecretEnvSource_FieldPathValue interface {
	SecretEnvSource_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **SecretEnvSource)
	CompareWith(*SecretEnvSource) (cmp int, comparable bool)
}

func ParseSecretEnvSource_FieldPathValue(pathStr, valueStr string) (SecretEnvSource_FieldPathValue, error) {
	fp, err := ParseSecretEnvSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretEnvSource field path value from %s: %v", valueStr, err)
	}
	return fpv.(SecretEnvSource_FieldPathValue), nil
}

func MustParseSecretEnvSource_FieldPathValue(pathStr, valueStr string) SecretEnvSource_FieldPathValue {
	fpv, err := ParseSecretEnvSource_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type SecretEnvSource_FieldTerminalPathValue struct {
	SecretEnvSource_FieldTerminalPath
	value interface{}
}

var _ SecretEnvSource_FieldPathValue = (*SecretEnvSource_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'SecretEnvSource' as interface{}
func (fpv *SecretEnvSource_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *SecretEnvSource_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *SecretEnvSource_FieldTerminalPathValue) AsOptionalValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object SecretEnvSource
func (fpv *SecretEnvSource_FieldTerminalPathValue) SetTo(target **SecretEnvSource) {
	if *target == nil {
		*target = new(SecretEnvSource)
	}
	switch fpv.selector {
	case SecretEnvSource_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case SecretEnvSource_FieldPathSelectorOptional:
		(*target).Optional = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fpv.selector))
	}
}

func (fpv *SecretEnvSource_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*SecretEnvSource)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'SecretEnvSource_FieldTerminalPathValue' with the value under path in 'SecretEnvSource'.
func (fpv *SecretEnvSource_FieldTerminalPathValue) CompareWith(source *SecretEnvSource) (int, bool) {
	switch fpv.selector {
	case SecretEnvSource_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SecretEnvSource_FieldPathSelectorOptional:
		leftValue := fpv.value.(bool)
		rightValue := source.GetOptional()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretEnvSource: %d", fpv.selector))
	}
}

func (fpv *SecretEnvSource_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*SecretEnvSource))
}

// SecretEnvSource_FieldPathArrayItemValue allows storing single item in Path-specific values for SecretEnvSource according to their type
// Present only for array (repeated) types.
type SecretEnvSource_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	SecretEnvSource_FieldPath
	ContainsValue(*SecretEnvSource) bool
}

// ParseSecretEnvSource_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseSecretEnvSource_FieldPathArrayItemValue(pathStr, valueStr string) (SecretEnvSource_FieldPathArrayItemValue, error) {
	fp, err := ParseSecretEnvSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretEnvSource field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(SecretEnvSource_FieldPathArrayItemValue), nil
}

func MustParseSecretEnvSource_FieldPathArrayItemValue(pathStr, valueStr string) SecretEnvSource_FieldPathArrayItemValue {
	fpaiv, err := ParseSecretEnvSource_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type SecretEnvSource_FieldTerminalPathArrayItemValue struct {
	SecretEnvSource_FieldTerminalPath
	value interface{}
}

var _ SecretEnvSource_FieldPathArrayItemValue = (*SecretEnvSource_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object SecretEnvSource as interface{}
func (fpaiv *SecretEnvSource_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *SecretEnvSource_FieldTerminalPathArrayItemValue) GetSingle(source *SecretEnvSource) (interface{}, bool) {
	return nil, false
}

func (fpaiv *SecretEnvSource_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*SecretEnvSource))
}

// Contains returns a boolean indicating if value that is being held is present in given 'SecretEnvSource'
func (fpaiv *SecretEnvSource_FieldTerminalPathArrayItemValue) ContainsValue(source *SecretEnvSource) bool {
	slice := fpaiv.SecretEnvSource_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// SecretEnvSource_FieldPathArrayOfValues allows storing slice of values for SecretEnvSource fields according to their type
type SecretEnvSource_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	SecretEnvSource_FieldPath
}

func ParseSecretEnvSource_FieldPathArrayOfValues(pathStr, valuesStr string) (SecretEnvSource_FieldPathArrayOfValues, error) {
	fp, err := ParseSecretEnvSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretEnvSource field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(SecretEnvSource_FieldPathArrayOfValues), nil
}

func MustParseSecretEnvSource_FieldPathArrayOfValues(pathStr, valuesStr string) SecretEnvSource_FieldPathArrayOfValues {
	fpaov, err := ParseSecretEnvSource_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type SecretEnvSource_FieldTerminalPathArrayOfValues struct {
	SecretEnvSource_FieldTerminalPath
	values interface{}
}

var _ SecretEnvSource_FieldPathArrayOfValues = (*SecretEnvSource_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *SecretEnvSource_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case SecretEnvSource_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case SecretEnvSource_FieldPathSelectorOptional:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *SecretEnvSource_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *SecretEnvSource_FieldTerminalPathArrayOfValues) AsOptionalArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type EnvVarSource_FieldPath interface {
	gotenobject.FieldPath
	Selector() EnvVarSource_FieldPathSelector
	Get(source *EnvVarSource) []interface{}
	GetSingle(source *EnvVarSource) (interface{}, bool)
	ClearValue(item *EnvVarSource)

	// Those methods build corresponding EnvVarSource_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) EnvVarSource_FieldPathValue
	WithIArrayOfValues(values interface{}) EnvVarSource_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) EnvVarSource_FieldPathArrayItemValue
}

type EnvVarSource_FieldPathSelector int32

const (
	EnvVarSource_FieldPathSelectorConfigMapKeyRef EnvVarSource_FieldPathSelector = 0
	EnvVarSource_FieldPathSelectorSecretKeyRef    EnvVarSource_FieldPathSelector = 1
)

func (s EnvVarSource_FieldPathSelector) String() string {
	switch s {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		return "config_map_key_ref"
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		return "secret_key_ref"
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", s))
	}
}

func BuildEnvVarSource_FieldPath(fp gotenobject.RawFieldPath) (EnvVarSource_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object EnvVarSource")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "config_map_key_ref", "configMapKeyRef", "config-map-key-ref":
			return &EnvVarSource_FieldTerminalPath{selector: EnvVarSource_FieldPathSelectorConfigMapKeyRef}, nil
		case "secret_key_ref", "secretKeyRef", "secret-key-ref":
			return &EnvVarSource_FieldTerminalPath{selector: EnvVarSource_FieldPathSelectorSecretKeyRef}, nil
		}
	} else {
		switch fp[0] {
		case "config_map_key_ref", "configMapKeyRef", "config-map-key-ref":
			if subpath, err := BuildConfigMapKeySelector_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &EnvVarSource_FieldSubPath{selector: EnvVarSource_FieldPathSelectorConfigMapKeyRef, subPath: subpath}, nil
			}
		case "secret_key_ref", "secretKeyRef", "secret-key-ref":
			if subpath, err := BuildSecretKeySelector_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &EnvVarSource_FieldSubPath{selector: EnvVarSource_FieldPathSelectorSecretKeyRef, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object EnvVarSource", fp)
}

func ParseEnvVarSource_FieldPath(rawField string) (EnvVarSource_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildEnvVarSource_FieldPath(fp)
}

func MustParseEnvVarSource_FieldPath(rawField string) EnvVarSource_FieldPath {
	fp, err := ParseEnvVarSource_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type EnvVarSource_FieldTerminalPath struct {
	selector EnvVarSource_FieldPathSelector
}

var _ EnvVarSource_FieldPath = (*EnvVarSource_FieldTerminalPath)(nil)

func (fp *EnvVarSource_FieldTerminalPath) Selector() EnvVarSource_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *EnvVarSource_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *EnvVarSource_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source EnvVarSource
func (fp *EnvVarSource_FieldTerminalPath) Get(source *EnvVarSource) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
			if source.ConfigMapKeyRef != nil {
				values = append(values, source.ConfigMapKeyRef)
			}
		case EnvVarSource_FieldPathSelectorSecretKeyRef:
			if source.SecretKeyRef != nil {
				values = append(values, source.SecretKeyRef)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fp.selector))
		}
	}
	return
}

func (fp *EnvVarSource_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*EnvVarSource))
}

// GetSingle returns value pointed by specific field of from source EnvVarSource
func (fp *EnvVarSource_FieldTerminalPath) GetSingle(source *EnvVarSource) (interface{}, bool) {
	switch fp.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		res := source.GetConfigMapKeyRef()
		return res, res != nil
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		res := source.GetSecretKeyRef()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fp.selector))
	}
}

func (fp *EnvVarSource_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*EnvVarSource))
}

// GetDefault returns a default value of the field type
func (fp *EnvVarSource_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		return (*ConfigMapKeySelector)(nil)
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		return (*SecretKeySelector)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fp.selector))
	}
}

func (fp *EnvVarSource_FieldTerminalPath) ClearValue(item *EnvVarSource) {
	if item != nil {
		switch fp.selector {
		case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
			item.ConfigMapKeyRef = nil
		case EnvVarSource_FieldPathSelectorSecretKeyRef:
			item.SecretKeyRef = nil
		default:
			panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fp.selector))
		}
	}
}

func (fp *EnvVarSource_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*EnvVarSource))
}

// IsLeaf - whether field path is holds simple value
func (fp *EnvVarSource_FieldTerminalPath) IsLeaf() bool {
	return false
}

func (fp *EnvVarSource_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *EnvVarSource_FieldTerminalPath) WithIValue(value interface{}) EnvVarSource_FieldPathValue {
	switch fp.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		return &EnvVarSource_FieldTerminalPathValue{EnvVarSource_FieldTerminalPath: *fp, value: value.(*ConfigMapKeySelector)}
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		return &EnvVarSource_FieldTerminalPathValue{EnvVarSource_FieldTerminalPath: *fp, value: value.(*SecretKeySelector)}
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fp.selector))
	}
}

func (fp *EnvVarSource_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *EnvVarSource_FieldTerminalPath) WithIArrayOfValues(values interface{}) EnvVarSource_FieldPathArrayOfValues {
	fpaov := &EnvVarSource_FieldTerminalPathArrayOfValues{EnvVarSource_FieldTerminalPath: *fp}
	switch fp.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		return &EnvVarSource_FieldTerminalPathArrayOfValues{EnvVarSource_FieldTerminalPath: *fp, values: values.([]*ConfigMapKeySelector)}
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		return &EnvVarSource_FieldTerminalPathArrayOfValues{EnvVarSource_FieldTerminalPath: *fp, values: values.([]*SecretKeySelector)}
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fp.selector))
	}
	return fpaov
}

func (fp *EnvVarSource_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *EnvVarSource_FieldTerminalPath) WithIArrayItemValue(value interface{}) EnvVarSource_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fp.selector))
	}
}

func (fp *EnvVarSource_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type EnvVarSource_FieldSubPath struct {
	selector EnvVarSource_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ EnvVarSource_FieldPath = (*EnvVarSource_FieldSubPath)(nil)

func (fps *EnvVarSource_FieldSubPath) Selector() EnvVarSource_FieldPathSelector {
	return fps.selector
}
func (fps *EnvVarSource_FieldSubPath) AsConfigMapKeyRefSubPath() (ConfigMapKeySelector_FieldPath, bool) {
	res, ok := fps.subPath.(ConfigMapKeySelector_FieldPath)
	return res, ok
}
func (fps *EnvVarSource_FieldSubPath) AsSecretKeyRefSubPath() (SecretKeySelector_FieldPath, bool) {
	res, ok := fps.subPath.(SecretKeySelector_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *EnvVarSource_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *EnvVarSource_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source EnvVarSource
func (fps *EnvVarSource_FieldSubPath) Get(source *EnvVarSource) (values []interface{}) {
	switch fps.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		values = append(values, fps.subPath.GetRaw(source.GetConfigMapKeyRef())...)
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		values = append(values, fps.subPath.GetRaw(source.GetSecretKeyRef())...)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fps.selector))
	}
	return
}

func (fps *EnvVarSource_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*EnvVarSource))
}

// GetSingle returns value of selected field from source EnvVarSource
func (fps *EnvVarSource_FieldSubPath) GetSingle(source *EnvVarSource) (interface{}, bool) {
	switch fps.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		if source.GetConfigMapKeyRef() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetConfigMapKeyRef())
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		if source.GetSecretKeyRef() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetSecretKeyRef())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fps.selector))
	}
}

func (fps *EnvVarSource_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*EnvVarSource))
}

// GetDefault returns a default value of the field type
func (fps *EnvVarSource_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *EnvVarSource_FieldSubPath) ClearValue(item *EnvVarSource) {
	if item != nil {
		switch fps.selector {
		case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
			fps.subPath.ClearValueRaw(item.ConfigMapKeyRef)
		case EnvVarSource_FieldPathSelectorSecretKeyRef:
			fps.subPath.ClearValueRaw(item.SecretKeyRef)
		default:
			panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fps.selector))
		}
	}
}

func (fps *EnvVarSource_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*EnvVarSource))
}

// IsLeaf - whether field path is holds simple value
func (fps *EnvVarSource_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *EnvVarSource_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&EnvVarSource_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *EnvVarSource_FieldSubPath) WithIValue(value interface{}) EnvVarSource_FieldPathValue {
	return &EnvVarSource_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *EnvVarSource_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *EnvVarSource_FieldSubPath) WithIArrayOfValues(values interface{}) EnvVarSource_FieldPathArrayOfValues {
	return &EnvVarSource_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *EnvVarSource_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *EnvVarSource_FieldSubPath) WithIArrayItemValue(value interface{}) EnvVarSource_FieldPathArrayItemValue {
	return &EnvVarSource_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *EnvVarSource_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// EnvVarSource_FieldPathValue allows storing values for EnvVarSource fields according to their type
type EnvVarSource_FieldPathValue interface {
	EnvVarSource_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **EnvVarSource)
	CompareWith(*EnvVarSource) (cmp int, comparable bool)
}

func ParseEnvVarSource_FieldPathValue(pathStr, valueStr string) (EnvVarSource_FieldPathValue, error) {
	fp, err := ParseEnvVarSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvVarSource field path value from %s: %v", valueStr, err)
	}
	return fpv.(EnvVarSource_FieldPathValue), nil
}

func MustParseEnvVarSource_FieldPathValue(pathStr, valueStr string) EnvVarSource_FieldPathValue {
	fpv, err := ParseEnvVarSource_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type EnvVarSource_FieldTerminalPathValue struct {
	EnvVarSource_FieldTerminalPath
	value interface{}
}

var _ EnvVarSource_FieldPathValue = (*EnvVarSource_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'EnvVarSource' as interface{}
func (fpv *EnvVarSource_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *EnvVarSource_FieldTerminalPathValue) AsConfigMapKeyRefValue() (*ConfigMapKeySelector, bool) {
	res, ok := fpv.value.(*ConfigMapKeySelector)
	return res, ok
}
func (fpv *EnvVarSource_FieldTerminalPathValue) AsSecretKeyRefValue() (*SecretKeySelector, bool) {
	res, ok := fpv.value.(*SecretKeySelector)
	return res, ok
}

// SetTo stores value for selected field for object EnvVarSource
func (fpv *EnvVarSource_FieldTerminalPathValue) SetTo(target **EnvVarSource) {
	if *target == nil {
		*target = new(EnvVarSource)
	}
	switch fpv.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		(*target).ConfigMapKeyRef = fpv.value.(*ConfigMapKeySelector)
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		(*target).SecretKeyRef = fpv.value.(*SecretKeySelector)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fpv.selector))
	}
}

func (fpv *EnvVarSource_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*EnvVarSource)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'EnvVarSource_FieldTerminalPathValue' with the value under path in 'EnvVarSource'.
func (fpv *EnvVarSource_FieldTerminalPathValue) CompareWith(source *EnvVarSource) (int, bool) {
	switch fpv.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		return 0, false
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fpv.selector))
	}
}

func (fpv *EnvVarSource_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*EnvVarSource))
}

type EnvVarSource_FieldSubPathValue struct {
	EnvVarSource_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ EnvVarSource_FieldPathValue = (*EnvVarSource_FieldSubPathValue)(nil)

func (fpvs *EnvVarSource_FieldSubPathValue) AsConfigMapKeyRefPathValue() (ConfigMapKeySelector_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ConfigMapKeySelector_FieldPathValue)
	return res, ok
}
func (fpvs *EnvVarSource_FieldSubPathValue) AsSecretKeyRefPathValue() (SecretKeySelector_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(SecretKeySelector_FieldPathValue)
	return res, ok
}

func (fpvs *EnvVarSource_FieldSubPathValue) SetTo(target **EnvVarSource) {
	if *target == nil {
		*target = new(EnvVarSource)
	}
	switch fpvs.Selector() {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		fpvs.subPathValue.(ConfigMapKeySelector_FieldPathValue).SetTo(&(*target).ConfigMapKeyRef)
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		fpvs.subPathValue.(SecretKeySelector_FieldPathValue).SetTo(&(*target).SecretKeyRef)
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fpvs.Selector()))
	}
}

func (fpvs *EnvVarSource_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*EnvVarSource)
	fpvs.SetTo(&typedObject)
}

func (fpvs *EnvVarSource_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *EnvVarSource_FieldSubPathValue) CompareWith(source *EnvVarSource) (int, bool) {
	switch fpvs.Selector() {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		return fpvs.subPathValue.(ConfigMapKeySelector_FieldPathValue).CompareWith(source.GetConfigMapKeyRef())
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		return fpvs.subPathValue.(SecretKeySelector_FieldPathValue).CompareWith(source.GetSecretKeyRef())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fpvs.Selector()))
	}
}

func (fpvs *EnvVarSource_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*EnvVarSource))
}

// EnvVarSource_FieldPathArrayItemValue allows storing single item in Path-specific values for EnvVarSource according to their type
// Present only for array (repeated) types.
type EnvVarSource_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	EnvVarSource_FieldPath
	ContainsValue(*EnvVarSource) bool
}

// ParseEnvVarSource_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseEnvVarSource_FieldPathArrayItemValue(pathStr, valueStr string) (EnvVarSource_FieldPathArrayItemValue, error) {
	fp, err := ParseEnvVarSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvVarSource field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(EnvVarSource_FieldPathArrayItemValue), nil
}

func MustParseEnvVarSource_FieldPathArrayItemValue(pathStr, valueStr string) EnvVarSource_FieldPathArrayItemValue {
	fpaiv, err := ParseEnvVarSource_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type EnvVarSource_FieldTerminalPathArrayItemValue struct {
	EnvVarSource_FieldTerminalPath
	value interface{}
}

var _ EnvVarSource_FieldPathArrayItemValue = (*EnvVarSource_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object EnvVarSource as interface{}
func (fpaiv *EnvVarSource_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *EnvVarSource_FieldTerminalPathArrayItemValue) GetSingle(source *EnvVarSource) (interface{}, bool) {
	return nil, false
}

func (fpaiv *EnvVarSource_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*EnvVarSource))
}

// Contains returns a boolean indicating if value that is being held is present in given 'EnvVarSource'
func (fpaiv *EnvVarSource_FieldTerminalPathArrayItemValue) ContainsValue(source *EnvVarSource) bool {
	slice := fpaiv.EnvVarSource_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type EnvVarSource_FieldSubPathArrayItemValue struct {
	EnvVarSource_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *EnvVarSource_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *EnvVarSource_FieldSubPathArrayItemValue) AsConfigMapKeyRefPathItemValue() (ConfigMapKeySelector_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ConfigMapKeySelector_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *EnvVarSource_FieldSubPathArrayItemValue) AsSecretKeyRefPathItemValue() (SecretKeySelector_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(SecretKeySelector_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'EnvVarSource'
func (fpaivs *EnvVarSource_FieldSubPathArrayItemValue) ContainsValue(source *EnvVarSource) bool {
	switch fpaivs.Selector() {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		return fpaivs.subPathItemValue.(ConfigMapKeySelector_FieldPathArrayItemValue).ContainsValue(source.GetConfigMapKeyRef())
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		return fpaivs.subPathItemValue.(SecretKeySelector_FieldPathArrayItemValue).ContainsValue(source.GetSecretKeyRef())
	default:
		panic(fmt.Sprintf("Invalid selector for EnvVarSource: %d", fpaivs.Selector()))
	}
}

// EnvVarSource_FieldPathArrayOfValues allows storing slice of values for EnvVarSource fields according to their type
type EnvVarSource_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	EnvVarSource_FieldPath
}

func ParseEnvVarSource_FieldPathArrayOfValues(pathStr, valuesStr string) (EnvVarSource_FieldPathArrayOfValues, error) {
	fp, err := ParseEnvVarSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing EnvVarSource field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(EnvVarSource_FieldPathArrayOfValues), nil
}

func MustParseEnvVarSource_FieldPathArrayOfValues(pathStr, valuesStr string) EnvVarSource_FieldPathArrayOfValues {
	fpaov, err := ParseEnvVarSource_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type EnvVarSource_FieldTerminalPathArrayOfValues struct {
	EnvVarSource_FieldTerminalPath
	values interface{}
}

var _ EnvVarSource_FieldPathArrayOfValues = (*EnvVarSource_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *EnvVarSource_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case EnvVarSource_FieldPathSelectorConfigMapKeyRef:
		for _, v := range fpaov.values.([]*ConfigMapKeySelector) {
			values = append(values, v)
		}
	case EnvVarSource_FieldPathSelectorSecretKeyRef:
		for _, v := range fpaov.values.([]*SecretKeySelector) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *EnvVarSource_FieldTerminalPathArrayOfValues) AsConfigMapKeyRefArrayOfValues() ([]*ConfigMapKeySelector, bool) {
	res, ok := fpaov.values.([]*ConfigMapKeySelector)
	return res, ok
}
func (fpaov *EnvVarSource_FieldTerminalPathArrayOfValues) AsSecretKeyRefArrayOfValues() ([]*SecretKeySelector, bool) {
	res, ok := fpaov.values.([]*SecretKeySelector)
	return res, ok
}

type EnvVarSource_FieldSubPathArrayOfValues struct {
	EnvVarSource_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ EnvVarSource_FieldPathArrayOfValues = (*EnvVarSource_FieldSubPathArrayOfValues)(nil)

func (fpsaov *EnvVarSource_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *EnvVarSource_FieldSubPathArrayOfValues) AsConfigMapKeyRefPathArrayOfValues() (ConfigMapKeySelector_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ConfigMapKeySelector_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *EnvVarSource_FieldSubPathArrayOfValues) AsSecretKeyRefPathArrayOfValues() (SecretKeySelector_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(SecretKeySelector_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ConfigMapKeySelector_FieldPath interface {
	gotenobject.FieldPath
	Selector() ConfigMapKeySelector_FieldPathSelector
	Get(source *ConfigMapKeySelector) []interface{}
	GetSingle(source *ConfigMapKeySelector) (interface{}, bool)
	ClearValue(item *ConfigMapKeySelector)

	// Those methods build corresponding ConfigMapKeySelector_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ConfigMapKeySelector_FieldPathValue
	WithIArrayOfValues(values interface{}) ConfigMapKeySelector_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ConfigMapKeySelector_FieldPathArrayItemValue
}

type ConfigMapKeySelector_FieldPathSelector int32

const (
	ConfigMapKeySelector_FieldPathSelectorName     ConfigMapKeySelector_FieldPathSelector = 0
	ConfigMapKeySelector_FieldPathSelectorKey      ConfigMapKeySelector_FieldPathSelector = 1
	ConfigMapKeySelector_FieldPathSelectorOptional ConfigMapKeySelector_FieldPathSelector = 2
)

func (s ConfigMapKeySelector_FieldPathSelector) String() string {
	switch s {
	case ConfigMapKeySelector_FieldPathSelectorName:
		return "name"
	case ConfigMapKeySelector_FieldPathSelectorKey:
		return "key"
	case ConfigMapKeySelector_FieldPathSelectorOptional:
		return "optional"
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", s))
	}
}

func BuildConfigMapKeySelector_FieldPath(fp gotenobject.RawFieldPath) (ConfigMapKeySelector_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ConfigMapKeySelector")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorName}, nil
		case "key":
			return &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorKey}, nil
		case "optional":
			return &ConfigMapKeySelector_FieldTerminalPath{selector: ConfigMapKeySelector_FieldPathSelectorOptional}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ConfigMapKeySelector", fp)
}

func ParseConfigMapKeySelector_FieldPath(rawField string) (ConfigMapKeySelector_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildConfigMapKeySelector_FieldPath(fp)
}

func MustParseConfigMapKeySelector_FieldPath(rawField string) ConfigMapKeySelector_FieldPath {
	fp, err := ParseConfigMapKeySelector_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ConfigMapKeySelector_FieldTerminalPath struct {
	selector ConfigMapKeySelector_FieldPathSelector
}

var _ ConfigMapKeySelector_FieldPath = (*ConfigMapKeySelector_FieldTerminalPath)(nil)

func (fp *ConfigMapKeySelector_FieldTerminalPath) Selector() ConfigMapKeySelector_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ConfigMapKeySelector_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ConfigMapKeySelector_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ConfigMapKeySelector
func (fp *ConfigMapKeySelector_FieldTerminalPath) Get(source *ConfigMapKeySelector) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ConfigMapKeySelector_FieldPathSelectorName:
			values = append(values, source.Name)
		case ConfigMapKeySelector_FieldPathSelectorKey:
			values = append(values, source.Key)
		case ConfigMapKeySelector_FieldPathSelectorOptional:
			values = append(values, source.Optional)
		default:
			panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fp.selector))
		}
	}
	return
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ConfigMapKeySelector))
}

// GetSingle returns value pointed by specific field of from source ConfigMapKeySelector
func (fp *ConfigMapKeySelector_FieldTerminalPath) GetSingle(source *ConfigMapKeySelector) (interface{}, bool) {
	switch fp.selector {
	case ConfigMapKeySelector_FieldPathSelectorName:
		return source.GetName(), source != nil
	case ConfigMapKeySelector_FieldPathSelectorKey:
		return source.GetKey(), source != nil
	case ConfigMapKeySelector_FieldPathSelectorOptional:
		return source.GetOptional(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fp.selector))
	}
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ConfigMapKeySelector))
}

// GetDefault returns a default value of the field type
func (fp *ConfigMapKeySelector_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ConfigMapKeySelector_FieldPathSelectorName:
		return ""
	case ConfigMapKeySelector_FieldPathSelectorKey:
		return ""
	case ConfigMapKeySelector_FieldPathSelectorOptional:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fp.selector))
	}
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) ClearValue(item *ConfigMapKeySelector) {
	if item != nil {
		switch fp.selector {
		case ConfigMapKeySelector_FieldPathSelectorName:
			item.Name = ""
		case ConfigMapKeySelector_FieldPathSelectorKey:
			item.Key = ""
		case ConfigMapKeySelector_FieldPathSelectorOptional:
			item.Optional = false
		default:
			panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fp.selector))
		}
	}
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ConfigMapKeySelector))
}

// IsLeaf - whether field path is holds simple value
func (fp *ConfigMapKeySelector_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ConfigMapKeySelector_FieldPathSelectorName ||
		fp.selector == ConfigMapKeySelector_FieldPathSelectorKey ||
		fp.selector == ConfigMapKeySelector_FieldPathSelectorOptional
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) WithIValue(value interface{}) ConfigMapKeySelector_FieldPathValue {
	switch fp.selector {
	case ConfigMapKeySelector_FieldPathSelectorName:
		return &ConfigMapKeySelector_FieldTerminalPathValue{ConfigMapKeySelector_FieldTerminalPath: *fp, value: value.(string)}
	case ConfigMapKeySelector_FieldPathSelectorKey:
		return &ConfigMapKeySelector_FieldTerminalPathValue{ConfigMapKeySelector_FieldTerminalPath: *fp, value: value.(string)}
	case ConfigMapKeySelector_FieldPathSelectorOptional:
		return &ConfigMapKeySelector_FieldTerminalPathValue{ConfigMapKeySelector_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fp.selector))
	}
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) WithIArrayOfValues(values interface{}) ConfigMapKeySelector_FieldPathArrayOfValues {
	fpaov := &ConfigMapKeySelector_FieldTerminalPathArrayOfValues{ConfigMapKeySelector_FieldTerminalPath: *fp}
	switch fp.selector {
	case ConfigMapKeySelector_FieldPathSelectorName:
		return &ConfigMapKeySelector_FieldTerminalPathArrayOfValues{ConfigMapKeySelector_FieldTerminalPath: *fp, values: values.([]string)}
	case ConfigMapKeySelector_FieldPathSelectorKey:
		return &ConfigMapKeySelector_FieldTerminalPathArrayOfValues{ConfigMapKeySelector_FieldTerminalPath: *fp, values: values.([]string)}
	case ConfigMapKeySelector_FieldPathSelectorOptional:
		return &ConfigMapKeySelector_FieldTerminalPathArrayOfValues{ConfigMapKeySelector_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fp.selector))
	}
	return fpaov
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) WithIArrayItemValue(value interface{}) ConfigMapKeySelector_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fp.selector))
	}
}

func (fp *ConfigMapKeySelector_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ConfigMapKeySelector_FieldPathValue allows storing values for ConfigMapKeySelector fields according to their type
type ConfigMapKeySelector_FieldPathValue interface {
	ConfigMapKeySelector_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ConfigMapKeySelector)
	CompareWith(*ConfigMapKeySelector) (cmp int, comparable bool)
}

func ParseConfigMapKeySelector_FieldPathValue(pathStr, valueStr string) (ConfigMapKeySelector_FieldPathValue, error) {
	fp, err := ParseConfigMapKeySelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapKeySelector field path value from %s: %v", valueStr, err)
	}
	return fpv.(ConfigMapKeySelector_FieldPathValue), nil
}

func MustParseConfigMapKeySelector_FieldPathValue(pathStr, valueStr string) ConfigMapKeySelector_FieldPathValue {
	fpv, err := ParseConfigMapKeySelector_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ConfigMapKeySelector_FieldTerminalPathValue struct {
	ConfigMapKeySelector_FieldTerminalPath
	value interface{}
}

var _ ConfigMapKeySelector_FieldPathValue = (*ConfigMapKeySelector_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ConfigMapKeySelector' as interface{}
func (fpv *ConfigMapKeySelector_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ConfigMapKeySelector_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ConfigMapKeySelector_FieldTerminalPathValue) AsKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ConfigMapKeySelector_FieldTerminalPathValue) AsOptionalValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object ConfigMapKeySelector
func (fpv *ConfigMapKeySelector_FieldTerminalPathValue) SetTo(target **ConfigMapKeySelector) {
	if *target == nil {
		*target = new(ConfigMapKeySelector)
	}
	switch fpv.selector {
	case ConfigMapKeySelector_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case ConfigMapKeySelector_FieldPathSelectorKey:
		(*target).Key = fpv.value.(string)
	case ConfigMapKeySelector_FieldPathSelectorOptional:
		(*target).Optional = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fpv.selector))
	}
}

func (fpv *ConfigMapKeySelector_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ConfigMapKeySelector)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ConfigMapKeySelector_FieldTerminalPathValue' with the value under path in 'ConfigMapKeySelector'.
func (fpv *ConfigMapKeySelector_FieldTerminalPathValue) CompareWith(source *ConfigMapKeySelector) (int, bool) {
	switch fpv.selector {
	case ConfigMapKeySelector_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ConfigMapKeySelector_FieldPathSelectorKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ConfigMapKeySelector_FieldPathSelectorOptional:
		leftValue := fpv.value.(bool)
		rightValue := source.GetOptional()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapKeySelector: %d", fpv.selector))
	}
}

func (fpv *ConfigMapKeySelector_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ConfigMapKeySelector))
}

// ConfigMapKeySelector_FieldPathArrayItemValue allows storing single item in Path-specific values for ConfigMapKeySelector according to their type
// Present only for array (repeated) types.
type ConfigMapKeySelector_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ConfigMapKeySelector_FieldPath
	ContainsValue(*ConfigMapKeySelector) bool
}

// ParseConfigMapKeySelector_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseConfigMapKeySelector_FieldPathArrayItemValue(pathStr, valueStr string) (ConfigMapKeySelector_FieldPathArrayItemValue, error) {
	fp, err := ParseConfigMapKeySelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapKeySelector field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ConfigMapKeySelector_FieldPathArrayItemValue), nil
}

func MustParseConfigMapKeySelector_FieldPathArrayItemValue(pathStr, valueStr string) ConfigMapKeySelector_FieldPathArrayItemValue {
	fpaiv, err := ParseConfigMapKeySelector_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ConfigMapKeySelector_FieldTerminalPathArrayItemValue struct {
	ConfigMapKeySelector_FieldTerminalPath
	value interface{}
}

var _ ConfigMapKeySelector_FieldPathArrayItemValue = (*ConfigMapKeySelector_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ConfigMapKeySelector as interface{}
func (fpaiv *ConfigMapKeySelector_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ConfigMapKeySelector_FieldTerminalPathArrayItemValue) GetSingle(source *ConfigMapKeySelector) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ConfigMapKeySelector_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ConfigMapKeySelector))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ConfigMapKeySelector'
func (fpaiv *ConfigMapKeySelector_FieldTerminalPathArrayItemValue) ContainsValue(source *ConfigMapKeySelector) bool {
	slice := fpaiv.ConfigMapKeySelector_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ConfigMapKeySelector_FieldPathArrayOfValues allows storing slice of values for ConfigMapKeySelector fields according to their type
type ConfigMapKeySelector_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ConfigMapKeySelector_FieldPath
}

func ParseConfigMapKeySelector_FieldPathArrayOfValues(pathStr, valuesStr string) (ConfigMapKeySelector_FieldPathArrayOfValues, error) {
	fp, err := ParseConfigMapKeySelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapKeySelector field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ConfigMapKeySelector_FieldPathArrayOfValues), nil
}

func MustParseConfigMapKeySelector_FieldPathArrayOfValues(pathStr, valuesStr string) ConfigMapKeySelector_FieldPathArrayOfValues {
	fpaov, err := ParseConfigMapKeySelector_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ConfigMapKeySelector_FieldTerminalPathArrayOfValues struct {
	ConfigMapKeySelector_FieldTerminalPath
	values interface{}
}

var _ ConfigMapKeySelector_FieldPathArrayOfValues = (*ConfigMapKeySelector_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ConfigMapKeySelector_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ConfigMapKeySelector_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ConfigMapKeySelector_FieldPathSelectorKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ConfigMapKeySelector_FieldPathSelectorOptional:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ConfigMapKeySelector_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ConfigMapKeySelector_FieldTerminalPathArrayOfValues) AsKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ConfigMapKeySelector_FieldTerminalPathArrayOfValues) AsOptionalArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type SecretKeySelector_FieldPath interface {
	gotenobject.FieldPath
	Selector() SecretKeySelector_FieldPathSelector
	Get(source *SecretKeySelector) []interface{}
	GetSingle(source *SecretKeySelector) (interface{}, bool)
	ClearValue(item *SecretKeySelector)

	// Those methods build corresponding SecretKeySelector_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) SecretKeySelector_FieldPathValue
	WithIArrayOfValues(values interface{}) SecretKeySelector_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) SecretKeySelector_FieldPathArrayItemValue
}

type SecretKeySelector_FieldPathSelector int32

const (
	SecretKeySelector_FieldPathSelectorName     SecretKeySelector_FieldPathSelector = 0
	SecretKeySelector_FieldPathSelectorKey      SecretKeySelector_FieldPathSelector = 1
	SecretKeySelector_FieldPathSelectorOptional SecretKeySelector_FieldPathSelector = 2
)

func (s SecretKeySelector_FieldPathSelector) String() string {
	switch s {
	case SecretKeySelector_FieldPathSelectorName:
		return "name"
	case SecretKeySelector_FieldPathSelectorKey:
		return "key"
	case SecretKeySelector_FieldPathSelectorOptional:
		return "optional"
	default:
		panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", s))
	}
}

func BuildSecretKeySelector_FieldPath(fp gotenobject.RawFieldPath) (SecretKeySelector_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object SecretKeySelector")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorName}, nil
		case "key":
			return &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorKey}, nil
		case "optional":
			return &SecretKeySelector_FieldTerminalPath{selector: SecretKeySelector_FieldPathSelectorOptional}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object SecretKeySelector", fp)
}

func ParseSecretKeySelector_FieldPath(rawField string) (SecretKeySelector_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildSecretKeySelector_FieldPath(fp)
}

func MustParseSecretKeySelector_FieldPath(rawField string) SecretKeySelector_FieldPath {
	fp, err := ParseSecretKeySelector_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type SecretKeySelector_FieldTerminalPath struct {
	selector SecretKeySelector_FieldPathSelector
}

var _ SecretKeySelector_FieldPath = (*SecretKeySelector_FieldTerminalPath)(nil)

func (fp *SecretKeySelector_FieldTerminalPath) Selector() SecretKeySelector_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *SecretKeySelector_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *SecretKeySelector_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source SecretKeySelector
func (fp *SecretKeySelector_FieldTerminalPath) Get(source *SecretKeySelector) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case SecretKeySelector_FieldPathSelectorName:
			values = append(values, source.Name)
		case SecretKeySelector_FieldPathSelectorKey:
			values = append(values, source.Key)
		case SecretKeySelector_FieldPathSelectorOptional:
			values = append(values, source.Optional)
		default:
			panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fp.selector))
		}
	}
	return
}

func (fp *SecretKeySelector_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*SecretKeySelector))
}

// GetSingle returns value pointed by specific field of from source SecretKeySelector
func (fp *SecretKeySelector_FieldTerminalPath) GetSingle(source *SecretKeySelector) (interface{}, bool) {
	switch fp.selector {
	case SecretKeySelector_FieldPathSelectorName:
		return source.GetName(), source != nil
	case SecretKeySelector_FieldPathSelectorKey:
		return source.GetKey(), source != nil
	case SecretKeySelector_FieldPathSelectorOptional:
		return source.GetOptional(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fp.selector))
	}
}

func (fp *SecretKeySelector_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*SecretKeySelector))
}

// GetDefault returns a default value of the field type
func (fp *SecretKeySelector_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case SecretKeySelector_FieldPathSelectorName:
		return ""
	case SecretKeySelector_FieldPathSelectorKey:
		return ""
	case SecretKeySelector_FieldPathSelectorOptional:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fp.selector))
	}
}

func (fp *SecretKeySelector_FieldTerminalPath) ClearValue(item *SecretKeySelector) {
	if item != nil {
		switch fp.selector {
		case SecretKeySelector_FieldPathSelectorName:
			item.Name = ""
		case SecretKeySelector_FieldPathSelectorKey:
			item.Key = ""
		case SecretKeySelector_FieldPathSelectorOptional:
			item.Optional = false
		default:
			panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fp.selector))
		}
	}
}

func (fp *SecretKeySelector_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*SecretKeySelector))
}

// IsLeaf - whether field path is holds simple value
func (fp *SecretKeySelector_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == SecretKeySelector_FieldPathSelectorName ||
		fp.selector == SecretKeySelector_FieldPathSelectorKey ||
		fp.selector == SecretKeySelector_FieldPathSelectorOptional
}

func (fp *SecretKeySelector_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *SecretKeySelector_FieldTerminalPath) WithIValue(value interface{}) SecretKeySelector_FieldPathValue {
	switch fp.selector {
	case SecretKeySelector_FieldPathSelectorName:
		return &SecretKeySelector_FieldTerminalPathValue{SecretKeySelector_FieldTerminalPath: *fp, value: value.(string)}
	case SecretKeySelector_FieldPathSelectorKey:
		return &SecretKeySelector_FieldTerminalPathValue{SecretKeySelector_FieldTerminalPath: *fp, value: value.(string)}
	case SecretKeySelector_FieldPathSelectorOptional:
		return &SecretKeySelector_FieldTerminalPathValue{SecretKeySelector_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fp.selector))
	}
}

func (fp *SecretKeySelector_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *SecretKeySelector_FieldTerminalPath) WithIArrayOfValues(values interface{}) SecretKeySelector_FieldPathArrayOfValues {
	fpaov := &SecretKeySelector_FieldTerminalPathArrayOfValues{SecretKeySelector_FieldTerminalPath: *fp}
	switch fp.selector {
	case SecretKeySelector_FieldPathSelectorName:
		return &SecretKeySelector_FieldTerminalPathArrayOfValues{SecretKeySelector_FieldTerminalPath: *fp, values: values.([]string)}
	case SecretKeySelector_FieldPathSelectorKey:
		return &SecretKeySelector_FieldTerminalPathArrayOfValues{SecretKeySelector_FieldTerminalPath: *fp, values: values.([]string)}
	case SecretKeySelector_FieldPathSelectorOptional:
		return &SecretKeySelector_FieldTerminalPathArrayOfValues{SecretKeySelector_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fp.selector))
	}
	return fpaov
}

func (fp *SecretKeySelector_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *SecretKeySelector_FieldTerminalPath) WithIArrayItemValue(value interface{}) SecretKeySelector_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fp.selector))
	}
}

func (fp *SecretKeySelector_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// SecretKeySelector_FieldPathValue allows storing values for SecretKeySelector fields according to their type
type SecretKeySelector_FieldPathValue interface {
	SecretKeySelector_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **SecretKeySelector)
	CompareWith(*SecretKeySelector) (cmp int, comparable bool)
}

func ParseSecretKeySelector_FieldPathValue(pathStr, valueStr string) (SecretKeySelector_FieldPathValue, error) {
	fp, err := ParseSecretKeySelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretKeySelector field path value from %s: %v", valueStr, err)
	}
	return fpv.(SecretKeySelector_FieldPathValue), nil
}

func MustParseSecretKeySelector_FieldPathValue(pathStr, valueStr string) SecretKeySelector_FieldPathValue {
	fpv, err := ParseSecretKeySelector_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type SecretKeySelector_FieldTerminalPathValue struct {
	SecretKeySelector_FieldTerminalPath
	value interface{}
}

var _ SecretKeySelector_FieldPathValue = (*SecretKeySelector_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'SecretKeySelector' as interface{}
func (fpv *SecretKeySelector_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *SecretKeySelector_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *SecretKeySelector_FieldTerminalPathValue) AsKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *SecretKeySelector_FieldTerminalPathValue) AsOptionalValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object SecretKeySelector
func (fpv *SecretKeySelector_FieldTerminalPathValue) SetTo(target **SecretKeySelector) {
	if *target == nil {
		*target = new(SecretKeySelector)
	}
	switch fpv.selector {
	case SecretKeySelector_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case SecretKeySelector_FieldPathSelectorKey:
		(*target).Key = fpv.value.(string)
	case SecretKeySelector_FieldPathSelectorOptional:
		(*target).Optional = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fpv.selector))
	}
}

func (fpv *SecretKeySelector_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*SecretKeySelector)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'SecretKeySelector_FieldTerminalPathValue' with the value under path in 'SecretKeySelector'.
func (fpv *SecretKeySelector_FieldTerminalPathValue) CompareWith(source *SecretKeySelector) (int, bool) {
	switch fpv.selector {
	case SecretKeySelector_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SecretKeySelector_FieldPathSelectorKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SecretKeySelector_FieldPathSelectorOptional:
		leftValue := fpv.value.(bool)
		rightValue := source.GetOptional()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretKeySelector: %d", fpv.selector))
	}
}

func (fpv *SecretKeySelector_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*SecretKeySelector))
}

// SecretKeySelector_FieldPathArrayItemValue allows storing single item in Path-specific values for SecretKeySelector according to their type
// Present only for array (repeated) types.
type SecretKeySelector_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	SecretKeySelector_FieldPath
	ContainsValue(*SecretKeySelector) bool
}

// ParseSecretKeySelector_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseSecretKeySelector_FieldPathArrayItemValue(pathStr, valueStr string) (SecretKeySelector_FieldPathArrayItemValue, error) {
	fp, err := ParseSecretKeySelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretKeySelector field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(SecretKeySelector_FieldPathArrayItemValue), nil
}

func MustParseSecretKeySelector_FieldPathArrayItemValue(pathStr, valueStr string) SecretKeySelector_FieldPathArrayItemValue {
	fpaiv, err := ParseSecretKeySelector_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type SecretKeySelector_FieldTerminalPathArrayItemValue struct {
	SecretKeySelector_FieldTerminalPath
	value interface{}
}

var _ SecretKeySelector_FieldPathArrayItemValue = (*SecretKeySelector_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object SecretKeySelector as interface{}
func (fpaiv *SecretKeySelector_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *SecretKeySelector_FieldTerminalPathArrayItemValue) GetSingle(source *SecretKeySelector) (interface{}, bool) {
	return nil, false
}

func (fpaiv *SecretKeySelector_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*SecretKeySelector))
}

// Contains returns a boolean indicating if value that is being held is present in given 'SecretKeySelector'
func (fpaiv *SecretKeySelector_FieldTerminalPathArrayItemValue) ContainsValue(source *SecretKeySelector) bool {
	slice := fpaiv.SecretKeySelector_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// SecretKeySelector_FieldPathArrayOfValues allows storing slice of values for SecretKeySelector fields according to their type
type SecretKeySelector_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	SecretKeySelector_FieldPath
}

func ParseSecretKeySelector_FieldPathArrayOfValues(pathStr, valuesStr string) (SecretKeySelector_FieldPathArrayOfValues, error) {
	fp, err := ParseSecretKeySelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretKeySelector field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(SecretKeySelector_FieldPathArrayOfValues), nil
}

func MustParseSecretKeySelector_FieldPathArrayOfValues(pathStr, valuesStr string) SecretKeySelector_FieldPathArrayOfValues {
	fpaov, err := ParseSecretKeySelector_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type SecretKeySelector_FieldTerminalPathArrayOfValues struct {
	SecretKeySelector_FieldTerminalPath
	values interface{}
}

var _ SecretKeySelector_FieldPathArrayOfValues = (*SecretKeySelector_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *SecretKeySelector_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case SecretKeySelector_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case SecretKeySelector_FieldPathSelectorKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case SecretKeySelector_FieldPathSelectorOptional:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *SecretKeySelector_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *SecretKeySelector_FieldTerminalPathArrayOfValues) AsKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *SecretKeySelector_FieldTerminalPathArrayOfValues) AsOptionalArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type LocalObjectReferenceSecret_FieldPath interface {
	gotenobject.FieldPath
	Selector() LocalObjectReferenceSecret_FieldPathSelector
	Get(source *LocalObjectReferenceSecret) []interface{}
	GetSingle(source *LocalObjectReferenceSecret) (interface{}, bool)
	ClearValue(item *LocalObjectReferenceSecret)

	// Those methods build corresponding LocalObjectReferenceSecret_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) LocalObjectReferenceSecret_FieldPathValue
	WithIArrayOfValues(values interface{}) LocalObjectReferenceSecret_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) LocalObjectReferenceSecret_FieldPathArrayItemValue
}

type LocalObjectReferenceSecret_FieldPathSelector int32

const (
	LocalObjectReferenceSecret_FieldPathSelectorName LocalObjectReferenceSecret_FieldPathSelector = 0
)

func (s LocalObjectReferenceSecret_FieldPathSelector) String() string {
	switch s {
	case LocalObjectReferenceSecret_FieldPathSelectorName:
		return "name"
	default:
		panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", s))
	}
}

func BuildLocalObjectReferenceSecret_FieldPath(fp gotenobject.RawFieldPath) (LocalObjectReferenceSecret_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object LocalObjectReferenceSecret")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &LocalObjectReferenceSecret_FieldTerminalPath{selector: LocalObjectReferenceSecret_FieldPathSelectorName}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object LocalObjectReferenceSecret", fp)
}

func ParseLocalObjectReferenceSecret_FieldPath(rawField string) (LocalObjectReferenceSecret_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLocalObjectReferenceSecret_FieldPath(fp)
}

func MustParseLocalObjectReferenceSecret_FieldPath(rawField string) LocalObjectReferenceSecret_FieldPath {
	fp, err := ParseLocalObjectReferenceSecret_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type LocalObjectReferenceSecret_FieldTerminalPath struct {
	selector LocalObjectReferenceSecret_FieldPathSelector
}

var _ LocalObjectReferenceSecret_FieldPath = (*LocalObjectReferenceSecret_FieldTerminalPath)(nil)

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) Selector() LocalObjectReferenceSecret_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *LocalObjectReferenceSecret_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *LocalObjectReferenceSecret_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source LocalObjectReferenceSecret
func (fp *LocalObjectReferenceSecret_FieldTerminalPath) Get(source *LocalObjectReferenceSecret) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case LocalObjectReferenceSecret_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fp.selector))
		}
	}
	return
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*LocalObjectReferenceSecret))
}

// GetSingle returns value pointed by specific field of from source LocalObjectReferenceSecret
func (fp *LocalObjectReferenceSecret_FieldTerminalPath) GetSingle(source *LocalObjectReferenceSecret) (interface{}, bool) {
	switch fp.selector {
	case LocalObjectReferenceSecret_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fp.selector))
	}
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*LocalObjectReferenceSecret))
}

// GetDefault returns a default value of the field type
func (fp *LocalObjectReferenceSecret_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case LocalObjectReferenceSecret_FieldPathSelectorName:
		return (*secrets_secret.Reference)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fp.selector))
	}
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) ClearValue(item *LocalObjectReferenceSecret) {
	if item != nil {
		switch fp.selector {
		case LocalObjectReferenceSecret_FieldPathSelectorName:
			item.Name = nil
		default:
			panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fp.selector))
		}
	}
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*LocalObjectReferenceSecret))
}

// IsLeaf - whether field path is holds simple value
func (fp *LocalObjectReferenceSecret_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == LocalObjectReferenceSecret_FieldPathSelectorName
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) WithIValue(value interface{}) LocalObjectReferenceSecret_FieldPathValue {
	switch fp.selector {
	case LocalObjectReferenceSecret_FieldPathSelectorName:
		return &LocalObjectReferenceSecret_FieldTerminalPathValue{LocalObjectReferenceSecret_FieldTerminalPath: *fp, value: value.(*secrets_secret.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fp.selector))
	}
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) WithIArrayOfValues(values interface{}) LocalObjectReferenceSecret_FieldPathArrayOfValues {
	fpaov := &LocalObjectReferenceSecret_FieldTerminalPathArrayOfValues{LocalObjectReferenceSecret_FieldTerminalPath: *fp}
	switch fp.selector {
	case LocalObjectReferenceSecret_FieldPathSelectorName:
		return &LocalObjectReferenceSecret_FieldTerminalPathArrayOfValues{LocalObjectReferenceSecret_FieldTerminalPath: *fp, values: values.([]*secrets_secret.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fp.selector))
	}
	return fpaov
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) WithIArrayItemValue(value interface{}) LocalObjectReferenceSecret_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fp.selector))
	}
}

func (fp *LocalObjectReferenceSecret_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// LocalObjectReferenceSecret_FieldPathValue allows storing values for LocalObjectReferenceSecret fields according to their type
type LocalObjectReferenceSecret_FieldPathValue interface {
	LocalObjectReferenceSecret_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **LocalObjectReferenceSecret)
	CompareWith(*LocalObjectReferenceSecret) (cmp int, comparable bool)
}

func ParseLocalObjectReferenceSecret_FieldPathValue(pathStr, valueStr string) (LocalObjectReferenceSecret_FieldPathValue, error) {
	fp, err := ParseLocalObjectReferenceSecret_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LocalObjectReferenceSecret field path value from %s: %v", valueStr, err)
	}
	return fpv.(LocalObjectReferenceSecret_FieldPathValue), nil
}

func MustParseLocalObjectReferenceSecret_FieldPathValue(pathStr, valueStr string) LocalObjectReferenceSecret_FieldPathValue {
	fpv, err := ParseLocalObjectReferenceSecret_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type LocalObjectReferenceSecret_FieldTerminalPathValue struct {
	LocalObjectReferenceSecret_FieldTerminalPath
	value interface{}
}

var _ LocalObjectReferenceSecret_FieldPathValue = (*LocalObjectReferenceSecret_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'LocalObjectReferenceSecret' as interface{}
func (fpv *LocalObjectReferenceSecret_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *LocalObjectReferenceSecret_FieldTerminalPathValue) AsNameValue() (*secrets_secret.Reference, bool) {
	res, ok := fpv.value.(*secrets_secret.Reference)
	return res, ok
}

// SetTo stores value for selected field for object LocalObjectReferenceSecret
func (fpv *LocalObjectReferenceSecret_FieldTerminalPathValue) SetTo(target **LocalObjectReferenceSecret) {
	if *target == nil {
		*target = new(LocalObjectReferenceSecret)
	}
	switch fpv.selector {
	case LocalObjectReferenceSecret_FieldPathSelectorName:
		(*target).Name = fpv.value.(*secrets_secret.Reference)
	default:
		panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fpv.selector))
	}
}

func (fpv *LocalObjectReferenceSecret_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LocalObjectReferenceSecret)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LocalObjectReferenceSecret_FieldTerminalPathValue' with the value under path in 'LocalObjectReferenceSecret'.
func (fpv *LocalObjectReferenceSecret_FieldTerminalPathValue) CompareWith(source *LocalObjectReferenceSecret) (int, bool) {
	switch fpv.selector {
	case LocalObjectReferenceSecret_FieldPathSelectorName:
		leftValue := fpv.value.(*secrets_secret.Reference)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for LocalObjectReferenceSecret: %d", fpv.selector))
	}
}

func (fpv *LocalObjectReferenceSecret_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*LocalObjectReferenceSecret))
}

// LocalObjectReferenceSecret_FieldPathArrayItemValue allows storing single item in Path-specific values for LocalObjectReferenceSecret according to their type
// Present only for array (repeated) types.
type LocalObjectReferenceSecret_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	LocalObjectReferenceSecret_FieldPath
	ContainsValue(*LocalObjectReferenceSecret) bool
}

// ParseLocalObjectReferenceSecret_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLocalObjectReferenceSecret_FieldPathArrayItemValue(pathStr, valueStr string) (LocalObjectReferenceSecret_FieldPathArrayItemValue, error) {
	fp, err := ParseLocalObjectReferenceSecret_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LocalObjectReferenceSecret field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(LocalObjectReferenceSecret_FieldPathArrayItemValue), nil
}

func MustParseLocalObjectReferenceSecret_FieldPathArrayItemValue(pathStr, valueStr string) LocalObjectReferenceSecret_FieldPathArrayItemValue {
	fpaiv, err := ParseLocalObjectReferenceSecret_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type LocalObjectReferenceSecret_FieldTerminalPathArrayItemValue struct {
	LocalObjectReferenceSecret_FieldTerminalPath
	value interface{}
}

var _ LocalObjectReferenceSecret_FieldPathArrayItemValue = (*LocalObjectReferenceSecret_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object LocalObjectReferenceSecret as interface{}
func (fpaiv *LocalObjectReferenceSecret_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *LocalObjectReferenceSecret_FieldTerminalPathArrayItemValue) GetSingle(source *LocalObjectReferenceSecret) (interface{}, bool) {
	return nil, false
}

func (fpaiv *LocalObjectReferenceSecret_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*LocalObjectReferenceSecret))
}

// Contains returns a boolean indicating if value that is being held is present in given 'LocalObjectReferenceSecret'
func (fpaiv *LocalObjectReferenceSecret_FieldTerminalPathArrayItemValue) ContainsValue(source *LocalObjectReferenceSecret) bool {
	slice := fpaiv.LocalObjectReferenceSecret_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// LocalObjectReferenceSecret_FieldPathArrayOfValues allows storing slice of values for LocalObjectReferenceSecret fields according to their type
type LocalObjectReferenceSecret_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	LocalObjectReferenceSecret_FieldPath
}

func ParseLocalObjectReferenceSecret_FieldPathArrayOfValues(pathStr, valuesStr string) (LocalObjectReferenceSecret_FieldPathArrayOfValues, error) {
	fp, err := ParseLocalObjectReferenceSecret_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LocalObjectReferenceSecret field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(LocalObjectReferenceSecret_FieldPathArrayOfValues), nil
}

func MustParseLocalObjectReferenceSecret_FieldPathArrayOfValues(pathStr, valuesStr string) LocalObjectReferenceSecret_FieldPathArrayOfValues {
	fpaov, err := ParseLocalObjectReferenceSecret_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type LocalObjectReferenceSecret_FieldTerminalPathArrayOfValues struct {
	LocalObjectReferenceSecret_FieldTerminalPath
	values interface{}
}

var _ LocalObjectReferenceSecret_FieldPathArrayOfValues = (*LocalObjectReferenceSecret_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *LocalObjectReferenceSecret_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case LocalObjectReferenceSecret_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*secrets_secret.Reference) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *LocalObjectReferenceSecret_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*secrets_secret.Reference, bool) {
	res, ok := fpaov.values.([]*secrets_secret.Reference)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type SecurityContext_FieldPath interface {
	gotenobject.FieldPath
	Selector() SecurityContext_FieldPathSelector
	Get(source *SecurityContext) []interface{}
	GetSingle(source *SecurityContext) (interface{}, bool)
	ClearValue(item *SecurityContext)

	// Those methods build corresponding SecurityContext_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) SecurityContext_FieldPathValue
	WithIArrayOfValues(values interface{}) SecurityContext_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) SecurityContext_FieldPathArrayItemValue
}

type SecurityContext_FieldPathSelector int32

const (
	SecurityContext_FieldPathSelectorPrivileged SecurityContext_FieldPathSelector = 0
)

func (s SecurityContext_FieldPathSelector) String() string {
	switch s {
	case SecurityContext_FieldPathSelectorPrivileged:
		return "privileged"
	default:
		panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", s))
	}
}

func BuildSecurityContext_FieldPath(fp gotenobject.RawFieldPath) (SecurityContext_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object SecurityContext")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "privileged":
			return &SecurityContext_FieldTerminalPath{selector: SecurityContext_FieldPathSelectorPrivileged}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object SecurityContext", fp)
}

func ParseSecurityContext_FieldPath(rawField string) (SecurityContext_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildSecurityContext_FieldPath(fp)
}

func MustParseSecurityContext_FieldPath(rawField string) SecurityContext_FieldPath {
	fp, err := ParseSecurityContext_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type SecurityContext_FieldTerminalPath struct {
	selector SecurityContext_FieldPathSelector
}

var _ SecurityContext_FieldPath = (*SecurityContext_FieldTerminalPath)(nil)

func (fp *SecurityContext_FieldTerminalPath) Selector() SecurityContext_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *SecurityContext_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *SecurityContext_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source SecurityContext
func (fp *SecurityContext_FieldTerminalPath) Get(source *SecurityContext) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case SecurityContext_FieldPathSelectorPrivileged:
			values = append(values, source.Privileged)
		default:
			panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fp.selector))
		}
	}
	return
}

func (fp *SecurityContext_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*SecurityContext))
}

// GetSingle returns value pointed by specific field of from source SecurityContext
func (fp *SecurityContext_FieldTerminalPath) GetSingle(source *SecurityContext) (interface{}, bool) {
	switch fp.selector {
	case SecurityContext_FieldPathSelectorPrivileged:
		return source.GetPrivileged(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fp.selector))
	}
}

func (fp *SecurityContext_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*SecurityContext))
}

// GetDefault returns a default value of the field type
func (fp *SecurityContext_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case SecurityContext_FieldPathSelectorPrivileged:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fp.selector))
	}
}

func (fp *SecurityContext_FieldTerminalPath) ClearValue(item *SecurityContext) {
	if item != nil {
		switch fp.selector {
		case SecurityContext_FieldPathSelectorPrivileged:
			item.Privileged = false
		default:
			panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fp.selector))
		}
	}
}

func (fp *SecurityContext_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*SecurityContext))
}

// IsLeaf - whether field path is holds simple value
func (fp *SecurityContext_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == SecurityContext_FieldPathSelectorPrivileged
}

func (fp *SecurityContext_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *SecurityContext_FieldTerminalPath) WithIValue(value interface{}) SecurityContext_FieldPathValue {
	switch fp.selector {
	case SecurityContext_FieldPathSelectorPrivileged:
		return &SecurityContext_FieldTerminalPathValue{SecurityContext_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fp.selector))
	}
}

func (fp *SecurityContext_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *SecurityContext_FieldTerminalPath) WithIArrayOfValues(values interface{}) SecurityContext_FieldPathArrayOfValues {
	fpaov := &SecurityContext_FieldTerminalPathArrayOfValues{SecurityContext_FieldTerminalPath: *fp}
	switch fp.selector {
	case SecurityContext_FieldPathSelectorPrivileged:
		return &SecurityContext_FieldTerminalPathArrayOfValues{SecurityContext_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fp.selector))
	}
	return fpaov
}

func (fp *SecurityContext_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *SecurityContext_FieldTerminalPath) WithIArrayItemValue(value interface{}) SecurityContext_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fp.selector))
	}
}

func (fp *SecurityContext_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// SecurityContext_FieldPathValue allows storing values for SecurityContext fields according to their type
type SecurityContext_FieldPathValue interface {
	SecurityContext_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **SecurityContext)
	CompareWith(*SecurityContext) (cmp int, comparable bool)
}

func ParseSecurityContext_FieldPathValue(pathStr, valueStr string) (SecurityContext_FieldPathValue, error) {
	fp, err := ParseSecurityContext_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecurityContext field path value from %s: %v", valueStr, err)
	}
	return fpv.(SecurityContext_FieldPathValue), nil
}

func MustParseSecurityContext_FieldPathValue(pathStr, valueStr string) SecurityContext_FieldPathValue {
	fpv, err := ParseSecurityContext_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type SecurityContext_FieldTerminalPathValue struct {
	SecurityContext_FieldTerminalPath
	value interface{}
}

var _ SecurityContext_FieldPathValue = (*SecurityContext_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'SecurityContext' as interface{}
func (fpv *SecurityContext_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *SecurityContext_FieldTerminalPathValue) AsPrivilegedValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object SecurityContext
func (fpv *SecurityContext_FieldTerminalPathValue) SetTo(target **SecurityContext) {
	if *target == nil {
		*target = new(SecurityContext)
	}
	switch fpv.selector {
	case SecurityContext_FieldPathSelectorPrivileged:
		(*target).Privileged = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fpv.selector))
	}
}

func (fpv *SecurityContext_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*SecurityContext)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'SecurityContext_FieldTerminalPathValue' with the value under path in 'SecurityContext'.
func (fpv *SecurityContext_FieldTerminalPathValue) CompareWith(source *SecurityContext) (int, bool) {
	switch fpv.selector {
	case SecurityContext_FieldPathSelectorPrivileged:
		leftValue := fpv.value.(bool)
		rightValue := source.GetPrivileged()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for SecurityContext: %d", fpv.selector))
	}
}

func (fpv *SecurityContext_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*SecurityContext))
}

// SecurityContext_FieldPathArrayItemValue allows storing single item in Path-specific values for SecurityContext according to their type
// Present only for array (repeated) types.
type SecurityContext_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	SecurityContext_FieldPath
	ContainsValue(*SecurityContext) bool
}

// ParseSecurityContext_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseSecurityContext_FieldPathArrayItemValue(pathStr, valueStr string) (SecurityContext_FieldPathArrayItemValue, error) {
	fp, err := ParseSecurityContext_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecurityContext field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(SecurityContext_FieldPathArrayItemValue), nil
}

func MustParseSecurityContext_FieldPathArrayItemValue(pathStr, valueStr string) SecurityContext_FieldPathArrayItemValue {
	fpaiv, err := ParseSecurityContext_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type SecurityContext_FieldTerminalPathArrayItemValue struct {
	SecurityContext_FieldTerminalPath
	value interface{}
}

var _ SecurityContext_FieldPathArrayItemValue = (*SecurityContext_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object SecurityContext as interface{}
func (fpaiv *SecurityContext_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *SecurityContext_FieldTerminalPathArrayItemValue) GetSingle(source *SecurityContext) (interface{}, bool) {
	return nil, false
}

func (fpaiv *SecurityContext_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*SecurityContext))
}

// Contains returns a boolean indicating if value that is being held is present in given 'SecurityContext'
func (fpaiv *SecurityContext_FieldTerminalPathArrayItemValue) ContainsValue(source *SecurityContext) bool {
	slice := fpaiv.SecurityContext_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// SecurityContext_FieldPathArrayOfValues allows storing slice of values for SecurityContext fields according to their type
type SecurityContext_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	SecurityContext_FieldPath
}

func ParseSecurityContext_FieldPathArrayOfValues(pathStr, valuesStr string) (SecurityContext_FieldPathArrayOfValues, error) {
	fp, err := ParseSecurityContext_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecurityContext field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(SecurityContext_FieldPathArrayOfValues), nil
}

func MustParseSecurityContext_FieldPathArrayOfValues(pathStr, valuesStr string) SecurityContext_FieldPathArrayOfValues {
	fpaov, err := ParseSecurityContext_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type SecurityContext_FieldTerminalPathArrayOfValues struct {
	SecurityContext_FieldTerminalPath
	values interface{}
}

var _ SecurityContext_FieldPathArrayOfValues = (*SecurityContext_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *SecurityContext_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case SecurityContext_FieldPathSelectorPrivileged:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *SecurityContext_FieldTerminalPathArrayOfValues) AsPrivilegedArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Volume_FieldPath interface {
	gotenobject.FieldPath
	Selector() Volume_FieldPathSelector
	Get(source *Volume) []interface{}
	GetSingle(source *Volume) (interface{}, bool)
	ClearValue(item *Volume)

	// Those methods build corresponding Volume_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Volume_FieldPathValue
	WithIArrayOfValues(values interface{}) Volume_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Volume_FieldPathArrayItemValue
}

type Volume_FieldPathSelector int32

const (
	Volume_FieldPathSelectorName      Volume_FieldPathSelector = 0
	Volume_FieldPathSelectorHostPath  Volume_FieldPathSelector = 1
	Volume_FieldPathSelectorSecret    Volume_FieldPathSelector = 2
	Volume_FieldPathSelectorConfigMap Volume_FieldPathSelector = 3
)

func (s Volume_FieldPathSelector) String() string {
	switch s {
	case Volume_FieldPathSelectorName:
		return "name"
	case Volume_FieldPathSelectorHostPath:
		return "host_path"
	case Volume_FieldPathSelectorSecret:
		return "secret"
	case Volume_FieldPathSelectorConfigMap:
		return "config_map"
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", s))
	}
}

func BuildVolume_FieldPath(fp gotenobject.RawFieldPath) (Volume_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Volume")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorName}, nil
		case "host_path", "hostPath", "host-path":
			return &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorHostPath}, nil
		case "secret":
			return &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorSecret}, nil
		case "config_map", "configMap", "config-map":
			return &Volume_FieldTerminalPath{selector: Volume_FieldPathSelectorConfigMap}, nil
		}
	} else {
		switch fp[0] {
		case "host_path", "hostPath", "host-path":
			if subpath, err := BuildHostPathVolumeSource_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Volume_FieldSubPath{selector: Volume_FieldPathSelectorHostPath, subPath: subpath}, nil
			}
		case "secret":
			if subpath, err := BuildSecretVolumeSource_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Volume_FieldSubPath{selector: Volume_FieldPathSelectorSecret, subPath: subpath}, nil
			}
		case "config_map", "configMap", "config-map":
			if subpath, err := BuildConfigMapVolumeSource_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Volume_FieldSubPath{selector: Volume_FieldPathSelectorConfigMap, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Volume", fp)
}

func ParseVolume_FieldPath(rawField string) (Volume_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildVolume_FieldPath(fp)
}

func MustParseVolume_FieldPath(rawField string) Volume_FieldPath {
	fp, err := ParseVolume_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Volume_FieldTerminalPath struct {
	selector Volume_FieldPathSelector
}

var _ Volume_FieldPath = (*Volume_FieldTerminalPath)(nil)

func (fp *Volume_FieldTerminalPath) Selector() Volume_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Volume_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Volume_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Volume
func (fp *Volume_FieldTerminalPath) Get(source *Volume) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Volume_FieldPathSelectorName:
			values = append(values, source.Name)
		case Volume_FieldPathSelectorHostPath:
			if source.HostPath != nil {
				values = append(values, source.HostPath)
			}
		case Volume_FieldPathSelectorSecret:
			if source.Secret != nil {
				values = append(values, source.Secret)
			}
		case Volume_FieldPathSelectorConfigMap:
			if source.ConfigMap != nil {
				values = append(values, source.ConfigMap)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Volume: %d", fp.selector))
		}
	}
	return
}

func (fp *Volume_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Volume))
}

// GetSingle returns value pointed by specific field of from source Volume
func (fp *Volume_FieldTerminalPath) GetSingle(source *Volume) (interface{}, bool) {
	switch fp.selector {
	case Volume_FieldPathSelectorName:
		return source.GetName(), source != nil
	case Volume_FieldPathSelectorHostPath:
		res := source.GetHostPath()
		return res, res != nil
	case Volume_FieldPathSelectorSecret:
		res := source.GetSecret()
		return res, res != nil
	case Volume_FieldPathSelectorConfigMap:
		res := source.GetConfigMap()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fp.selector))
	}
}

func (fp *Volume_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Volume))
}

// GetDefault returns a default value of the field type
func (fp *Volume_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Volume_FieldPathSelectorName:
		return ""
	case Volume_FieldPathSelectorHostPath:
		return (*HostPathVolumeSource)(nil)
	case Volume_FieldPathSelectorSecret:
		return (*SecretVolumeSource)(nil)
	case Volume_FieldPathSelectorConfigMap:
		return (*ConfigMapVolumeSource)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fp.selector))
	}
}

func (fp *Volume_FieldTerminalPath) ClearValue(item *Volume) {
	if item != nil {
		switch fp.selector {
		case Volume_FieldPathSelectorName:
			item.Name = ""
		case Volume_FieldPathSelectorHostPath:
			item.HostPath = nil
		case Volume_FieldPathSelectorSecret:
			item.Secret = nil
		case Volume_FieldPathSelectorConfigMap:
			item.ConfigMap = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Volume: %d", fp.selector))
		}
	}
}

func (fp *Volume_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Volume))
}

// IsLeaf - whether field path is holds simple value
func (fp *Volume_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Volume_FieldPathSelectorName
}

func (fp *Volume_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Volume_FieldTerminalPath) WithIValue(value interface{}) Volume_FieldPathValue {
	switch fp.selector {
	case Volume_FieldPathSelectorName:
		return &Volume_FieldTerminalPathValue{Volume_FieldTerminalPath: *fp, value: value.(string)}
	case Volume_FieldPathSelectorHostPath:
		return &Volume_FieldTerminalPathValue{Volume_FieldTerminalPath: *fp, value: value.(*HostPathVolumeSource)}
	case Volume_FieldPathSelectorSecret:
		return &Volume_FieldTerminalPathValue{Volume_FieldTerminalPath: *fp, value: value.(*SecretVolumeSource)}
	case Volume_FieldPathSelectorConfigMap:
		return &Volume_FieldTerminalPathValue{Volume_FieldTerminalPath: *fp, value: value.(*ConfigMapVolumeSource)}
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fp.selector))
	}
}

func (fp *Volume_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Volume_FieldTerminalPath) WithIArrayOfValues(values interface{}) Volume_FieldPathArrayOfValues {
	fpaov := &Volume_FieldTerminalPathArrayOfValues{Volume_FieldTerminalPath: *fp}
	switch fp.selector {
	case Volume_FieldPathSelectorName:
		return &Volume_FieldTerminalPathArrayOfValues{Volume_FieldTerminalPath: *fp, values: values.([]string)}
	case Volume_FieldPathSelectorHostPath:
		return &Volume_FieldTerminalPathArrayOfValues{Volume_FieldTerminalPath: *fp, values: values.([]*HostPathVolumeSource)}
	case Volume_FieldPathSelectorSecret:
		return &Volume_FieldTerminalPathArrayOfValues{Volume_FieldTerminalPath: *fp, values: values.([]*SecretVolumeSource)}
	case Volume_FieldPathSelectorConfigMap:
		return &Volume_FieldTerminalPathArrayOfValues{Volume_FieldTerminalPath: *fp, values: values.([]*ConfigMapVolumeSource)}
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fp.selector))
	}
	return fpaov
}

func (fp *Volume_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Volume_FieldTerminalPath) WithIArrayItemValue(value interface{}) Volume_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fp.selector))
	}
}

func (fp *Volume_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type Volume_FieldSubPath struct {
	selector Volume_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ Volume_FieldPath = (*Volume_FieldSubPath)(nil)

func (fps *Volume_FieldSubPath) Selector() Volume_FieldPathSelector {
	return fps.selector
}
func (fps *Volume_FieldSubPath) AsHostPathSubPath() (HostPathVolumeSource_FieldPath, bool) {
	res, ok := fps.subPath.(HostPathVolumeSource_FieldPath)
	return res, ok
}
func (fps *Volume_FieldSubPath) AsSecretSubPath() (SecretVolumeSource_FieldPath, bool) {
	res, ok := fps.subPath.(SecretVolumeSource_FieldPath)
	return res, ok
}
func (fps *Volume_FieldSubPath) AsConfigMapSubPath() (ConfigMapVolumeSource_FieldPath, bool) {
	res, ok := fps.subPath.(ConfigMapVolumeSource_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *Volume_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *Volume_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Volume
func (fps *Volume_FieldSubPath) Get(source *Volume) (values []interface{}) {
	switch fps.selector {
	case Volume_FieldPathSelectorHostPath:
		values = append(values, fps.subPath.GetRaw(source.GetHostPath())...)
	case Volume_FieldPathSelectorSecret:
		values = append(values, fps.subPath.GetRaw(source.GetSecret())...)
	case Volume_FieldPathSelectorConfigMap:
		values = append(values, fps.subPath.GetRaw(source.GetConfigMap())...)
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fps.selector))
	}
	return
}

func (fps *Volume_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Volume))
}

// GetSingle returns value of selected field from source Volume
func (fps *Volume_FieldSubPath) GetSingle(source *Volume) (interface{}, bool) {
	switch fps.selector {
	case Volume_FieldPathSelectorHostPath:
		if source.GetHostPath() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetHostPath())
	case Volume_FieldPathSelectorSecret:
		if source.GetSecret() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetSecret())
	case Volume_FieldPathSelectorConfigMap:
		if source.GetConfigMap() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetConfigMap())
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fps.selector))
	}
}

func (fps *Volume_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Volume))
}

// GetDefault returns a default value of the field type
func (fps *Volume_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *Volume_FieldSubPath) ClearValue(item *Volume) {
	if item != nil {
		switch fps.selector {
		case Volume_FieldPathSelectorHostPath:
			fps.subPath.ClearValueRaw(item.HostPath)
		case Volume_FieldPathSelectorSecret:
			fps.subPath.ClearValueRaw(item.Secret)
		case Volume_FieldPathSelectorConfigMap:
			fps.subPath.ClearValueRaw(item.ConfigMap)
		default:
			panic(fmt.Sprintf("Invalid selector for Volume: %d", fps.selector))
		}
	}
}

func (fps *Volume_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Volume))
}

// IsLeaf - whether field path is holds simple value
func (fps *Volume_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *Volume_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&Volume_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *Volume_FieldSubPath) WithIValue(value interface{}) Volume_FieldPathValue {
	return &Volume_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *Volume_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *Volume_FieldSubPath) WithIArrayOfValues(values interface{}) Volume_FieldPathArrayOfValues {
	return &Volume_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *Volume_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *Volume_FieldSubPath) WithIArrayItemValue(value interface{}) Volume_FieldPathArrayItemValue {
	return &Volume_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *Volume_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// Volume_FieldPathValue allows storing values for Volume fields according to their type
type Volume_FieldPathValue interface {
	Volume_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Volume)
	CompareWith(*Volume) (cmp int, comparable bool)
}

func ParseVolume_FieldPathValue(pathStr, valueStr string) (Volume_FieldPathValue, error) {
	fp, err := ParseVolume_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Volume field path value from %s: %v", valueStr, err)
	}
	return fpv.(Volume_FieldPathValue), nil
}

func MustParseVolume_FieldPathValue(pathStr, valueStr string) Volume_FieldPathValue {
	fpv, err := ParseVolume_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Volume_FieldTerminalPathValue struct {
	Volume_FieldTerminalPath
	value interface{}
}

var _ Volume_FieldPathValue = (*Volume_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Volume' as interface{}
func (fpv *Volume_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Volume_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Volume_FieldTerminalPathValue) AsHostPathValue() (*HostPathVolumeSource, bool) {
	res, ok := fpv.value.(*HostPathVolumeSource)
	return res, ok
}
func (fpv *Volume_FieldTerminalPathValue) AsSecretValue() (*SecretVolumeSource, bool) {
	res, ok := fpv.value.(*SecretVolumeSource)
	return res, ok
}
func (fpv *Volume_FieldTerminalPathValue) AsConfigMapValue() (*ConfigMapVolumeSource, bool) {
	res, ok := fpv.value.(*ConfigMapVolumeSource)
	return res, ok
}

// SetTo stores value for selected field for object Volume
func (fpv *Volume_FieldTerminalPathValue) SetTo(target **Volume) {
	if *target == nil {
		*target = new(Volume)
	}
	switch fpv.selector {
	case Volume_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case Volume_FieldPathSelectorHostPath:
		(*target).HostPath = fpv.value.(*HostPathVolumeSource)
	case Volume_FieldPathSelectorSecret:
		(*target).Secret = fpv.value.(*SecretVolumeSource)
	case Volume_FieldPathSelectorConfigMap:
		(*target).ConfigMap = fpv.value.(*ConfigMapVolumeSource)
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fpv.selector))
	}
}

func (fpv *Volume_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Volume)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Volume_FieldTerminalPathValue' with the value under path in 'Volume'.
func (fpv *Volume_FieldTerminalPathValue) CompareWith(source *Volume) (int, bool) {
	switch fpv.selector {
	case Volume_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Volume_FieldPathSelectorHostPath:
		return 0, false
	case Volume_FieldPathSelectorSecret:
		return 0, false
	case Volume_FieldPathSelectorConfigMap:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fpv.selector))
	}
}

func (fpv *Volume_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Volume))
}

type Volume_FieldSubPathValue struct {
	Volume_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ Volume_FieldPathValue = (*Volume_FieldSubPathValue)(nil)

func (fpvs *Volume_FieldSubPathValue) AsHostPathPathValue() (HostPathVolumeSource_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(HostPathVolumeSource_FieldPathValue)
	return res, ok
}
func (fpvs *Volume_FieldSubPathValue) AsSecretPathValue() (SecretVolumeSource_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(SecretVolumeSource_FieldPathValue)
	return res, ok
}
func (fpvs *Volume_FieldSubPathValue) AsConfigMapPathValue() (ConfigMapVolumeSource_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ConfigMapVolumeSource_FieldPathValue)
	return res, ok
}

func (fpvs *Volume_FieldSubPathValue) SetTo(target **Volume) {
	if *target == nil {
		*target = new(Volume)
	}
	switch fpvs.Selector() {
	case Volume_FieldPathSelectorHostPath:
		fpvs.subPathValue.(HostPathVolumeSource_FieldPathValue).SetTo(&(*target).HostPath)
	case Volume_FieldPathSelectorSecret:
		fpvs.subPathValue.(SecretVolumeSource_FieldPathValue).SetTo(&(*target).Secret)
	case Volume_FieldPathSelectorConfigMap:
		fpvs.subPathValue.(ConfigMapVolumeSource_FieldPathValue).SetTo(&(*target).ConfigMap)
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fpvs.Selector()))
	}
}

func (fpvs *Volume_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Volume)
	fpvs.SetTo(&typedObject)
}

func (fpvs *Volume_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *Volume_FieldSubPathValue) CompareWith(source *Volume) (int, bool) {
	switch fpvs.Selector() {
	case Volume_FieldPathSelectorHostPath:
		return fpvs.subPathValue.(HostPathVolumeSource_FieldPathValue).CompareWith(source.GetHostPath())
	case Volume_FieldPathSelectorSecret:
		return fpvs.subPathValue.(SecretVolumeSource_FieldPathValue).CompareWith(source.GetSecret())
	case Volume_FieldPathSelectorConfigMap:
		return fpvs.subPathValue.(ConfigMapVolumeSource_FieldPathValue).CompareWith(source.GetConfigMap())
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fpvs.Selector()))
	}
}

func (fpvs *Volume_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Volume))
}

// Volume_FieldPathArrayItemValue allows storing single item in Path-specific values for Volume according to their type
// Present only for array (repeated) types.
type Volume_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Volume_FieldPath
	ContainsValue(*Volume) bool
}

// ParseVolume_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseVolume_FieldPathArrayItemValue(pathStr, valueStr string) (Volume_FieldPathArrayItemValue, error) {
	fp, err := ParseVolume_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Volume field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Volume_FieldPathArrayItemValue), nil
}

func MustParseVolume_FieldPathArrayItemValue(pathStr, valueStr string) Volume_FieldPathArrayItemValue {
	fpaiv, err := ParseVolume_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Volume_FieldTerminalPathArrayItemValue struct {
	Volume_FieldTerminalPath
	value interface{}
}

var _ Volume_FieldPathArrayItemValue = (*Volume_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Volume as interface{}
func (fpaiv *Volume_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Volume_FieldTerminalPathArrayItemValue) GetSingle(source *Volume) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Volume_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Volume))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Volume'
func (fpaiv *Volume_FieldTerminalPathArrayItemValue) ContainsValue(source *Volume) bool {
	slice := fpaiv.Volume_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type Volume_FieldSubPathArrayItemValue struct {
	Volume_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *Volume_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *Volume_FieldSubPathArrayItemValue) AsHostPathPathItemValue() (HostPathVolumeSource_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(HostPathVolumeSource_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Volume_FieldSubPathArrayItemValue) AsSecretPathItemValue() (SecretVolumeSource_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(SecretVolumeSource_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Volume_FieldSubPathArrayItemValue) AsConfigMapPathItemValue() (ConfigMapVolumeSource_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ConfigMapVolumeSource_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'Volume'
func (fpaivs *Volume_FieldSubPathArrayItemValue) ContainsValue(source *Volume) bool {
	switch fpaivs.Selector() {
	case Volume_FieldPathSelectorHostPath:
		return fpaivs.subPathItemValue.(HostPathVolumeSource_FieldPathArrayItemValue).ContainsValue(source.GetHostPath())
	case Volume_FieldPathSelectorSecret:
		return fpaivs.subPathItemValue.(SecretVolumeSource_FieldPathArrayItemValue).ContainsValue(source.GetSecret())
	case Volume_FieldPathSelectorConfigMap:
		return fpaivs.subPathItemValue.(ConfigMapVolumeSource_FieldPathArrayItemValue).ContainsValue(source.GetConfigMap())
	default:
		panic(fmt.Sprintf("Invalid selector for Volume: %d", fpaivs.Selector()))
	}
}

// Volume_FieldPathArrayOfValues allows storing slice of values for Volume fields according to their type
type Volume_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Volume_FieldPath
}

func ParseVolume_FieldPathArrayOfValues(pathStr, valuesStr string) (Volume_FieldPathArrayOfValues, error) {
	fp, err := ParseVolume_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Volume field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Volume_FieldPathArrayOfValues), nil
}

func MustParseVolume_FieldPathArrayOfValues(pathStr, valuesStr string) Volume_FieldPathArrayOfValues {
	fpaov, err := ParseVolume_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Volume_FieldTerminalPathArrayOfValues struct {
	Volume_FieldTerminalPath
	values interface{}
}

var _ Volume_FieldPathArrayOfValues = (*Volume_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Volume_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Volume_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Volume_FieldPathSelectorHostPath:
		for _, v := range fpaov.values.([]*HostPathVolumeSource) {
			values = append(values, v)
		}
	case Volume_FieldPathSelectorSecret:
		for _, v := range fpaov.values.([]*SecretVolumeSource) {
			values = append(values, v)
		}
	case Volume_FieldPathSelectorConfigMap:
		for _, v := range fpaov.values.([]*ConfigMapVolumeSource) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Volume_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Volume_FieldTerminalPathArrayOfValues) AsHostPathArrayOfValues() ([]*HostPathVolumeSource, bool) {
	res, ok := fpaov.values.([]*HostPathVolumeSource)
	return res, ok
}
func (fpaov *Volume_FieldTerminalPathArrayOfValues) AsSecretArrayOfValues() ([]*SecretVolumeSource, bool) {
	res, ok := fpaov.values.([]*SecretVolumeSource)
	return res, ok
}
func (fpaov *Volume_FieldTerminalPathArrayOfValues) AsConfigMapArrayOfValues() ([]*ConfigMapVolumeSource, bool) {
	res, ok := fpaov.values.([]*ConfigMapVolumeSource)
	return res, ok
}

type Volume_FieldSubPathArrayOfValues struct {
	Volume_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ Volume_FieldPathArrayOfValues = (*Volume_FieldSubPathArrayOfValues)(nil)

func (fpsaov *Volume_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *Volume_FieldSubPathArrayOfValues) AsHostPathPathArrayOfValues() (HostPathVolumeSource_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(HostPathVolumeSource_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Volume_FieldSubPathArrayOfValues) AsSecretPathArrayOfValues() (SecretVolumeSource_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(SecretVolumeSource_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Volume_FieldSubPathArrayOfValues) AsConfigMapPathArrayOfValues() (ConfigMapVolumeSource_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ConfigMapVolumeSource_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type VolumeMount_FieldPath interface {
	gotenobject.FieldPath
	Selector() VolumeMount_FieldPathSelector
	Get(source *VolumeMount) []interface{}
	GetSingle(source *VolumeMount) (interface{}, bool)
	ClearValue(item *VolumeMount)

	// Those methods build corresponding VolumeMount_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) VolumeMount_FieldPathValue
	WithIArrayOfValues(values interface{}) VolumeMount_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) VolumeMount_FieldPathArrayItemValue
}

type VolumeMount_FieldPathSelector int32

const (
	VolumeMount_FieldPathSelectorName      VolumeMount_FieldPathSelector = 0
	VolumeMount_FieldPathSelectorReadOnly  VolumeMount_FieldPathSelector = 1
	VolumeMount_FieldPathSelectorMountPath VolumeMount_FieldPathSelector = 2
	VolumeMount_FieldPathSelectorSubPath   VolumeMount_FieldPathSelector = 3
)

func (s VolumeMount_FieldPathSelector) String() string {
	switch s {
	case VolumeMount_FieldPathSelectorName:
		return "name"
	case VolumeMount_FieldPathSelectorReadOnly:
		return "read_only"
	case VolumeMount_FieldPathSelectorMountPath:
		return "mount_path"
	case VolumeMount_FieldPathSelectorSubPath:
		return "sub_path"
	default:
		panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", s))
	}
}

func BuildVolumeMount_FieldPath(fp gotenobject.RawFieldPath) (VolumeMount_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object VolumeMount")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorName}, nil
		case "read_only", "readOnly", "read-only":
			return &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorReadOnly}, nil
		case "mount_path", "mountPath", "mount-path":
			return &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorMountPath}, nil
		case "sub_path", "subPath", "sub-path":
			return &VolumeMount_FieldTerminalPath{selector: VolumeMount_FieldPathSelectorSubPath}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object VolumeMount", fp)
}

func ParseVolumeMount_FieldPath(rawField string) (VolumeMount_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildVolumeMount_FieldPath(fp)
}

func MustParseVolumeMount_FieldPath(rawField string) VolumeMount_FieldPath {
	fp, err := ParseVolumeMount_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type VolumeMount_FieldTerminalPath struct {
	selector VolumeMount_FieldPathSelector
}

var _ VolumeMount_FieldPath = (*VolumeMount_FieldTerminalPath)(nil)

func (fp *VolumeMount_FieldTerminalPath) Selector() VolumeMount_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *VolumeMount_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *VolumeMount_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source VolumeMount
func (fp *VolumeMount_FieldTerminalPath) Get(source *VolumeMount) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case VolumeMount_FieldPathSelectorName:
			values = append(values, source.Name)
		case VolumeMount_FieldPathSelectorReadOnly:
			values = append(values, source.ReadOnly)
		case VolumeMount_FieldPathSelectorMountPath:
			values = append(values, source.MountPath)
		case VolumeMount_FieldPathSelectorSubPath:
			values = append(values, source.SubPath)
		default:
			panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fp.selector))
		}
	}
	return
}

func (fp *VolumeMount_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*VolumeMount))
}

// GetSingle returns value pointed by specific field of from source VolumeMount
func (fp *VolumeMount_FieldTerminalPath) GetSingle(source *VolumeMount) (interface{}, bool) {
	switch fp.selector {
	case VolumeMount_FieldPathSelectorName:
		return source.GetName(), source != nil
	case VolumeMount_FieldPathSelectorReadOnly:
		return source.GetReadOnly(), source != nil
	case VolumeMount_FieldPathSelectorMountPath:
		return source.GetMountPath(), source != nil
	case VolumeMount_FieldPathSelectorSubPath:
		return source.GetSubPath(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fp.selector))
	}
}

func (fp *VolumeMount_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*VolumeMount))
}

// GetDefault returns a default value of the field type
func (fp *VolumeMount_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case VolumeMount_FieldPathSelectorName:
		return ""
	case VolumeMount_FieldPathSelectorReadOnly:
		return false
	case VolumeMount_FieldPathSelectorMountPath:
		return ""
	case VolumeMount_FieldPathSelectorSubPath:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fp.selector))
	}
}

func (fp *VolumeMount_FieldTerminalPath) ClearValue(item *VolumeMount) {
	if item != nil {
		switch fp.selector {
		case VolumeMount_FieldPathSelectorName:
			item.Name = ""
		case VolumeMount_FieldPathSelectorReadOnly:
			item.ReadOnly = false
		case VolumeMount_FieldPathSelectorMountPath:
			item.MountPath = ""
		case VolumeMount_FieldPathSelectorSubPath:
			item.SubPath = ""
		default:
			panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fp.selector))
		}
	}
}

func (fp *VolumeMount_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*VolumeMount))
}

// IsLeaf - whether field path is holds simple value
func (fp *VolumeMount_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == VolumeMount_FieldPathSelectorName ||
		fp.selector == VolumeMount_FieldPathSelectorReadOnly ||
		fp.selector == VolumeMount_FieldPathSelectorMountPath ||
		fp.selector == VolumeMount_FieldPathSelectorSubPath
}

func (fp *VolumeMount_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *VolumeMount_FieldTerminalPath) WithIValue(value interface{}) VolumeMount_FieldPathValue {
	switch fp.selector {
	case VolumeMount_FieldPathSelectorName:
		return &VolumeMount_FieldTerminalPathValue{VolumeMount_FieldTerminalPath: *fp, value: value.(string)}
	case VolumeMount_FieldPathSelectorReadOnly:
		return &VolumeMount_FieldTerminalPathValue{VolumeMount_FieldTerminalPath: *fp, value: value.(bool)}
	case VolumeMount_FieldPathSelectorMountPath:
		return &VolumeMount_FieldTerminalPathValue{VolumeMount_FieldTerminalPath: *fp, value: value.(string)}
	case VolumeMount_FieldPathSelectorSubPath:
		return &VolumeMount_FieldTerminalPathValue{VolumeMount_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fp.selector))
	}
}

func (fp *VolumeMount_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *VolumeMount_FieldTerminalPath) WithIArrayOfValues(values interface{}) VolumeMount_FieldPathArrayOfValues {
	fpaov := &VolumeMount_FieldTerminalPathArrayOfValues{VolumeMount_FieldTerminalPath: *fp}
	switch fp.selector {
	case VolumeMount_FieldPathSelectorName:
		return &VolumeMount_FieldTerminalPathArrayOfValues{VolumeMount_FieldTerminalPath: *fp, values: values.([]string)}
	case VolumeMount_FieldPathSelectorReadOnly:
		return &VolumeMount_FieldTerminalPathArrayOfValues{VolumeMount_FieldTerminalPath: *fp, values: values.([]bool)}
	case VolumeMount_FieldPathSelectorMountPath:
		return &VolumeMount_FieldTerminalPathArrayOfValues{VolumeMount_FieldTerminalPath: *fp, values: values.([]string)}
	case VolumeMount_FieldPathSelectorSubPath:
		return &VolumeMount_FieldTerminalPathArrayOfValues{VolumeMount_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fp.selector))
	}
	return fpaov
}

func (fp *VolumeMount_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *VolumeMount_FieldTerminalPath) WithIArrayItemValue(value interface{}) VolumeMount_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fp.selector))
	}
}

func (fp *VolumeMount_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// VolumeMount_FieldPathValue allows storing values for VolumeMount fields according to their type
type VolumeMount_FieldPathValue interface {
	VolumeMount_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **VolumeMount)
	CompareWith(*VolumeMount) (cmp int, comparable bool)
}

func ParseVolumeMount_FieldPathValue(pathStr, valueStr string) (VolumeMount_FieldPathValue, error) {
	fp, err := ParseVolumeMount_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing VolumeMount field path value from %s: %v", valueStr, err)
	}
	return fpv.(VolumeMount_FieldPathValue), nil
}

func MustParseVolumeMount_FieldPathValue(pathStr, valueStr string) VolumeMount_FieldPathValue {
	fpv, err := ParseVolumeMount_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type VolumeMount_FieldTerminalPathValue struct {
	VolumeMount_FieldTerminalPath
	value interface{}
}

var _ VolumeMount_FieldPathValue = (*VolumeMount_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'VolumeMount' as interface{}
func (fpv *VolumeMount_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *VolumeMount_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *VolumeMount_FieldTerminalPathValue) AsReadOnlyValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *VolumeMount_FieldTerminalPathValue) AsMountPathValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *VolumeMount_FieldTerminalPathValue) AsSubPathValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object VolumeMount
func (fpv *VolumeMount_FieldTerminalPathValue) SetTo(target **VolumeMount) {
	if *target == nil {
		*target = new(VolumeMount)
	}
	switch fpv.selector {
	case VolumeMount_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case VolumeMount_FieldPathSelectorReadOnly:
		(*target).ReadOnly = fpv.value.(bool)
	case VolumeMount_FieldPathSelectorMountPath:
		(*target).MountPath = fpv.value.(string)
	case VolumeMount_FieldPathSelectorSubPath:
		(*target).SubPath = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fpv.selector))
	}
}

func (fpv *VolumeMount_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*VolumeMount)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'VolumeMount_FieldTerminalPathValue' with the value under path in 'VolumeMount'.
func (fpv *VolumeMount_FieldTerminalPathValue) CompareWith(source *VolumeMount) (int, bool) {
	switch fpv.selector {
	case VolumeMount_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case VolumeMount_FieldPathSelectorReadOnly:
		leftValue := fpv.value.(bool)
		rightValue := source.GetReadOnly()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case VolumeMount_FieldPathSelectorMountPath:
		leftValue := fpv.value.(string)
		rightValue := source.GetMountPath()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case VolumeMount_FieldPathSelectorSubPath:
		leftValue := fpv.value.(string)
		rightValue := source.GetSubPath()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for VolumeMount: %d", fpv.selector))
	}
}

func (fpv *VolumeMount_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*VolumeMount))
}

// VolumeMount_FieldPathArrayItemValue allows storing single item in Path-specific values for VolumeMount according to their type
// Present only for array (repeated) types.
type VolumeMount_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	VolumeMount_FieldPath
	ContainsValue(*VolumeMount) bool
}

// ParseVolumeMount_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseVolumeMount_FieldPathArrayItemValue(pathStr, valueStr string) (VolumeMount_FieldPathArrayItemValue, error) {
	fp, err := ParseVolumeMount_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing VolumeMount field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(VolumeMount_FieldPathArrayItemValue), nil
}

func MustParseVolumeMount_FieldPathArrayItemValue(pathStr, valueStr string) VolumeMount_FieldPathArrayItemValue {
	fpaiv, err := ParseVolumeMount_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type VolumeMount_FieldTerminalPathArrayItemValue struct {
	VolumeMount_FieldTerminalPath
	value interface{}
}

var _ VolumeMount_FieldPathArrayItemValue = (*VolumeMount_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object VolumeMount as interface{}
func (fpaiv *VolumeMount_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *VolumeMount_FieldTerminalPathArrayItemValue) GetSingle(source *VolumeMount) (interface{}, bool) {
	return nil, false
}

func (fpaiv *VolumeMount_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*VolumeMount))
}

// Contains returns a boolean indicating if value that is being held is present in given 'VolumeMount'
func (fpaiv *VolumeMount_FieldTerminalPathArrayItemValue) ContainsValue(source *VolumeMount) bool {
	slice := fpaiv.VolumeMount_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// VolumeMount_FieldPathArrayOfValues allows storing slice of values for VolumeMount fields according to their type
type VolumeMount_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	VolumeMount_FieldPath
}

func ParseVolumeMount_FieldPathArrayOfValues(pathStr, valuesStr string) (VolumeMount_FieldPathArrayOfValues, error) {
	fp, err := ParseVolumeMount_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing VolumeMount field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(VolumeMount_FieldPathArrayOfValues), nil
}

func MustParseVolumeMount_FieldPathArrayOfValues(pathStr, valuesStr string) VolumeMount_FieldPathArrayOfValues {
	fpaov, err := ParseVolumeMount_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type VolumeMount_FieldTerminalPathArrayOfValues struct {
	VolumeMount_FieldTerminalPath
	values interface{}
}

var _ VolumeMount_FieldPathArrayOfValues = (*VolumeMount_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *VolumeMount_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case VolumeMount_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case VolumeMount_FieldPathSelectorReadOnly:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case VolumeMount_FieldPathSelectorMountPath:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case VolumeMount_FieldPathSelectorSubPath:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *VolumeMount_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *VolumeMount_FieldTerminalPathArrayOfValues) AsReadOnlyArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *VolumeMount_FieldTerminalPathArrayOfValues) AsMountPathArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *VolumeMount_FieldTerminalPathArrayOfValues) AsSubPathArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type HostPathVolumeSource_FieldPath interface {
	gotenobject.FieldPath
	Selector() HostPathVolumeSource_FieldPathSelector
	Get(source *HostPathVolumeSource) []interface{}
	GetSingle(source *HostPathVolumeSource) (interface{}, bool)
	ClearValue(item *HostPathVolumeSource)

	// Those methods build corresponding HostPathVolumeSource_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) HostPathVolumeSource_FieldPathValue
	WithIArrayOfValues(values interface{}) HostPathVolumeSource_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) HostPathVolumeSource_FieldPathArrayItemValue
}

type HostPathVolumeSource_FieldPathSelector int32

const (
	HostPathVolumeSource_FieldPathSelectorPath HostPathVolumeSource_FieldPathSelector = 0
	HostPathVolumeSource_FieldPathSelectorType HostPathVolumeSource_FieldPathSelector = 1
)

func (s HostPathVolumeSource_FieldPathSelector) String() string {
	switch s {
	case HostPathVolumeSource_FieldPathSelectorPath:
		return "path"
	case HostPathVolumeSource_FieldPathSelectorType:
		return "type"
	default:
		panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", s))
	}
}

func BuildHostPathVolumeSource_FieldPath(fp gotenobject.RawFieldPath) (HostPathVolumeSource_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object HostPathVolumeSource")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "path":
			return &HostPathVolumeSource_FieldTerminalPath{selector: HostPathVolumeSource_FieldPathSelectorPath}, nil
		case "type":
			return &HostPathVolumeSource_FieldTerminalPath{selector: HostPathVolumeSource_FieldPathSelectorType}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object HostPathVolumeSource", fp)
}

func ParseHostPathVolumeSource_FieldPath(rawField string) (HostPathVolumeSource_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildHostPathVolumeSource_FieldPath(fp)
}

func MustParseHostPathVolumeSource_FieldPath(rawField string) HostPathVolumeSource_FieldPath {
	fp, err := ParseHostPathVolumeSource_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type HostPathVolumeSource_FieldTerminalPath struct {
	selector HostPathVolumeSource_FieldPathSelector
}

var _ HostPathVolumeSource_FieldPath = (*HostPathVolumeSource_FieldTerminalPath)(nil)

func (fp *HostPathVolumeSource_FieldTerminalPath) Selector() HostPathVolumeSource_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *HostPathVolumeSource_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *HostPathVolumeSource_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source HostPathVolumeSource
func (fp *HostPathVolumeSource_FieldTerminalPath) Get(source *HostPathVolumeSource) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case HostPathVolumeSource_FieldPathSelectorPath:
			values = append(values, source.Path)
		case HostPathVolumeSource_FieldPathSelectorType:
			values = append(values, source.Type)
		default:
			panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fp.selector))
		}
	}
	return
}

func (fp *HostPathVolumeSource_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*HostPathVolumeSource))
}

// GetSingle returns value pointed by specific field of from source HostPathVolumeSource
func (fp *HostPathVolumeSource_FieldTerminalPath) GetSingle(source *HostPathVolumeSource) (interface{}, bool) {
	switch fp.selector {
	case HostPathVolumeSource_FieldPathSelectorPath:
		return source.GetPath(), source != nil
	case HostPathVolumeSource_FieldPathSelectorType:
		return source.GetType(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fp.selector))
	}
}

func (fp *HostPathVolumeSource_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*HostPathVolumeSource))
}

// GetDefault returns a default value of the field type
func (fp *HostPathVolumeSource_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case HostPathVolumeSource_FieldPathSelectorPath:
		return ""
	case HostPathVolumeSource_FieldPathSelectorType:
		return HostPathVolumeSource_TYPE_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fp.selector))
	}
}

func (fp *HostPathVolumeSource_FieldTerminalPath) ClearValue(item *HostPathVolumeSource) {
	if item != nil {
		switch fp.selector {
		case HostPathVolumeSource_FieldPathSelectorPath:
			item.Path = ""
		case HostPathVolumeSource_FieldPathSelectorType:
			item.Type = HostPathVolumeSource_TYPE_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fp.selector))
		}
	}
}

func (fp *HostPathVolumeSource_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*HostPathVolumeSource))
}

// IsLeaf - whether field path is holds simple value
func (fp *HostPathVolumeSource_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == HostPathVolumeSource_FieldPathSelectorPath ||
		fp.selector == HostPathVolumeSource_FieldPathSelectorType
}

func (fp *HostPathVolumeSource_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *HostPathVolumeSource_FieldTerminalPath) WithIValue(value interface{}) HostPathVolumeSource_FieldPathValue {
	switch fp.selector {
	case HostPathVolumeSource_FieldPathSelectorPath:
		return &HostPathVolumeSource_FieldTerminalPathValue{HostPathVolumeSource_FieldTerminalPath: *fp, value: value.(string)}
	case HostPathVolumeSource_FieldPathSelectorType:
		return &HostPathVolumeSource_FieldTerminalPathValue{HostPathVolumeSource_FieldTerminalPath: *fp, value: value.(HostPathVolumeSource_Type)}
	default:
		panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fp.selector))
	}
}

func (fp *HostPathVolumeSource_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *HostPathVolumeSource_FieldTerminalPath) WithIArrayOfValues(values interface{}) HostPathVolumeSource_FieldPathArrayOfValues {
	fpaov := &HostPathVolumeSource_FieldTerminalPathArrayOfValues{HostPathVolumeSource_FieldTerminalPath: *fp}
	switch fp.selector {
	case HostPathVolumeSource_FieldPathSelectorPath:
		return &HostPathVolumeSource_FieldTerminalPathArrayOfValues{HostPathVolumeSource_FieldTerminalPath: *fp, values: values.([]string)}
	case HostPathVolumeSource_FieldPathSelectorType:
		return &HostPathVolumeSource_FieldTerminalPathArrayOfValues{HostPathVolumeSource_FieldTerminalPath: *fp, values: values.([]HostPathVolumeSource_Type)}
	default:
		panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fp.selector))
	}
	return fpaov
}

func (fp *HostPathVolumeSource_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *HostPathVolumeSource_FieldTerminalPath) WithIArrayItemValue(value interface{}) HostPathVolumeSource_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fp.selector))
	}
}

func (fp *HostPathVolumeSource_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// HostPathVolumeSource_FieldPathValue allows storing values for HostPathVolumeSource fields according to their type
type HostPathVolumeSource_FieldPathValue interface {
	HostPathVolumeSource_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **HostPathVolumeSource)
	CompareWith(*HostPathVolumeSource) (cmp int, comparable bool)
}

func ParseHostPathVolumeSource_FieldPathValue(pathStr, valueStr string) (HostPathVolumeSource_FieldPathValue, error) {
	fp, err := ParseHostPathVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HostPathVolumeSource field path value from %s: %v", valueStr, err)
	}
	return fpv.(HostPathVolumeSource_FieldPathValue), nil
}

func MustParseHostPathVolumeSource_FieldPathValue(pathStr, valueStr string) HostPathVolumeSource_FieldPathValue {
	fpv, err := ParseHostPathVolumeSource_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type HostPathVolumeSource_FieldTerminalPathValue struct {
	HostPathVolumeSource_FieldTerminalPath
	value interface{}
}

var _ HostPathVolumeSource_FieldPathValue = (*HostPathVolumeSource_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'HostPathVolumeSource' as interface{}
func (fpv *HostPathVolumeSource_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *HostPathVolumeSource_FieldTerminalPathValue) AsPathValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *HostPathVolumeSource_FieldTerminalPathValue) AsTypeValue() (HostPathVolumeSource_Type, bool) {
	res, ok := fpv.value.(HostPathVolumeSource_Type)
	return res, ok
}

// SetTo stores value for selected field for object HostPathVolumeSource
func (fpv *HostPathVolumeSource_FieldTerminalPathValue) SetTo(target **HostPathVolumeSource) {
	if *target == nil {
		*target = new(HostPathVolumeSource)
	}
	switch fpv.selector {
	case HostPathVolumeSource_FieldPathSelectorPath:
		(*target).Path = fpv.value.(string)
	case HostPathVolumeSource_FieldPathSelectorType:
		(*target).Type = fpv.value.(HostPathVolumeSource_Type)
	default:
		panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fpv.selector))
	}
}

func (fpv *HostPathVolumeSource_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*HostPathVolumeSource)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'HostPathVolumeSource_FieldTerminalPathValue' with the value under path in 'HostPathVolumeSource'.
func (fpv *HostPathVolumeSource_FieldTerminalPathValue) CompareWith(source *HostPathVolumeSource) (int, bool) {
	switch fpv.selector {
	case HostPathVolumeSource_FieldPathSelectorPath:
		leftValue := fpv.value.(string)
		rightValue := source.GetPath()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case HostPathVolumeSource_FieldPathSelectorType:
		leftValue := fpv.value.(HostPathVolumeSource_Type)
		rightValue := source.GetType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for HostPathVolumeSource: %d", fpv.selector))
	}
}

func (fpv *HostPathVolumeSource_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*HostPathVolumeSource))
}

// HostPathVolumeSource_FieldPathArrayItemValue allows storing single item in Path-specific values for HostPathVolumeSource according to their type
// Present only for array (repeated) types.
type HostPathVolumeSource_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	HostPathVolumeSource_FieldPath
	ContainsValue(*HostPathVolumeSource) bool
}

// ParseHostPathVolumeSource_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseHostPathVolumeSource_FieldPathArrayItemValue(pathStr, valueStr string) (HostPathVolumeSource_FieldPathArrayItemValue, error) {
	fp, err := ParseHostPathVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HostPathVolumeSource field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(HostPathVolumeSource_FieldPathArrayItemValue), nil
}

func MustParseHostPathVolumeSource_FieldPathArrayItemValue(pathStr, valueStr string) HostPathVolumeSource_FieldPathArrayItemValue {
	fpaiv, err := ParseHostPathVolumeSource_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type HostPathVolumeSource_FieldTerminalPathArrayItemValue struct {
	HostPathVolumeSource_FieldTerminalPath
	value interface{}
}

var _ HostPathVolumeSource_FieldPathArrayItemValue = (*HostPathVolumeSource_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object HostPathVolumeSource as interface{}
func (fpaiv *HostPathVolumeSource_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *HostPathVolumeSource_FieldTerminalPathArrayItemValue) GetSingle(source *HostPathVolumeSource) (interface{}, bool) {
	return nil, false
}

func (fpaiv *HostPathVolumeSource_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*HostPathVolumeSource))
}

// Contains returns a boolean indicating if value that is being held is present in given 'HostPathVolumeSource'
func (fpaiv *HostPathVolumeSource_FieldTerminalPathArrayItemValue) ContainsValue(source *HostPathVolumeSource) bool {
	slice := fpaiv.HostPathVolumeSource_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// HostPathVolumeSource_FieldPathArrayOfValues allows storing slice of values for HostPathVolumeSource fields according to their type
type HostPathVolumeSource_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	HostPathVolumeSource_FieldPath
}

func ParseHostPathVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr string) (HostPathVolumeSource_FieldPathArrayOfValues, error) {
	fp, err := ParseHostPathVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing HostPathVolumeSource field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(HostPathVolumeSource_FieldPathArrayOfValues), nil
}

func MustParseHostPathVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr string) HostPathVolumeSource_FieldPathArrayOfValues {
	fpaov, err := ParseHostPathVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type HostPathVolumeSource_FieldTerminalPathArrayOfValues struct {
	HostPathVolumeSource_FieldTerminalPath
	values interface{}
}

var _ HostPathVolumeSource_FieldPathArrayOfValues = (*HostPathVolumeSource_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *HostPathVolumeSource_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case HostPathVolumeSource_FieldPathSelectorPath:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case HostPathVolumeSource_FieldPathSelectorType:
		for _, v := range fpaov.values.([]HostPathVolumeSource_Type) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *HostPathVolumeSource_FieldTerminalPathArrayOfValues) AsPathArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *HostPathVolumeSource_FieldTerminalPathArrayOfValues) AsTypeArrayOfValues() ([]HostPathVolumeSource_Type, bool) {
	res, ok := fpaov.values.([]HostPathVolumeSource_Type)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type SecretVolumeSource_FieldPath interface {
	gotenobject.FieldPath
	Selector() SecretVolumeSource_FieldPathSelector
	Get(source *SecretVolumeSource) []interface{}
	GetSingle(source *SecretVolumeSource) (interface{}, bool)
	ClearValue(item *SecretVolumeSource)

	// Those methods build corresponding SecretVolumeSource_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) SecretVolumeSource_FieldPathValue
	WithIArrayOfValues(values interface{}) SecretVolumeSource_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) SecretVolumeSource_FieldPathArrayItemValue
}

type SecretVolumeSource_FieldPathSelector int32

const (
	SecretVolumeSource_FieldPathSelectorSecretName  SecretVolumeSource_FieldPathSelector = 0
	SecretVolumeSource_FieldPathSelectorItems       SecretVolumeSource_FieldPathSelector = 1
	SecretVolumeSource_FieldPathSelectorDefaultMode SecretVolumeSource_FieldPathSelector = 2
	SecretVolumeSource_FieldPathSelectorOptional    SecretVolumeSource_FieldPathSelector = 3
)

func (s SecretVolumeSource_FieldPathSelector) String() string {
	switch s {
	case SecretVolumeSource_FieldPathSelectorSecretName:
		return "secret_name"
	case SecretVolumeSource_FieldPathSelectorItems:
		return "items"
	case SecretVolumeSource_FieldPathSelectorDefaultMode:
		return "default_mode"
	case SecretVolumeSource_FieldPathSelectorOptional:
		return "optional"
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", s))
	}
}

func BuildSecretVolumeSource_FieldPath(fp gotenobject.RawFieldPath) (SecretVolumeSource_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object SecretVolumeSource")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "secret_name", "secretName", "secret-name":
			return &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorSecretName}, nil
		case "items":
			return &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorItems}, nil
		case "default_mode", "defaultMode", "default-mode":
			return &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorDefaultMode}, nil
		case "optional":
			return &SecretVolumeSource_FieldTerminalPath{selector: SecretVolumeSource_FieldPathSelectorOptional}, nil
		}
	} else {
		switch fp[0] {
		case "items":
			if subpath, err := BuildKeyToPath_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &SecretVolumeSource_FieldSubPath{selector: SecretVolumeSource_FieldPathSelectorItems, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object SecretVolumeSource", fp)
}

func ParseSecretVolumeSource_FieldPath(rawField string) (SecretVolumeSource_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildSecretVolumeSource_FieldPath(fp)
}

func MustParseSecretVolumeSource_FieldPath(rawField string) SecretVolumeSource_FieldPath {
	fp, err := ParseSecretVolumeSource_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type SecretVolumeSource_FieldTerminalPath struct {
	selector SecretVolumeSource_FieldPathSelector
}

var _ SecretVolumeSource_FieldPath = (*SecretVolumeSource_FieldTerminalPath)(nil)

func (fp *SecretVolumeSource_FieldTerminalPath) Selector() SecretVolumeSource_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *SecretVolumeSource_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *SecretVolumeSource_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source SecretVolumeSource
func (fp *SecretVolumeSource_FieldTerminalPath) Get(source *SecretVolumeSource) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case SecretVolumeSource_FieldPathSelectorSecretName:
			values = append(values, source.SecretName)
		case SecretVolumeSource_FieldPathSelectorItems:
			for _, value := range source.GetItems() {
				values = append(values, value)
			}
		case SecretVolumeSource_FieldPathSelectorDefaultMode:
			values = append(values, source.DefaultMode)
		case SecretVolumeSource_FieldPathSelectorOptional:
			values = append(values, source.Optional)
		default:
			panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fp.selector))
		}
	}
	return
}

func (fp *SecretVolumeSource_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*SecretVolumeSource))
}

// GetSingle returns value pointed by specific field of from source SecretVolumeSource
func (fp *SecretVolumeSource_FieldTerminalPath) GetSingle(source *SecretVolumeSource) (interface{}, bool) {
	switch fp.selector {
	case SecretVolumeSource_FieldPathSelectorSecretName:
		return source.GetSecretName(), source != nil
	case SecretVolumeSource_FieldPathSelectorItems:
		res := source.GetItems()
		return res, res != nil
	case SecretVolumeSource_FieldPathSelectorDefaultMode:
		return source.GetDefaultMode(), source != nil
	case SecretVolumeSource_FieldPathSelectorOptional:
		return source.GetOptional(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fp.selector))
	}
}

func (fp *SecretVolumeSource_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*SecretVolumeSource))
}

// GetDefault returns a default value of the field type
func (fp *SecretVolumeSource_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case SecretVolumeSource_FieldPathSelectorSecretName:
		return ""
	case SecretVolumeSource_FieldPathSelectorItems:
		return ([]*KeyToPath)(nil)
	case SecretVolumeSource_FieldPathSelectorDefaultMode:
		return int32(0)
	case SecretVolumeSource_FieldPathSelectorOptional:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fp.selector))
	}
}

func (fp *SecretVolumeSource_FieldTerminalPath) ClearValue(item *SecretVolumeSource) {
	if item != nil {
		switch fp.selector {
		case SecretVolumeSource_FieldPathSelectorSecretName:
			item.SecretName = ""
		case SecretVolumeSource_FieldPathSelectorItems:
			item.Items = nil
		case SecretVolumeSource_FieldPathSelectorDefaultMode:
			item.DefaultMode = int32(0)
		case SecretVolumeSource_FieldPathSelectorOptional:
			item.Optional = false
		default:
			panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fp.selector))
		}
	}
}

func (fp *SecretVolumeSource_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*SecretVolumeSource))
}

// IsLeaf - whether field path is holds simple value
func (fp *SecretVolumeSource_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == SecretVolumeSource_FieldPathSelectorSecretName ||
		fp.selector == SecretVolumeSource_FieldPathSelectorDefaultMode ||
		fp.selector == SecretVolumeSource_FieldPathSelectorOptional
}

func (fp *SecretVolumeSource_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *SecretVolumeSource_FieldTerminalPath) WithIValue(value interface{}) SecretVolumeSource_FieldPathValue {
	switch fp.selector {
	case SecretVolumeSource_FieldPathSelectorSecretName:
		return &SecretVolumeSource_FieldTerminalPathValue{SecretVolumeSource_FieldTerminalPath: *fp, value: value.(string)}
	case SecretVolumeSource_FieldPathSelectorItems:
		return &SecretVolumeSource_FieldTerminalPathValue{SecretVolumeSource_FieldTerminalPath: *fp, value: value.([]*KeyToPath)}
	case SecretVolumeSource_FieldPathSelectorDefaultMode:
		return &SecretVolumeSource_FieldTerminalPathValue{SecretVolumeSource_FieldTerminalPath: *fp, value: value.(int32)}
	case SecretVolumeSource_FieldPathSelectorOptional:
		return &SecretVolumeSource_FieldTerminalPathValue{SecretVolumeSource_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fp.selector))
	}
}

func (fp *SecretVolumeSource_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *SecretVolumeSource_FieldTerminalPath) WithIArrayOfValues(values interface{}) SecretVolumeSource_FieldPathArrayOfValues {
	fpaov := &SecretVolumeSource_FieldTerminalPathArrayOfValues{SecretVolumeSource_FieldTerminalPath: *fp}
	switch fp.selector {
	case SecretVolumeSource_FieldPathSelectorSecretName:
		return &SecretVolumeSource_FieldTerminalPathArrayOfValues{SecretVolumeSource_FieldTerminalPath: *fp, values: values.([]string)}
	case SecretVolumeSource_FieldPathSelectorItems:
		return &SecretVolumeSource_FieldTerminalPathArrayOfValues{SecretVolumeSource_FieldTerminalPath: *fp, values: values.([][]*KeyToPath)}
	case SecretVolumeSource_FieldPathSelectorDefaultMode:
		return &SecretVolumeSource_FieldTerminalPathArrayOfValues{SecretVolumeSource_FieldTerminalPath: *fp, values: values.([]int32)}
	case SecretVolumeSource_FieldPathSelectorOptional:
		return &SecretVolumeSource_FieldTerminalPathArrayOfValues{SecretVolumeSource_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fp.selector))
	}
	return fpaov
}

func (fp *SecretVolumeSource_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *SecretVolumeSource_FieldTerminalPath) WithIArrayItemValue(value interface{}) SecretVolumeSource_FieldPathArrayItemValue {
	switch fp.selector {
	case SecretVolumeSource_FieldPathSelectorItems:
		return &SecretVolumeSource_FieldTerminalPathArrayItemValue{SecretVolumeSource_FieldTerminalPath: *fp, value: value.(*KeyToPath)}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fp.selector))
	}
}

func (fp *SecretVolumeSource_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type SecretVolumeSource_FieldSubPath struct {
	selector SecretVolumeSource_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ SecretVolumeSource_FieldPath = (*SecretVolumeSource_FieldSubPath)(nil)

func (fps *SecretVolumeSource_FieldSubPath) Selector() SecretVolumeSource_FieldPathSelector {
	return fps.selector
}
func (fps *SecretVolumeSource_FieldSubPath) AsItemsSubPath() (KeyToPath_FieldPath, bool) {
	res, ok := fps.subPath.(KeyToPath_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *SecretVolumeSource_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *SecretVolumeSource_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source SecretVolumeSource
func (fps *SecretVolumeSource_FieldSubPath) Get(source *SecretVolumeSource) (values []interface{}) {
	switch fps.selector {
	case SecretVolumeSource_FieldPathSelectorItems:
		for _, item := range source.GetItems() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fps.selector))
	}
	return
}

func (fps *SecretVolumeSource_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*SecretVolumeSource))
}

// GetSingle returns value of selected field from source SecretVolumeSource
func (fps *SecretVolumeSource_FieldSubPath) GetSingle(source *SecretVolumeSource) (interface{}, bool) {
	switch fps.selector {
	case SecretVolumeSource_FieldPathSelectorItems:
		if len(source.GetItems()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetItems()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fps.selector))
	}
}

func (fps *SecretVolumeSource_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*SecretVolumeSource))
}

// GetDefault returns a default value of the field type
func (fps *SecretVolumeSource_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *SecretVolumeSource_FieldSubPath) ClearValue(item *SecretVolumeSource) {
	if item != nil {
		switch fps.selector {
		case SecretVolumeSource_FieldPathSelectorItems:
			for _, subItem := range item.Items {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fps.selector))
		}
	}
}

func (fps *SecretVolumeSource_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*SecretVolumeSource))
}

// IsLeaf - whether field path is holds simple value
func (fps *SecretVolumeSource_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *SecretVolumeSource_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&SecretVolumeSource_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *SecretVolumeSource_FieldSubPath) WithIValue(value interface{}) SecretVolumeSource_FieldPathValue {
	return &SecretVolumeSource_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *SecretVolumeSource_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *SecretVolumeSource_FieldSubPath) WithIArrayOfValues(values interface{}) SecretVolumeSource_FieldPathArrayOfValues {
	return &SecretVolumeSource_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *SecretVolumeSource_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *SecretVolumeSource_FieldSubPath) WithIArrayItemValue(value interface{}) SecretVolumeSource_FieldPathArrayItemValue {
	return &SecretVolumeSource_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *SecretVolumeSource_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// SecretVolumeSource_FieldPathValue allows storing values for SecretVolumeSource fields according to their type
type SecretVolumeSource_FieldPathValue interface {
	SecretVolumeSource_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **SecretVolumeSource)
	CompareWith(*SecretVolumeSource) (cmp int, comparable bool)
}

func ParseSecretVolumeSource_FieldPathValue(pathStr, valueStr string) (SecretVolumeSource_FieldPathValue, error) {
	fp, err := ParseSecretVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretVolumeSource field path value from %s: %v", valueStr, err)
	}
	return fpv.(SecretVolumeSource_FieldPathValue), nil
}

func MustParseSecretVolumeSource_FieldPathValue(pathStr, valueStr string) SecretVolumeSource_FieldPathValue {
	fpv, err := ParseSecretVolumeSource_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type SecretVolumeSource_FieldTerminalPathValue struct {
	SecretVolumeSource_FieldTerminalPath
	value interface{}
}

var _ SecretVolumeSource_FieldPathValue = (*SecretVolumeSource_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'SecretVolumeSource' as interface{}
func (fpv *SecretVolumeSource_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *SecretVolumeSource_FieldTerminalPathValue) AsSecretNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *SecretVolumeSource_FieldTerminalPathValue) AsItemsValue() ([]*KeyToPath, bool) {
	res, ok := fpv.value.([]*KeyToPath)
	return res, ok
}
func (fpv *SecretVolumeSource_FieldTerminalPathValue) AsDefaultModeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *SecretVolumeSource_FieldTerminalPathValue) AsOptionalValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object SecretVolumeSource
func (fpv *SecretVolumeSource_FieldTerminalPathValue) SetTo(target **SecretVolumeSource) {
	if *target == nil {
		*target = new(SecretVolumeSource)
	}
	switch fpv.selector {
	case SecretVolumeSource_FieldPathSelectorSecretName:
		(*target).SecretName = fpv.value.(string)
	case SecretVolumeSource_FieldPathSelectorItems:
		(*target).Items = fpv.value.([]*KeyToPath)
	case SecretVolumeSource_FieldPathSelectorDefaultMode:
		(*target).DefaultMode = fpv.value.(int32)
	case SecretVolumeSource_FieldPathSelectorOptional:
		(*target).Optional = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fpv.selector))
	}
}

func (fpv *SecretVolumeSource_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*SecretVolumeSource)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'SecretVolumeSource_FieldTerminalPathValue' with the value under path in 'SecretVolumeSource'.
func (fpv *SecretVolumeSource_FieldTerminalPathValue) CompareWith(source *SecretVolumeSource) (int, bool) {
	switch fpv.selector {
	case SecretVolumeSource_FieldPathSelectorSecretName:
		leftValue := fpv.value.(string)
		rightValue := source.GetSecretName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SecretVolumeSource_FieldPathSelectorItems:
		return 0, false
	case SecretVolumeSource_FieldPathSelectorDefaultMode:
		leftValue := fpv.value.(int32)
		rightValue := source.GetDefaultMode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SecretVolumeSource_FieldPathSelectorOptional:
		leftValue := fpv.value.(bool)
		rightValue := source.GetOptional()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fpv.selector))
	}
}

func (fpv *SecretVolumeSource_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*SecretVolumeSource))
}

type SecretVolumeSource_FieldSubPathValue struct {
	SecretVolumeSource_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ SecretVolumeSource_FieldPathValue = (*SecretVolumeSource_FieldSubPathValue)(nil)

func (fpvs *SecretVolumeSource_FieldSubPathValue) AsItemsPathValue() (KeyToPath_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(KeyToPath_FieldPathValue)
	return res, ok
}

func (fpvs *SecretVolumeSource_FieldSubPathValue) SetTo(target **SecretVolumeSource) {
	if *target == nil {
		*target = new(SecretVolumeSource)
	}
	switch fpvs.Selector() {
	case SecretVolumeSource_FieldPathSelectorItems:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fpvs.Selector()))
	}
}

func (fpvs *SecretVolumeSource_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*SecretVolumeSource)
	fpvs.SetTo(&typedObject)
}

func (fpvs *SecretVolumeSource_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *SecretVolumeSource_FieldSubPathValue) CompareWith(source *SecretVolumeSource) (int, bool) {
	switch fpvs.Selector() {
	case SecretVolumeSource_FieldPathSelectorItems:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fpvs.Selector()))
	}
}

func (fpvs *SecretVolumeSource_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*SecretVolumeSource))
}

// SecretVolumeSource_FieldPathArrayItemValue allows storing single item in Path-specific values for SecretVolumeSource according to their type
// Present only for array (repeated) types.
type SecretVolumeSource_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	SecretVolumeSource_FieldPath
	ContainsValue(*SecretVolumeSource) bool
}

// ParseSecretVolumeSource_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseSecretVolumeSource_FieldPathArrayItemValue(pathStr, valueStr string) (SecretVolumeSource_FieldPathArrayItemValue, error) {
	fp, err := ParseSecretVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretVolumeSource field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(SecretVolumeSource_FieldPathArrayItemValue), nil
}

func MustParseSecretVolumeSource_FieldPathArrayItemValue(pathStr, valueStr string) SecretVolumeSource_FieldPathArrayItemValue {
	fpaiv, err := ParseSecretVolumeSource_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type SecretVolumeSource_FieldTerminalPathArrayItemValue struct {
	SecretVolumeSource_FieldTerminalPath
	value interface{}
}

var _ SecretVolumeSource_FieldPathArrayItemValue = (*SecretVolumeSource_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object SecretVolumeSource as interface{}
func (fpaiv *SecretVolumeSource_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *SecretVolumeSource_FieldTerminalPathArrayItemValue) AsItemsItemValue() (*KeyToPath, bool) {
	res, ok := fpaiv.value.(*KeyToPath)
	return res, ok
}

func (fpaiv *SecretVolumeSource_FieldTerminalPathArrayItemValue) GetSingle(source *SecretVolumeSource) (interface{}, bool) {
	return nil, false
}

func (fpaiv *SecretVolumeSource_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*SecretVolumeSource))
}

// Contains returns a boolean indicating if value that is being held is present in given 'SecretVolumeSource'
func (fpaiv *SecretVolumeSource_FieldTerminalPathArrayItemValue) ContainsValue(source *SecretVolumeSource) bool {
	slice := fpaiv.SecretVolumeSource_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type SecretVolumeSource_FieldSubPathArrayItemValue struct {
	SecretVolumeSource_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *SecretVolumeSource_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *SecretVolumeSource_FieldSubPathArrayItemValue) AsItemsPathItemValue() (KeyToPath_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(KeyToPath_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'SecretVolumeSource'
func (fpaivs *SecretVolumeSource_FieldSubPathArrayItemValue) ContainsValue(source *SecretVolumeSource) bool {
	switch fpaivs.Selector() {
	case SecretVolumeSource_FieldPathSelectorItems:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for SecretVolumeSource: %d", fpaivs.Selector()))
	}
}

// SecretVolumeSource_FieldPathArrayOfValues allows storing slice of values for SecretVolumeSource fields according to their type
type SecretVolumeSource_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	SecretVolumeSource_FieldPath
}

func ParseSecretVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr string) (SecretVolumeSource_FieldPathArrayOfValues, error) {
	fp, err := ParseSecretVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SecretVolumeSource field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(SecretVolumeSource_FieldPathArrayOfValues), nil
}

func MustParseSecretVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr string) SecretVolumeSource_FieldPathArrayOfValues {
	fpaov, err := ParseSecretVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type SecretVolumeSource_FieldTerminalPathArrayOfValues struct {
	SecretVolumeSource_FieldTerminalPath
	values interface{}
}

var _ SecretVolumeSource_FieldPathArrayOfValues = (*SecretVolumeSource_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *SecretVolumeSource_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case SecretVolumeSource_FieldPathSelectorSecretName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case SecretVolumeSource_FieldPathSelectorItems:
		for _, v := range fpaov.values.([][]*KeyToPath) {
			values = append(values, v)
		}
	case SecretVolumeSource_FieldPathSelectorDefaultMode:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case SecretVolumeSource_FieldPathSelectorOptional:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *SecretVolumeSource_FieldTerminalPathArrayOfValues) AsSecretNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *SecretVolumeSource_FieldTerminalPathArrayOfValues) AsItemsArrayOfValues() ([][]*KeyToPath, bool) {
	res, ok := fpaov.values.([][]*KeyToPath)
	return res, ok
}
func (fpaov *SecretVolumeSource_FieldTerminalPathArrayOfValues) AsDefaultModeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *SecretVolumeSource_FieldTerminalPathArrayOfValues) AsOptionalArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

type SecretVolumeSource_FieldSubPathArrayOfValues struct {
	SecretVolumeSource_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ SecretVolumeSource_FieldPathArrayOfValues = (*SecretVolumeSource_FieldSubPathArrayOfValues)(nil)

func (fpsaov *SecretVolumeSource_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *SecretVolumeSource_FieldSubPathArrayOfValues) AsItemsPathArrayOfValues() (KeyToPath_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(KeyToPath_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type KeyToPath_FieldPath interface {
	gotenobject.FieldPath
	Selector() KeyToPath_FieldPathSelector
	Get(source *KeyToPath) []interface{}
	GetSingle(source *KeyToPath) (interface{}, bool)
	ClearValue(item *KeyToPath)

	// Those methods build corresponding KeyToPath_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) KeyToPath_FieldPathValue
	WithIArrayOfValues(values interface{}) KeyToPath_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) KeyToPath_FieldPathArrayItemValue
}

type KeyToPath_FieldPathSelector int32

const (
	KeyToPath_FieldPathSelectorKey  KeyToPath_FieldPathSelector = 0
	KeyToPath_FieldPathSelectorPath KeyToPath_FieldPathSelector = 1
	KeyToPath_FieldPathSelectorMode KeyToPath_FieldPathSelector = 2
)

func (s KeyToPath_FieldPathSelector) String() string {
	switch s {
	case KeyToPath_FieldPathSelectorKey:
		return "key"
	case KeyToPath_FieldPathSelectorPath:
		return "path"
	case KeyToPath_FieldPathSelectorMode:
		return "mode"
	default:
		panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", s))
	}
}

func BuildKeyToPath_FieldPath(fp gotenobject.RawFieldPath) (KeyToPath_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object KeyToPath")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "key":
			return &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorKey}, nil
		case "path":
			return &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorPath}, nil
		case "mode":
			return &KeyToPath_FieldTerminalPath{selector: KeyToPath_FieldPathSelectorMode}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object KeyToPath", fp)
}

func ParseKeyToPath_FieldPath(rawField string) (KeyToPath_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildKeyToPath_FieldPath(fp)
}

func MustParseKeyToPath_FieldPath(rawField string) KeyToPath_FieldPath {
	fp, err := ParseKeyToPath_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type KeyToPath_FieldTerminalPath struct {
	selector KeyToPath_FieldPathSelector
}

var _ KeyToPath_FieldPath = (*KeyToPath_FieldTerminalPath)(nil)

func (fp *KeyToPath_FieldTerminalPath) Selector() KeyToPath_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *KeyToPath_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *KeyToPath_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source KeyToPath
func (fp *KeyToPath_FieldTerminalPath) Get(source *KeyToPath) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case KeyToPath_FieldPathSelectorKey:
			values = append(values, source.Key)
		case KeyToPath_FieldPathSelectorPath:
			values = append(values, source.Path)
		case KeyToPath_FieldPathSelectorMode:
			values = append(values, source.Mode)
		default:
			panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fp.selector))
		}
	}
	return
}

func (fp *KeyToPath_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*KeyToPath))
}

// GetSingle returns value pointed by specific field of from source KeyToPath
func (fp *KeyToPath_FieldTerminalPath) GetSingle(source *KeyToPath) (interface{}, bool) {
	switch fp.selector {
	case KeyToPath_FieldPathSelectorKey:
		return source.GetKey(), source != nil
	case KeyToPath_FieldPathSelectorPath:
		return source.GetPath(), source != nil
	case KeyToPath_FieldPathSelectorMode:
		return source.GetMode(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fp.selector))
	}
}

func (fp *KeyToPath_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*KeyToPath))
}

// GetDefault returns a default value of the field type
func (fp *KeyToPath_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case KeyToPath_FieldPathSelectorKey:
		return ""
	case KeyToPath_FieldPathSelectorPath:
		return ""
	case KeyToPath_FieldPathSelectorMode:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fp.selector))
	}
}

func (fp *KeyToPath_FieldTerminalPath) ClearValue(item *KeyToPath) {
	if item != nil {
		switch fp.selector {
		case KeyToPath_FieldPathSelectorKey:
			item.Key = ""
		case KeyToPath_FieldPathSelectorPath:
			item.Path = ""
		case KeyToPath_FieldPathSelectorMode:
			item.Mode = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fp.selector))
		}
	}
}

func (fp *KeyToPath_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*KeyToPath))
}

// IsLeaf - whether field path is holds simple value
func (fp *KeyToPath_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == KeyToPath_FieldPathSelectorKey ||
		fp.selector == KeyToPath_FieldPathSelectorPath ||
		fp.selector == KeyToPath_FieldPathSelectorMode
}

func (fp *KeyToPath_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *KeyToPath_FieldTerminalPath) WithIValue(value interface{}) KeyToPath_FieldPathValue {
	switch fp.selector {
	case KeyToPath_FieldPathSelectorKey:
		return &KeyToPath_FieldTerminalPathValue{KeyToPath_FieldTerminalPath: *fp, value: value.(string)}
	case KeyToPath_FieldPathSelectorPath:
		return &KeyToPath_FieldTerminalPathValue{KeyToPath_FieldTerminalPath: *fp, value: value.(string)}
	case KeyToPath_FieldPathSelectorMode:
		return &KeyToPath_FieldTerminalPathValue{KeyToPath_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fp.selector))
	}
}

func (fp *KeyToPath_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *KeyToPath_FieldTerminalPath) WithIArrayOfValues(values interface{}) KeyToPath_FieldPathArrayOfValues {
	fpaov := &KeyToPath_FieldTerminalPathArrayOfValues{KeyToPath_FieldTerminalPath: *fp}
	switch fp.selector {
	case KeyToPath_FieldPathSelectorKey:
		return &KeyToPath_FieldTerminalPathArrayOfValues{KeyToPath_FieldTerminalPath: *fp, values: values.([]string)}
	case KeyToPath_FieldPathSelectorPath:
		return &KeyToPath_FieldTerminalPathArrayOfValues{KeyToPath_FieldTerminalPath: *fp, values: values.([]string)}
	case KeyToPath_FieldPathSelectorMode:
		return &KeyToPath_FieldTerminalPathArrayOfValues{KeyToPath_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fp.selector))
	}
	return fpaov
}

func (fp *KeyToPath_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *KeyToPath_FieldTerminalPath) WithIArrayItemValue(value interface{}) KeyToPath_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fp.selector))
	}
}

func (fp *KeyToPath_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// KeyToPath_FieldPathValue allows storing values for KeyToPath fields according to their type
type KeyToPath_FieldPathValue interface {
	KeyToPath_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **KeyToPath)
	CompareWith(*KeyToPath) (cmp int, comparable bool)
}

func ParseKeyToPath_FieldPathValue(pathStr, valueStr string) (KeyToPath_FieldPathValue, error) {
	fp, err := ParseKeyToPath_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing KeyToPath field path value from %s: %v", valueStr, err)
	}
	return fpv.(KeyToPath_FieldPathValue), nil
}

func MustParseKeyToPath_FieldPathValue(pathStr, valueStr string) KeyToPath_FieldPathValue {
	fpv, err := ParseKeyToPath_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type KeyToPath_FieldTerminalPathValue struct {
	KeyToPath_FieldTerminalPath
	value interface{}
}

var _ KeyToPath_FieldPathValue = (*KeyToPath_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'KeyToPath' as interface{}
func (fpv *KeyToPath_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *KeyToPath_FieldTerminalPathValue) AsKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *KeyToPath_FieldTerminalPathValue) AsPathValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *KeyToPath_FieldTerminalPathValue) AsModeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object KeyToPath
func (fpv *KeyToPath_FieldTerminalPathValue) SetTo(target **KeyToPath) {
	if *target == nil {
		*target = new(KeyToPath)
	}
	switch fpv.selector {
	case KeyToPath_FieldPathSelectorKey:
		(*target).Key = fpv.value.(string)
	case KeyToPath_FieldPathSelectorPath:
		(*target).Path = fpv.value.(string)
	case KeyToPath_FieldPathSelectorMode:
		(*target).Mode = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fpv.selector))
	}
}

func (fpv *KeyToPath_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*KeyToPath)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'KeyToPath_FieldTerminalPathValue' with the value under path in 'KeyToPath'.
func (fpv *KeyToPath_FieldTerminalPathValue) CompareWith(source *KeyToPath) (int, bool) {
	switch fpv.selector {
	case KeyToPath_FieldPathSelectorKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case KeyToPath_FieldPathSelectorPath:
		leftValue := fpv.value.(string)
		rightValue := source.GetPath()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case KeyToPath_FieldPathSelectorMode:
		leftValue := fpv.value.(int32)
		rightValue := source.GetMode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for KeyToPath: %d", fpv.selector))
	}
}

func (fpv *KeyToPath_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*KeyToPath))
}

// KeyToPath_FieldPathArrayItemValue allows storing single item in Path-specific values for KeyToPath according to their type
// Present only for array (repeated) types.
type KeyToPath_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	KeyToPath_FieldPath
	ContainsValue(*KeyToPath) bool
}

// ParseKeyToPath_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseKeyToPath_FieldPathArrayItemValue(pathStr, valueStr string) (KeyToPath_FieldPathArrayItemValue, error) {
	fp, err := ParseKeyToPath_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing KeyToPath field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(KeyToPath_FieldPathArrayItemValue), nil
}

func MustParseKeyToPath_FieldPathArrayItemValue(pathStr, valueStr string) KeyToPath_FieldPathArrayItemValue {
	fpaiv, err := ParseKeyToPath_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type KeyToPath_FieldTerminalPathArrayItemValue struct {
	KeyToPath_FieldTerminalPath
	value interface{}
}

var _ KeyToPath_FieldPathArrayItemValue = (*KeyToPath_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object KeyToPath as interface{}
func (fpaiv *KeyToPath_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *KeyToPath_FieldTerminalPathArrayItemValue) GetSingle(source *KeyToPath) (interface{}, bool) {
	return nil, false
}

func (fpaiv *KeyToPath_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*KeyToPath))
}

// Contains returns a boolean indicating if value that is being held is present in given 'KeyToPath'
func (fpaiv *KeyToPath_FieldTerminalPathArrayItemValue) ContainsValue(source *KeyToPath) bool {
	slice := fpaiv.KeyToPath_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// KeyToPath_FieldPathArrayOfValues allows storing slice of values for KeyToPath fields according to their type
type KeyToPath_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	KeyToPath_FieldPath
}

func ParseKeyToPath_FieldPathArrayOfValues(pathStr, valuesStr string) (KeyToPath_FieldPathArrayOfValues, error) {
	fp, err := ParseKeyToPath_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing KeyToPath field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(KeyToPath_FieldPathArrayOfValues), nil
}

func MustParseKeyToPath_FieldPathArrayOfValues(pathStr, valuesStr string) KeyToPath_FieldPathArrayOfValues {
	fpaov, err := ParseKeyToPath_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type KeyToPath_FieldTerminalPathArrayOfValues struct {
	KeyToPath_FieldTerminalPath
	values interface{}
}

var _ KeyToPath_FieldPathArrayOfValues = (*KeyToPath_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *KeyToPath_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case KeyToPath_FieldPathSelectorKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case KeyToPath_FieldPathSelectorPath:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case KeyToPath_FieldPathSelectorMode:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *KeyToPath_FieldTerminalPathArrayOfValues) AsKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *KeyToPath_FieldTerminalPathArrayOfValues) AsPathArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *KeyToPath_FieldTerminalPathArrayOfValues) AsModeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ConfigMapVolumeSource_FieldPath interface {
	gotenobject.FieldPath
	Selector() ConfigMapVolumeSource_FieldPathSelector
	Get(source *ConfigMapVolumeSource) []interface{}
	GetSingle(source *ConfigMapVolumeSource) (interface{}, bool)
	ClearValue(item *ConfigMapVolumeSource)

	// Those methods build corresponding ConfigMapVolumeSource_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ConfigMapVolumeSource_FieldPathValue
	WithIArrayOfValues(values interface{}) ConfigMapVolumeSource_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ConfigMapVolumeSource_FieldPathArrayItemValue
}

type ConfigMapVolumeSource_FieldPathSelector int32

const (
	ConfigMapVolumeSource_FieldPathSelectorName        ConfigMapVolumeSource_FieldPathSelector = 0
	ConfigMapVolumeSource_FieldPathSelectorItems       ConfigMapVolumeSource_FieldPathSelector = 1
	ConfigMapVolumeSource_FieldPathSelectorDefaultMode ConfigMapVolumeSource_FieldPathSelector = 2
	ConfigMapVolumeSource_FieldPathSelectorOptional    ConfigMapVolumeSource_FieldPathSelector = 3
)

func (s ConfigMapVolumeSource_FieldPathSelector) String() string {
	switch s {
	case ConfigMapVolumeSource_FieldPathSelectorName:
		return "name"
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		return "items"
	case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
		return "default_mode"
	case ConfigMapVolumeSource_FieldPathSelectorOptional:
		return "optional"
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", s))
	}
}

func BuildConfigMapVolumeSource_FieldPath(fp gotenobject.RawFieldPath) (ConfigMapVolumeSource_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ConfigMapVolumeSource")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorName}, nil
		case "items":
			return &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorItems}, nil
		case "default_mode", "defaultMode", "default-mode":
			return &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorDefaultMode}, nil
		case "optional":
			return &ConfigMapVolumeSource_FieldTerminalPath{selector: ConfigMapVolumeSource_FieldPathSelectorOptional}, nil
		}
	} else {
		switch fp[0] {
		case "items":
			if subpath, err := BuildKeyToPath_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ConfigMapVolumeSource_FieldSubPath{selector: ConfigMapVolumeSource_FieldPathSelectorItems, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ConfigMapVolumeSource", fp)
}

func ParseConfigMapVolumeSource_FieldPath(rawField string) (ConfigMapVolumeSource_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildConfigMapVolumeSource_FieldPath(fp)
}

func MustParseConfigMapVolumeSource_FieldPath(rawField string) ConfigMapVolumeSource_FieldPath {
	fp, err := ParseConfigMapVolumeSource_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ConfigMapVolumeSource_FieldTerminalPath struct {
	selector ConfigMapVolumeSource_FieldPathSelector
}

var _ ConfigMapVolumeSource_FieldPath = (*ConfigMapVolumeSource_FieldTerminalPath)(nil)

func (fp *ConfigMapVolumeSource_FieldTerminalPath) Selector() ConfigMapVolumeSource_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ConfigMapVolumeSource_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ConfigMapVolumeSource_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ConfigMapVolumeSource
func (fp *ConfigMapVolumeSource_FieldTerminalPath) Get(source *ConfigMapVolumeSource) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ConfigMapVolumeSource_FieldPathSelectorName:
			values = append(values, source.Name)
		case ConfigMapVolumeSource_FieldPathSelectorItems:
			for _, value := range source.GetItems() {
				values = append(values, value)
			}
		case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
			values = append(values, source.DefaultMode)
		case ConfigMapVolumeSource_FieldPathSelectorOptional:
			values = append(values, source.Optional)
		default:
			panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fp.selector))
		}
	}
	return
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ConfigMapVolumeSource))
}

// GetSingle returns value pointed by specific field of from source ConfigMapVolumeSource
func (fp *ConfigMapVolumeSource_FieldTerminalPath) GetSingle(source *ConfigMapVolumeSource) (interface{}, bool) {
	switch fp.selector {
	case ConfigMapVolumeSource_FieldPathSelectorName:
		return source.GetName(), source != nil
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		res := source.GetItems()
		return res, res != nil
	case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
		return source.GetDefaultMode(), source != nil
	case ConfigMapVolumeSource_FieldPathSelectorOptional:
		return source.GetOptional(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fp.selector))
	}
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ConfigMapVolumeSource))
}

// GetDefault returns a default value of the field type
func (fp *ConfigMapVolumeSource_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ConfigMapVolumeSource_FieldPathSelectorName:
		return ""
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		return ([]*KeyToPath)(nil)
	case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
		return int32(0)
	case ConfigMapVolumeSource_FieldPathSelectorOptional:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fp.selector))
	}
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) ClearValue(item *ConfigMapVolumeSource) {
	if item != nil {
		switch fp.selector {
		case ConfigMapVolumeSource_FieldPathSelectorName:
			item.Name = ""
		case ConfigMapVolumeSource_FieldPathSelectorItems:
			item.Items = nil
		case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
			item.DefaultMode = int32(0)
		case ConfigMapVolumeSource_FieldPathSelectorOptional:
			item.Optional = false
		default:
			panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fp.selector))
		}
	}
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ConfigMapVolumeSource))
}

// IsLeaf - whether field path is holds simple value
func (fp *ConfigMapVolumeSource_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ConfigMapVolumeSource_FieldPathSelectorName ||
		fp.selector == ConfigMapVolumeSource_FieldPathSelectorDefaultMode ||
		fp.selector == ConfigMapVolumeSource_FieldPathSelectorOptional
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) WithIValue(value interface{}) ConfigMapVolumeSource_FieldPathValue {
	switch fp.selector {
	case ConfigMapVolumeSource_FieldPathSelectorName:
		return &ConfigMapVolumeSource_FieldTerminalPathValue{ConfigMapVolumeSource_FieldTerminalPath: *fp, value: value.(string)}
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		return &ConfigMapVolumeSource_FieldTerminalPathValue{ConfigMapVolumeSource_FieldTerminalPath: *fp, value: value.([]*KeyToPath)}
	case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
		return &ConfigMapVolumeSource_FieldTerminalPathValue{ConfigMapVolumeSource_FieldTerminalPath: *fp, value: value.(int32)}
	case ConfigMapVolumeSource_FieldPathSelectorOptional:
		return &ConfigMapVolumeSource_FieldTerminalPathValue{ConfigMapVolumeSource_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fp.selector))
	}
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) WithIArrayOfValues(values interface{}) ConfigMapVolumeSource_FieldPathArrayOfValues {
	fpaov := &ConfigMapVolumeSource_FieldTerminalPathArrayOfValues{ConfigMapVolumeSource_FieldTerminalPath: *fp}
	switch fp.selector {
	case ConfigMapVolumeSource_FieldPathSelectorName:
		return &ConfigMapVolumeSource_FieldTerminalPathArrayOfValues{ConfigMapVolumeSource_FieldTerminalPath: *fp, values: values.([]string)}
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		return &ConfigMapVolumeSource_FieldTerminalPathArrayOfValues{ConfigMapVolumeSource_FieldTerminalPath: *fp, values: values.([][]*KeyToPath)}
	case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
		return &ConfigMapVolumeSource_FieldTerminalPathArrayOfValues{ConfigMapVolumeSource_FieldTerminalPath: *fp, values: values.([]int32)}
	case ConfigMapVolumeSource_FieldPathSelectorOptional:
		return &ConfigMapVolumeSource_FieldTerminalPathArrayOfValues{ConfigMapVolumeSource_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fp.selector))
	}
	return fpaov
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) WithIArrayItemValue(value interface{}) ConfigMapVolumeSource_FieldPathArrayItemValue {
	switch fp.selector {
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		return &ConfigMapVolumeSource_FieldTerminalPathArrayItemValue{ConfigMapVolumeSource_FieldTerminalPath: *fp, value: value.(*KeyToPath)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fp.selector))
	}
}

func (fp *ConfigMapVolumeSource_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ConfigMapVolumeSource_FieldSubPath struct {
	selector ConfigMapVolumeSource_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ConfigMapVolumeSource_FieldPath = (*ConfigMapVolumeSource_FieldSubPath)(nil)

func (fps *ConfigMapVolumeSource_FieldSubPath) Selector() ConfigMapVolumeSource_FieldPathSelector {
	return fps.selector
}
func (fps *ConfigMapVolumeSource_FieldSubPath) AsItemsSubPath() (KeyToPath_FieldPath, bool) {
	res, ok := fps.subPath.(KeyToPath_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ConfigMapVolumeSource_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ConfigMapVolumeSource_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ConfigMapVolumeSource
func (fps *ConfigMapVolumeSource_FieldSubPath) Get(source *ConfigMapVolumeSource) (values []interface{}) {
	switch fps.selector {
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		for _, item := range source.GetItems() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fps.selector))
	}
	return
}

func (fps *ConfigMapVolumeSource_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ConfigMapVolumeSource))
}

// GetSingle returns value of selected field from source ConfigMapVolumeSource
func (fps *ConfigMapVolumeSource_FieldSubPath) GetSingle(source *ConfigMapVolumeSource) (interface{}, bool) {
	switch fps.selector {
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		if len(source.GetItems()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetItems()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fps.selector))
	}
}

func (fps *ConfigMapVolumeSource_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ConfigMapVolumeSource))
}

// GetDefault returns a default value of the field type
func (fps *ConfigMapVolumeSource_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ConfigMapVolumeSource_FieldSubPath) ClearValue(item *ConfigMapVolumeSource) {
	if item != nil {
		switch fps.selector {
		case ConfigMapVolumeSource_FieldPathSelectorItems:
			for _, subItem := range item.Items {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fps.selector))
		}
	}
}

func (fps *ConfigMapVolumeSource_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ConfigMapVolumeSource))
}

// IsLeaf - whether field path is holds simple value
func (fps *ConfigMapVolumeSource_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ConfigMapVolumeSource_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&ConfigMapVolumeSource_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *ConfigMapVolumeSource_FieldSubPath) WithIValue(value interface{}) ConfigMapVolumeSource_FieldPathValue {
	return &ConfigMapVolumeSource_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ConfigMapVolumeSource_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ConfigMapVolumeSource_FieldSubPath) WithIArrayOfValues(values interface{}) ConfigMapVolumeSource_FieldPathArrayOfValues {
	return &ConfigMapVolumeSource_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ConfigMapVolumeSource_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ConfigMapVolumeSource_FieldSubPath) WithIArrayItemValue(value interface{}) ConfigMapVolumeSource_FieldPathArrayItemValue {
	return &ConfigMapVolumeSource_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ConfigMapVolumeSource_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ConfigMapVolumeSource_FieldPathValue allows storing values for ConfigMapVolumeSource fields according to their type
type ConfigMapVolumeSource_FieldPathValue interface {
	ConfigMapVolumeSource_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ConfigMapVolumeSource)
	CompareWith(*ConfigMapVolumeSource) (cmp int, comparable bool)
}

func ParseConfigMapVolumeSource_FieldPathValue(pathStr, valueStr string) (ConfigMapVolumeSource_FieldPathValue, error) {
	fp, err := ParseConfigMapVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapVolumeSource field path value from %s: %v", valueStr, err)
	}
	return fpv.(ConfigMapVolumeSource_FieldPathValue), nil
}

func MustParseConfigMapVolumeSource_FieldPathValue(pathStr, valueStr string) ConfigMapVolumeSource_FieldPathValue {
	fpv, err := ParseConfigMapVolumeSource_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ConfigMapVolumeSource_FieldTerminalPathValue struct {
	ConfigMapVolumeSource_FieldTerminalPath
	value interface{}
}

var _ ConfigMapVolumeSource_FieldPathValue = (*ConfigMapVolumeSource_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ConfigMapVolumeSource' as interface{}
func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) AsItemsValue() ([]*KeyToPath, bool) {
	res, ok := fpv.value.([]*KeyToPath)
	return res, ok
}
func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) AsDefaultModeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) AsOptionalValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object ConfigMapVolumeSource
func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) SetTo(target **ConfigMapVolumeSource) {
	if *target == nil {
		*target = new(ConfigMapVolumeSource)
	}
	switch fpv.selector {
	case ConfigMapVolumeSource_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		(*target).Items = fpv.value.([]*KeyToPath)
	case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
		(*target).DefaultMode = fpv.value.(int32)
	case ConfigMapVolumeSource_FieldPathSelectorOptional:
		(*target).Optional = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fpv.selector))
	}
}

func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ConfigMapVolumeSource)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ConfigMapVolumeSource_FieldTerminalPathValue' with the value under path in 'ConfigMapVolumeSource'.
func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) CompareWith(source *ConfigMapVolumeSource) (int, bool) {
	switch fpv.selector {
	case ConfigMapVolumeSource_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		return 0, false
	case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
		leftValue := fpv.value.(int32)
		rightValue := source.GetDefaultMode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ConfigMapVolumeSource_FieldPathSelectorOptional:
		leftValue := fpv.value.(bool)
		rightValue := source.GetOptional()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fpv.selector))
	}
}

func (fpv *ConfigMapVolumeSource_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ConfigMapVolumeSource))
}

type ConfigMapVolumeSource_FieldSubPathValue struct {
	ConfigMapVolumeSource_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ConfigMapVolumeSource_FieldPathValue = (*ConfigMapVolumeSource_FieldSubPathValue)(nil)

func (fpvs *ConfigMapVolumeSource_FieldSubPathValue) AsItemsPathValue() (KeyToPath_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(KeyToPath_FieldPathValue)
	return res, ok
}

func (fpvs *ConfigMapVolumeSource_FieldSubPathValue) SetTo(target **ConfigMapVolumeSource) {
	if *target == nil {
		*target = new(ConfigMapVolumeSource)
	}
	switch fpvs.Selector() {
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fpvs.Selector()))
	}
}

func (fpvs *ConfigMapVolumeSource_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ConfigMapVolumeSource)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ConfigMapVolumeSource_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ConfigMapVolumeSource_FieldSubPathValue) CompareWith(source *ConfigMapVolumeSource) (int, bool) {
	switch fpvs.Selector() {
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fpvs.Selector()))
	}
}

func (fpvs *ConfigMapVolumeSource_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ConfigMapVolumeSource))
}

// ConfigMapVolumeSource_FieldPathArrayItemValue allows storing single item in Path-specific values for ConfigMapVolumeSource according to their type
// Present only for array (repeated) types.
type ConfigMapVolumeSource_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ConfigMapVolumeSource_FieldPath
	ContainsValue(*ConfigMapVolumeSource) bool
}

// ParseConfigMapVolumeSource_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseConfigMapVolumeSource_FieldPathArrayItemValue(pathStr, valueStr string) (ConfigMapVolumeSource_FieldPathArrayItemValue, error) {
	fp, err := ParseConfigMapVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapVolumeSource field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ConfigMapVolumeSource_FieldPathArrayItemValue), nil
}

func MustParseConfigMapVolumeSource_FieldPathArrayItemValue(pathStr, valueStr string) ConfigMapVolumeSource_FieldPathArrayItemValue {
	fpaiv, err := ParseConfigMapVolumeSource_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ConfigMapVolumeSource_FieldTerminalPathArrayItemValue struct {
	ConfigMapVolumeSource_FieldTerminalPath
	value interface{}
}

var _ ConfigMapVolumeSource_FieldPathArrayItemValue = (*ConfigMapVolumeSource_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ConfigMapVolumeSource as interface{}
func (fpaiv *ConfigMapVolumeSource_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *ConfigMapVolumeSource_FieldTerminalPathArrayItemValue) AsItemsItemValue() (*KeyToPath, bool) {
	res, ok := fpaiv.value.(*KeyToPath)
	return res, ok
}

func (fpaiv *ConfigMapVolumeSource_FieldTerminalPathArrayItemValue) GetSingle(source *ConfigMapVolumeSource) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ConfigMapVolumeSource_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ConfigMapVolumeSource))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ConfigMapVolumeSource'
func (fpaiv *ConfigMapVolumeSource_FieldTerminalPathArrayItemValue) ContainsValue(source *ConfigMapVolumeSource) bool {
	slice := fpaiv.ConfigMapVolumeSource_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ConfigMapVolumeSource_FieldSubPathArrayItemValue struct {
	ConfigMapVolumeSource_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ConfigMapVolumeSource_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ConfigMapVolumeSource_FieldSubPathArrayItemValue) AsItemsPathItemValue() (KeyToPath_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(KeyToPath_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ConfigMapVolumeSource'
func (fpaivs *ConfigMapVolumeSource_FieldSubPathArrayItemValue) ContainsValue(source *ConfigMapVolumeSource) bool {
	switch fpaivs.Selector() {
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for ConfigMapVolumeSource: %d", fpaivs.Selector()))
	}
}

// ConfigMapVolumeSource_FieldPathArrayOfValues allows storing slice of values for ConfigMapVolumeSource fields according to their type
type ConfigMapVolumeSource_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ConfigMapVolumeSource_FieldPath
}

func ParseConfigMapVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr string) (ConfigMapVolumeSource_FieldPathArrayOfValues, error) {
	fp, err := ParseConfigMapVolumeSource_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConfigMapVolumeSource field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ConfigMapVolumeSource_FieldPathArrayOfValues), nil
}

func MustParseConfigMapVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr string) ConfigMapVolumeSource_FieldPathArrayOfValues {
	fpaov, err := ParseConfigMapVolumeSource_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ConfigMapVolumeSource_FieldTerminalPathArrayOfValues struct {
	ConfigMapVolumeSource_FieldTerminalPath
	values interface{}
}

var _ ConfigMapVolumeSource_FieldPathArrayOfValues = (*ConfigMapVolumeSource_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ConfigMapVolumeSource_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ConfigMapVolumeSource_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ConfigMapVolumeSource_FieldPathSelectorItems:
		for _, v := range fpaov.values.([][]*KeyToPath) {
			values = append(values, v)
		}
	case ConfigMapVolumeSource_FieldPathSelectorDefaultMode:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ConfigMapVolumeSource_FieldPathSelectorOptional:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ConfigMapVolumeSource_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ConfigMapVolumeSource_FieldTerminalPathArrayOfValues) AsItemsArrayOfValues() ([][]*KeyToPath, bool) {
	res, ok := fpaov.values.([][]*KeyToPath)
	return res, ok
}
func (fpaov *ConfigMapVolumeSource_FieldTerminalPathArrayOfValues) AsDefaultModeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ConfigMapVolumeSource_FieldTerminalPathArrayOfValues) AsOptionalArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

type ConfigMapVolumeSource_FieldSubPathArrayOfValues struct {
	ConfigMapVolumeSource_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ConfigMapVolumeSource_FieldPathArrayOfValues = (*ConfigMapVolumeSource_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ConfigMapVolumeSource_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ConfigMapVolumeSource_FieldSubPathArrayOfValues) AsItemsPathArrayOfValues() (KeyToPath_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(KeyToPath_FieldPathArrayOfValues)
	return res, ok
}
