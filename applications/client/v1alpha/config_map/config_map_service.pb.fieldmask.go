// Code generated by protoc-gen-goten-object
// File: edgelq/applications/proto/v1alpha/config_map_service.proto
// DO NOT EDIT!!!

package config_map_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	config_map "github.com/cloudwan/edgelq-sdk/applications/resources/v1alpha/config_map"
	project "github.com/cloudwan/edgelq-sdk/applications/resources/v1alpha/project"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &config_map.ConfigMap{}
	_ = &project.Project{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetConfigMapRequest_FieldMask struct {
	Paths []GetConfigMapRequest_FieldPath
}

func FullGetConfigMapRequest_FieldMask() *GetConfigMapRequest_FieldMask {
	res := &GetConfigMapRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetConfigMapRequest_FieldTerminalPath{selector: GetConfigMapRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetConfigMapRequest_FieldTerminalPath{selector: GetConfigMapRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetConfigMapRequest_FieldTerminalPath{selector: GetConfigMapRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetConfigMapRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetConfigMapRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetConfigMapRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetConfigMapRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetConfigMapRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetConfigMapRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetConfigMapRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetConfigMapRequest_FieldPath(raw)
	})
}

func (fieldMask *GetConfigMapRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetConfigMapRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetConfigMapRequest_FieldMask) Subtract(other *GetConfigMapRequest_FieldMask) *GetConfigMapRequest_FieldMask {
	result := &GetConfigMapRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetConfigMapRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetConfigMapRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetConfigMapRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetConfigMapRequest_FieldMask) FilterInputFields() *GetConfigMapRequest_FieldMask {
	result := &GetConfigMapRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetConfigMapRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetConfigMapRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetConfigMapRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetConfigMapRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetConfigMapRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetConfigMapRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetConfigMapRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetConfigMapRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetConfigMapRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetConfigMapRequest_FieldMask) AppendPath(path GetConfigMapRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetConfigMapRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetConfigMapRequest_FieldPath))
}

func (fieldMask *GetConfigMapRequest_FieldMask) GetPaths() []GetConfigMapRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetConfigMapRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetConfigMapRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetConfigMapRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetConfigMapRequest_FieldMask) Set(target, source *GetConfigMapRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetConfigMapRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetConfigMapRequest), source.(*GetConfigMapRequest))
}

func (fieldMask *GetConfigMapRequest_FieldMask) Project(source *GetConfigMapRequest) *GetConfigMapRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetConfigMapRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetConfigMapRequest_FieldTerminalPath:
			switch tp.selector {
			case GetConfigMapRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetConfigMapRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetConfigMapRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetConfigMapRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetConfigMapRequest))
}

func (fieldMask *GetConfigMapRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetConfigMapsRequest_FieldMask struct {
	Paths []BatchGetConfigMapsRequest_FieldPath
}

func FullBatchGetConfigMapsRequest_FieldMask() *BatchGetConfigMapsRequest_FieldMask {
	res := &BatchGetConfigMapsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetConfigMapsRequest_FieldTerminalPath{selector: BatchGetConfigMapsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &BatchGetConfigMapsRequest_FieldTerminalPath{selector: BatchGetConfigMapsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetConfigMapsRequest_FieldTerminalPath{selector: BatchGetConfigMapsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetConfigMapsRequest_FieldTerminalPath{selector: BatchGetConfigMapsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetConfigMapsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetConfigMapsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetConfigMapsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetConfigMapsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) Subtract(other *BatchGetConfigMapsRequest_FieldMask) *BatchGetConfigMapsRequest_FieldMask {
	result := &BatchGetConfigMapsRequest_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetConfigMapsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetConfigMapsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetConfigMapsRequest_FieldMask) FilterInputFields() *BatchGetConfigMapsRequest_FieldMask {
	result := &BatchGetConfigMapsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetConfigMapsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetConfigMapsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetConfigMapsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetConfigMapsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetConfigMapsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) AppendPath(path BatchGetConfigMapsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetConfigMapsRequest_FieldPath))
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) GetPaths() []BatchGetConfigMapsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetConfigMapsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) Set(target, source *BatchGetConfigMapsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetConfigMapsRequest), source.(*BatchGetConfigMapsRequest))
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) Project(source *BatchGetConfigMapsRequest) *BatchGetConfigMapsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetConfigMapsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetConfigMapsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetConfigMapsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case BatchGetConfigMapsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetConfigMapsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetConfigMapsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetConfigMapsRequest))
}

func (fieldMask *BatchGetConfigMapsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetConfigMapsResponse_FieldMask struct {
	Paths []BatchGetConfigMapsResponse_FieldPath
}

func FullBatchGetConfigMapsResponse_FieldMask() *BatchGetConfigMapsResponse_FieldMask {
	res := &BatchGetConfigMapsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetConfigMapsResponse_FieldTerminalPath{selector: BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps})
	res.Paths = append(res.Paths, &BatchGetConfigMapsResponse_FieldTerminalPath{selector: BatchGetConfigMapsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetConfigMapsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetConfigMapsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetConfigMapsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetConfigMapsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) Subtract(other *BatchGetConfigMapsResponse_FieldMask) *BatchGetConfigMapsResponse_FieldMask {
	result := &BatchGetConfigMapsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetConfigMapsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps: &config_map.ConfigMap_FieldMask{},
	}
	mySubMasks := map[BatchGetConfigMapsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps: &config_map.ConfigMap_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetConfigMapsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetConfigMapsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetConfigMapsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps:
						mySubMasks[BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps] = config_map.FullConfigMap_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetConfigMapsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetConfigMapsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetConfigMapsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetConfigMapsResponse_FieldMask) FilterInputFields() *BatchGetConfigMapsResponse_FieldMask {
	result := &BatchGetConfigMapsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps:
			if _, ok := path.(*BatchGetConfigMapsResponse_FieldTerminalPath); ok {
				for _, subpath := range config_map.FullConfigMap_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetConfigMapsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetConfigMapsResponse_FieldSubPath); ok {
				selectedMask := &config_map.ConfigMap_FieldMask{
					Paths: []config_map.ConfigMap_FieldPath{sub.subPath.(config_map.ConfigMap_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetConfigMapsResponse_FieldSubPath{selector: BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetConfigMapsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetConfigMapsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetConfigMapsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetConfigMapsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetConfigMapsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) AppendPath(path BatchGetConfigMapsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetConfigMapsResponse_FieldPath))
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) GetPaths() []BatchGetConfigMapsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetConfigMapsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) Set(target, source *BatchGetConfigMapsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetConfigMapsResponse), source.(*BatchGetConfigMapsResponse))
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) Project(source *BatchGetConfigMapsResponse) *BatchGetConfigMapsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetConfigMapsResponse{}
	configMapsMask := &config_map.ConfigMap_FieldMask{}
	wholeConfigMapsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetConfigMapsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps:
				result.ConfigMaps = source.ConfigMaps
				wholeConfigMapsAccepted = true
			case BatchGetConfigMapsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetConfigMapsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetConfigMapsResponse_FieldPathSelectorConfigMaps:
				configMapsMask.AppendPath(tp.subPath.(config_map.ConfigMap_FieldPath))
			}
		}
	}
	if wholeConfigMapsAccepted == false && len(configMapsMask.Paths) > 0 {
		for _, sourceItem := range source.GetConfigMaps() {
			result.ConfigMaps = append(result.ConfigMaps, configMapsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetConfigMapsResponse))
}

func (fieldMask *BatchGetConfigMapsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListConfigMapsRequest_FieldMask struct {
	Paths []ListConfigMapsRequest_FieldPath
}

func FullListConfigMapsRequest_FieldMask() *ListConfigMapsRequest_FieldMask {
	res := &ListConfigMapsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListConfigMapsRequest_FieldTerminalPath{selector: ListConfigMapsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListConfigMapsRequest_FieldTerminalPath{selector: ListConfigMapsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListConfigMapsRequest_FieldTerminalPath{selector: ListConfigMapsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListConfigMapsRequest_FieldTerminalPath{selector: ListConfigMapsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListConfigMapsRequest_FieldTerminalPath{selector: ListConfigMapsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListConfigMapsRequest_FieldTerminalPath{selector: ListConfigMapsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListConfigMapsRequest_FieldTerminalPath{selector: ListConfigMapsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListConfigMapsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListConfigMapsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListConfigMapsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListConfigMapsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListConfigMapsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListConfigMapsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListConfigMapsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListConfigMapsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListConfigMapsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListConfigMapsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListConfigMapsRequest_FieldMask) Subtract(other *ListConfigMapsRequest_FieldMask) *ListConfigMapsRequest_FieldMask {
	result := &ListConfigMapsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListConfigMapsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListConfigMapsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListConfigMapsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListConfigMapsRequest_FieldMask) FilterInputFields() *ListConfigMapsRequest_FieldMask {
	result := &ListConfigMapsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListConfigMapsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListConfigMapsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListConfigMapsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListConfigMapsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListConfigMapsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListConfigMapsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListConfigMapsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListConfigMapsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListConfigMapsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListConfigMapsRequest_FieldMask) AppendPath(path ListConfigMapsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListConfigMapsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListConfigMapsRequest_FieldPath))
}

func (fieldMask *ListConfigMapsRequest_FieldMask) GetPaths() []ListConfigMapsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListConfigMapsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListConfigMapsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListConfigMapsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListConfigMapsRequest_FieldMask) Set(target, source *ListConfigMapsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListConfigMapsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListConfigMapsRequest), source.(*ListConfigMapsRequest))
}

func (fieldMask *ListConfigMapsRequest_FieldMask) Project(source *ListConfigMapsRequest) *ListConfigMapsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListConfigMapsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListConfigMapsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListConfigMapsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListConfigMapsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListConfigMapsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListConfigMapsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListConfigMapsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListConfigMapsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListConfigMapsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListConfigMapsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListConfigMapsRequest))
}

func (fieldMask *ListConfigMapsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListConfigMapsResponse_FieldMask struct {
	Paths []ListConfigMapsResponse_FieldPath
}

func FullListConfigMapsResponse_FieldMask() *ListConfigMapsResponse_FieldMask {
	res := &ListConfigMapsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListConfigMapsResponse_FieldTerminalPath{selector: ListConfigMapsResponse_FieldPathSelectorConfigMaps})
	res.Paths = append(res.Paths, &ListConfigMapsResponse_FieldTerminalPath{selector: ListConfigMapsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListConfigMapsResponse_FieldTerminalPath{selector: ListConfigMapsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListConfigMapsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListConfigMapsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListConfigMapsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListConfigMapsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListConfigMapsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListConfigMapsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListConfigMapsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListConfigMapsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListConfigMapsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListConfigMapsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListConfigMapsResponse_FieldMask) Subtract(other *ListConfigMapsResponse_FieldMask) *ListConfigMapsResponse_FieldMask {
	result := &ListConfigMapsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListConfigMapsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListConfigMapsResponse_FieldPathSelectorConfigMaps: &config_map.ConfigMap_FieldMask{},
	}
	mySubMasks := map[ListConfigMapsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListConfigMapsResponse_FieldPathSelectorConfigMaps: &config_map.ConfigMap_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListConfigMapsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListConfigMapsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListConfigMapsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListConfigMapsResponse_FieldPathSelectorConfigMaps:
						mySubMasks[ListConfigMapsResponse_FieldPathSelectorConfigMaps] = config_map.FullConfigMap_FieldMask()
					}
				} else if tp, ok := path.(*ListConfigMapsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListConfigMapsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListConfigMapsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListConfigMapsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListConfigMapsResponse_FieldMask) FilterInputFields() *ListConfigMapsResponse_FieldMask {
	result := &ListConfigMapsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListConfigMapsResponse_FieldPathSelectorConfigMaps:
			if _, ok := path.(*ListConfigMapsResponse_FieldTerminalPath); ok {
				for _, subpath := range config_map.FullConfigMap_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListConfigMapsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListConfigMapsResponse_FieldSubPath); ok {
				selectedMask := &config_map.ConfigMap_FieldMask{
					Paths: []config_map.ConfigMap_FieldPath{sub.subPath.(config_map.ConfigMap_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListConfigMapsResponse_FieldSubPath{selector: ListConfigMapsResponse_FieldPathSelectorConfigMaps, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListConfigMapsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListConfigMapsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListConfigMapsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListConfigMapsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListConfigMapsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListConfigMapsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListConfigMapsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListConfigMapsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListConfigMapsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListConfigMapsResponse_FieldMask) AppendPath(path ListConfigMapsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListConfigMapsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListConfigMapsResponse_FieldPath))
}

func (fieldMask *ListConfigMapsResponse_FieldMask) GetPaths() []ListConfigMapsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListConfigMapsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListConfigMapsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListConfigMapsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListConfigMapsResponse_FieldMask) Set(target, source *ListConfigMapsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListConfigMapsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListConfigMapsResponse), source.(*ListConfigMapsResponse))
}

func (fieldMask *ListConfigMapsResponse_FieldMask) Project(source *ListConfigMapsResponse) *ListConfigMapsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListConfigMapsResponse{}
	configMapsMask := &config_map.ConfigMap_FieldMask{}
	wholeConfigMapsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListConfigMapsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListConfigMapsResponse_FieldPathSelectorConfigMaps:
				result.ConfigMaps = source.ConfigMaps
				wholeConfigMapsAccepted = true
			case ListConfigMapsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListConfigMapsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListConfigMapsResponse_FieldSubPath:
			switch tp.selector {
			case ListConfigMapsResponse_FieldPathSelectorConfigMaps:
				configMapsMask.AppendPath(tp.subPath.(config_map.ConfigMap_FieldPath))
			}
		}
	}
	if wholeConfigMapsAccepted == false && len(configMapsMask.Paths) > 0 {
		for _, sourceItem := range source.GetConfigMaps() {
			result.ConfigMaps = append(result.ConfigMaps, configMapsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListConfigMapsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListConfigMapsResponse))
}

func (fieldMask *ListConfigMapsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchConfigMapRequest_FieldMask struct {
	Paths []WatchConfigMapRequest_FieldPath
}

func FullWatchConfigMapRequest_FieldMask() *WatchConfigMapRequest_FieldMask {
	res := &WatchConfigMapRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchConfigMapRequest_FieldTerminalPath{selector: WatchConfigMapRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchConfigMapRequest_FieldTerminalPath{selector: WatchConfigMapRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchConfigMapRequest_FieldTerminalPath{selector: WatchConfigMapRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchConfigMapRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchConfigMapRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchConfigMapRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchConfigMapRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchConfigMapRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchConfigMapRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchConfigMapRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchConfigMapRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchConfigMapRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchConfigMapRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchConfigMapRequest_FieldMask) Subtract(other *WatchConfigMapRequest_FieldMask) *WatchConfigMapRequest_FieldMask {
	result := &WatchConfigMapRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchConfigMapRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchConfigMapRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchConfigMapRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchConfigMapRequest_FieldMask) FilterInputFields() *WatchConfigMapRequest_FieldMask {
	result := &WatchConfigMapRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchConfigMapRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchConfigMapRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchConfigMapRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchConfigMapRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchConfigMapRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchConfigMapRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchConfigMapRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchConfigMapRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapRequest_FieldMask) AppendPath(path WatchConfigMapRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchConfigMapRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchConfigMapRequest_FieldPath))
}

func (fieldMask *WatchConfigMapRequest_FieldMask) GetPaths() []WatchConfigMapRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchConfigMapRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchConfigMapRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchConfigMapRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchConfigMapRequest_FieldMask) Set(target, source *WatchConfigMapRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchConfigMapRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchConfigMapRequest), source.(*WatchConfigMapRequest))
}

func (fieldMask *WatchConfigMapRequest_FieldMask) Project(source *WatchConfigMapRequest) *WatchConfigMapRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchConfigMapRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchConfigMapRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchConfigMapRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchConfigMapRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchConfigMapRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchConfigMapRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchConfigMapRequest))
}

func (fieldMask *WatchConfigMapRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchConfigMapResponse_FieldMask struct {
	Paths []WatchConfigMapResponse_FieldPath
}

func FullWatchConfigMapResponse_FieldMask() *WatchConfigMapResponse_FieldMask {
	res := &WatchConfigMapResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchConfigMapResponse_FieldTerminalPath{selector: WatchConfigMapResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchConfigMapResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchConfigMapResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchConfigMapResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchConfigMapResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchConfigMapResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchConfigMapResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchConfigMapResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchConfigMapResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchConfigMapResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchConfigMapResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchConfigMapResponse_FieldMask) Subtract(other *WatchConfigMapResponse_FieldMask) *WatchConfigMapResponse_FieldMask {
	result := &WatchConfigMapResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchConfigMapResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchConfigMapResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchConfigMapResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchConfigMapResponse_FieldMask) FilterInputFields() *WatchConfigMapResponse_FieldMask {
	result := &WatchConfigMapResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchConfigMapResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchConfigMapResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchConfigMapResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchConfigMapResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchConfigMapResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchConfigMapResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchConfigMapResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchConfigMapResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapResponse_FieldMask) AppendPath(path WatchConfigMapResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchConfigMapResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchConfigMapResponse_FieldPath))
}

func (fieldMask *WatchConfigMapResponse_FieldMask) GetPaths() []WatchConfigMapResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchConfigMapResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchConfigMapResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchConfigMapResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchConfigMapResponse_FieldMask) Set(target, source *WatchConfigMapResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchConfigMapResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchConfigMapResponse), source.(*WatchConfigMapResponse))
}

func (fieldMask *WatchConfigMapResponse_FieldMask) Project(source *WatchConfigMapResponse) *WatchConfigMapResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchConfigMapResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchConfigMapResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchConfigMapResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchConfigMapResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchConfigMapResponse))
}

func (fieldMask *WatchConfigMapResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchConfigMapsRequest_FieldMask struct {
	Paths []WatchConfigMapsRequest_FieldPath
}

func FullWatchConfigMapsRequest_FieldMask() *WatchConfigMapsRequest_FieldMask {
	res := &WatchConfigMapsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchConfigMapsRequest_FieldTerminalPath{selector: WatchConfigMapsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchConfigMapsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchConfigMapsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchConfigMapsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchConfigMapsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchConfigMapsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) Subtract(other *WatchConfigMapsRequest_FieldMask) *WatchConfigMapsRequest_FieldMask {
	result := &WatchConfigMapsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchConfigMapsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchConfigMapsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchConfigMapsRequest_FieldMask) FilterInputFields() *WatchConfigMapsRequest_FieldMask {
	result := &WatchConfigMapsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchConfigMapsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchConfigMapsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchConfigMapsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchConfigMapsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchConfigMapsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) AppendPath(path WatchConfigMapsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchConfigMapsRequest_FieldPath))
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) GetPaths() []WatchConfigMapsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchConfigMapsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) Set(target, source *WatchConfigMapsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchConfigMapsRequest), source.(*WatchConfigMapsRequest))
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) Project(source *WatchConfigMapsRequest) *WatchConfigMapsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchConfigMapsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchConfigMapsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchConfigMapsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchConfigMapsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchConfigMapsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchConfigMapsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchConfigMapsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchConfigMapsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchConfigMapsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchConfigMapsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchConfigMapsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchConfigMapsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchConfigMapsRequest))
}

func (fieldMask *WatchConfigMapsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchConfigMapsResponse_FieldMask struct {
	Paths []WatchConfigMapsResponse_FieldPath
}

func FullWatchConfigMapsResponse_FieldMask() *WatchConfigMapsResponse_FieldMask {
	res := &WatchConfigMapsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchConfigMapsResponse_FieldTerminalPath{selector: WatchConfigMapsResponse_FieldPathSelectorConfigMapChanges})
	res.Paths = append(res.Paths, &WatchConfigMapsResponse_FieldTerminalPath{selector: WatchConfigMapsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchConfigMapsResponse_FieldTerminalPath{selector: WatchConfigMapsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchConfigMapsResponse_FieldTerminalPath{selector: WatchConfigMapsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchConfigMapsResponse_FieldTerminalPath{selector: WatchConfigMapsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchConfigMapsResponse_FieldTerminalPath{selector: WatchConfigMapsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchConfigMapsResponse_FieldTerminalPath{selector: WatchConfigMapsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchConfigMapsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchConfigMapsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchConfigMapsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchConfigMapsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchConfigMapsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) Subtract(other *WatchConfigMapsResponse_FieldMask) *WatchConfigMapsResponse_FieldMask {
	result := &WatchConfigMapsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchConfigMapsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchConfigMapsResponse_FieldPathSelectorPageTokenChange: &WatchConfigMapsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchConfigMapsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchConfigMapsResponse_FieldPathSelectorPageTokenChange: &WatchConfigMapsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchConfigMapsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchConfigMapsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchConfigMapsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchConfigMapsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchConfigMapsResponse_FieldPathSelectorPageTokenChange] = FullWatchConfigMapsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchConfigMapsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchConfigMapsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchConfigMapsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchConfigMapsResponse_FieldMask) FilterInputFields() *WatchConfigMapsResponse_FieldMask {
	result := &WatchConfigMapsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchConfigMapsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchConfigMapsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchConfigMapsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchConfigMapsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchConfigMapsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) AppendPath(path WatchConfigMapsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchConfigMapsResponse_FieldPath))
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) GetPaths() []WatchConfigMapsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchConfigMapsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) Set(target, source *WatchConfigMapsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchConfigMapsResponse), source.(*WatchConfigMapsResponse))
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) Project(source *WatchConfigMapsResponse) *WatchConfigMapsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchConfigMapsResponse{}
	pageTokenChangeMask := &WatchConfigMapsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchConfigMapsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchConfigMapsResponse_FieldPathSelectorConfigMapChanges:
				result.ConfigMapChanges = source.ConfigMapChanges
			case WatchConfigMapsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchConfigMapsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchConfigMapsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchConfigMapsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchConfigMapsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchConfigMapsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchConfigMapsResponse_FieldSubPath:
			switch tp.selector {
			case WatchConfigMapsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchConfigMapsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchConfigMapsResponse))
}

func (fieldMask *WatchConfigMapsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchConfigMapsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchConfigMapsResponsePageTokenChange_FieldPath
}

func FullWatchConfigMapsResponse_PageTokenChange_FieldMask() *WatchConfigMapsResponse_PageTokenChange_FieldMask {
	res := &WatchConfigMapsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchConfigMapsResponsePageTokenChange_FieldTerminalPath{selector: WatchConfigMapsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchConfigMapsResponsePageTokenChange_FieldTerminalPath{selector: WatchConfigMapsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchConfigMapsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchConfigMapsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchConfigMapsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) Subtract(other *WatchConfigMapsResponse_PageTokenChange_FieldMask) *WatchConfigMapsResponse_PageTokenChange_FieldMask {
	result := &WatchConfigMapsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchConfigMapsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchConfigMapsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchConfigMapsResponse_PageTokenChange_FieldMask {
	result := &WatchConfigMapsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchConfigMapsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchConfigMapsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchConfigMapsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchConfigMapsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) AppendPath(path WatchConfigMapsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchConfigMapsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) GetPaths() []WatchConfigMapsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchConfigMapsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) Set(target, source *WatchConfigMapsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchConfigMapsResponse_PageTokenChange), source.(*WatchConfigMapsResponse_PageTokenChange))
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) Project(source *WatchConfigMapsResponse_PageTokenChange) *WatchConfigMapsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchConfigMapsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchConfigMapsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchConfigMapsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchConfigMapsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchConfigMapsResponse_PageTokenChange))
}

func (fieldMask *WatchConfigMapsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateConfigMapRequest_FieldMask struct {
	Paths []CreateConfigMapRequest_FieldPath
}

func FullCreateConfigMapRequest_FieldMask() *CreateConfigMapRequest_FieldMask {
	res := &CreateConfigMapRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateConfigMapRequest_FieldTerminalPath{selector: CreateConfigMapRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateConfigMapRequest_FieldTerminalPath{selector: CreateConfigMapRequest_FieldPathSelectorConfigMap})
	return res
}

func (fieldMask *CreateConfigMapRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateConfigMapRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateConfigMapRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateConfigMapRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateConfigMapRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateConfigMapRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateConfigMapRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateConfigMapRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateConfigMapRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateConfigMapRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateConfigMapRequest_FieldMask) Subtract(other *CreateConfigMapRequest_FieldMask) *CreateConfigMapRequest_FieldMask {
	result := &CreateConfigMapRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateConfigMapRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateConfigMapRequest_FieldPathSelectorConfigMap: &config_map.ConfigMap_FieldMask{},
	}
	mySubMasks := map[CreateConfigMapRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateConfigMapRequest_FieldPathSelectorConfigMap: &config_map.ConfigMap_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateConfigMapRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateConfigMapRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateConfigMapRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateConfigMapRequest_FieldPathSelectorConfigMap:
						mySubMasks[CreateConfigMapRequest_FieldPathSelectorConfigMap] = config_map.FullConfigMap_FieldMask()
					}
				} else if tp, ok := path.(*CreateConfigMapRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateConfigMapRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateConfigMapRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateConfigMapRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateConfigMapRequest_FieldMask) FilterInputFields() *CreateConfigMapRequest_FieldMask {
	result := &CreateConfigMapRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateConfigMapRequest_FieldPathSelectorConfigMap:
			if _, ok := path.(*CreateConfigMapRequest_FieldTerminalPath); ok {
				for _, subpath := range config_map.FullConfigMap_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateConfigMapRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateConfigMapRequest_FieldSubPath); ok {
				selectedMask := &config_map.ConfigMap_FieldMask{
					Paths: []config_map.ConfigMap_FieldPath{sub.subPath.(config_map.ConfigMap_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateConfigMapRequest_FieldSubPath{selector: CreateConfigMapRequest_FieldPathSelectorConfigMap, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateConfigMapRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateConfigMapRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateConfigMapRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateConfigMapRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateConfigMapRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateConfigMapRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateConfigMapRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateConfigMapRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateConfigMapRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateConfigMapRequest_FieldMask) AppendPath(path CreateConfigMapRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateConfigMapRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateConfigMapRequest_FieldPath))
}

func (fieldMask *CreateConfigMapRequest_FieldMask) GetPaths() []CreateConfigMapRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateConfigMapRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateConfigMapRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateConfigMapRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateConfigMapRequest_FieldMask) Set(target, source *CreateConfigMapRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateConfigMapRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateConfigMapRequest), source.(*CreateConfigMapRequest))
}

func (fieldMask *CreateConfigMapRequest_FieldMask) Project(source *CreateConfigMapRequest) *CreateConfigMapRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateConfigMapRequest{}
	configMapMask := &config_map.ConfigMap_FieldMask{}
	wholeConfigMapAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateConfigMapRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateConfigMapRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateConfigMapRequest_FieldPathSelectorConfigMap:
				result.ConfigMap = source.ConfigMap
				wholeConfigMapAccepted = true
			}
		case *CreateConfigMapRequest_FieldSubPath:
			switch tp.selector {
			case CreateConfigMapRequest_FieldPathSelectorConfigMap:
				configMapMask.AppendPath(tp.subPath.(config_map.ConfigMap_FieldPath))
			}
		}
	}
	if wholeConfigMapAccepted == false && len(configMapMask.Paths) > 0 {
		result.ConfigMap = configMapMask.Project(source.GetConfigMap())
	}
	return result
}

func (fieldMask *CreateConfigMapRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateConfigMapRequest))
}

func (fieldMask *CreateConfigMapRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateConfigMapRequest_FieldMask struct {
	Paths []UpdateConfigMapRequest_FieldPath
}

func FullUpdateConfigMapRequest_FieldMask() *UpdateConfigMapRequest_FieldMask {
	res := &UpdateConfigMapRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateConfigMapRequest_FieldTerminalPath{selector: UpdateConfigMapRequest_FieldPathSelectorConfigMap})
	res.Paths = append(res.Paths, &UpdateConfigMapRequest_FieldTerminalPath{selector: UpdateConfigMapRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateConfigMapRequest_FieldTerminalPath{selector: UpdateConfigMapRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateConfigMapRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateConfigMapRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateConfigMapRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateConfigMapRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateConfigMapRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) Subtract(other *UpdateConfigMapRequest_FieldMask) *UpdateConfigMapRequest_FieldMask {
	result := &UpdateConfigMapRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateConfigMapRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateConfigMapRequest_FieldPathSelectorConfigMap: &config_map.ConfigMap_FieldMask{},
		UpdateConfigMapRequest_FieldPathSelectorCas:       &UpdateConfigMapRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateConfigMapRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateConfigMapRequest_FieldPathSelectorConfigMap: &config_map.ConfigMap_FieldMask{},
		UpdateConfigMapRequest_FieldPathSelectorCas:       &UpdateConfigMapRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateConfigMapRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateConfigMapRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateConfigMapRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateConfigMapRequest_FieldPathSelectorConfigMap:
						mySubMasks[UpdateConfigMapRequest_FieldPathSelectorConfigMap] = config_map.FullConfigMap_FieldMask()
					case UpdateConfigMapRequest_FieldPathSelectorCas:
						mySubMasks[UpdateConfigMapRequest_FieldPathSelectorCas] = FullUpdateConfigMapRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateConfigMapRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateConfigMapRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateConfigMapRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateConfigMapRequest_FieldMask) FilterInputFields() *UpdateConfigMapRequest_FieldMask {
	result := &UpdateConfigMapRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateConfigMapRequest_FieldPathSelectorConfigMap:
			if _, ok := path.(*UpdateConfigMapRequest_FieldTerminalPath); ok {
				for _, subpath := range config_map.FullConfigMap_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateConfigMapRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateConfigMapRequest_FieldSubPath); ok {
				selectedMask := &config_map.ConfigMap_FieldMask{
					Paths: []config_map.ConfigMap_FieldPath{sub.subPath.(config_map.ConfigMap_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateConfigMapRequest_FieldSubPath{selector: UpdateConfigMapRequest_FieldPathSelectorConfigMap, subPath: allowedPath})
				}
			}
		case UpdateConfigMapRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateConfigMapRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateConfigMapRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateConfigMapRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateConfigMapRequest_FieldSubPath); ok {
				selectedMask := &UpdateConfigMapRequest_CAS_FieldMask{
					Paths: []UpdateConfigMapRequestCAS_FieldPath{sub.subPath.(UpdateConfigMapRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateConfigMapRequest_FieldSubPath{selector: UpdateConfigMapRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateConfigMapRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateConfigMapRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateConfigMapRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateConfigMapRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateConfigMapRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) AppendPath(path UpdateConfigMapRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateConfigMapRequest_FieldPath))
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) GetPaths() []UpdateConfigMapRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateConfigMapRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) Set(target, source *UpdateConfigMapRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateConfigMapRequest), source.(*UpdateConfigMapRequest))
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) Project(source *UpdateConfigMapRequest) *UpdateConfigMapRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateConfigMapRequest{}
	configMapMask := &config_map.ConfigMap_FieldMask{}
	wholeConfigMapAccepted := false
	casMask := &UpdateConfigMapRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateConfigMapRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateConfigMapRequest_FieldPathSelectorConfigMap:
				result.ConfigMap = source.ConfigMap
				wholeConfigMapAccepted = true
			case UpdateConfigMapRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateConfigMapRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateConfigMapRequest_FieldSubPath:
			switch tp.selector {
			case UpdateConfigMapRequest_FieldPathSelectorConfigMap:
				configMapMask.AppendPath(tp.subPath.(config_map.ConfigMap_FieldPath))
			case UpdateConfigMapRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateConfigMapRequestCAS_FieldPath))
			}
		}
	}
	if wholeConfigMapAccepted == false && len(configMapMask.Paths) > 0 {
		result.ConfigMap = configMapMask.Project(source.GetConfigMap())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateConfigMapRequest))
}

func (fieldMask *UpdateConfigMapRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateConfigMapRequest_CAS_FieldMask struct {
	Paths []UpdateConfigMapRequestCAS_FieldPath
}

func FullUpdateConfigMapRequest_CAS_FieldMask() *UpdateConfigMapRequest_CAS_FieldMask {
	res := &UpdateConfigMapRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateConfigMapRequestCAS_FieldTerminalPath{selector: UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateConfigMapRequestCAS_FieldTerminalPath{selector: UpdateConfigMapRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateConfigMapRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateConfigMapRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateConfigMapRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) Subtract(other *UpdateConfigMapRequest_CAS_FieldMask) *UpdateConfigMapRequest_CAS_FieldMask {
	result := &UpdateConfigMapRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateConfigMapRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState: &config_map.ConfigMap_FieldMask{},
	}
	mySubMasks := map[UpdateConfigMapRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState: &config_map.ConfigMap_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateConfigMapRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateConfigMapRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateConfigMapRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState] = config_map.FullConfigMap_FieldMask()
					}
				} else if tp, ok := path.(*UpdateConfigMapRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateConfigMapRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateConfigMapRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) FilterInputFields() *UpdateConfigMapRequest_CAS_FieldMask {
	result := &UpdateConfigMapRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateConfigMapRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range config_map.FullConfigMap_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateConfigMapRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateConfigMapRequestCAS_FieldSubPath); ok {
				selectedMask := &config_map.ConfigMap_FieldMask{
					Paths: []config_map.ConfigMap_FieldPath{sub.subPath.(config_map.ConfigMap_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateConfigMapRequestCAS_FieldSubPath{selector: UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateConfigMapRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateConfigMapRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateConfigMapRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateConfigMapRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) AppendPath(path UpdateConfigMapRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateConfigMapRequestCAS_FieldPath))
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) GetPaths() []UpdateConfigMapRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateConfigMapRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) Set(target, source *UpdateConfigMapRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateConfigMapRequest_CAS), source.(*UpdateConfigMapRequest_CAS))
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) Project(source *UpdateConfigMapRequest_CAS) *UpdateConfigMapRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateConfigMapRequest_CAS{}
	conditionalStateMask := &config_map.ConfigMap_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateConfigMapRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateConfigMapRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateConfigMapRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateConfigMapRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(config_map.ConfigMap_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateConfigMapRequest_CAS))
}

func (fieldMask *UpdateConfigMapRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteConfigMapRequest_FieldMask struct {
	Paths []DeleteConfigMapRequest_FieldPath
}

func FullDeleteConfigMapRequest_FieldMask() *DeleteConfigMapRequest_FieldMask {
	res := &DeleteConfigMapRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteConfigMapRequest_FieldTerminalPath{selector: DeleteConfigMapRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteConfigMapRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteConfigMapRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteConfigMapRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteConfigMapRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteConfigMapRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) Subtract(other *DeleteConfigMapRequest_FieldMask) *DeleteConfigMapRequest_FieldMask {
	result := &DeleteConfigMapRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteConfigMapRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteConfigMapRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteConfigMapRequest_FieldMask) FilterInputFields() *DeleteConfigMapRequest_FieldMask {
	result := &DeleteConfigMapRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteConfigMapRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteConfigMapRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteConfigMapRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteConfigMapRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteConfigMapRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) AppendPath(path DeleteConfigMapRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteConfigMapRequest_FieldPath))
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) GetPaths() []DeleteConfigMapRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteConfigMapRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) Set(target, source *DeleteConfigMapRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteConfigMapRequest), source.(*DeleteConfigMapRequest))
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) Project(source *DeleteConfigMapRequest) *DeleteConfigMapRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteConfigMapRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteConfigMapRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteConfigMapRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteConfigMapRequest))
}

func (fieldMask *DeleteConfigMapRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
