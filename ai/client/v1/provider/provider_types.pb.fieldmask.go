// Code generated by protoc-gen-goten-object
// File: edgelq/ai/proto/v1/provider_types.proto
// DO NOT EDIT!!!

package provider_client

import (
	"encoding/json"
	"strings"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	common_client "github.com/cloudwan/edgelq-sdk/ai/client/v1/common"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &common_client.Message{}
)

type ProviderChatRequest_FieldMask struct {
	Paths []ProviderChatRequest_FieldPath
}

func FullProviderChatRequest_FieldMask() *ProviderChatRequest_FieldMask {
	res := &ProviderChatRequest_FieldMask{}
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorMessages})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorTools})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorParameters})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorUser})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorOpenaiConfig})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorAzureConfig})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorAnthropicConfig})
	res.Paths = append(res.Paths, &ProviderChatRequest_FieldTerminalPath{selector: ProviderChatRequest_FieldPathSelectorGeminiConfig})
	return res
}

func (fieldMask *ProviderChatRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ProviderChatRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProviderChatRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ProviderChatRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProviderChatRequest_FieldPath(raw)
	})
}

func (fieldMask *ProviderChatRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ProviderChatRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ProviderChatRequest_FieldMask) Subtract(other *ProviderChatRequest_FieldMask) *ProviderChatRequest_FieldMask {
	result := &ProviderChatRequest_FieldMask{}
	removedSelectors := make([]bool, 10)
	otherSubMasks := map[ProviderChatRequest_FieldPathSelector]gotenobject.FieldMask{
		ProviderChatRequest_FieldPathSelectorParameters:      &ChatParameters_FieldMask{},
		ProviderChatRequest_FieldPathSelectorOpenaiConfig:    &OpenAIConfig_FieldMask{},
		ProviderChatRequest_FieldPathSelectorAzureConfig:     &AzureConfig_FieldMask{},
		ProviderChatRequest_FieldPathSelectorAnthropicConfig: &AnthropicConfig_FieldMask{},
		ProviderChatRequest_FieldPathSelectorGeminiConfig:    &GeminiConfig_FieldMask{},
	}
	mySubMasks := map[ProviderChatRequest_FieldPathSelector]gotenobject.FieldMask{
		ProviderChatRequest_FieldPathSelectorParameters:      &ChatParameters_FieldMask{},
		ProviderChatRequest_FieldPathSelectorOpenaiConfig:    &OpenAIConfig_FieldMask{},
		ProviderChatRequest_FieldPathSelectorAzureConfig:     &AzureConfig_FieldMask{},
		ProviderChatRequest_FieldPathSelectorAnthropicConfig: &AnthropicConfig_FieldMask{},
		ProviderChatRequest_FieldPathSelectorGeminiConfig:    &GeminiConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProviderChatRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ProviderChatRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ProviderChatRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case ProviderChatRequest_FieldPathSelectorParameters:
						mySubMasks[ProviderChatRequest_FieldPathSelectorParameters] = FullChatParameters_FieldMask()
					case ProviderChatRequest_FieldPathSelectorOpenaiConfig:
						mySubMasks[ProviderChatRequest_FieldPathSelectorOpenaiConfig] = FullOpenAIConfig_FieldMask()
					case ProviderChatRequest_FieldPathSelectorAzureConfig:
						mySubMasks[ProviderChatRequest_FieldPathSelectorAzureConfig] = FullAzureConfig_FieldMask()
					case ProviderChatRequest_FieldPathSelectorAnthropicConfig:
						mySubMasks[ProviderChatRequest_FieldPathSelectorAnthropicConfig] = FullAnthropicConfig_FieldMask()
					case ProviderChatRequest_FieldPathSelectorGeminiConfig:
						mySubMasks[ProviderChatRequest_FieldPathSelectorGeminiConfig] = FullGeminiConfig_FieldMask()
					}
				} else if tp, ok := path.(*ProviderChatRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ProviderChatRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ProviderChatRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ProviderChatRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ProviderChatRequest_FieldMask) FilterInputFields() *ProviderChatRequest_FieldMask {
	result := &ProviderChatRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ProviderChatRequest_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ProviderChatRequest_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProviderChatRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProviderChatRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ProviderChatRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ProviderChatRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProviderChatRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ProviderChatRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ProviderChatRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProviderChatRequest_FieldMask) AppendPath(path ProviderChatRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ProviderChatRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProviderChatRequest_FieldPath))
}

func (fieldMask *ProviderChatRequest_FieldMask) GetPaths() []ProviderChatRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ProviderChatRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ProviderChatRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProviderChatRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ProviderChatRequest_FieldMask) Set(target, source *ProviderChatRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ProviderChatRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ProviderChatRequest), source.(*ProviderChatRequest))
}

func (fieldMask *ProviderChatRequest_FieldMask) Project(source *ProviderChatRequest) *ProviderChatRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ProviderChatRequest{}
	parametersMask := &ChatParameters_FieldMask{}
	wholeParametersAccepted := false
	openaiConfigMask := &OpenAIConfig_FieldMask{}
	wholeOpenaiConfigAccepted := false
	azureConfigMask := &AzureConfig_FieldMask{}
	wholeAzureConfigAccepted := false
	anthropicConfigMask := &AnthropicConfig_FieldMask{}
	wholeAnthropicConfigAccepted := false
	geminiConfigMask := &GeminiConfig_FieldMask{}
	wholeGeminiConfigAccepted := false
	var metadataMapKeys []string
	wholeMetadataAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProviderChatRequest_FieldTerminalPath:
			switch tp.selector {
			case ProviderChatRequest_FieldPathSelectorModel:
				result.Model = source.Model
			case ProviderChatRequest_FieldPathSelectorMessages:
				result.Messages = source.Messages
			case ProviderChatRequest_FieldPathSelectorTools:
				result.Tools = source.Tools
			case ProviderChatRequest_FieldPathSelectorParameters:
				result.Parameters = source.Parameters
				wholeParametersAccepted = true
			case ProviderChatRequest_FieldPathSelectorUser:
				result.User = source.User
			case ProviderChatRequest_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case ProviderChatRequest_FieldPathSelectorOpenaiConfig:
				if source, ok := source.ProviderConfig.(*ProviderChatRequest_OpenaiConfig); ok {
					result.ProviderConfig = &ProviderChatRequest_OpenaiConfig{
						OpenaiConfig: source.OpenaiConfig,
					}
				}
				wholeOpenaiConfigAccepted = true
			case ProviderChatRequest_FieldPathSelectorAzureConfig:
				if source, ok := source.ProviderConfig.(*ProviderChatRequest_AzureConfig); ok {
					result.ProviderConfig = &ProviderChatRequest_AzureConfig{
						AzureConfig: source.AzureConfig,
					}
				}
				wholeAzureConfigAccepted = true
			case ProviderChatRequest_FieldPathSelectorAnthropicConfig:
				if source, ok := source.ProviderConfig.(*ProviderChatRequest_AnthropicConfig); ok {
					result.ProviderConfig = &ProviderChatRequest_AnthropicConfig{
						AnthropicConfig: source.AnthropicConfig,
					}
				}
				wholeAnthropicConfigAccepted = true
			case ProviderChatRequest_FieldPathSelectorGeminiConfig:
				if source, ok := source.ProviderConfig.(*ProviderChatRequest_GeminiConfig); ok {
					result.ProviderConfig = &ProviderChatRequest_GeminiConfig{
						GeminiConfig: source.GeminiConfig,
					}
				}
				wholeGeminiConfigAccepted = true
			}
		case *ProviderChatRequest_FieldSubPath:
			switch tp.selector {
			case ProviderChatRequest_FieldPathSelectorParameters:
				parametersMask.AppendPath(tp.subPath.(ChatParameters_FieldPath))
			case ProviderChatRequest_FieldPathSelectorOpenaiConfig:
				openaiConfigMask.AppendPath(tp.subPath.(OpenAIConfig_FieldPath))
			case ProviderChatRequest_FieldPathSelectorAzureConfig:
				azureConfigMask.AppendPath(tp.subPath.(AzureConfig_FieldPath))
			case ProviderChatRequest_FieldPathSelectorAnthropicConfig:
				anthropicConfigMask.AppendPath(tp.subPath.(AnthropicConfig_FieldPath))
			case ProviderChatRequest_FieldPathSelectorGeminiConfig:
				geminiConfigMask.AppendPath(tp.subPath.(GeminiConfig_FieldPath))
			}
		case *ProviderChatRequest_FieldPathMap:
			switch tp.selector {
			case ProviderChatRequest_FieldPathSelectorMetadata:
				metadataMapKeys = append(metadataMapKeys, tp.key)
			}
		}
	}
	if wholeParametersAccepted == false && len(parametersMask.Paths) > 0 {
		result.Parameters = parametersMask.Project(source.GetParameters())
	}
	if wholeMetadataAccepted == false && len(metadataMapKeys) > 0 && source.GetMetadata() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetMetadata()
		for _, key := range metadataMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Metadata = copiedMap
	}
	if wholeOpenaiConfigAccepted == false && len(openaiConfigMask.Paths) > 0 {
		if asOneOf, ok := source.ProviderConfig.(*ProviderChatRequest_OpenaiConfig); ok {
			result.ProviderConfig = (*ProviderChatRequest_OpenaiConfig)(nil)
			if asOneOf != nil {
				oneOfRes := &ProviderChatRequest_OpenaiConfig{}
				oneOfRes.OpenaiConfig = openaiConfigMask.Project(asOneOf.OpenaiConfig)
				result.ProviderConfig = oneOfRes
			}
		}
	}
	if wholeAzureConfigAccepted == false && len(azureConfigMask.Paths) > 0 {
		if asOneOf, ok := source.ProviderConfig.(*ProviderChatRequest_AzureConfig); ok {
			result.ProviderConfig = (*ProviderChatRequest_AzureConfig)(nil)
			if asOneOf != nil {
				oneOfRes := &ProviderChatRequest_AzureConfig{}
				oneOfRes.AzureConfig = azureConfigMask.Project(asOneOf.AzureConfig)
				result.ProviderConfig = oneOfRes
			}
		}
	}
	if wholeAnthropicConfigAccepted == false && len(anthropicConfigMask.Paths) > 0 {
		if asOneOf, ok := source.ProviderConfig.(*ProviderChatRequest_AnthropicConfig); ok {
			result.ProviderConfig = (*ProviderChatRequest_AnthropicConfig)(nil)
			if asOneOf != nil {
				oneOfRes := &ProviderChatRequest_AnthropicConfig{}
				oneOfRes.AnthropicConfig = anthropicConfigMask.Project(asOneOf.AnthropicConfig)
				result.ProviderConfig = oneOfRes
			}
		}
	}
	if wholeGeminiConfigAccepted == false && len(geminiConfigMask.Paths) > 0 {
		if asOneOf, ok := source.ProviderConfig.(*ProviderChatRequest_GeminiConfig); ok {
			result.ProviderConfig = (*ProviderChatRequest_GeminiConfig)(nil)
			if asOneOf != nil {
				oneOfRes := &ProviderChatRequest_GeminiConfig{}
				oneOfRes.GeminiConfig = geminiConfigMask.Project(asOneOf.GeminiConfig)
				result.ProviderConfig = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ProviderChatRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ProviderChatRequest))
}

func (fieldMask *ProviderChatRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ChatParameters_FieldMask struct {
	Paths []ChatParameters_FieldPath
}

func FullChatParameters_FieldMask() *ChatParameters_FieldMask {
	res := &ChatParameters_FieldMask{}
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorMaxTokens})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorTemperature})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorTopP})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorTopK})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorPresencePenalty})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorFrequencyPenalty})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorSeed})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorStopSequences})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorResponseFormat})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorLogprobs})
	res.Paths = append(res.Paths, &ChatParameters_FieldTerminalPath{selector: ChatParameters_FieldPathSelectorTopLogprobs})
	return res
}

func (fieldMask *ChatParameters_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ChatParameters_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ChatParameters_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ChatParameters_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseChatParameters_FieldPath(raw)
	})
}

func (fieldMask *ChatParameters_FieldMask) ProtoMessage() {}

func (fieldMask *ChatParameters_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ChatParameters_FieldMask) Subtract(other *ChatParameters_FieldMask) *ChatParameters_FieldMask {
	result := &ChatParameters_FieldMask{}
	removedSelectors := make([]bool, 11)
	otherSubMasks := map[ChatParameters_FieldPathSelector]gotenobject.FieldMask{
		ChatParameters_FieldPathSelectorResponseFormat: &ResponseFormat_FieldMask{},
	}
	mySubMasks := map[ChatParameters_FieldPathSelector]gotenobject.FieldMask{
		ChatParameters_FieldPathSelectorResponseFormat: &ResponseFormat_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ChatParameters_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ChatParameters_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ChatParameters_FieldTerminalPath); ok {
					switch tp.selector {
					case ChatParameters_FieldPathSelectorResponseFormat:
						mySubMasks[ChatParameters_FieldPathSelectorResponseFormat] = FullResponseFormat_FieldMask()
					}
				} else if tp, ok := path.(*ChatParameters_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ChatParameters_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ChatParameters_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ChatParameters_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ChatParameters_FieldMask) FilterInputFields() *ChatParameters_FieldMask {
	result := &ChatParameters_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ChatParameters_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ChatParameters_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ChatParameters_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseChatParameters_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ChatParameters_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ChatParameters_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ChatParameters_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ChatParameters_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ChatParameters_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ChatParameters_FieldMask) AppendPath(path ChatParameters_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ChatParameters_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ChatParameters_FieldPath))
}

func (fieldMask *ChatParameters_FieldMask) GetPaths() []ChatParameters_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ChatParameters_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ChatParameters_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseChatParameters_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ChatParameters_FieldMask) Set(target, source *ChatParameters) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ChatParameters_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ChatParameters), source.(*ChatParameters))
}

func (fieldMask *ChatParameters_FieldMask) Project(source *ChatParameters) *ChatParameters {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ChatParameters{}
	responseFormatMask := &ResponseFormat_FieldMask{}
	wholeResponseFormatAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ChatParameters_FieldTerminalPath:
			switch tp.selector {
			case ChatParameters_FieldPathSelectorMaxTokens:
				result.MaxTokens = source.MaxTokens
			case ChatParameters_FieldPathSelectorTemperature:
				result.Temperature = source.Temperature
			case ChatParameters_FieldPathSelectorTopP:
				result.TopP = source.TopP
			case ChatParameters_FieldPathSelectorTopK:
				result.TopK = source.TopK
			case ChatParameters_FieldPathSelectorPresencePenalty:
				result.PresencePenalty = source.PresencePenalty
			case ChatParameters_FieldPathSelectorFrequencyPenalty:
				result.FrequencyPenalty = source.FrequencyPenalty
			case ChatParameters_FieldPathSelectorSeed:
				result.Seed = source.Seed
			case ChatParameters_FieldPathSelectorStopSequences:
				result.StopSequences = source.StopSequences
			case ChatParameters_FieldPathSelectorResponseFormat:
				result.ResponseFormat = source.ResponseFormat
				wholeResponseFormatAccepted = true
			case ChatParameters_FieldPathSelectorLogprobs:
				result.Logprobs = source.Logprobs
			case ChatParameters_FieldPathSelectorTopLogprobs:
				result.TopLogprobs = source.TopLogprobs
			}
		case *ChatParameters_FieldSubPath:
			switch tp.selector {
			case ChatParameters_FieldPathSelectorResponseFormat:
				responseFormatMask.AppendPath(tp.subPath.(ResponseFormat_FieldPath))
			}
		}
	}
	if wholeResponseFormatAccepted == false && len(responseFormatMask.Paths) > 0 {
		result.ResponseFormat = responseFormatMask.Project(source.GetResponseFormat())
	}
	return result
}

func (fieldMask *ChatParameters_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ChatParameters))
}

func (fieldMask *ChatParameters_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ResponseFormat_FieldMask struct {
	Paths []ResponseFormat_FieldPath
}

func FullResponseFormat_FieldMask() *ResponseFormat_FieldMask {
	res := &ResponseFormat_FieldMask{}
	res.Paths = append(res.Paths, &ResponseFormat_FieldTerminalPath{selector: ResponseFormat_FieldPathSelectorMode})
	res.Paths = append(res.Paths, &ResponseFormat_FieldTerminalPath{selector: ResponseFormat_FieldPathSelectorJsonSchema})
	return res
}

func (fieldMask *ResponseFormat_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ResponseFormat_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ResponseFormat_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ResponseFormat_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseResponseFormat_FieldPath(raw)
	})
}

func (fieldMask *ResponseFormat_FieldMask) ProtoMessage() {}

func (fieldMask *ResponseFormat_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ResponseFormat_FieldMask) Subtract(other *ResponseFormat_FieldMask) *ResponseFormat_FieldMask {
	result := &ResponseFormat_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ResponseFormat_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ResponseFormat_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ResponseFormat_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ResponseFormat_FieldMask) FilterInputFields() *ResponseFormat_FieldMask {
	result := &ResponseFormat_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ResponseFormat_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ResponseFormat_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ResponseFormat_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseResponseFormat_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ResponseFormat_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ResponseFormat_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ResponseFormat_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ResponseFormat_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ResponseFormat_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ResponseFormat_FieldMask) AppendPath(path ResponseFormat_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ResponseFormat_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ResponseFormat_FieldPath))
}

func (fieldMask *ResponseFormat_FieldMask) GetPaths() []ResponseFormat_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ResponseFormat_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ResponseFormat_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseResponseFormat_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ResponseFormat_FieldMask) Set(target, source *ResponseFormat) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ResponseFormat_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ResponseFormat), source.(*ResponseFormat))
}

func (fieldMask *ResponseFormat_FieldMask) Project(source *ResponseFormat) *ResponseFormat {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ResponseFormat{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ResponseFormat_FieldTerminalPath:
			switch tp.selector {
			case ResponseFormat_FieldPathSelectorMode:
				result.Mode = source.Mode
			case ResponseFormat_FieldPathSelectorJsonSchema:
				result.JsonSchema = source.JsonSchema
			}
		}
	}
	return result
}

func (fieldMask *ResponseFormat_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ResponseFormat))
}

func (fieldMask *ResponseFormat_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ProviderContentDelta_FieldMask struct {
	Paths []ProviderContentDelta_FieldPath
}

func FullProviderContentDelta_FieldMask() *ProviderContentDelta_FieldMask {
	res := &ProviderContentDelta_FieldMask{}
	res.Paths = append(res.Paths, &ProviderContentDelta_FieldTerminalPath{selector: ProviderContentDelta_FieldPathSelectorText})
	res.Paths = append(res.Paths, &ProviderContentDelta_FieldTerminalPath{selector: ProviderContentDelta_FieldPathSelectorChannel})
	return res
}

func (fieldMask *ProviderContentDelta_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ProviderContentDelta_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProviderContentDelta_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ProviderContentDelta_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProviderContentDelta_FieldPath(raw)
	})
}

func (fieldMask *ProviderContentDelta_FieldMask) ProtoMessage() {}

func (fieldMask *ProviderContentDelta_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ProviderContentDelta_FieldMask) Subtract(other *ProviderContentDelta_FieldMask) *ProviderContentDelta_FieldMask {
	result := &ProviderContentDelta_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProviderContentDelta_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ProviderContentDelta_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ProviderContentDelta_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ProviderContentDelta_FieldMask) FilterInputFields() *ProviderContentDelta_FieldMask {
	result := &ProviderContentDelta_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ProviderContentDelta_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ProviderContentDelta_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProviderContentDelta_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProviderContentDelta_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ProviderContentDelta_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ProviderContentDelta_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProviderContentDelta_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ProviderContentDelta_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ProviderContentDelta_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProviderContentDelta_FieldMask) AppendPath(path ProviderContentDelta_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ProviderContentDelta_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProviderContentDelta_FieldPath))
}

func (fieldMask *ProviderContentDelta_FieldMask) GetPaths() []ProviderContentDelta_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ProviderContentDelta_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ProviderContentDelta_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProviderContentDelta_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ProviderContentDelta_FieldMask) Set(target, source *ProviderContentDelta) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ProviderContentDelta_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ProviderContentDelta), source.(*ProviderContentDelta))
}

func (fieldMask *ProviderContentDelta_FieldMask) Project(source *ProviderContentDelta) *ProviderContentDelta {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ProviderContentDelta{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProviderContentDelta_FieldTerminalPath:
			switch tp.selector {
			case ProviderContentDelta_FieldPathSelectorText:
				result.Text = source.Text
			case ProviderContentDelta_FieldPathSelectorChannel:
				result.Channel = source.Channel
			}
		}
	}
	return result
}

func (fieldMask *ProviderContentDelta_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ProviderContentDelta))
}

func (fieldMask *ProviderContentDelta_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type StreamError_FieldMask struct {
	Paths []StreamError_FieldPath
}

func FullStreamError_FieldMask() *StreamError_FieldMask {
	res := &StreamError_FieldMask{}
	res.Paths = append(res.Paths, &StreamError_FieldTerminalPath{selector: StreamError_FieldPathSelectorType})
	res.Paths = append(res.Paths, &StreamError_FieldTerminalPath{selector: StreamError_FieldPathSelectorMessage})
	return res
}

func (fieldMask *StreamError_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *StreamError_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*StreamError_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *StreamError_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseStreamError_FieldPath(raw)
	})
}

func (fieldMask *StreamError_FieldMask) ProtoMessage() {}

func (fieldMask *StreamError_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *StreamError_FieldMask) Subtract(other *StreamError_FieldMask) *StreamError_FieldMask {
	result := &StreamError_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *StreamError_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *StreamError_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*StreamError_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *StreamError_FieldMask) FilterInputFields() *StreamError_FieldMask {
	result := &StreamError_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *StreamError_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *StreamError_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]StreamError_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseStreamError_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask StreamError_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *StreamError_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *StreamError_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask StreamError_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *StreamError_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *StreamError_FieldMask) AppendPath(path StreamError_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *StreamError_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(StreamError_FieldPath))
}

func (fieldMask *StreamError_FieldMask) GetPaths() []StreamError_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *StreamError_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *StreamError_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseStreamError_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *StreamError_FieldMask) Set(target, source *StreamError) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *StreamError_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*StreamError), source.(*StreamError))
}

func (fieldMask *StreamError_FieldMask) Project(source *StreamError) *StreamError {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &StreamError{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *StreamError_FieldTerminalPath:
			switch tp.selector {
			case StreamError_FieldPathSelectorType:
				result.Type = source.Type
			case StreamError_FieldPathSelectorMessage:
				result.Message = source.Message
			}
		}
	}
	return result
}

func (fieldMask *StreamError_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*StreamError))
}

func (fieldMask *StreamError_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ProviderStreamEvent_FieldMask struct {
	Paths []ProviderStreamEvent_FieldPath
}

func FullProviderStreamEvent_FieldMask() *ProviderStreamEvent_FieldMask {
	res := &ProviderStreamEvent_FieldMask{}
	res.Paths = append(res.Paths, &ProviderStreamEvent_FieldTerminalPath{selector: ProviderStreamEvent_FieldPathSelectorDelta})
	res.Paths = append(res.Paths, &ProviderStreamEvent_FieldTerminalPath{selector: ProviderStreamEvent_FieldPathSelectorUsage})
	res.Paths = append(res.Paths, &ProviderStreamEvent_FieldTerminalPath{selector: ProviderStreamEvent_FieldPathSelectorError})
	res.Paths = append(res.Paths, &ProviderStreamEvent_FieldTerminalPath{selector: ProviderStreamEvent_FieldPathSelectorDone})
	res.Paths = append(res.Paths, &ProviderStreamEvent_FieldTerminalPath{selector: ProviderStreamEvent_FieldPathSelectorToolCalls})
	return res
}

func (fieldMask *ProviderStreamEvent_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ProviderStreamEvent_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProviderStreamEvent_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ProviderStreamEvent_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProviderStreamEvent_FieldPath(raw)
	})
}

func (fieldMask *ProviderStreamEvent_FieldMask) ProtoMessage() {}

func (fieldMask *ProviderStreamEvent_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ProviderStreamEvent_FieldMask) Subtract(other *ProviderStreamEvent_FieldMask) *ProviderStreamEvent_FieldMask {
	result := &ProviderStreamEvent_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ProviderStreamEvent_FieldPathSelector]gotenobject.FieldMask{
		ProviderStreamEvent_FieldPathSelectorDelta: &ProviderContentDelta_FieldMask{},
		ProviderStreamEvent_FieldPathSelectorError: &StreamError_FieldMask{},
		ProviderStreamEvent_FieldPathSelectorDone:  &ProviderDone_FieldMask{},
	}
	mySubMasks := map[ProviderStreamEvent_FieldPathSelector]gotenobject.FieldMask{
		ProviderStreamEvent_FieldPathSelectorDelta: &ProviderContentDelta_FieldMask{},
		ProviderStreamEvent_FieldPathSelectorError: &StreamError_FieldMask{},
		ProviderStreamEvent_FieldPathSelectorDone:  &ProviderDone_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProviderStreamEvent_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ProviderStreamEvent_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ProviderStreamEvent_FieldTerminalPath); ok {
					switch tp.selector {
					case ProviderStreamEvent_FieldPathSelectorDelta:
						mySubMasks[ProviderStreamEvent_FieldPathSelectorDelta] = FullProviderContentDelta_FieldMask()
					case ProviderStreamEvent_FieldPathSelectorError:
						mySubMasks[ProviderStreamEvent_FieldPathSelectorError] = FullStreamError_FieldMask()
					case ProviderStreamEvent_FieldPathSelectorDone:
						mySubMasks[ProviderStreamEvent_FieldPathSelectorDone] = FullProviderDone_FieldMask()
					}
				} else if tp, ok := path.(*ProviderStreamEvent_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ProviderStreamEvent_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ProviderStreamEvent_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ProviderStreamEvent_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ProviderStreamEvent_FieldMask) FilterInputFields() *ProviderStreamEvent_FieldMask {
	result := &ProviderStreamEvent_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ProviderStreamEvent_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ProviderStreamEvent_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProviderStreamEvent_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProviderStreamEvent_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ProviderStreamEvent_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ProviderStreamEvent_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProviderStreamEvent_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ProviderStreamEvent_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ProviderStreamEvent_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProviderStreamEvent_FieldMask) AppendPath(path ProviderStreamEvent_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ProviderStreamEvent_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProviderStreamEvent_FieldPath))
}

func (fieldMask *ProviderStreamEvent_FieldMask) GetPaths() []ProviderStreamEvent_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ProviderStreamEvent_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ProviderStreamEvent_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProviderStreamEvent_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ProviderStreamEvent_FieldMask) Set(target, source *ProviderStreamEvent) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ProviderStreamEvent_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ProviderStreamEvent), source.(*ProviderStreamEvent))
}

func (fieldMask *ProviderStreamEvent_FieldMask) Project(source *ProviderStreamEvent) *ProviderStreamEvent {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ProviderStreamEvent{}
	deltaMask := &ProviderContentDelta_FieldMask{}
	wholeDeltaAccepted := false
	errorMask := &StreamError_FieldMask{}
	wholeErrorAccepted := false
	doneMask := &ProviderDone_FieldMask{}
	wholeDoneAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProviderStreamEvent_FieldTerminalPath:
			switch tp.selector {
			case ProviderStreamEvent_FieldPathSelectorDelta:
				if source, ok := source.Event.(*ProviderStreamEvent_Delta); ok {
					result.Event = &ProviderStreamEvent_Delta{
						Delta: source.Delta,
					}
				}
				wholeDeltaAccepted = true
			case ProviderStreamEvent_FieldPathSelectorUsage:
				if source, ok := source.Event.(*ProviderStreamEvent_Usage); ok {
					result.Event = &ProviderStreamEvent_Usage{
						Usage: source.Usage,
					}
				}
			case ProviderStreamEvent_FieldPathSelectorError:
				if source, ok := source.Event.(*ProviderStreamEvent_Error); ok {
					result.Event = &ProviderStreamEvent_Error{
						Error: source.Error,
					}
				}
				wholeErrorAccepted = true
			case ProviderStreamEvent_FieldPathSelectorDone:
				if source, ok := source.Event.(*ProviderStreamEvent_Done); ok {
					result.Event = &ProviderStreamEvent_Done{
						Done: source.Done,
					}
				}
				wholeDoneAccepted = true
			case ProviderStreamEvent_FieldPathSelectorToolCalls:
				if source, ok := source.Event.(*ProviderStreamEvent_ToolCalls); ok {
					result.Event = &ProviderStreamEvent_ToolCalls{
						ToolCalls: source.ToolCalls,
					}
				}
			}
		case *ProviderStreamEvent_FieldSubPath:
			switch tp.selector {
			case ProviderStreamEvent_FieldPathSelectorDelta:
				deltaMask.AppendPath(tp.subPath.(ProviderContentDelta_FieldPath))
			case ProviderStreamEvent_FieldPathSelectorError:
				errorMask.AppendPath(tp.subPath.(StreamError_FieldPath))
			case ProviderStreamEvent_FieldPathSelectorDone:
				doneMask.AppendPath(tp.subPath.(ProviderDone_FieldPath))
			}
		}
	}
	if wholeDeltaAccepted == false && len(deltaMask.Paths) > 0 {
		if asOneOf, ok := source.Event.(*ProviderStreamEvent_Delta); ok {
			result.Event = (*ProviderStreamEvent_Delta)(nil)
			if asOneOf != nil {
				oneOfRes := &ProviderStreamEvent_Delta{}
				oneOfRes.Delta = deltaMask.Project(asOneOf.Delta)
				result.Event = oneOfRes
			}
		}
	}
	if wholeErrorAccepted == false && len(errorMask.Paths) > 0 {
		if asOneOf, ok := source.Event.(*ProviderStreamEvent_Error); ok {
			result.Event = (*ProviderStreamEvent_Error)(nil)
			if asOneOf != nil {
				oneOfRes := &ProviderStreamEvent_Error{}
				oneOfRes.Error = errorMask.Project(asOneOf.Error)
				result.Event = oneOfRes
			}
		}
	}
	if wholeDoneAccepted == false && len(doneMask.Paths) > 0 {
		if asOneOf, ok := source.Event.(*ProviderStreamEvent_Done); ok {
			result.Event = (*ProviderStreamEvent_Done)(nil)
			if asOneOf != nil {
				oneOfRes := &ProviderStreamEvent_Done{}
				oneOfRes.Done = doneMask.Project(asOneOf.Done)
				result.Event = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ProviderStreamEvent_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ProviderStreamEvent))
}

func (fieldMask *ProviderStreamEvent_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ProviderDone_FieldMask struct {
	Paths []ProviderDone_FieldPath
}

func FullProviderDone_FieldMask() *ProviderDone_FieldMask {
	res := &ProviderDone_FieldMask{}
	res.Paths = append(res.Paths, &ProviderDone_FieldTerminalPath{selector: ProviderDone_FieldPathSelectorStopReason})
	return res
}

func (fieldMask *ProviderDone_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ProviderDone_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ProviderDone_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ProviderDone_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseProviderDone_FieldPath(raw)
	})
}

func (fieldMask *ProviderDone_FieldMask) ProtoMessage() {}

func (fieldMask *ProviderDone_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ProviderDone_FieldMask) Subtract(other *ProviderDone_FieldMask) *ProviderDone_FieldMask {
	result := &ProviderDone_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ProviderDone_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ProviderDone_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ProviderDone_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ProviderDone_FieldMask) FilterInputFields() *ProviderDone_FieldMask {
	result := &ProviderDone_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ProviderDone_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ProviderDone_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ProviderDone_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseProviderDone_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ProviderDone_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ProviderDone_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProviderDone_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ProviderDone_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ProviderDone_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ProviderDone_FieldMask) AppendPath(path ProviderDone_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ProviderDone_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ProviderDone_FieldPath))
}

func (fieldMask *ProviderDone_FieldMask) GetPaths() []ProviderDone_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ProviderDone_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ProviderDone_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseProviderDone_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ProviderDone_FieldMask) Set(target, source *ProviderDone) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ProviderDone_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ProviderDone), source.(*ProviderDone))
}

func (fieldMask *ProviderDone_FieldMask) Project(source *ProviderDone) *ProviderDone {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ProviderDone{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ProviderDone_FieldTerminalPath:
			switch tp.selector {
			case ProviderDone_FieldPathSelectorStopReason:
				result.StopReason = source.StopReason
			}
		}
	}
	return result
}

func (fieldMask *ProviderDone_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ProviderDone))
}

func (fieldMask *ProviderDone_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type OpenAIConfig_FieldMask struct {
	Paths []OpenAIConfig_FieldPath
}

func FullOpenAIConfig_FieldMask() *OpenAIConfig_FieldMask {
	res := &OpenAIConfig_FieldMask{}
	res.Paths = append(res.Paths, &OpenAIConfig_FieldTerminalPath{selector: OpenAIConfig_FieldPathSelectorParallelToolCalls})
	res.Paths = append(res.Paths, &OpenAIConfig_FieldTerminalPath{selector: OpenAIConfig_FieldPathSelectorMaxCompletionTokens})
	res.Paths = append(res.Paths, &OpenAIConfig_FieldTerminalPath{selector: OpenAIConfig_FieldPathSelectorReasoningEffort})
	return res
}

func (fieldMask *OpenAIConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *OpenAIConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*OpenAIConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *OpenAIConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseOpenAIConfig_FieldPath(raw)
	})
}

func (fieldMask *OpenAIConfig_FieldMask) ProtoMessage() {}

func (fieldMask *OpenAIConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *OpenAIConfig_FieldMask) Subtract(other *OpenAIConfig_FieldMask) *OpenAIConfig_FieldMask {
	result := &OpenAIConfig_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *OpenAIConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *OpenAIConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*OpenAIConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *OpenAIConfig_FieldMask) FilterInputFields() *OpenAIConfig_FieldMask {
	result := &OpenAIConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *OpenAIConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *OpenAIConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]OpenAIConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseOpenAIConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask OpenAIConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *OpenAIConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *OpenAIConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask OpenAIConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *OpenAIConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *OpenAIConfig_FieldMask) AppendPath(path OpenAIConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *OpenAIConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(OpenAIConfig_FieldPath))
}

func (fieldMask *OpenAIConfig_FieldMask) GetPaths() []OpenAIConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *OpenAIConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *OpenAIConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseOpenAIConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *OpenAIConfig_FieldMask) Set(target, source *OpenAIConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *OpenAIConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*OpenAIConfig), source.(*OpenAIConfig))
}

func (fieldMask *OpenAIConfig_FieldMask) Project(source *OpenAIConfig) *OpenAIConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &OpenAIConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *OpenAIConfig_FieldTerminalPath:
			switch tp.selector {
			case OpenAIConfig_FieldPathSelectorParallelToolCalls:
				result.ParallelToolCalls = source.ParallelToolCalls
			case OpenAIConfig_FieldPathSelectorMaxCompletionTokens:
				result.MaxCompletionTokens = source.MaxCompletionTokens
			case OpenAIConfig_FieldPathSelectorReasoningEffort:
				result.ReasoningEffort = source.ReasoningEffort
			}
		}
	}
	return result
}

func (fieldMask *OpenAIConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*OpenAIConfig))
}

func (fieldMask *OpenAIConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type AzureConfig_FieldMask struct {
	Paths []AzureConfig_FieldPath
}

func FullAzureConfig_FieldMask() *AzureConfig_FieldMask {
	res := &AzureConfig_FieldMask{}
	res.Paths = append(res.Paths, &AzureConfig_FieldTerminalPath{selector: AzureConfig_FieldPathSelectorSearch})
	res.Paths = append(res.Paths, &AzureConfig_FieldTerminalPath{selector: AzureConfig_FieldPathSelectorParallelToolCalls})
	res.Paths = append(res.Paths, &AzureConfig_FieldTerminalPath{selector: AzureConfig_FieldPathSelectorMaxCompletionTokens})
	res.Paths = append(res.Paths, &AzureConfig_FieldTerminalPath{selector: AzureConfig_FieldPathSelectorReasoningEffort})
	return res
}

func (fieldMask *AzureConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *AzureConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*AzureConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *AzureConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAzureConfig_FieldPath(raw)
	})
}

func (fieldMask *AzureConfig_FieldMask) ProtoMessage() {}

func (fieldMask *AzureConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *AzureConfig_FieldMask) Subtract(other *AzureConfig_FieldMask) *AzureConfig_FieldMask {
	result := &AzureConfig_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[AzureConfig_FieldPathSelector]gotenobject.FieldMask{
		AzureConfig_FieldPathSelectorSearch: &AzureSearchConfig_FieldMask{},
	}
	mySubMasks := map[AzureConfig_FieldPathSelector]gotenobject.FieldMask{
		AzureConfig_FieldPathSelectorSearch: &AzureSearchConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *AzureConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *AzureConfig_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*AzureConfig_FieldTerminalPath); ok {
					switch tp.selector {
					case AzureConfig_FieldPathSelectorSearch:
						mySubMasks[AzureConfig_FieldPathSelectorSearch] = FullAzureSearchConfig_FieldMask()
					}
				} else if tp, ok := path.(*AzureConfig_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &AzureConfig_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *AzureConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*AzureConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *AzureConfig_FieldMask) FilterInputFields() *AzureConfig_FieldMask {
	result := &AzureConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *AzureConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *AzureConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]AzureConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAzureConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask AzureConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *AzureConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AzureConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask AzureConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *AzureConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AzureConfig_FieldMask) AppendPath(path AzureConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *AzureConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(AzureConfig_FieldPath))
}

func (fieldMask *AzureConfig_FieldMask) GetPaths() []AzureConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *AzureConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *AzureConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAzureConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *AzureConfig_FieldMask) Set(target, source *AzureConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *AzureConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*AzureConfig), source.(*AzureConfig))
}

func (fieldMask *AzureConfig_FieldMask) Project(source *AzureConfig) *AzureConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &AzureConfig{}
	searchMask := &AzureSearchConfig_FieldMask{}
	wholeSearchAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *AzureConfig_FieldTerminalPath:
			switch tp.selector {
			case AzureConfig_FieldPathSelectorSearch:
				result.Search = source.Search
				wholeSearchAccepted = true
			case AzureConfig_FieldPathSelectorParallelToolCalls:
				result.ParallelToolCalls = source.ParallelToolCalls
			case AzureConfig_FieldPathSelectorMaxCompletionTokens:
				result.MaxCompletionTokens = source.MaxCompletionTokens
			case AzureConfig_FieldPathSelectorReasoningEffort:
				result.ReasoningEffort = source.ReasoningEffort
			}
		case *AzureConfig_FieldSubPath:
			switch tp.selector {
			case AzureConfig_FieldPathSelectorSearch:
				searchMask.AppendPath(tp.subPath.(AzureSearchConfig_FieldPath))
			}
		}
	}
	if wholeSearchAccepted == false && len(searchMask.Paths) > 0 {
		result.Search = searchMask.Project(source.GetSearch())
	}
	return result
}

func (fieldMask *AzureConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*AzureConfig))
}

func (fieldMask *AzureConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type AzureSearchConfig_FieldMask struct {
	Paths []AzureSearchConfig_FieldPath
}

func FullAzureSearchConfig_FieldMask() *AzureSearchConfig_FieldMask {
	res := &AzureSearchConfig_FieldMask{}
	res.Paths = append(res.Paths, &AzureSearchConfig_FieldTerminalPath{selector: AzureSearchConfig_FieldPathSelectorEndpoint})
	res.Paths = append(res.Paths, &AzureSearchConfig_FieldTerminalPath{selector: AzureSearchConfig_FieldPathSelectorIndex})
	res.Paths = append(res.Paths, &AzureSearchConfig_FieldTerminalPath{selector: AzureSearchConfig_FieldPathSelectorApiKey})
	res.Paths = append(res.Paths, &AzureSearchConfig_FieldTerminalPath{selector: AzureSearchConfig_FieldPathSelectorEnableSemantic})
	return res
}

func (fieldMask *AzureSearchConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *AzureSearchConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*AzureSearchConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *AzureSearchConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAzureSearchConfig_FieldPath(raw)
	})
}

func (fieldMask *AzureSearchConfig_FieldMask) ProtoMessage() {}

func (fieldMask *AzureSearchConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *AzureSearchConfig_FieldMask) Subtract(other *AzureSearchConfig_FieldMask) *AzureSearchConfig_FieldMask {
	result := &AzureSearchConfig_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *AzureSearchConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *AzureSearchConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*AzureSearchConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *AzureSearchConfig_FieldMask) FilterInputFields() *AzureSearchConfig_FieldMask {
	result := &AzureSearchConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *AzureSearchConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *AzureSearchConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]AzureSearchConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAzureSearchConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask AzureSearchConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *AzureSearchConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AzureSearchConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask AzureSearchConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *AzureSearchConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AzureSearchConfig_FieldMask) AppendPath(path AzureSearchConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *AzureSearchConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(AzureSearchConfig_FieldPath))
}

func (fieldMask *AzureSearchConfig_FieldMask) GetPaths() []AzureSearchConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *AzureSearchConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *AzureSearchConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAzureSearchConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *AzureSearchConfig_FieldMask) Set(target, source *AzureSearchConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *AzureSearchConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*AzureSearchConfig), source.(*AzureSearchConfig))
}

func (fieldMask *AzureSearchConfig_FieldMask) Project(source *AzureSearchConfig) *AzureSearchConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &AzureSearchConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *AzureSearchConfig_FieldTerminalPath:
			switch tp.selector {
			case AzureSearchConfig_FieldPathSelectorEndpoint:
				result.Endpoint = source.Endpoint
			case AzureSearchConfig_FieldPathSelectorIndex:
				result.Index = source.Index
			case AzureSearchConfig_FieldPathSelectorApiKey:
				result.ApiKey = source.ApiKey
			case AzureSearchConfig_FieldPathSelectorEnableSemantic:
				result.EnableSemantic = source.EnableSemantic
			}
		}
	}
	return result
}

func (fieldMask *AzureSearchConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*AzureSearchConfig))
}

func (fieldMask *AzureSearchConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type AnthropicConfig_FieldMask struct {
	Paths []AnthropicConfig_FieldPath
}

func FullAnthropicConfig_FieldMask() *AnthropicConfig_FieldMask {
	res := &AnthropicConfig_FieldMask{}
	return res
}

func (fieldMask *AnthropicConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *AnthropicConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*AnthropicConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *AnthropicConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAnthropicConfig_FieldPath(raw)
	})
}

func (fieldMask *AnthropicConfig_FieldMask) ProtoMessage() {}

func (fieldMask *AnthropicConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *AnthropicConfig_FieldMask) Subtract(other *AnthropicConfig_FieldMask) *AnthropicConfig_FieldMask {
	result := &AnthropicConfig_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *AnthropicConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *AnthropicConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*AnthropicConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *AnthropicConfig_FieldMask) FilterInputFields() *AnthropicConfig_FieldMask {
	result := &AnthropicConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *AnthropicConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *AnthropicConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]AnthropicConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAnthropicConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask AnthropicConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *AnthropicConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AnthropicConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask AnthropicConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *AnthropicConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AnthropicConfig_FieldMask) AppendPath(path AnthropicConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *AnthropicConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(AnthropicConfig_FieldPath))
}

func (fieldMask *AnthropicConfig_FieldMask) GetPaths() []AnthropicConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *AnthropicConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *AnthropicConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAnthropicConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *AnthropicConfig_FieldMask) Set(target, source *AnthropicConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *AnthropicConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*AnthropicConfig), source.(*AnthropicConfig))
}

func (fieldMask *AnthropicConfig_FieldMask) Project(source *AnthropicConfig) *AnthropicConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &AnthropicConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *AnthropicConfig_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *AnthropicConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*AnthropicConfig))
}

func (fieldMask *AnthropicConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type GeminiConfig_FieldMask struct {
	Paths []GeminiConfig_FieldPath
}

func FullGeminiConfig_FieldMask() *GeminiConfig_FieldMask {
	res := &GeminiConfig_FieldMask{}
	return res
}

func (fieldMask *GeminiConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *GeminiConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GeminiConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GeminiConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGeminiConfig_FieldPath(raw)
	})
}

func (fieldMask *GeminiConfig_FieldMask) ProtoMessage() {}

func (fieldMask *GeminiConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GeminiConfig_FieldMask) Subtract(other *GeminiConfig_FieldMask) *GeminiConfig_FieldMask {
	result := &GeminiConfig_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GeminiConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GeminiConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GeminiConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GeminiConfig_FieldMask) FilterInputFields() *GeminiConfig_FieldMask {
	result := &GeminiConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GeminiConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GeminiConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GeminiConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGeminiConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GeminiConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GeminiConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GeminiConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GeminiConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GeminiConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GeminiConfig_FieldMask) AppendPath(path GeminiConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GeminiConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GeminiConfig_FieldPath))
}

func (fieldMask *GeminiConfig_FieldMask) GetPaths() []GeminiConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GeminiConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GeminiConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGeminiConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GeminiConfig_FieldMask) Set(target, source *GeminiConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GeminiConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GeminiConfig), source.(*GeminiConfig))
}

func (fieldMask *GeminiConfig_FieldMask) Project(source *GeminiConfig) *GeminiConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GeminiConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GeminiConfig_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *GeminiConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GeminiConfig))
}

func (fieldMask *GeminiConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
