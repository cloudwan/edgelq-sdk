// Code generated by protoc-gen-goten-object
// File: edgelq/ai/proto/v1/capability_template.proto
// DO NOT EDIT!!!

package capability_template

import (
	"fmt"
	"sort"

	"google.golang.org/protobuf/proto"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	common_client "github.com/cloudwan/edgelq-sdk/ai/client/v1/common"
	chat_model "github.com/cloudwan/edgelq-sdk/ai/resources/v1/chat_model"
	connector "github.com/cloudwan/edgelq-sdk/ai/resources/v1/connector"
	search_index "github.com/cloudwan/edgelq-sdk/ai/resources/v1/search_index"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1/project"
	meta "github.com/cloudwan/goten-sdk/types/meta"
)

// ensure the imports are used
var (
	_ = new(fmt.Stringer)
	_ = new(sort.Interface)

	_ = new(proto.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &chat_model.ChatModel{}
	_ = &common_client.Message{}
	_ = &connector.Connector{}
	_ = &search_index.SearchIndex{}
	_ = &iam_project.ProjectFeatureConfig{}
	_ = &meta.Meta{}
)

func (o *CapabilityTemplate) GotenObjectExt() {}

func (o *CapabilityTemplate) MakeFullFieldMask() *CapabilityTemplate_FieldMask {
	return FullCapabilityTemplate_FieldMask()
}

func (o *CapabilityTemplate) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullCapabilityTemplate_FieldMask()
}

func (o *CapabilityTemplate) MakeDiffFieldMask(other *CapabilityTemplate) *CapabilityTemplate_FieldMask {
	if o == nil && other == nil {
		return &CapabilityTemplate_FieldMask{}
	}
	if o == nil || other == nil {
		return FullCapabilityTemplate_FieldMask()
	}

	res := &CapabilityTemplate_FieldMask{}
	if o.GetName().String() != other.GetName().String() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorName})
	}
	{
		subMask := o.GetMetadata().MakeDiffFieldMask(other.GetMetadata())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMetadata})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorMetadata, subPath: subpath})
			}
		}
	}
	if o.GetDescription() != other.GetDescription() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDescription})
	}

	if len(o.GetConnectors()) == len(other.GetConnectors()) {
		for i, lValue := range o.GetConnectors() {
			rValue := other.GetConnectors()[i]
			if lValue.String() != rValue.String() {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorConnectors})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorConnectors})
	}
	{
		subMask := o.GetRagConfig().MakeDiffFieldMask(other.GetRagConfig())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorRagConfig})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorRagConfig, subPath: subpath})
			}
		}
	}
	if o.GetDisplayName() != other.GetDisplayName() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDisplayName})
	}
	{
		subMask := o.GetReasoning().MakeDiffFieldMask(other.GetReasoning())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorReasoning})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorReasoning, subPath: subpath})
			}
		}
	}
	if o.GetMaxOutputTokens() != other.GetMaxOutputTokens() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMaxOutputTokens})
	}
	if o.GetSystemPrompt() != other.GetSystemPrompt() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorSystemPrompt})
	}
	{
		subMask := o.GetSystemPromptAppend().MakeDiffFieldMask(other.GetSystemPromptAppend())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorSystemPromptAppend})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorSystemPromptAppend, subPath: subpath})
			}
		}
	}
	if o.GetDisableInputTokenCache() != other.GetDisableInputTokenCache() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDisableInputTokenCache})
	}

	if len(o.GetAllowedModels()) == len(other.GetAllowedModels()) {
		for i, lValue := range o.GetAllowedModels() {
			rValue := other.GetAllowedModels()[i]
			if lValue.String() != rValue.String() {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorAllowedModels})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorAllowedModels})
	}
	{
		subMask := o.GetToolSafety().MakeDiffFieldMask(other.GetToolSafety())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorToolSafety})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorToolSafety, subPath: subpath})
			}
		}
	}
	if o.GetDefaultModel().String() != other.GetDefaultModel().String() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDefaultModel})
	}

	if len(o.GetUserPromptTemplates()) == len(other.GetUserPromptTemplates()) {
		for i, lValue := range o.GetUserPromptTemplates() {
			rValue := other.GetUserPromptTemplates()[i]
			if len(lValue.MakeDiffFieldMask(rValue).Paths) > 0 {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorUserPromptTemplates})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorUserPromptTemplates})
	}
	return res
}

func (o *CapabilityTemplate) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*CapabilityTemplate))
}

func (o *CapabilityTemplate) Clone() *CapabilityTemplate {
	if o == nil {
		return nil
	}
	result := &CapabilityTemplate{}
	if o.Name == nil {
		result.Name = nil
	} else if data, err := o.Name.ProtoString(); err != nil {
		panic(err)
	} else {
		result.Name = &Name{}
		if err := result.Name.ParseProtoString(data); err != nil {
			panic(err)
		}
	}
	result.Metadata = o.Metadata.Clone()
	result.Description = o.Description
	result.Connectors = make([]*connector.Reference, len(o.Connectors))
	for i, sourceValue := range o.Connectors {
		if sourceValue == nil {
			result.Connectors[i] = nil
		} else if data, err := sourceValue.ProtoString(); err != nil {
			panic(err)
		} else {
			result.Connectors[i] = &connector.Reference{}
			if err := result.Connectors[i].ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	}
	result.RagConfig = o.RagConfig.Clone()
	result.DisplayName = o.DisplayName
	result.Reasoning = o.Reasoning.Clone()
	result.MaxOutputTokens = o.MaxOutputTokens
	result.SystemPrompt = o.SystemPrompt
	result.SystemPromptAppend = o.SystemPromptAppend.Clone()
	result.DisableInputTokenCache = o.DisableInputTokenCache
	result.AllowedModels = make([]*chat_model.Reference, len(o.AllowedModels))
	for i, sourceValue := range o.AllowedModels {
		if sourceValue == nil {
			result.AllowedModels[i] = nil
		} else if data, err := sourceValue.ProtoString(); err != nil {
			panic(err)
		} else {
			result.AllowedModels[i] = &chat_model.Reference{}
			if err := result.AllowedModels[i].ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	}
	result.ToolSafety = o.ToolSafety.Clone()
	if o.DefaultModel == nil {
		result.DefaultModel = nil
	} else if data, err := o.DefaultModel.ProtoString(); err != nil {
		panic(err)
	} else {
		result.DefaultModel = &chat_model.Name{}
		if err := result.DefaultModel.ParseProtoString(data); err != nil {
			panic(err)
		}
	}
	result.UserPromptTemplates = make([]*UserPromptTemplate, len(o.UserPromptTemplates))
	for i, sourceValue := range o.UserPromptTemplates {
		result.UserPromptTemplates[i] = sourceValue.Clone()
	}
	return result
}

func (o *CapabilityTemplate) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *CapabilityTemplate) Merge(source *CapabilityTemplate) {
	if source.GetName() != nil {
		if data, err := source.GetName().ProtoString(); err != nil {
			panic(err)
		} else {
			o.Name = &Name{}
			if err := o.Name.ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	} else {
		o.Name = nil
	}
	if source.GetMetadata() != nil {
		if o.Metadata == nil {
			o.Metadata = new(meta.Meta)
		}
		o.Metadata.Merge(source.GetMetadata())
	}
	o.Description = source.GetDescription()
	for _, sourceValue := range source.GetConnectors() {
		exists := false
		for _, currentValue := range o.Connectors {
			leftProtoStr, _ := currentValue.ProtoString()
			rightProtoStr, _ := sourceValue.ProtoString()
			if leftProtoStr == rightProtoStr {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *connector.Reference
			if sourceValue != nil {
				if data, err := sourceValue.ProtoString(); err != nil {
					panic(err)
				} else {
					newDstElement = &connector.Reference{}
					if err := newDstElement.ParseProtoString(data); err != nil {
						panic(err)
					}
				}
			}
			o.Connectors = append(o.Connectors, newDstElement)
		}
	}

	if source.GetRagConfig() != nil {
		if o.RagConfig == nil {
			o.RagConfig = new(RAGConfig)
		}
		o.RagConfig.Merge(source.GetRagConfig())
	}
	o.DisplayName = source.GetDisplayName()
	if source.GetReasoning() != nil {
		if o.Reasoning == nil {
			o.Reasoning = new(ReasoningConfig)
		}
		o.Reasoning.Merge(source.GetReasoning())
	}
	o.MaxOutputTokens = source.GetMaxOutputTokens()
	o.SystemPrompt = source.GetSystemPrompt()
	if source.GetSystemPromptAppend() != nil {
		if o.SystemPromptAppend == nil {
			o.SystemPromptAppend = new(PromptAppendTemplate)
		}
		o.SystemPromptAppend.Merge(source.GetSystemPromptAppend())
	}
	o.DisableInputTokenCache = source.GetDisableInputTokenCache()
	for _, sourceValue := range source.GetAllowedModels() {
		exists := false
		for _, currentValue := range o.AllowedModels {
			leftProtoStr, _ := currentValue.ProtoString()
			rightProtoStr, _ := sourceValue.ProtoString()
			if leftProtoStr == rightProtoStr {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *chat_model.Reference
			if sourceValue != nil {
				if data, err := sourceValue.ProtoString(); err != nil {
					panic(err)
				} else {
					newDstElement = &chat_model.Reference{}
					if err := newDstElement.ParseProtoString(data); err != nil {
						panic(err)
					}
				}
			}
			o.AllowedModels = append(o.AllowedModels, newDstElement)
		}
	}

	if source.GetToolSafety() != nil {
		if o.ToolSafety == nil {
			o.ToolSafety = new(ToolSafetyConfig)
		}
		o.ToolSafety.Merge(source.GetToolSafety())
	}
	if source.GetDefaultModel() != nil {
		if data, err := source.GetDefaultModel().ProtoString(); err != nil {
			panic(err)
		} else {
			o.DefaultModel = &chat_model.Name{}
			if err := o.DefaultModel.ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	} else {
		o.DefaultModel = nil
	}
	for _, sourceValue := range source.GetUserPromptTemplates() {
		exists := false
		for _, currentValue := range o.UserPromptTemplates {
			if proto.Equal(sourceValue, currentValue) {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *UserPromptTemplate
			if sourceValue != nil {
				newDstElement = new(UserPromptTemplate)
				newDstElement.Merge(sourceValue)
			}
			o.UserPromptTemplates = append(o.UserPromptTemplates, newDstElement)
		}
	}

}

func (o *CapabilityTemplate) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*CapabilityTemplate))
}

func (o *PromptAppendTemplate) GotenObjectExt() {}

func (o *PromptAppendTemplate) MakeFullFieldMask() *PromptAppendTemplate_FieldMask {
	return FullPromptAppendTemplate_FieldMask()
}

func (o *PromptAppendTemplate) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullPromptAppendTemplate_FieldMask()
}

func (o *PromptAppendTemplate) MakeDiffFieldMask(other *PromptAppendTemplate) *PromptAppendTemplate_FieldMask {
	if o == nil && other == nil {
		return &PromptAppendTemplate_FieldMask{}
	}
	if o == nil || other == nil {
		return FullPromptAppendTemplate_FieldMask()
	}

	res := &PromptAppendTemplate_FieldMask{}
	if o.GetText() != other.GetText() {
		res.Paths = append(res.Paths, &PromptAppendTemplate_FieldTerminalPath{selector: PromptAppendTemplate_FieldPathSelectorText})
	}
	if o.GetMode() != other.GetMode() {
		res.Paths = append(res.Paths, &PromptAppendTemplate_FieldTerminalPath{selector: PromptAppendTemplate_FieldPathSelectorMode})
	}
	if o.GetOnMissing() != other.GetOnMissing() {
		res.Paths = append(res.Paths, &PromptAppendTemplate_FieldTerminalPath{selector: PromptAppendTemplate_FieldPathSelectorOnMissing})
	}
	return res
}

func (o *PromptAppendTemplate) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*PromptAppendTemplate))
}

func (o *PromptAppendTemplate) Clone() *PromptAppendTemplate {
	if o == nil {
		return nil
	}
	result := &PromptAppendTemplate{}
	result.Text = o.Text
	result.Mode = o.Mode
	result.OnMissing = o.OnMissing
	return result
}

func (o *PromptAppendTemplate) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *PromptAppendTemplate) Merge(source *PromptAppendTemplate) {
	o.Text = source.GetText()
	o.Mode = source.GetMode()
	o.OnMissing = source.GetOnMissing()
}

func (o *PromptAppendTemplate) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*PromptAppendTemplate))
}

func (o *RAGConfig) GotenObjectExt() {}

func (o *RAGConfig) MakeFullFieldMask() *RAGConfig_FieldMask {
	return FullRAGConfig_FieldMask()
}

func (o *RAGConfig) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullRAGConfig_FieldMask()
}

func (o *RAGConfig) MakeDiffFieldMask(other *RAGConfig) *RAGConfig_FieldMask {
	if o == nil && other == nil {
		return &RAGConfig_FieldMask{}
	}
	if o == nil || other == nil {
		return FullRAGConfig_FieldMask()
	}

	res := &RAGConfig_FieldMask{}

	if len(o.GetSearchIndices()) == len(other.GetSearchIndices()) {
		for i, lValue := range o.GetSearchIndices() {
			rValue := other.GetSearchIndices()[i]
			if lValue.String() != rValue.String() {
				res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorSearchIndices})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorSearchIndices})
	}
	{
		subMask := o.GetIndexingPolicy().MakeDiffFieldMask(other.GetIndexingPolicy())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorIndexingPolicy})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &RAGConfig_FieldSubPath{selector: RAGConfig_FieldPathSelectorIndexingPolicy, subPath: subpath})
			}
		}
	}
	{
		subMask := o.GetRetrievalLimits().MakeDiffFieldMask(other.GetRetrievalLimits())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorRetrievalLimits})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &RAGConfig_FieldSubPath{selector: RAGConfig_FieldPathSelectorRetrievalLimits, subPath: subpath})
			}
		}
	}
	if o.GetUseAzureNativeRag() != other.GetUseAzureNativeRag() {
		res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorUseAzureNativeRag})
	}
	return res
}

func (o *RAGConfig) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*RAGConfig))
}

func (o *RAGConfig) Clone() *RAGConfig {
	if o == nil {
		return nil
	}
	result := &RAGConfig{}
	result.SearchIndices = make([]*search_index.Reference, len(o.SearchIndices))
	for i, sourceValue := range o.SearchIndices {
		if sourceValue == nil {
			result.SearchIndices[i] = nil
		} else if data, err := sourceValue.ProtoString(); err != nil {
			panic(err)
		} else {
			result.SearchIndices[i] = &search_index.Reference{}
			if err := result.SearchIndices[i].ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	}
	result.IndexingPolicy = o.IndexingPolicy.Clone()
	result.RetrievalLimits = o.RetrievalLimits.Clone()
	result.UseAzureNativeRag = o.UseAzureNativeRag
	return result
}

func (o *RAGConfig) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *RAGConfig) Merge(source *RAGConfig) {
	for _, sourceValue := range source.GetSearchIndices() {
		exists := false
		for _, currentValue := range o.SearchIndices {
			leftProtoStr, _ := currentValue.ProtoString()
			rightProtoStr, _ := sourceValue.ProtoString()
			if leftProtoStr == rightProtoStr {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *search_index.Reference
			if sourceValue != nil {
				if data, err := sourceValue.ProtoString(); err != nil {
					panic(err)
				} else {
					newDstElement = &search_index.Reference{}
					if err := newDstElement.ParseProtoString(data); err != nil {
						panic(err)
					}
				}
			}
			o.SearchIndices = append(o.SearchIndices, newDstElement)
		}
	}

	if source.GetIndexingPolicy() != nil {
		if o.IndexingPolicy == nil {
			o.IndexingPolicy = new(IndexingPolicy)
		}
		o.IndexingPolicy.Merge(source.GetIndexingPolicy())
	}
	if source.GetRetrievalLimits() != nil {
		if o.RetrievalLimits == nil {
			o.RetrievalLimits = new(RetrievalLimits)
		}
		o.RetrievalLimits.Merge(source.GetRetrievalLimits())
	}
	o.UseAzureNativeRag = source.GetUseAzureNativeRag()
}

func (o *RAGConfig) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*RAGConfig))
}

func (o *IndexingPolicy) GotenObjectExt() {}

func (o *IndexingPolicy) MakeFullFieldMask() *IndexingPolicy_FieldMask {
	return FullIndexingPolicy_FieldMask()
}

func (o *IndexingPolicy) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullIndexingPolicy_FieldMask()
}

func (o *IndexingPolicy) MakeDiffFieldMask(other *IndexingPolicy) *IndexingPolicy_FieldMask {
	if o == nil && other == nil {
		return &IndexingPolicy_FieldMask{}
	}
	if o == nil || other == nil {
		return FullIndexingPolicy_FieldMask()
	}

	res := &IndexingPolicy_FieldMask{}
	if o.GetChunkSizeTokens() != other.GetChunkSizeTokens() {
		res.Paths = append(res.Paths, &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkSizeTokens})
	}
	if o.GetChunkOverlapTokens() != other.GetChunkOverlapTokens() {
		res.Paths = append(res.Paths, &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkOverlapTokens})
	}
	if o.GetEmbeddingModel() != other.GetEmbeddingModel() {
		res.Paths = append(res.Paths, &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorEmbeddingModel})
	}
	if o.GetChunkingStrategy() != other.GetChunkingStrategy() {
		res.Paths = append(res.Paths, &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkingStrategy})
	}
	return res
}

func (o *IndexingPolicy) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*IndexingPolicy))
}

func (o *IndexingPolicy) Clone() *IndexingPolicy {
	if o == nil {
		return nil
	}
	result := &IndexingPolicy{}
	result.ChunkSizeTokens = o.ChunkSizeTokens
	result.ChunkOverlapTokens = o.ChunkOverlapTokens
	result.EmbeddingModel = o.EmbeddingModel
	result.ChunkingStrategy = o.ChunkingStrategy
	return result
}

func (o *IndexingPolicy) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *IndexingPolicy) Merge(source *IndexingPolicy) {
	o.ChunkSizeTokens = source.GetChunkSizeTokens()
	o.ChunkOverlapTokens = source.GetChunkOverlapTokens()
	o.EmbeddingModel = source.GetEmbeddingModel()
	o.ChunkingStrategy = source.GetChunkingStrategy()
}

func (o *IndexingPolicy) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*IndexingPolicy))
}

func (o *RetrievalLimits) GotenObjectExt() {}

func (o *RetrievalLimits) MakeFullFieldMask() *RetrievalLimits_FieldMask {
	return FullRetrievalLimits_FieldMask()
}

func (o *RetrievalLimits) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullRetrievalLimits_FieldMask()
}

func (o *RetrievalLimits) MakeDiffFieldMask(other *RetrievalLimits) *RetrievalLimits_FieldMask {
	if o == nil && other == nil {
		return &RetrievalLimits_FieldMask{}
	}
	if o == nil || other == nil {
		return FullRetrievalLimits_FieldMask()
	}

	res := &RetrievalLimits_FieldMask{}
	if o.GetMaxDocuments() != other.GetMaxDocuments() {
		res.Paths = append(res.Paths, &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMaxDocuments})
	}
	if o.GetMaxContextTokens() != other.GetMaxContextTokens() {
		res.Paths = append(res.Paths, &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMaxContextTokens})
	}
	if o.GetMinRelevanceScore() != other.GetMinRelevanceScore() {
		res.Paths = append(res.Paths, &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMinRelevanceScore})
	}
	if o.GetRequireCitations() != other.GetRequireCitations() {
		res.Paths = append(res.Paths, &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorRequireCitations})
	}
	return res
}

func (o *RetrievalLimits) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*RetrievalLimits))
}

func (o *RetrievalLimits) Clone() *RetrievalLimits {
	if o == nil {
		return nil
	}
	result := &RetrievalLimits{}
	result.MaxDocuments = o.MaxDocuments
	result.MaxContextTokens = o.MaxContextTokens
	result.MinRelevanceScore = o.MinRelevanceScore
	result.RequireCitations = o.RequireCitations
	return result
}

func (o *RetrievalLimits) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *RetrievalLimits) Merge(source *RetrievalLimits) {
	o.MaxDocuments = source.GetMaxDocuments()
	o.MaxContextTokens = source.GetMaxContextTokens()
	o.MinRelevanceScore = source.GetMinRelevanceScore()
	o.RequireCitations = source.GetRequireCitations()
}

func (o *RetrievalLimits) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*RetrievalLimits))
}

func (o *ReasoningConfig) GotenObjectExt() {}

func (o *ReasoningConfig) MakeFullFieldMask() *ReasoningConfig_FieldMask {
	return FullReasoningConfig_FieldMask()
}

func (o *ReasoningConfig) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullReasoningConfig_FieldMask()
}

func (o *ReasoningConfig) MakeDiffFieldMask(other *ReasoningConfig) *ReasoningConfig_FieldMask {
	if o == nil && other == nil {
		return &ReasoningConfig_FieldMask{}
	}
	if o == nil || other == nil {
		return FullReasoningConfig_FieldMask()
	}

	res := &ReasoningConfig_FieldMask{}
	if o.GetMaxLevel() != other.GetMaxLevel() {
		res.Paths = append(res.Paths, &ReasoningConfig_FieldTerminalPath{selector: ReasoningConfig_FieldPathSelectorMaxLevel})
	}
	if o.GetDefaultLevel() != other.GetDefaultLevel() {
		res.Paths = append(res.Paths, &ReasoningConfig_FieldTerminalPath{selector: ReasoningConfig_FieldPathSelectorDefaultLevel})
	}
	return res
}

func (o *ReasoningConfig) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*ReasoningConfig))
}

func (o *ReasoningConfig) Clone() *ReasoningConfig {
	if o == nil {
		return nil
	}
	result := &ReasoningConfig{}
	result.MaxLevel = o.MaxLevel
	result.DefaultLevel = o.DefaultLevel
	return result
}

func (o *ReasoningConfig) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *ReasoningConfig) Merge(source *ReasoningConfig) {
	o.MaxLevel = source.GetMaxLevel()
	o.DefaultLevel = source.GetDefaultLevel()
}

func (o *ReasoningConfig) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*ReasoningConfig))
}

func (o *ToolSafetyConfig) GotenObjectExt() {}

func (o *ToolSafetyConfig) MakeFullFieldMask() *ToolSafetyConfig_FieldMask {
	return FullToolSafetyConfig_FieldMask()
}

func (o *ToolSafetyConfig) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullToolSafetyConfig_FieldMask()
}

func (o *ToolSafetyConfig) MakeDiffFieldMask(other *ToolSafetyConfig) *ToolSafetyConfig_FieldMask {
	if o == nil && other == nil {
		return &ToolSafetyConfig_FieldMask{}
	}
	if o == nil || other == nil {
		return FullToolSafetyConfig_FieldMask()
	}

	res := &ToolSafetyConfig_FieldMask{}
	if o.GetMaxConsecutiveToolCalls() != other.GetMaxConsecutiveToolCalls() {
		res.Paths = append(res.Paths, &ToolSafetyConfig_FieldTerminalPath{selector: ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls})
	}
	if o.GetMaxConsecutiveIdenticalToolCalls() != other.GetMaxConsecutiveIdenticalToolCalls() {
		res.Paths = append(res.Paths, &ToolSafetyConfig_FieldTerminalPath{selector: ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls})
	}
	if o.GetMaxConsecutiveSameToolCalls() != other.GetMaxConsecutiveSameToolCalls() {
		res.Paths = append(res.Paths, &ToolSafetyConfig_FieldTerminalPath{selector: ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls})
	}
	return res
}

func (o *ToolSafetyConfig) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*ToolSafetyConfig))
}

func (o *ToolSafetyConfig) Clone() *ToolSafetyConfig {
	if o == nil {
		return nil
	}
	result := &ToolSafetyConfig{}
	result.MaxConsecutiveToolCalls = o.MaxConsecutiveToolCalls
	result.MaxConsecutiveIdenticalToolCalls = o.MaxConsecutiveIdenticalToolCalls
	result.MaxConsecutiveSameToolCalls = o.MaxConsecutiveSameToolCalls
	return result
}

func (o *ToolSafetyConfig) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *ToolSafetyConfig) Merge(source *ToolSafetyConfig) {
	o.MaxConsecutiveToolCalls = source.GetMaxConsecutiveToolCalls()
	o.MaxConsecutiveIdenticalToolCalls = source.GetMaxConsecutiveIdenticalToolCalls()
	o.MaxConsecutiveSameToolCalls = source.GetMaxConsecutiveSameToolCalls()
}

func (o *ToolSafetyConfig) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*ToolSafetyConfig))
}

func (o *UserPromptTemplate) GotenObjectExt() {}

func (o *UserPromptTemplate) MakeFullFieldMask() *UserPromptTemplate_FieldMask {
	return FullUserPromptTemplate_FieldMask()
}

func (o *UserPromptTemplate) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullUserPromptTemplate_FieldMask()
}

func (o *UserPromptTemplate) MakeDiffFieldMask(other *UserPromptTemplate) *UserPromptTemplate_FieldMask {
	if o == nil && other == nil {
		return &UserPromptTemplate_FieldMask{}
	}
	if o == nil || other == nil {
		return FullUserPromptTemplate_FieldMask()
	}

	res := &UserPromptTemplate_FieldMask{}
	if o.GetDisplayName() != other.GetDisplayName() {
		res.Paths = append(res.Paths, &UserPromptTemplate_FieldTerminalPath{selector: UserPromptTemplate_FieldPathSelectorDisplayName})
	}
	if o.GetDescription() != other.GetDescription() {
		res.Paths = append(res.Paths, &UserPromptTemplate_FieldTerminalPath{selector: UserPromptTemplate_FieldPathSelectorDescription})
	}

	if len(o.GetTags()) == len(other.GetTags()) {
		for i, lValue := range o.GetTags() {
			rValue := other.GetTags()[i]
			if lValue != rValue {
				res.Paths = append(res.Paths, &UserPromptTemplate_FieldTerminalPath{selector: UserPromptTemplate_FieldPathSelectorTags})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &UserPromptTemplate_FieldTerminalPath{selector: UserPromptTemplate_FieldPathSelectorTags})
	}
	if o.GetTemplateText() != other.GetTemplateText() {
		res.Paths = append(res.Paths, &UserPromptTemplate_FieldTerminalPath{selector: UserPromptTemplate_FieldPathSelectorTemplateText})
	}

	if len(o.GetVariables()) == len(other.GetVariables()) {
		for i, lValue := range o.GetVariables() {
			rValue := other.GetVariables()[i]
			if len(lValue.MakeDiffFieldMask(rValue).Paths) > 0 {
				res.Paths = append(res.Paths, &UserPromptTemplate_FieldTerminalPath{selector: UserPromptTemplate_FieldPathSelectorVariables})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &UserPromptTemplate_FieldTerminalPath{selector: UserPromptTemplate_FieldPathSelectorVariables})
	}
	return res
}

func (o *UserPromptTemplate) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*UserPromptTemplate))
}

func (o *UserPromptTemplate) Clone() *UserPromptTemplate {
	if o == nil {
		return nil
	}
	result := &UserPromptTemplate{}
	result.DisplayName = o.DisplayName
	result.Description = o.Description
	result.Tags = make([]string, len(o.Tags))
	for i, sourceValue := range o.Tags {
		result.Tags[i] = sourceValue
	}
	result.TemplateText = o.TemplateText
	result.Variables = map[string]*TemplateVariable{}
	for key, sourceValue := range o.Variables {
		result.Variables[key] = sourceValue.Clone()
	}
	return result
}

func (o *UserPromptTemplate) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *UserPromptTemplate) Merge(source *UserPromptTemplate) {
	o.DisplayName = source.GetDisplayName()
	o.Description = source.GetDescription()
	for _, sourceValue := range source.GetTags() {
		exists := false
		for _, currentValue := range o.Tags {
			if currentValue == sourceValue {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement string
			newDstElement = sourceValue
			o.Tags = append(o.Tags, newDstElement)
		}
	}

	o.TemplateText = source.GetTemplateText()
	if source.GetVariables() != nil {
		if o.Variables == nil {
			o.Variables = make(map[string]*TemplateVariable, len(source.GetVariables()))
		}
		for key, sourceValue := range source.GetVariables() {
			if sourceValue != nil {
				if o.Variables[key] == nil {
					o.Variables[key] = new(TemplateVariable)
				}
				o.Variables[key].Merge(sourceValue)
			}
		}
	}
}

func (o *UserPromptTemplate) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*UserPromptTemplate))
}

func (o *TemplateVariable) GotenObjectExt() {}

func (o *TemplateVariable) MakeFullFieldMask() *TemplateVariable_FieldMask {
	return FullTemplateVariable_FieldMask()
}

func (o *TemplateVariable) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullTemplateVariable_FieldMask()
}

func (o *TemplateVariable) MakeDiffFieldMask(other *TemplateVariable) *TemplateVariable_FieldMask {
	if o == nil && other == nil {
		return &TemplateVariable_FieldMask{}
	}
	if o == nil || other == nil {
		return FullTemplateVariable_FieldMask()
	}

	res := &TemplateVariable_FieldMask{}
	if o.GetLabel() != other.GetLabel() {
		res.Paths = append(res.Paths, &TemplateVariable_FieldTerminalPath{selector: TemplateVariable_FieldPathSelectorLabel})
	}
	if o.GetHelpText() != other.GetHelpText() {
		res.Paths = append(res.Paths, &TemplateVariable_FieldTerminalPath{selector: TemplateVariable_FieldPathSelectorHelpText})
	}
	if o.GetInputType() != other.GetInputType() {
		res.Paths = append(res.Paths, &TemplateVariable_FieldTerminalPath{selector: TemplateVariable_FieldPathSelectorInputType})
	}

	if len(o.GetSuggestions()) == len(other.GetSuggestions()) {
		for i, lValue := range o.GetSuggestions() {
			rValue := other.GetSuggestions()[i]
			if lValue != rValue {
				res.Paths = append(res.Paths, &TemplateVariable_FieldTerminalPath{selector: TemplateVariable_FieldPathSelectorSuggestions})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &TemplateVariable_FieldTerminalPath{selector: TemplateVariable_FieldPathSelectorSuggestions})
	}
	if o.GetDefaultValue() != other.GetDefaultValue() {
		res.Paths = append(res.Paths, &TemplateVariable_FieldTerminalPath{selector: TemplateVariable_FieldPathSelectorDefaultValue})
	}
	if o.GetResourceType() != other.GetResourceType() {
		res.Paths = append(res.Paths, &TemplateVariable_FieldTerminalPath{selector: TemplateVariable_FieldPathSelectorResourceType})
	}
	return res
}

func (o *TemplateVariable) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*TemplateVariable))
}

func (o *TemplateVariable) Clone() *TemplateVariable {
	if o == nil {
		return nil
	}
	result := &TemplateVariable{}
	result.Label = o.Label
	result.HelpText = o.HelpText
	result.InputType = o.InputType
	result.Suggestions = make([]string, len(o.Suggestions))
	for i, sourceValue := range o.Suggestions {
		result.Suggestions[i] = sourceValue
	}
	result.DefaultValue = o.DefaultValue
	result.ResourceType = o.ResourceType
	return result
}

func (o *TemplateVariable) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *TemplateVariable) Merge(source *TemplateVariable) {
	o.Label = source.GetLabel()
	o.HelpText = source.GetHelpText()
	o.InputType = source.GetInputType()
	for _, sourceValue := range source.GetSuggestions() {
		exists := false
		for _, currentValue := range o.Suggestions {
			if currentValue == sourceValue {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement string
			newDstElement = sourceValue
			o.Suggestions = append(o.Suggestions, newDstElement)
		}
	}

	o.DefaultValue = source.GetDefaultValue()
	o.ResourceType = source.GetResourceType()
}

func (o *TemplateVariable) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*TemplateVariable))
}
