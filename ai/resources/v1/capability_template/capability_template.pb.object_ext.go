// Code generated by protoc-gen-goten-object
// File: edgelq/ai/proto/v1/capability_template.proto
// DO NOT EDIT!!!

package capability_template

import (
	"fmt"
	"sort"

	"google.golang.org/protobuf/proto"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	common_client "github.com/cloudwan/edgelq-sdk/ai/client/v1/common"
	chat_model "github.com/cloudwan/edgelq-sdk/ai/resources/v1/chat_model"
	connector "github.com/cloudwan/edgelq-sdk/ai/resources/v1/connector"
	search_index "github.com/cloudwan/edgelq-sdk/ai/resources/v1/search_index"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1/project"
	meta "github.com/cloudwan/goten-sdk/types/meta"
)

// ensure the imports are used
var (
	_ = new(fmt.Stringer)
	_ = new(sort.Interface)

	_ = new(proto.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &chat_model.ChatModel{}
	_ = &common_client.Message{}
	_ = &connector.Connector{}
	_ = &search_index.SearchIndex{}
	_ = &iam_project.Project{}
	_ = &meta.Meta{}
)

func (o *CapabilityTemplate) GotenObjectExt() {}

func (o *CapabilityTemplate) MakeFullFieldMask() *CapabilityTemplate_FieldMask {
	return FullCapabilityTemplate_FieldMask()
}

func (o *CapabilityTemplate) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullCapabilityTemplate_FieldMask()
}

func (o *CapabilityTemplate) MakeDiffFieldMask(other *CapabilityTemplate) *CapabilityTemplate_FieldMask {
	if o == nil && other == nil {
		return &CapabilityTemplate_FieldMask{}
	}
	if o == nil || other == nil {
		return FullCapabilityTemplate_FieldMask()
	}

	res := &CapabilityTemplate_FieldMask{}
	if o.GetName().String() != other.GetName().String() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorName})
	}
	{
		subMask := o.GetMetadata().MakeDiffFieldMask(other.GetMetadata())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMetadata})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorMetadata, subPath: subpath})
			}
		}
	}
	if o.GetDescription() != other.GetDescription() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDescription})
	}

	if len(o.GetConnectors()) == len(other.GetConnectors()) {
		for i, lValue := range o.GetConnectors() {
			rValue := other.GetConnectors()[i]
			if lValue.String() != rValue.String() {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorConnectors})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorConnectors})
	}
	{
		subMask := o.GetRagConfig().MakeDiffFieldMask(other.GetRagConfig())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorRagConfig})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorRagConfig, subPath: subpath})
			}
		}
	}
	if o.GetMaxToolRounds() != other.GetMaxToolRounds() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMaxToolRounds})
	}
	if o.GetDefaultModel() != other.GetDefaultModel() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDefaultModel})
	}
	if o.GetDisplayName() != other.GetDisplayName() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDisplayName})
	}
	{
		subMask := o.GetReasoning().MakeDiffFieldMask(other.GetReasoning())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorReasoning})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorReasoning, subPath: subpath})
			}
		}
	}
	if o.GetMaxOutputTokens() != other.GetMaxOutputTokens() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMaxOutputTokens})
	}
	if o.GetSystemPrompt() != other.GetSystemPrompt() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorSystemPrompt})
	}
	if o.GetDisableInputTokenCache() != other.GetDisableInputTokenCache() {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDisableInputTokenCache})
	}

	if len(o.GetAllowedModels()) == len(other.GetAllowedModels()) {
		for i, lValue := range o.GetAllowedModels() {
			rValue := other.GetAllowedModels()[i]
			if lValue.String() != rValue.String() {
				res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorAllowedModels})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorAllowedModels})
	}
	return res
}

func (o *CapabilityTemplate) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*CapabilityTemplate))
}

func (o *CapabilityTemplate) Clone() *CapabilityTemplate {
	if o == nil {
		return nil
	}
	result := &CapabilityTemplate{}
	if o.Name == nil {
		result.Name = nil
	} else if data, err := o.Name.ProtoString(); err != nil {
		panic(err)
	} else {
		result.Name = &Name{}
		if err := result.Name.ParseProtoString(data); err != nil {
			panic(err)
		}
	}
	result.Metadata = o.Metadata.Clone()
	result.Description = o.Description
	result.Connectors = make([]*connector.Reference, len(o.Connectors))
	for i, sourceValue := range o.Connectors {
		if sourceValue == nil {
			result.Connectors[i] = nil
		} else if data, err := sourceValue.ProtoString(); err != nil {
			panic(err)
		} else {
			result.Connectors[i] = &connector.Reference{}
			if err := result.Connectors[i].ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	}
	result.RagConfig = o.RagConfig.Clone()
	result.MaxToolRounds = o.MaxToolRounds
	result.DefaultModel = o.DefaultModel
	result.DisplayName = o.DisplayName
	result.Reasoning = o.Reasoning.Clone()
	result.MaxOutputTokens = o.MaxOutputTokens
	result.SystemPrompt = o.SystemPrompt
	result.DisableInputTokenCache = o.DisableInputTokenCache
	result.AllowedModels = make([]*chat_model.Reference, len(o.AllowedModels))
	for i, sourceValue := range o.AllowedModels {
		if sourceValue == nil {
			result.AllowedModels[i] = nil
		} else if data, err := sourceValue.ProtoString(); err != nil {
			panic(err)
		} else {
			result.AllowedModels[i] = &chat_model.Reference{}
			if err := result.AllowedModels[i].ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	}
	return result
}

func (o *CapabilityTemplate) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *CapabilityTemplate) Merge(source *CapabilityTemplate) {
	if source.GetName() != nil {
		if data, err := source.GetName().ProtoString(); err != nil {
			panic(err)
		} else {
			o.Name = &Name{}
			if err := o.Name.ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	} else {
		o.Name = nil
	}
	if source.GetMetadata() != nil {
		if o.Metadata == nil {
			o.Metadata = new(meta.Meta)
		}
		o.Metadata.Merge(source.GetMetadata())
	}
	o.Description = source.GetDescription()
	for _, sourceValue := range source.GetConnectors() {
		exists := false
		for _, currentValue := range o.Connectors {
			leftProtoStr, _ := currentValue.ProtoString()
			rightProtoStr, _ := sourceValue.ProtoString()
			if leftProtoStr == rightProtoStr {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *connector.Reference
			if sourceValue != nil {
				if data, err := sourceValue.ProtoString(); err != nil {
					panic(err)
				} else {
					newDstElement = &connector.Reference{}
					if err := newDstElement.ParseProtoString(data); err != nil {
						panic(err)
					}
				}
			}
			o.Connectors = append(o.Connectors, newDstElement)
		}
	}

	if source.GetRagConfig() != nil {
		if o.RagConfig == nil {
			o.RagConfig = new(RAGConfig)
		}
		o.RagConfig.Merge(source.GetRagConfig())
	}
	o.MaxToolRounds = source.GetMaxToolRounds()
	o.DefaultModel = source.GetDefaultModel()
	o.DisplayName = source.GetDisplayName()
	if source.GetReasoning() != nil {
		if o.Reasoning == nil {
			o.Reasoning = new(ReasoningConfig)
		}
		o.Reasoning.Merge(source.GetReasoning())
	}
	o.MaxOutputTokens = source.GetMaxOutputTokens()
	o.SystemPrompt = source.GetSystemPrompt()
	o.DisableInputTokenCache = source.GetDisableInputTokenCache()
	for _, sourceValue := range source.GetAllowedModels() {
		exists := false
		for _, currentValue := range o.AllowedModels {
			leftProtoStr, _ := currentValue.ProtoString()
			rightProtoStr, _ := sourceValue.ProtoString()
			if leftProtoStr == rightProtoStr {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *chat_model.Reference
			if sourceValue != nil {
				if data, err := sourceValue.ProtoString(); err != nil {
					panic(err)
				} else {
					newDstElement = &chat_model.Reference{}
					if err := newDstElement.ParseProtoString(data); err != nil {
						panic(err)
					}
				}
			}
			o.AllowedModels = append(o.AllowedModels, newDstElement)
		}
	}

}

func (o *CapabilityTemplate) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*CapabilityTemplate))
}

func (o *RAGConfig) GotenObjectExt() {}

func (o *RAGConfig) MakeFullFieldMask() *RAGConfig_FieldMask {
	return FullRAGConfig_FieldMask()
}

func (o *RAGConfig) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullRAGConfig_FieldMask()
}

func (o *RAGConfig) MakeDiffFieldMask(other *RAGConfig) *RAGConfig_FieldMask {
	if o == nil && other == nil {
		return &RAGConfig_FieldMask{}
	}
	if o == nil || other == nil {
		return FullRAGConfig_FieldMask()
	}

	res := &RAGConfig_FieldMask{}

	if len(o.GetSearchIndices()) == len(other.GetSearchIndices()) {
		for i, lValue := range o.GetSearchIndices() {
			rValue := other.GetSearchIndices()[i]
			if lValue.String() != rValue.String() {
				res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorSearchIndices})
				break
			}
		}
	} else {
		res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorSearchIndices})
	}
	{
		subMask := o.GetIndexingPolicy().MakeDiffFieldMask(other.GetIndexingPolicy())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorIndexingPolicy})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &RAGConfig_FieldSubPath{selector: RAGConfig_FieldPathSelectorIndexingPolicy, subPath: subpath})
			}
		}
	}
	{
		subMask := o.GetRetrievalLimits().MakeDiffFieldMask(other.GetRetrievalLimits())
		if subMask.IsFull() {
			res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorRetrievalLimits})
		} else {
			for _, subpath := range subMask.Paths {
				res.Paths = append(res.Paths, &RAGConfig_FieldSubPath{selector: RAGConfig_FieldPathSelectorRetrievalLimits, subPath: subpath})
			}
		}
	}
	if o.GetUseAzureNativeRag() != other.GetUseAzureNativeRag() {
		res.Paths = append(res.Paths, &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorUseAzureNativeRag})
	}
	return res
}

func (o *RAGConfig) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*RAGConfig))
}

func (o *RAGConfig) Clone() *RAGConfig {
	if o == nil {
		return nil
	}
	result := &RAGConfig{}
	result.SearchIndices = make([]*search_index.Reference, len(o.SearchIndices))
	for i, sourceValue := range o.SearchIndices {
		if sourceValue == nil {
			result.SearchIndices[i] = nil
		} else if data, err := sourceValue.ProtoString(); err != nil {
			panic(err)
		} else {
			result.SearchIndices[i] = &search_index.Reference{}
			if err := result.SearchIndices[i].ParseProtoString(data); err != nil {
				panic(err)
			}
		}
	}
	result.IndexingPolicy = o.IndexingPolicy.Clone()
	result.RetrievalLimits = o.RetrievalLimits.Clone()
	result.UseAzureNativeRag = o.UseAzureNativeRag
	return result
}

func (o *RAGConfig) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *RAGConfig) Merge(source *RAGConfig) {
	for _, sourceValue := range source.GetSearchIndices() {
		exists := false
		for _, currentValue := range o.SearchIndices {
			leftProtoStr, _ := currentValue.ProtoString()
			rightProtoStr, _ := sourceValue.ProtoString()
			if leftProtoStr == rightProtoStr {
				exists = true
				break
			}
		}
		if !exists {
			var newDstElement *search_index.Reference
			if sourceValue != nil {
				if data, err := sourceValue.ProtoString(); err != nil {
					panic(err)
				} else {
					newDstElement = &search_index.Reference{}
					if err := newDstElement.ParseProtoString(data); err != nil {
						panic(err)
					}
				}
			}
			o.SearchIndices = append(o.SearchIndices, newDstElement)
		}
	}

	if source.GetIndexingPolicy() != nil {
		if o.IndexingPolicy == nil {
			o.IndexingPolicy = new(IndexingPolicy)
		}
		o.IndexingPolicy.Merge(source.GetIndexingPolicy())
	}
	if source.GetRetrievalLimits() != nil {
		if o.RetrievalLimits == nil {
			o.RetrievalLimits = new(RetrievalLimits)
		}
		o.RetrievalLimits.Merge(source.GetRetrievalLimits())
	}
	o.UseAzureNativeRag = source.GetUseAzureNativeRag()
}

func (o *RAGConfig) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*RAGConfig))
}

func (o *IndexingPolicy) GotenObjectExt() {}

func (o *IndexingPolicy) MakeFullFieldMask() *IndexingPolicy_FieldMask {
	return FullIndexingPolicy_FieldMask()
}

func (o *IndexingPolicy) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullIndexingPolicy_FieldMask()
}

func (o *IndexingPolicy) MakeDiffFieldMask(other *IndexingPolicy) *IndexingPolicy_FieldMask {
	if o == nil && other == nil {
		return &IndexingPolicy_FieldMask{}
	}
	if o == nil || other == nil {
		return FullIndexingPolicy_FieldMask()
	}

	res := &IndexingPolicy_FieldMask{}
	if o.GetChunkSizeTokens() != other.GetChunkSizeTokens() {
		res.Paths = append(res.Paths, &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkSizeTokens})
	}
	if o.GetChunkOverlapTokens() != other.GetChunkOverlapTokens() {
		res.Paths = append(res.Paths, &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkOverlapTokens})
	}
	if o.GetEmbeddingModel() != other.GetEmbeddingModel() {
		res.Paths = append(res.Paths, &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorEmbeddingModel})
	}
	if o.GetChunkingStrategy() != other.GetChunkingStrategy() {
		res.Paths = append(res.Paths, &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkingStrategy})
	}
	return res
}

func (o *IndexingPolicy) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*IndexingPolicy))
}

func (o *IndexingPolicy) Clone() *IndexingPolicy {
	if o == nil {
		return nil
	}
	result := &IndexingPolicy{}
	result.ChunkSizeTokens = o.ChunkSizeTokens
	result.ChunkOverlapTokens = o.ChunkOverlapTokens
	result.EmbeddingModel = o.EmbeddingModel
	result.ChunkingStrategy = o.ChunkingStrategy
	return result
}

func (o *IndexingPolicy) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *IndexingPolicy) Merge(source *IndexingPolicy) {
	o.ChunkSizeTokens = source.GetChunkSizeTokens()
	o.ChunkOverlapTokens = source.GetChunkOverlapTokens()
	o.EmbeddingModel = source.GetEmbeddingModel()
	o.ChunkingStrategy = source.GetChunkingStrategy()
}

func (o *IndexingPolicy) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*IndexingPolicy))
}

func (o *RetrievalLimits) GotenObjectExt() {}

func (o *RetrievalLimits) MakeFullFieldMask() *RetrievalLimits_FieldMask {
	return FullRetrievalLimits_FieldMask()
}

func (o *RetrievalLimits) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullRetrievalLimits_FieldMask()
}

func (o *RetrievalLimits) MakeDiffFieldMask(other *RetrievalLimits) *RetrievalLimits_FieldMask {
	if o == nil && other == nil {
		return &RetrievalLimits_FieldMask{}
	}
	if o == nil || other == nil {
		return FullRetrievalLimits_FieldMask()
	}

	res := &RetrievalLimits_FieldMask{}
	if o.GetMaxDocuments() != other.GetMaxDocuments() {
		res.Paths = append(res.Paths, &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMaxDocuments})
	}
	if o.GetMaxContextTokens() != other.GetMaxContextTokens() {
		res.Paths = append(res.Paths, &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMaxContextTokens})
	}
	if o.GetMinRelevanceScore() != other.GetMinRelevanceScore() {
		res.Paths = append(res.Paths, &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMinRelevanceScore})
	}
	if o.GetRequireCitations() != other.GetRequireCitations() {
		res.Paths = append(res.Paths, &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorRequireCitations})
	}
	return res
}

func (o *RetrievalLimits) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*RetrievalLimits))
}

func (o *RetrievalLimits) Clone() *RetrievalLimits {
	if o == nil {
		return nil
	}
	result := &RetrievalLimits{}
	result.MaxDocuments = o.MaxDocuments
	result.MaxContextTokens = o.MaxContextTokens
	result.MinRelevanceScore = o.MinRelevanceScore
	result.RequireCitations = o.RequireCitations
	return result
}

func (o *RetrievalLimits) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *RetrievalLimits) Merge(source *RetrievalLimits) {
	o.MaxDocuments = source.GetMaxDocuments()
	o.MaxContextTokens = source.GetMaxContextTokens()
	o.MinRelevanceScore = source.GetMinRelevanceScore()
	o.RequireCitations = source.GetRequireCitations()
}

func (o *RetrievalLimits) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*RetrievalLimits))
}

func (o *ReasoningConfig) GotenObjectExt() {}

func (o *ReasoningConfig) MakeFullFieldMask() *ReasoningConfig_FieldMask {
	return FullReasoningConfig_FieldMask()
}

func (o *ReasoningConfig) MakeRawFullFieldMask() gotenobject.FieldMask {
	return FullReasoningConfig_FieldMask()
}

func (o *ReasoningConfig) MakeDiffFieldMask(other *ReasoningConfig) *ReasoningConfig_FieldMask {
	if o == nil && other == nil {
		return &ReasoningConfig_FieldMask{}
	}
	if o == nil || other == nil {
		return FullReasoningConfig_FieldMask()
	}

	res := &ReasoningConfig_FieldMask{}
	if o.GetMaxLevel() != other.GetMaxLevel() {
		res.Paths = append(res.Paths, &ReasoningConfig_FieldTerminalPath{selector: ReasoningConfig_FieldPathSelectorMaxLevel})
	}
	if o.GetDefaultLevel() != other.GetDefaultLevel() {
		res.Paths = append(res.Paths, &ReasoningConfig_FieldTerminalPath{selector: ReasoningConfig_FieldPathSelectorDefaultLevel})
	}
	return res
}

func (o *ReasoningConfig) MakeRawDiffFieldMask(other gotenobject.GotenObjectExt) gotenobject.FieldMask {
	return o.MakeDiffFieldMask(other.(*ReasoningConfig))
}

func (o *ReasoningConfig) Clone() *ReasoningConfig {
	if o == nil {
		return nil
	}
	result := &ReasoningConfig{}
	result.MaxLevel = o.MaxLevel
	result.DefaultLevel = o.DefaultLevel
	return result
}

func (o *ReasoningConfig) CloneRaw() gotenobject.GotenObjectExt {
	return o.Clone()
}

func (o *ReasoningConfig) Merge(source *ReasoningConfig) {
	o.MaxLevel = source.GetMaxLevel()
	o.DefaultLevel = source.GetDefaultLevel()
}

func (o *ReasoningConfig) MergeRaw(source gotenobject.GotenObjectExt) {
	o.Merge(source.(*ReasoningConfig))
}
