// Code generated by protoc-gen-goten-object
// File: edgelq/ai/proto/v1/capability_template.proto
// DO NOT EDIT!!!

package capability_template

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
	"github.com/cloudwan/goten-sdk/runtime/strcase"
)

// proto imports
import (
	connector "github.com/cloudwan/edgelq-sdk/ai/resources/v1/connector"
	search_db "github.com/cloudwan/edgelq-sdk/ai/resources/v1/search_db"
	search_index "github.com/cloudwan/edgelq-sdk/ai/resources/v1/search_index"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1/project"
	meta "github.com/cloudwan/goten-sdk/types/meta"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &connector.Connector{}
	_ = &search_db.SearchDb{}
	_ = &search_index.SearchIndex{}
	_ = &iam_project.Project{}
	_ = &meta.Meta{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type CapabilityTemplate_FieldPath interface {
	gotenobject.FieldPath
	Selector() CapabilityTemplate_FieldPathSelector
	Get(source *CapabilityTemplate) []interface{}
	GetSingle(source *CapabilityTemplate) (interface{}, bool)
	ClearValue(item *CapabilityTemplate)

	// Those methods build corresponding CapabilityTemplate_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) CapabilityTemplate_FieldPathValue
	WithIArrayOfValues(values interface{}) CapabilityTemplate_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) CapabilityTemplate_FieldPathArrayItemValue
}

type CapabilityTemplate_FieldPathSelector int32

const (
	CapabilityTemplate_FieldPathSelectorName          CapabilityTemplate_FieldPathSelector = 0
	CapabilityTemplate_FieldPathSelectorMetadata      CapabilityTemplate_FieldPathSelector = 1
	CapabilityTemplate_FieldPathSelectorDescription   CapabilityTemplate_FieldPathSelector = 2
	CapabilityTemplate_FieldPathSelectorConnectors    CapabilityTemplate_FieldPathSelector = 3
	CapabilityTemplate_FieldPathSelectorRagConfig     CapabilityTemplate_FieldPathSelector = 4
	CapabilityTemplate_FieldPathSelectorMaxToolRounds CapabilityTemplate_FieldPathSelector = 5
	CapabilityTemplate_FieldPathSelectorDefaultModel  CapabilityTemplate_FieldPathSelector = 6
	CapabilityTemplate_FieldPathSelectorDisplayName   CapabilityTemplate_FieldPathSelector = 7
)

func (s CapabilityTemplate_FieldPathSelector) String() string {
	switch s {
	case CapabilityTemplate_FieldPathSelectorName:
		return "name"
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return "metadata"
	case CapabilityTemplate_FieldPathSelectorDescription:
		return "description"
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return "connectors"
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return "rag_config"
	case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
		return "max_tool_rounds"
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return "default_model"
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return "display_name"
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", s))
	}
}

func BuildCapabilityTemplate_FieldPath(fp gotenobject.RawFieldPath) (CapabilityTemplate_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object CapabilityTemplate")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorName}, nil
		case "metadata":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMetadata}, nil
		case "description":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDescription}, nil
		case "connectors":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorConnectors}, nil
		case "rag_config", "ragConfig", "rag-config":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorRagConfig}, nil
		case "max_tool_rounds", "maxToolRounds", "max-tool-rounds":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMaxToolRounds}, nil
		case "default_model", "defaultModel", "default-model":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDefaultModel}, nil
		case "display_name", "displayName", "display-name":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDisplayName}, nil
		}
	} else {
		switch fp[0] {
		case "metadata":
			if subpath, err := meta.BuildMeta_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorMetadata, subPath: subpath}, nil
			}
		case "rag_config", "ragConfig", "rag-config":
			if subpath, err := BuildRAGConfig_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorRagConfig, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object CapabilityTemplate", fp)
}

func ParseCapabilityTemplate_FieldPath(rawField string) (CapabilityTemplate_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildCapabilityTemplate_FieldPath(fp)
}

func MustParseCapabilityTemplate_FieldPath(rawField string) CapabilityTemplate_FieldPath {
	fp, err := ParseCapabilityTemplate_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type CapabilityTemplate_FieldTerminalPath struct {
	selector CapabilityTemplate_FieldPathSelector
}

var _ CapabilityTemplate_FieldPath = (*CapabilityTemplate_FieldTerminalPath)(nil)

func (fp *CapabilityTemplate_FieldTerminalPath) Selector() CapabilityTemplate_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *CapabilityTemplate_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *CapabilityTemplate_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source CapabilityTemplate
func (fp *CapabilityTemplate_FieldTerminalPath) Get(source *CapabilityTemplate) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case CapabilityTemplate_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		case CapabilityTemplate_FieldPathSelectorMetadata:
			if source.Metadata != nil {
				values = append(values, source.Metadata)
			}
		case CapabilityTemplate_FieldPathSelectorDescription:
			values = append(values, source.Description)
		case CapabilityTemplate_FieldPathSelectorConnectors:
			for _, value := range source.GetConnectors() {
				values = append(values, value)
			}
		case CapabilityTemplate_FieldPathSelectorRagConfig:
			if source.RagConfig != nil {
				values = append(values, source.RagConfig)
			}
		case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
			values = append(values, source.MaxToolRounds)
		case CapabilityTemplate_FieldPathSelectorDefaultModel:
			values = append(values, source.DefaultModel)
		case CapabilityTemplate_FieldPathSelectorDisplayName:
			values = append(values, source.DisplayName)
		default:
			panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
		}
	}
	return
}

func (fp *CapabilityTemplate_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*CapabilityTemplate))
}

// GetSingle returns value pointed by specific field of from source CapabilityTemplate
func (fp *CapabilityTemplate_FieldTerminalPath) GetSingle(source *CapabilityTemplate) (interface{}, bool) {
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorMetadata:
		res := source.GetMetadata()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorDescription:
		return source.GetDescription(), source != nil
	case CapabilityTemplate_FieldPathSelectorConnectors:
		res := source.GetConnectors()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		res := source.GetRagConfig()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
		return source.GetMaxToolRounds(), source != nil
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return source.GetDefaultModel(), source != nil
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return source.GetDisplayName(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*CapabilityTemplate))
}

// GetDefault returns a default value of the field type
func (fp *CapabilityTemplate_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		return (*Name)(nil)
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return (*meta.Meta)(nil)
	case CapabilityTemplate_FieldPathSelectorDescription:
		return ""
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return ([]*connector.Name)(nil)
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return (*RAGConfig)(nil)
	case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
		return uint32(0)
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return ""
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) ClearValue(item *CapabilityTemplate) {
	if item != nil {
		switch fp.selector {
		case CapabilityTemplate_FieldPathSelectorName:
			item.Name = nil
		case CapabilityTemplate_FieldPathSelectorMetadata:
			item.Metadata = nil
		case CapabilityTemplate_FieldPathSelectorDescription:
			item.Description = ""
		case CapabilityTemplate_FieldPathSelectorConnectors:
			item.Connectors = nil
		case CapabilityTemplate_FieldPathSelectorRagConfig:
			item.RagConfig = nil
		case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
			item.MaxToolRounds = uint32(0)
		case CapabilityTemplate_FieldPathSelectorDefaultModel:
			item.DefaultModel = ""
		case CapabilityTemplate_FieldPathSelectorDisplayName:
			item.DisplayName = ""
		default:
			panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
		}
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*CapabilityTemplate))
}

// IsLeaf - whether field path is holds simple value
func (fp *CapabilityTemplate_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == CapabilityTemplate_FieldPathSelectorName ||
		fp.selector == CapabilityTemplate_FieldPathSelectorDescription ||
		fp.selector == CapabilityTemplate_FieldPathSelectorConnectors ||
		fp.selector == CapabilityTemplate_FieldPathSelectorMaxToolRounds ||
		fp.selector == CapabilityTemplate_FieldPathSelectorDefaultModel ||
		fp.selector == CapabilityTemplate_FieldPathSelectorDisplayName
}

func (fp *CapabilityTemplate_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithIValue(value interface{}) CapabilityTemplate_FieldPathValue {
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*Name)}
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*meta.Meta)}
	case CapabilityTemplate_FieldPathSelectorDescription:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(string)}
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.([]*connector.Name)}
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*RAGConfig)}
	case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(uint32)}
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(string)}
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithIArrayOfValues(values interface{}) CapabilityTemplate_FieldPathArrayOfValues {
	fpaov := &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp}
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*Name)}
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*meta.Meta)}
	case CapabilityTemplate_FieldPathSelectorDescription:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]string)}
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([][]*connector.Name)}
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*RAGConfig)}
	case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]uint32)}
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]string)}
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
	return fpaov
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithIArrayItemValue(value interface{}) CapabilityTemplate_FieldPathArrayItemValue {
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return &CapabilityTemplate_FieldTerminalPathArrayItemValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*connector.Name)}
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type CapabilityTemplate_FieldSubPath struct {
	selector CapabilityTemplate_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ CapabilityTemplate_FieldPath = (*CapabilityTemplate_FieldSubPath)(nil)

func (fps *CapabilityTemplate_FieldSubPath) Selector() CapabilityTemplate_FieldPathSelector {
	return fps.selector
}
func (fps *CapabilityTemplate_FieldSubPath) AsMetadataSubPath() (meta.Meta_FieldPath, bool) {
	res, ok := fps.subPath.(meta.Meta_FieldPath)
	return res, ok
}
func (fps *CapabilityTemplate_FieldSubPath) AsRagConfigSubPath() (RAGConfig_FieldPath, bool) {
	res, ok := fps.subPath.(RAGConfig_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *CapabilityTemplate_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *CapabilityTemplate_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source CapabilityTemplate
func (fps *CapabilityTemplate_FieldSubPath) Get(source *CapabilityTemplate) (values []interface{}) {
	switch fps.selector {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		values = append(values, fps.subPath.GetRaw(source.GetMetadata())...)
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		values = append(values, fps.subPath.GetRaw(source.GetRagConfig())...)
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fps.selector))
	}
	return
}

func (fps *CapabilityTemplate_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*CapabilityTemplate))
}

// GetSingle returns value of selected field from source CapabilityTemplate
func (fps *CapabilityTemplate_FieldSubPath) GetSingle(source *CapabilityTemplate) (interface{}, bool) {
	switch fps.selector {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		if source.GetMetadata() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetMetadata())
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		if source.GetRagConfig() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetRagConfig())
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fps.selector))
	}
}

func (fps *CapabilityTemplate_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*CapabilityTemplate))
}

// GetDefault returns a default value of the field type
func (fps *CapabilityTemplate_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *CapabilityTemplate_FieldSubPath) ClearValue(item *CapabilityTemplate) {
	if item != nil {
		switch fps.selector {
		case CapabilityTemplate_FieldPathSelectorMetadata:
			fps.subPath.ClearValueRaw(item.Metadata)
		case CapabilityTemplate_FieldPathSelectorRagConfig:
			fps.subPath.ClearValueRaw(item.RagConfig)
		default:
			panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fps.selector))
		}
	}
}

func (fps *CapabilityTemplate_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*CapabilityTemplate))
}

// IsLeaf - whether field path is holds simple value
func (fps *CapabilityTemplate_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *CapabilityTemplate_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&CapabilityTemplate_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *CapabilityTemplate_FieldSubPath) WithIValue(value interface{}) CapabilityTemplate_FieldPathValue {
	return &CapabilityTemplate_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *CapabilityTemplate_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *CapabilityTemplate_FieldSubPath) WithIArrayOfValues(values interface{}) CapabilityTemplate_FieldPathArrayOfValues {
	return &CapabilityTemplate_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *CapabilityTemplate_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *CapabilityTemplate_FieldSubPath) WithIArrayItemValue(value interface{}) CapabilityTemplate_FieldPathArrayItemValue {
	return &CapabilityTemplate_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *CapabilityTemplate_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// CapabilityTemplate_FieldPathValue allows storing values for CapabilityTemplate fields according to their type
type CapabilityTemplate_FieldPathValue interface {
	CapabilityTemplate_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **CapabilityTemplate)
	CompareWith(*CapabilityTemplate) (cmp int, comparable bool)
}

func ParseCapabilityTemplate_FieldPathValue(pathStr, valueStr string) (CapabilityTemplate_FieldPathValue, error) {
	fp, err := ParseCapabilityTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CapabilityTemplate field path value from %s: %v", valueStr, err)
	}
	return fpv.(CapabilityTemplate_FieldPathValue), nil
}

func MustParseCapabilityTemplate_FieldPathValue(pathStr, valueStr string) CapabilityTemplate_FieldPathValue {
	fpv, err := ParseCapabilityTemplate_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type CapabilityTemplate_FieldTerminalPathValue struct {
	CapabilityTemplate_FieldTerminalPath
	value interface{}
}

var _ CapabilityTemplate_FieldPathValue = (*CapabilityTemplate_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'CapabilityTemplate' as interface{}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsNameValue() (*Name, bool) {
	res, ok := fpv.value.(*Name)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsMetadataValue() (*meta.Meta, bool) {
	res, ok := fpv.value.(*meta.Meta)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsDescriptionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsConnectorsValue() ([]*connector.Name, bool) {
	res, ok := fpv.value.([]*connector.Name)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsRagConfigValue() (*RAGConfig, bool) {
	res, ok := fpv.value.(*RAGConfig)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsMaxToolRoundsValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsDefaultModelValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsDisplayNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object CapabilityTemplate
func (fpv *CapabilityTemplate_FieldTerminalPathValue) SetTo(target **CapabilityTemplate) {
	if *target == nil {
		*target = new(CapabilityTemplate)
	}
	switch fpv.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		(*target).Name = fpv.value.(*Name)
	case CapabilityTemplate_FieldPathSelectorMetadata:
		(*target).Metadata = fpv.value.(*meta.Meta)
	case CapabilityTemplate_FieldPathSelectorDescription:
		(*target).Description = fpv.value.(string)
	case CapabilityTemplate_FieldPathSelectorConnectors:
		(*target).Connectors = fpv.value.([]*connector.Name)
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		(*target).RagConfig = fpv.value.(*RAGConfig)
	case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
		(*target).MaxToolRounds = fpv.value.(uint32)
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		(*target).DefaultModel = fpv.value.(string)
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		(*target).DisplayName = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpv.selector))
	}
}

func (fpv *CapabilityTemplate_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*CapabilityTemplate)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'CapabilityTemplate_FieldTerminalPathValue' with the value under path in 'CapabilityTemplate'.
func (fpv *CapabilityTemplate_FieldTerminalPathValue) CompareWith(source *CapabilityTemplate) (int, bool) {
	switch fpv.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		leftValue := fpv.value.(*Name)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorDescription:
		leftValue := fpv.value.(string)
		rightValue := source.GetDescription()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetMaxToolRounds()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		leftValue := fpv.value.(string)
		rightValue := source.GetDefaultModel()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		leftValue := fpv.value.(string)
		rightValue := source.GetDisplayName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpv.selector))
	}
}

func (fpv *CapabilityTemplate_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*CapabilityTemplate))
}

type CapabilityTemplate_FieldSubPathValue struct {
	CapabilityTemplate_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ CapabilityTemplate_FieldPathValue = (*CapabilityTemplate_FieldSubPathValue)(nil)

func (fpvs *CapabilityTemplate_FieldSubPathValue) AsMetadataPathValue() (meta.Meta_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(meta.Meta_FieldPathValue)
	return res, ok
}
func (fpvs *CapabilityTemplate_FieldSubPathValue) AsRagConfigPathValue() (RAGConfig_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(RAGConfig_FieldPathValue)
	return res, ok
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) SetTo(target **CapabilityTemplate) {
	if *target == nil {
		*target = new(CapabilityTemplate)
	}
	switch fpvs.Selector() {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		fpvs.subPathValue.(meta.Meta_FieldPathValue).SetTo(&(*target).Metadata)
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		fpvs.subPathValue.(RAGConfig_FieldPathValue).SetTo(&(*target).RagConfig)
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpvs.Selector()))
	}
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*CapabilityTemplate)
	fpvs.SetTo(&typedObject)
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) CompareWith(source *CapabilityTemplate) (int, bool) {
	switch fpvs.Selector() {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return fpvs.subPathValue.(meta.Meta_FieldPathValue).CompareWith(source.GetMetadata())
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return fpvs.subPathValue.(RAGConfig_FieldPathValue).CompareWith(source.GetRagConfig())
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpvs.Selector()))
	}
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*CapabilityTemplate))
}

// CapabilityTemplate_FieldPathArrayItemValue allows storing single item in Path-specific values for CapabilityTemplate according to their type
// Present only for array (repeated) types.
type CapabilityTemplate_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	CapabilityTemplate_FieldPath
	ContainsValue(*CapabilityTemplate) bool
}

// ParseCapabilityTemplate_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseCapabilityTemplate_FieldPathArrayItemValue(pathStr, valueStr string) (CapabilityTemplate_FieldPathArrayItemValue, error) {
	fp, err := ParseCapabilityTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CapabilityTemplate field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(CapabilityTemplate_FieldPathArrayItemValue), nil
}

func MustParseCapabilityTemplate_FieldPathArrayItemValue(pathStr, valueStr string) CapabilityTemplate_FieldPathArrayItemValue {
	fpaiv, err := ParseCapabilityTemplate_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type CapabilityTemplate_FieldTerminalPathArrayItemValue struct {
	CapabilityTemplate_FieldTerminalPath
	value interface{}
}

var _ CapabilityTemplate_FieldPathArrayItemValue = (*CapabilityTemplate_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object CapabilityTemplate as interface{}
func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) AsConnectorsItemValue() (*connector.Name, bool) {
	res, ok := fpaiv.value.(*connector.Name)
	return res, ok
}

func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) GetSingle(source *CapabilityTemplate) (interface{}, bool) {
	return nil, false
}

func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*CapabilityTemplate))
}

// Contains returns a boolean indicating if value that is being held is present in given 'CapabilityTemplate'
func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) ContainsValue(source *CapabilityTemplate) bool {
	slice := fpaiv.CapabilityTemplate_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type CapabilityTemplate_FieldSubPathArrayItemValue struct {
	CapabilityTemplate_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) AsMetadataPathItemValue() (meta.Meta_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(meta.Meta_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) AsRagConfigPathItemValue() (RAGConfig_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(RAGConfig_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'CapabilityTemplate'
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) ContainsValue(source *CapabilityTemplate) bool {
	switch fpaivs.Selector() {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return fpaivs.subPathItemValue.(meta.Meta_FieldPathArrayItemValue).ContainsValue(source.GetMetadata())
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return fpaivs.subPathItemValue.(RAGConfig_FieldPathArrayItemValue).ContainsValue(source.GetRagConfig())
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpaivs.Selector()))
	}
}

// CapabilityTemplate_FieldPathArrayOfValues allows storing slice of values for CapabilityTemplate fields according to their type
type CapabilityTemplate_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	CapabilityTemplate_FieldPath
}

func ParseCapabilityTemplate_FieldPathArrayOfValues(pathStr, valuesStr string) (CapabilityTemplate_FieldPathArrayOfValues, error) {
	fp, err := ParseCapabilityTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CapabilityTemplate field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(CapabilityTemplate_FieldPathArrayOfValues), nil
}

func MustParseCapabilityTemplate_FieldPathArrayOfValues(pathStr, valuesStr string) CapabilityTemplate_FieldPathArrayOfValues {
	fpaov, err := ParseCapabilityTemplate_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type CapabilityTemplate_FieldTerminalPathArrayOfValues struct {
	CapabilityTemplate_FieldTerminalPath
	values interface{}
}

var _ CapabilityTemplate_FieldPathArrayOfValues = (*CapabilityTemplate_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*Name) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorMetadata:
		for _, v := range fpaov.values.([]*meta.Meta) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorDescription:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorConnectors:
		for _, v := range fpaov.values.([][]*connector.Name) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		for _, v := range fpaov.values.([]*RAGConfig) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorMaxToolRounds:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*Name, bool) {
	res, ok := fpaov.values.([]*Name)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsMetadataArrayOfValues() ([]*meta.Meta, bool) {
	res, ok := fpaov.values.([]*meta.Meta)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsDescriptionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsConnectorsArrayOfValues() ([][]*connector.Name, bool) {
	res, ok := fpaov.values.([][]*connector.Name)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsRagConfigArrayOfValues() ([]*RAGConfig, bool) {
	res, ok := fpaov.values.([]*RAGConfig)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsMaxToolRoundsArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsDefaultModelArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsDisplayNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

type CapabilityTemplate_FieldSubPathArrayOfValues struct {
	CapabilityTemplate_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ CapabilityTemplate_FieldPathArrayOfValues = (*CapabilityTemplate_FieldSubPathArrayOfValues)(nil)

func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) AsMetadataPathArrayOfValues() (meta.Meta_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(meta.Meta_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) AsRagConfigPathArrayOfValues() (RAGConfig_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(RAGConfig_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type RAGConfig_FieldPath interface {
	gotenobject.FieldPath
	Selector() RAGConfig_FieldPathSelector
	Get(source *RAGConfig) []interface{}
	GetSingle(source *RAGConfig) (interface{}, bool)
	ClearValue(item *RAGConfig)

	// Those methods build corresponding RAGConfig_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) RAGConfig_FieldPathValue
	WithIArrayOfValues(values interface{}) RAGConfig_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) RAGConfig_FieldPathArrayItemValue
}

type RAGConfig_FieldPathSelector int32

const (
	RAGConfig_FieldPathSelectorSearchIndices     RAGConfig_FieldPathSelector = 0
	RAGConfig_FieldPathSelectorIndexingPolicy    RAGConfig_FieldPathSelector = 1
	RAGConfig_FieldPathSelectorRetrievalLimits   RAGConfig_FieldPathSelector = 2
	RAGConfig_FieldPathSelectorUseAzureNativeRag RAGConfig_FieldPathSelector = 3
)

func (s RAGConfig_FieldPathSelector) String() string {
	switch s {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return "search_indices"
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return "indexing_policy"
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return "retrieval_limits"
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return "use_azure_native_rag"
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", s))
	}
}

func BuildRAGConfig_FieldPath(fp gotenobject.RawFieldPath) (RAGConfig_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object RAGConfig")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "search_indices", "searchIndices", "search-indices":
			return &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorSearchIndices}, nil
		case "indexing_policy", "indexingPolicy", "indexing-policy":
			return &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorIndexingPolicy}, nil
		case "retrieval_limits", "retrievalLimits", "retrieval-limits":
			return &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorRetrievalLimits}, nil
		case "use_azure_native_rag", "useAzureNativeRag", "use-azure-native-rag":
			return &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorUseAzureNativeRag}, nil
		}
	} else {
		switch fp[0] {
		case "indexing_policy", "indexingPolicy", "indexing-policy":
			if subpath, err := BuildIndexingPolicy_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &RAGConfig_FieldSubPath{selector: RAGConfig_FieldPathSelectorIndexingPolicy, subPath: subpath}, nil
			}
		case "retrieval_limits", "retrievalLimits", "retrieval-limits":
			if subpath, err := BuildRetrievalLimits_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &RAGConfig_FieldSubPath{selector: RAGConfig_FieldPathSelectorRetrievalLimits, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object RAGConfig", fp)
}

func ParseRAGConfig_FieldPath(rawField string) (RAGConfig_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildRAGConfig_FieldPath(fp)
}

func MustParseRAGConfig_FieldPath(rawField string) RAGConfig_FieldPath {
	fp, err := ParseRAGConfig_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type RAGConfig_FieldTerminalPath struct {
	selector RAGConfig_FieldPathSelector
}

var _ RAGConfig_FieldPath = (*RAGConfig_FieldTerminalPath)(nil)

func (fp *RAGConfig_FieldTerminalPath) Selector() RAGConfig_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *RAGConfig_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *RAGConfig_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source RAGConfig
func (fp *RAGConfig_FieldTerminalPath) Get(source *RAGConfig) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case RAGConfig_FieldPathSelectorSearchIndices:
			for _, value := range source.GetSearchIndices() {
				values = append(values, value)
			}
		case RAGConfig_FieldPathSelectorIndexingPolicy:
			if source.IndexingPolicy != nil {
				values = append(values, source.IndexingPolicy)
			}
		case RAGConfig_FieldPathSelectorRetrievalLimits:
			if source.RetrievalLimits != nil {
				values = append(values, source.RetrievalLimits)
			}
		case RAGConfig_FieldPathSelectorUseAzureNativeRag:
			values = append(values, source.UseAzureNativeRag)
		default:
			panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
		}
	}
	return
}

func (fp *RAGConfig_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*RAGConfig))
}

// GetSingle returns value pointed by specific field of from source RAGConfig
func (fp *RAGConfig_FieldTerminalPath) GetSingle(source *RAGConfig) (interface{}, bool) {
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		res := source.GetSearchIndices()
		return res, res != nil
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		res := source.GetIndexingPolicy()
		return res, res != nil
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		res := source.GetRetrievalLimits()
		return res, res != nil
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return source.GetUseAzureNativeRag(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
}

func (fp *RAGConfig_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*RAGConfig))
}

// GetDefault returns a default value of the field type
func (fp *RAGConfig_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return ([]*search_index.Name)(nil)
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return (*IndexingPolicy)(nil)
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return (*RetrievalLimits)(nil)
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
}

func (fp *RAGConfig_FieldTerminalPath) ClearValue(item *RAGConfig) {
	if item != nil {
		switch fp.selector {
		case RAGConfig_FieldPathSelectorSearchIndices:
			item.SearchIndices = nil
		case RAGConfig_FieldPathSelectorIndexingPolicy:
			item.IndexingPolicy = nil
		case RAGConfig_FieldPathSelectorRetrievalLimits:
			item.RetrievalLimits = nil
		case RAGConfig_FieldPathSelectorUseAzureNativeRag:
			item.UseAzureNativeRag = false
		default:
			panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
		}
	}
}

func (fp *RAGConfig_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*RAGConfig))
}

// IsLeaf - whether field path is holds simple value
func (fp *RAGConfig_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == RAGConfig_FieldPathSelectorSearchIndices ||
		fp.selector == RAGConfig_FieldPathSelectorUseAzureNativeRag
}

func (fp *RAGConfig_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *RAGConfig_FieldTerminalPath) WithIValue(value interface{}) RAGConfig_FieldPathValue {
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return &RAGConfig_FieldTerminalPathValue{RAGConfig_FieldTerminalPath: *fp, value: value.([]*search_index.Name)}
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return &RAGConfig_FieldTerminalPathValue{RAGConfig_FieldTerminalPath: *fp, value: value.(*IndexingPolicy)}
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return &RAGConfig_FieldTerminalPathValue{RAGConfig_FieldTerminalPath: *fp, value: value.(*RetrievalLimits)}
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return &RAGConfig_FieldTerminalPathValue{RAGConfig_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
}

func (fp *RAGConfig_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *RAGConfig_FieldTerminalPath) WithIArrayOfValues(values interface{}) RAGConfig_FieldPathArrayOfValues {
	fpaov := &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp}
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp, values: values.([][]*search_index.Name)}
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp, values: values.([]*IndexingPolicy)}
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp, values: values.([]*RetrievalLimits)}
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
	return fpaov
}

func (fp *RAGConfig_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *RAGConfig_FieldTerminalPath) WithIArrayItemValue(value interface{}) RAGConfig_FieldPathArrayItemValue {
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return &RAGConfig_FieldTerminalPathArrayItemValue{RAGConfig_FieldTerminalPath: *fp, value: value.(*search_index.Name)}
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
}

func (fp *RAGConfig_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type RAGConfig_FieldSubPath struct {
	selector RAGConfig_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ RAGConfig_FieldPath = (*RAGConfig_FieldSubPath)(nil)

func (fps *RAGConfig_FieldSubPath) Selector() RAGConfig_FieldPathSelector {
	return fps.selector
}
func (fps *RAGConfig_FieldSubPath) AsIndexingPolicySubPath() (IndexingPolicy_FieldPath, bool) {
	res, ok := fps.subPath.(IndexingPolicy_FieldPath)
	return res, ok
}
func (fps *RAGConfig_FieldSubPath) AsRetrievalLimitsSubPath() (RetrievalLimits_FieldPath, bool) {
	res, ok := fps.subPath.(RetrievalLimits_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *RAGConfig_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *RAGConfig_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source RAGConfig
func (fps *RAGConfig_FieldSubPath) Get(source *RAGConfig) (values []interface{}) {
	switch fps.selector {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		values = append(values, fps.subPath.GetRaw(source.GetIndexingPolicy())...)
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		values = append(values, fps.subPath.GetRaw(source.GetRetrievalLimits())...)
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fps.selector))
	}
	return
}

func (fps *RAGConfig_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*RAGConfig))
}

// GetSingle returns value of selected field from source RAGConfig
func (fps *RAGConfig_FieldSubPath) GetSingle(source *RAGConfig) (interface{}, bool) {
	switch fps.selector {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		if source.GetIndexingPolicy() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetIndexingPolicy())
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		if source.GetRetrievalLimits() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetRetrievalLimits())
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fps.selector))
	}
}

func (fps *RAGConfig_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*RAGConfig))
}

// GetDefault returns a default value of the field type
func (fps *RAGConfig_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *RAGConfig_FieldSubPath) ClearValue(item *RAGConfig) {
	if item != nil {
		switch fps.selector {
		case RAGConfig_FieldPathSelectorIndexingPolicy:
			fps.subPath.ClearValueRaw(item.IndexingPolicy)
		case RAGConfig_FieldPathSelectorRetrievalLimits:
			fps.subPath.ClearValueRaw(item.RetrievalLimits)
		default:
			panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fps.selector))
		}
	}
}

func (fps *RAGConfig_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*RAGConfig))
}

// IsLeaf - whether field path is holds simple value
func (fps *RAGConfig_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *RAGConfig_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&RAGConfig_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *RAGConfig_FieldSubPath) WithIValue(value interface{}) RAGConfig_FieldPathValue {
	return &RAGConfig_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *RAGConfig_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *RAGConfig_FieldSubPath) WithIArrayOfValues(values interface{}) RAGConfig_FieldPathArrayOfValues {
	return &RAGConfig_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *RAGConfig_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *RAGConfig_FieldSubPath) WithIArrayItemValue(value interface{}) RAGConfig_FieldPathArrayItemValue {
	return &RAGConfig_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *RAGConfig_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// RAGConfig_FieldPathValue allows storing values for RAGConfig fields according to their type
type RAGConfig_FieldPathValue interface {
	RAGConfig_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **RAGConfig)
	CompareWith(*RAGConfig) (cmp int, comparable bool)
}

func ParseRAGConfig_FieldPathValue(pathStr, valueStr string) (RAGConfig_FieldPathValue, error) {
	fp, err := ParseRAGConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RAGConfig field path value from %s: %v", valueStr, err)
	}
	return fpv.(RAGConfig_FieldPathValue), nil
}

func MustParseRAGConfig_FieldPathValue(pathStr, valueStr string) RAGConfig_FieldPathValue {
	fpv, err := ParseRAGConfig_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type RAGConfig_FieldTerminalPathValue struct {
	RAGConfig_FieldTerminalPath
	value interface{}
}

var _ RAGConfig_FieldPathValue = (*RAGConfig_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'RAGConfig' as interface{}
func (fpv *RAGConfig_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *RAGConfig_FieldTerminalPathValue) AsSearchIndicesValue() ([]*search_index.Name, bool) {
	res, ok := fpv.value.([]*search_index.Name)
	return res, ok
}
func (fpv *RAGConfig_FieldTerminalPathValue) AsIndexingPolicyValue() (*IndexingPolicy, bool) {
	res, ok := fpv.value.(*IndexingPolicy)
	return res, ok
}
func (fpv *RAGConfig_FieldTerminalPathValue) AsRetrievalLimitsValue() (*RetrievalLimits, bool) {
	res, ok := fpv.value.(*RetrievalLimits)
	return res, ok
}
func (fpv *RAGConfig_FieldTerminalPathValue) AsUseAzureNativeRagValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object RAGConfig
func (fpv *RAGConfig_FieldTerminalPathValue) SetTo(target **RAGConfig) {
	if *target == nil {
		*target = new(RAGConfig)
	}
	switch fpv.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		(*target).SearchIndices = fpv.value.([]*search_index.Name)
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		(*target).IndexingPolicy = fpv.value.(*IndexingPolicy)
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		(*target).RetrievalLimits = fpv.value.(*RetrievalLimits)
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		(*target).UseAzureNativeRag = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpv.selector))
	}
}

func (fpv *RAGConfig_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*RAGConfig)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'RAGConfig_FieldTerminalPathValue' with the value under path in 'RAGConfig'.
func (fpv *RAGConfig_FieldTerminalPathValue) CompareWith(source *RAGConfig) (int, bool) {
	switch fpv.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return 0, false
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return 0, false
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return 0, false
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		leftValue := fpv.value.(bool)
		rightValue := source.GetUseAzureNativeRag()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpv.selector))
	}
}

func (fpv *RAGConfig_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*RAGConfig))
}

type RAGConfig_FieldSubPathValue struct {
	RAGConfig_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ RAGConfig_FieldPathValue = (*RAGConfig_FieldSubPathValue)(nil)

func (fpvs *RAGConfig_FieldSubPathValue) AsIndexingPolicyPathValue() (IndexingPolicy_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(IndexingPolicy_FieldPathValue)
	return res, ok
}
func (fpvs *RAGConfig_FieldSubPathValue) AsRetrievalLimitsPathValue() (RetrievalLimits_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(RetrievalLimits_FieldPathValue)
	return res, ok
}

func (fpvs *RAGConfig_FieldSubPathValue) SetTo(target **RAGConfig) {
	if *target == nil {
		*target = new(RAGConfig)
	}
	switch fpvs.Selector() {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		fpvs.subPathValue.(IndexingPolicy_FieldPathValue).SetTo(&(*target).IndexingPolicy)
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		fpvs.subPathValue.(RetrievalLimits_FieldPathValue).SetTo(&(*target).RetrievalLimits)
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpvs.Selector()))
	}
}

func (fpvs *RAGConfig_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*RAGConfig)
	fpvs.SetTo(&typedObject)
}

func (fpvs *RAGConfig_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *RAGConfig_FieldSubPathValue) CompareWith(source *RAGConfig) (int, bool) {
	switch fpvs.Selector() {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return fpvs.subPathValue.(IndexingPolicy_FieldPathValue).CompareWith(source.GetIndexingPolicy())
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return fpvs.subPathValue.(RetrievalLimits_FieldPathValue).CompareWith(source.GetRetrievalLimits())
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpvs.Selector()))
	}
}

func (fpvs *RAGConfig_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*RAGConfig))
}

// RAGConfig_FieldPathArrayItemValue allows storing single item in Path-specific values for RAGConfig according to their type
// Present only for array (repeated) types.
type RAGConfig_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	RAGConfig_FieldPath
	ContainsValue(*RAGConfig) bool
}

// ParseRAGConfig_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseRAGConfig_FieldPathArrayItemValue(pathStr, valueStr string) (RAGConfig_FieldPathArrayItemValue, error) {
	fp, err := ParseRAGConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RAGConfig field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(RAGConfig_FieldPathArrayItemValue), nil
}

func MustParseRAGConfig_FieldPathArrayItemValue(pathStr, valueStr string) RAGConfig_FieldPathArrayItemValue {
	fpaiv, err := ParseRAGConfig_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type RAGConfig_FieldTerminalPathArrayItemValue struct {
	RAGConfig_FieldTerminalPath
	value interface{}
}

var _ RAGConfig_FieldPathArrayItemValue = (*RAGConfig_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object RAGConfig as interface{}
func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) AsSearchIndicesItemValue() (*search_index.Name, bool) {
	res, ok := fpaiv.value.(*search_index.Name)
	return res, ok
}

func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) GetSingle(source *RAGConfig) (interface{}, bool) {
	return nil, false
}

func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*RAGConfig))
}

// Contains returns a boolean indicating if value that is being held is present in given 'RAGConfig'
func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) ContainsValue(source *RAGConfig) bool {
	slice := fpaiv.RAGConfig_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type RAGConfig_FieldSubPathArrayItemValue struct {
	RAGConfig_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *RAGConfig_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *RAGConfig_FieldSubPathArrayItemValue) AsIndexingPolicyPathItemValue() (IndexingPolicy_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(IndexingPolicy_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *RAGConfig_FieldSubPathArrayItemValue) AsRetrievalLimitsPathItemValue() (RetrievalLimits_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(RetrievalLimits_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'RAGConfig'
func (fpaivs *RAGConfig_FieldSubPathArrayItemValue) ContainsValue(source *RAGConfig) bool {
	switch fpaivs.Selector() {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return fpaivs.subPathItemValue.(IndexingPolicy_FieldPathArrayItemValue).ContainsValue(source.GetIndexingPolicy())
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return fpaivs.subPathItemValue.(RetrievalLimits_FieldPathArrayItemValue).ContainsValue(source.GetRetrievalLimits())
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpaivs.Selector()))
	}
}

// RAGConfig_FieldPathArrayOfValues allows storing slice of values for RAGConfig fields according to their type
type RAGConfig_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	RAGConfig_FieldPath
}

func ParseRAGConfig_FieldPathArrayOfValues(pathStr, valuesStr string) (RAGConfig_FieldPathArrayOfValues, error) {
	fp, err := ParseRAGConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RAGConfig field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(RAGConfig_FieldPathArrayOfValues), nil
}

func MustParseRAGConfig_FieldPathArrayOfValues(pathStr, valuesStr string) RAGConfig_FieldPathArrayOfValues {
	fpaov, err := ParseRAGConfig_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type RAGConfig_FieldTerminalPathArrayOfValues struct {
	RAGConfig_FieldTerminalPath
	values interface{}
}

var _ RAGConfig_FieldPathArrayOfValues = (*RAGConfig_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		for _, v := range fpaov.values.([][]*search_index.Name) {
			values = append(values, v)
		}
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		for _, v := range fpaov.values.([]*IndexingPolicy) {
			values = append(values, v)
		}
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		for _, v := range fpaov.values.([]*RetrievalLimits) {
			values = append(values, v)
		}
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) AsSearchIndicesArrayOfValues() ([][]*search_index.Name, bool) {
	res, ok := fpaov.values.([][]*search_index.Name)
	return res, ok
}
func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) AsIndexingPolicyArrayOfValues() ([]*IndexingPolicy, bool) {
	res, ok := fpaov.values.([]*IndexingPolicy)
	return res, ok
}
func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) AsRetrievalLimitsArrayOfValues() ([]*RetrievalLimits, bool) {
	res, ok := fpaov.values.([]*RetrievalLimits)
	return res, ok
}
func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) AsUseAzureNativeRagArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

type RAGConfig_FieldSubPathArrayOfValues struct {
	RAGConfig_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ RAGConfig_FieldPathArrayOfValues = (*RAGConfig_FieldSubPathArrayOfValues)(nil)

func (fpsaov *RAGConfig_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *RAGConfig_FieldSubPathArrayOfValues) AsIndexingPolicyPathArrayOfValues() (IndexingPolicy_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(IndexingPolicy_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *RAGConfig_FieldSubPathArrayOfValues) AsRetrievalLimitsPathArrayOfValues() (RetrievalLimits_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(RetrievalLimits_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type IndexingPolicy_FieldPath interface {
	gotenobject.FieldPath
	Selector() IndexingPolicy_FieldPathSelector
	Get(source *IndexingPolicy) []interface{}
	GetSingle(source *IndexingPolicy) (interface{}, bool)
	ClearValue(item *IndexingPolicy)

	// Those methods build corresponding IndexingPolicy_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) IndexingPolicy_FieldPathValue
	WithIArrayOfValues(values interface{}) IndexingPolicy_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) IndexingPolicy_FieldPathArrayItemValue
}

type IndexingPolicy_FieldPathSelector int32

const (
	IndexingPolicy_FieldPathSelectorChunkSizeTokens    IndexingPolicy_FieldPathSelector = 0
	IndexingPolicy_FieldPathSelectorChunkOverlapTokens IndexingPolicy_FieldPathSelector = 1
	IndexingPolicy_FieldPathSelectorEmbeddingModel     IndexingPolicy_FieldPathSelector = 2
	IndexingPolicy_FieldPathSelectorChunkingStrategy   IndexingPolicy_FieldPathSelector = 3
)

func (s IndexingPolicy_FieldPathSelector) String() string {
	switch s {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return "chunk_size_tokens"
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return "chunk_overlap_tokens"
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return "embedding_model"
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return "chunking_strategy"
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", s))
	}
}

func BuildIndexingPolicy_FieldPath(fp gotenobject.RawFieldPath) (IndexingPolicy_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object IndexingPolicy")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "chunk_size_tokens", "chunkSizeTokens", "chunk-size-tokens":
			return &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkSizeTokens}, nil
		case "chunk_overlap_tokens", "chunkOverlapTokens", "chunk-overlap-tokens":
			return &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkOverlapTokens}, nil
		case "embedding_model", "embeddingModel", "embedding-model":
			return &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorEmbeddingModel}, nil
		case "chunking_strategy", "chunkingStrategy", "chunking-strategy":
			return &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkingStrategy}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object IndexingPolicy", fp)
}

func ParseIndexingPolicy_FieldPath(rawField string) (IndexingPolicy_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildIndexingPolicy_FieldPath(fp)
}

func MustParseIndexingPolicy_FieldPath(rawField string) IndexingPolicy_FieldPath {
	fp, err := ParseIndexingPolicy_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type IndexingPolicy_FieldTerminalPath struct {
	selector IndexingPolicy_FieldPathSelector
}

var _ IndexingPolicy_FieldPath = (*IndexingPolicy_FieldTerminalPath)(nil)

func (fp *IndexingPolicy_FieldTerminalPath) Selector() IndexingPolicy_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *IndexingPolicy_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *IndexingPolicy_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source IndexingPolicy
func (fp *IndexingPolicy_FieldTerminalPath) Get(source *IndexingPolicy) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
			values = append(values, source.ChunkSizeTokens)
		case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
			values = append(values, source.ChunkOverlapTokens)
		case IndexingPolicy_FieldPathSelectorEmbeddingModel:
			values = append(values, source.EmbeddingModel)
		case IndexingPolicy_FieldPathSelectorChunkingStrategy:
			values = append(values, source.ChunkingStrategy)
		default:
			panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
		}
	}
	return
}

func (fp *IndexingPolicy_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*IndexingPolicy))
}

// GetSingle returns value pointed by specific field of from source IndexingPolicy
func (fp *IndexingPolicy_FieldTerminalPath) GetSingle(source *IndexingPolicy) (interface{}, bool) {
	switch fp.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return source.GetChunkSizeTokens(), source != nil
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return source.GetChunkOverlapTokens(), source != nil
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return source.GetEmbeddingModel(), source != nil
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return source.GetChunkingStrategy(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*IndexingPolicy))
}

// GetDefault returns a default value of the field type
func (fp *IndexingPolicy_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return uint32(0)
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return uint32(0)
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return ""
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) ClearValue(item *IndexingPolicy) {
	if item != nil {
		switch fp.selector {
		case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
			item.ChunkSizeTokens = uint32(0)
		case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
			item.ChunkOverlapTokens = uint32(0)
		case IndexingPolicy_FieldPathSelectorEmbeddingModel:
			item.EmbeddingModel = ""
		case IndexingPolicy_FieldPathSelectorChunkingStrategy:
			item.ChunkingStrategy = ""
		default:
			panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
		}
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*IndexingPolicy))
}

// IsLeaf - whether field path is holds simple value
func (fp *IndexingPolicy_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == IndexingPolicy_FieldPathSelectorChunkSizeTokens ||
		fp.selector == IndexingPolicy_FieldPathSelectorChunkOverlapTokens ||
		fp.selector == IndexingPolicy_FieldPathSelectorEmbeddingModel ||
		fp.selector == IndexingPolicy_FieldPathSelectorChunkingStrategy
}

func (fp *IndexingPolicy_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *IndexingPolicy_FieldTerminalPath) WithIValue(value interface{}) IndexingPolicy_FieldPathValue {
	switch fp.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return &IndexingPolicy_FieldTerminalPathValue{IndexingPolicy_FieldTerminalPath: *fp, value: value.(uint32)}
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return &IndexingPolicy_FieldTerminalPathValue{IndexingPolicy_FieldTerminalPath: *fp, value: value.(uint32)}
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return &IndexingPolicy_FieldTerminalPathValue{IndexingPolicy_FieldTerminalPath: *fp, value: value.(string)}
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return &IndexingPolicy_FieldTerminalPathValue{IndexingPolicy_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *IndexingPolicy_FieldTerminalPath) WithIArrayOfValues(values interface{}) IndexingPolicy_FieldPathArrayOfValues {
	fpaov := &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp}
	switch fp.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp, values: values.([]uint32)}
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp, values: values.([]uint32)}
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp, values: values.([]string)}
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
	return fpaov
}

func (fp *IndexingPolicy_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *IndexingPolicy_FieldTerminalPath) WithIArrayItemValue(value interface{}) IndexingPolicy_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// IndexingPolicy_FieldPathValue allows storing values for IndexingPolicy fields according to their type
type IndexingPolicy_FieldPathValue interface {
	IndexingPolicy_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **IndexingPolicy)
	CompareWith(*IndexingPolicy) (cmp int, comparable bool)
}

func ParseIndexingPolicy_FieldPathValue(pathStr, valueStr string) (IndexingPolicy_FieldPathValue, error) {
	fp, err := ParseIndexingPolicy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing IndexingPolicy field path value from %s: %v", valueStr, err)
	}
	return fpv.(IndexingPolicy_FieldPathValue), nil
}

func MustParseIndexingPolicy_FieldPathValue(pathStr, valueStr string) IndexingPolicy_FieldPathValue {
	fpv, err := ParseIndexingPolicy_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type IndexingPolicy_FieldTerminalPathValue struct {
	IndexingPolicy_FieldTerminalPath
	value interface{}
}

var _ IndexingPolicy_FieldPathValue = (*IndexingPolicy_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'IndexingPolicy' as interface{}
func (fpv *IndexingPolicy_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *IndexingPolicy_FieldTerminalPathValue) AsChunkSizeTokensValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *IndexingPolicy_FieldTerminalPathValue) AsChunkOverlapTokensValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *IndexingPolicy_FieldTerminalPathValue) AsEmbeddingModelValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *IndexingPolicy_FieldTerminalPathValue) AsChunkingStrategyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object IndexingPolicy
func (fpv *IndexingPolicy_FieldTerminalPathValue) SetTo(target **IndexingPolicy) {
	if *target == nil {
		*target = new(IndexingPolicy)
	}
	switch fpv.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		(*target).ChunkSizeTokens = fpv.value.(uint32)
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		(*target).ChunkOverlapTokens = fpv.value.(uint32)
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		(*target).EmbeddingModel = fpv.value.(string)
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		(*target).ChunkingStrategy = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fpv.selector))
	}
}

func (fpv *IndexingPolicy_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*IndexingPolicy)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'IndexingPolicy_FieldTerminalPathValue' with the value under path in 'IndexingPolicy'.
func (fpv *IndexingPolicy_FieldTerminalPathValue) CompareWith(source *IndexingPolicy) (int, bool) {
	switch fpv.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetChunkSizeTokens()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetChunkOverlapTokens()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		leftValue := fpv.value.(string)
		rightValue := source.GetEmbeddingModel()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		leftValue := fpv.value.(string)
		rightValue := source.GetChunkingStrategy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fpv.selector))
	}
}

func (fpv *IndexingPolicy_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*IndexingPolicy))
}

// IndexingPolicy_FieldPathArrayItemValue allows storing single item in Path-specific values for IndexingPolicy according to their type
// Present only for array (repeated) types.
type IndexingPolicy_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	IndexingPolicy_FieldPath
	ContainsValue(*IndexingPolicy) bool
}

// ParseIndexingPolicy_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseIndexingPolicy_FieldPathArrayItemValue(pathStr, valueStr string) (IndexingPolicy_FieldPathArrayItemValue, error) {
	fp, err := ParseIndexingPolicy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing IndexingPolicy field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(IndexingPolicy_FieldPathArrayItemValue), nil
}

func MustParseIndexingPolicy_FieldPathArrayItemValue(pathStr, valueStr string) IndexingPolicy_FieldPathArrayItemValue {
	fpaiv, err := ParseIndexingPolicy_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type IndexingPolicy_FieldTerminalPathArrayItemValue struct {
	IndexingPolicy_FieldTerminalPath
	value interface{}
}

var _ IndexingPolicy_FieldPathArrayItemValue = (*IndexingPolicy_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object IndexingPolicy as interface{}
func (fpaiv *IndexingPolicy_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *IndexingPolicy_FieldTerminalPathArrayItemValue) GetSingle(source *IndexingPolicy) (interface{}, bool) {
	return nil, false
}

func (fpaiv *IndexingPolicy_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*IndexingPolicy))
}

// Contains returns a boolean indicating if value that is being held is present in given 'IndexingPolicy'
func (fpaiv *IndexingPolicy_FieldTerminalPathArrayItemValue) ContainsValue(source *IndexingPolicy) bool {
	slice := fpaiv.IndexingPolicy_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// IndexingPolicy_FieldPathArrayOfValues allows storing slice of values for IndexingPolicy fields according to their type
type IndexingPolicy_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	IndexingPolicy_FieldPath
}

func ParseIndexingPolicy_FieldPathArrayOfValues(pathStr, valuesStr string) (IndexingPolicy_FieldPathArrayOfValues, error) {
	fp, err := ParseIndexingPolicy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing IndexingPolicy field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(IndexingPolicy_FieldPathArrayOfValues), nil
}

func MustParseIndexingPolicy_FieldPathArrayOfValues(pathStr, valuesStr string) IndexingPolicy_FieldPathArrayOfValues {
	fpaov, err := ParseIndexingPolicy_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type IndexingPolicy_FieldTerminalPathArrayOfValues struct {
	IndexingPolicy_FieldTerminalPath
	values interface{}
}

var _ IndexingPolicy_FieldPathArrayOfValues = (*IndexingPolicy_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) AsChunkSizeTokensArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) AsChunkOverlapTokensArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) AsEmbeddingModelArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) AsChunkingStrategyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type RetrievalLimits_FieldPath interface {
	gotenobject.FieldPath
	Selector() RetrievalLimits_FieldPathSelector
	Get(source *RetrievalLimits) []interface{}
	GetSingle(source *RetrievalLimits) (interface{}, bool)
	ClearValue(item *RetrievalLimits)

	// Those methods build corresponding RetrievalLimits_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) RetrievalLimits_FieldPathValue
	WithIArrayOfValues(values interface{}) RetrievalLimits_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) RetrievalLimits_FieldPathArrayItemValue
}

type RetrievalLimits_FieldPathSelector int32

const (
	RetrievalLimits_FieldPathSelectorMaxDocuments      RetrievalLimits_FieldPathSelector = 0
	RetrievalLimits_FieldPathSelectorMaxContextTokens  RetrievalLimits_FieldPathSelector = 1
	RetrievalLimits_FieldPathSelectorMinRelevanceScore RetrievalLimits_FieldPathSelector = 2
	RetrievalLimits_FieldPathSelectorRequireCitations  RetrievalLimits_FieldPathSelector = 3
)

func (s RetrievalLimits_FieldPathSelector) String() string {
	switch s {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return "max_documents"
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return "max_context_tokens"
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return "min_relevance_score"
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return "require_citations"
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", s))
	}
}

func BuildRetrievalLimits_FieldPath(fp gotenobject.RawFieldPath) (RetrievalLimits_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object RetrievalLimits")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "max_documents", "maxDocuments", "max-documents":
			return &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMaxDocuments}, nil
		case "max_context_tokens", "maxContextTokens", "max-context-tokens":
			return &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMaxContextTokens}, nil
		case "min_relevance_score", "minRelevanceScore", "min-relevance-score":
			return &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMinRelevanceScore}, nil
		case "require_citations", "requireCitations", "require-citations":
			return &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorRequireCitations}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object RetrievalLimits", fp)
}

func ParseRetrievalLimits_FieldPath(rawField string) (RetrievalLimits_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildRetrievalLimits_FieldPath(fp)
}

func MustParseRetrievalLimits_FieldPath(rawField string) RetrievalLimits_FieldPath {
	fp, err := ParseRetrievalLimits_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type RetrievalLimits_FieldTerminalPath struct {
	selector RetrievalLimits_FieldPathSelector
}

var _ RetrievalLimits_FieldPath = (*RetrievalLimits_FieldTerminalPath)(nil)

func (fp *RetrievalLimits_FieldTerminalPath) Selector() RetrievalLimits_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *RetrievalLimits_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *RetrievalLimits_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source RetrievalLimits
func (fp *RetrievalLimits_FieldTerminalPath) Get(source *RetrievalLimits) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case RetrievalLimits_FieldPathSelectorMaxDocuments:
			values = append(values, source.MaxDocuments)
		case RetrievalLimits_FieldPathSelectorMaxContextTokens:
			values = append(values, source.MaxContextTokens)
		case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
			values = append(values, source.MinRelevanceScore)
		case RetrievalLimits_FieldPathSelectorRequireCitations:
			values = append(values, source.RequireCitations)
		default:
			panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
		}
	}
	return
}

func (fp *RetrievalLimits_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*RetrievalLimits))
}

// GetSingle returns value pointed by specific field of from source RetrievalLimits
func (fp *RetrievalLimits_FieldTerminalPath) GetSingle(source *RetrievalLimits) (interface{}, bool) {
	switch fp.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return source.GetMaxDocuments(), source != nil
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return source.GetMaxContextTokens(), source != nil
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return source.GetMinRelevanceScore(), source != nil
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return source.GetRequireCitations(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*RetrievalLimits))
}

// GetDefault returns a default value of the field type
func (fp *RetrievalLimits_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return uint32(0)
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return uint32(0)
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return float32(0)
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) ClearValue(item *RetrievalLimits) {
	if item != nil {
		switch fp.selector {
		case RetrievalLimits_FieldPathSelectorMaxDocuments:
			item.MaxDocuments = uint32(0)
		case RetrievalLimits_FieldPathSelectorMaxContextTokens:
			item.MaxContextTokens = uint32(0)
		case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
			item.MinRelevanceScore = float32(0)
		case RetrievalLimits_FieldPathSelectorRequireCitations:
			item.RequireCitations = false
		default:
			panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
		}
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*RetrievalLimits))
}

// IsLeaf - whether field path is holds simple value
func (fp *RetrievalLimits_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == RetrievalLimits_FieldPathSelectorMaxDocuments ||
		fp.selector == RetrievalLimits_FieldPathSelectorMaxContextTokens ||
		fp.selector == RetrievalLimits_FieldPathSelectorMinRelevanceScore ||
		fp.selector == RetrievalLimits_FieldPathSelectorRequireCitations
}

func (fp *RetrievalLimits_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *RetrievalLimits_FieldTerminalPath) WithIValue(value interface{}) RetrievalLimits_FieldPathValue {
	switch fp.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return &RetrievalLimits_FieldTerminalPathValue{RetrievalLimits_FieldTerminalPath: *fp, value: value.(uint32)}
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return &RetrievalLimits_FieldTerminalPathValue{RetrievalLimits_FieldTerminalPath: *fp, value: value.(uint32)}
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return &RetrievalLimits_FieldTerminalPathValue{RetrievalLimits_FieldTerminalPath: *fp, value: value.(float32)}
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return &RetrievalLimits_FieldTerminalPathValue{RetrievalLimits_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *RetrievalLimits_FieldTerminalPath) WithIArrayOfValues(values interface{}) RetrievalLimits_FieldPathArrayOfValues {
	fpaov := &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp}
	switch fp.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp, values: values.([]uint32)}
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp, values: values.([]uint32)}
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp, values: values.([]float32)}
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
	return fpaov
}

func (fp *RetrievalLimits_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *RetrievalLimits_FieldTerminalPath) WithIArrayItemValue(value interface{}) RetrievalLimits_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// RetrievalLimits_FieldPathValue allows storing values for RetrievalLimits fields according to their type
type RetrievalLimits_FieldPathValue interface {
	RetrievalLimits_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **RetrievalLimits)
	CompareWith(*RetrievalLimits) (cmp int, comparable bool)
}

func ParseRetrievalLimits_FieldPathValue(pathStr, valueStr string) (RetrievalLimits_FieldPathValue, error) {
	fp, err := ParseRetrievalLimits_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RetrievalLimits field path value from %s: %v", valueStr, err)
	}
	return fpv.(RetrievalLimits_FieldPathValue), nil
}

func MustParseRetrievalLimits_FieldPathValue(pathStr, valueStr string) RetrievalLimits_FieldPathValue {
	fpv, err := ParseRetrievalLimits_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type RetrievalLimits_FieldTerminalPathValue struct {
	RetrievalLimits_FieldTerminalPath
	value interface{}
}

var _ RetrievalLimits_FieldPathValue = (*RetrievalLimits_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'RetrievalLimits' as interface{}
func (fpv *RetrievalLimits_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *RetrievalLimits_FieldTerminalPathValue) AsMaxDocumentsValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *RetrievalLimits_FieldTerminalPathValue) AsMaxContextTokensValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *RetrievalLimits_FieldTerminalPathValue) AsMinRelevanceScoreValue() (float32, bool) {
	res, ok := fpv.value.(float32)
	return res, ok
}
func (fpv *RetrievalLimits_FieldTerminalPathValue) AsRequireCitationsValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object RetrievalLimits
func (fpv *RetrievalLimits_FieldTerminalPathValue) SetTo(target **RetrievalLimits) {
	if *target == nil {
		*target = new(RetrievalLimits)
	}
	switch fpv.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		(*target).MaxDocuments = fpv.value.(uint32)
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		(*target).MaxContextTokens = fpv.value.(uint32)
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		(*target).MinRelevanceScore = fpv.value.(float32)
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		(*target).RequireCitations = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fpv.selector))
	}
}

func (fpv *RetrievalLimits_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*RetrievalLimits)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'RetrievalLimits_FieldTerminalPathValue' with the value under path in 'RetrievalLimits'.
func (fpv *RetrievalLimits_FieldTerminalPathValue) CompareWith(source *RetrievalLimits) (int, bool) {
	switch fpv.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetMaxDocuments()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetMaxContextTokens()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		leftValue := fpv.value.(float32)
		rightValue := source.GetMinRelevanceScore()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		leftValue := fpv.value.(bool)
		rightValue := source.GetRequireCitations()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fpv.selector))
	}
}

func (fpv *RetrievalLimits_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*RetrievalLimits))
}

// RetrievalLimits_FieldPathArrayItemValue allows storing single item in Path-specific values for RetrievalLimits according to their type
// Present only for array (repeated) types.
type RetrievalLimits_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	RetrievalLimits_FieldPath
	ContainsValue(*RetrievalLimits) bool
}

// ParseRetrievalLimits_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseRetrievalLimits_FieldPathArrayItemValue(pathStr, valueStr string) (RetrievalLimits_FieldPathArrayItemValue, error) {
	fp, err := ParseRetrievalLimits_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RetrievalLimits field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(RetrievalLimits_FieldPathArrayItemValue), nil
}

func MustParseRetrievalLimits_FieldPathArrayItemValue(pathStr, valueStr string) RetrievalLimits_FieldPathArrayItemValue {
	fpaiv, err := ParseRetrievalLimits_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type RetrievalLimits_FieldTerminalPathArrayItemValue struct {
	RetrievalLimits_FieldTerminalPath
	value interface{}
}

var _ RetrievalLimits_FieldPathArrayItemValue = (*RetrievalLimits_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object RetrievalLimits as interface{}
func (fpaiv *RetrievalLimits_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *RetrievalLimits_FieldTerminalPathArrayItemValue) GetSingle(source *RetrievalLimits) (interface{}, bool) {
	return nil, false
}

func (fpaiv *RetrievalLimits_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*RetrievalLimits))
}

// Contains returns a boolean indicating if value that is being held is present in given 'RetrievalLimits'
func (fpaiv *RetrievalLimits_FieldTerminalPathArrayItemValue) ContainsValue(source *RetrievalLimits) bool {
	slice := fpaiv.RetrievalLimits_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// RetrievalLimits_FieldPathArrayOfValues allows storing slice of values for RetrievalLimits fields according to their type
type RetrievalLimits_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	RetrievalLimits_FieldPath
}

func ParseRetrievalLimits_FieldPathArrayOfValues(pathStr, valuesStr string) (RetrievalLimits_FieldPathArrayOfValues, error) {
	fp, err := ParseRetrievalLimits_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RetrievalLimits field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(RetrievalLimits_FieldPathArrayOfValues), nil
}

func MustParseRetrievalLimits_FieldPathArrayOfValues(pathStr, valuesStr string) RetrievalLimits_FieldPathArrayOfValues {
	fpaov, err := ParseRetrievalLimits_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type RetrievalLimits_FieldTerminalPathArrayOfValues struct {
	RetrievalLimits_FieldTerminalPath
	values interface{}
}

var _ RetrievalLimits_FieldPathArrayOfValues = (*RetrievalLimits_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		for _, v := range fpaov.values.([]float32) {
			values = append(values, v)
		}
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) AsMaxDocumentsArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) AsMaxContextTokensArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) AsMinRelevanceScoreArrayOfValues() ([]float32, bool) {
	res, ok := fpaov.values.([]float32)
	return res, ok
}
func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) AsRequireCitationsArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
