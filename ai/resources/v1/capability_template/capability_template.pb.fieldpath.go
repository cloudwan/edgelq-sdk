// Code generated by protoc-gen-goten-object
// File: edgelq/ai/proto/v1/capability_template.proto
// DO NOT EDIT!!!

package capability_template

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
	"github.com/cloudwan/goten-sdk/runtime/strcase"
)

// proto imports
import (
	common_client "github.com/cloudwan/edgelq-sdk/ai/client/v1/common"
	chat_model "github.com/cloudwan/edgelq-sdk/ai/resources/v1/chat_model"
	connector "github.com/cloudwan/edgelq-sdk/ai/resources/v1/connector"
	search_index "github.com/cloudwan/edgelq-sdk/ai/resources/v1/search_index"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1/project"
	meta "github.com/cloudwan/goten-sdk/types/meta"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &chat_model.ChatModel{}
	_ = &common_client.Message{}
	_ = &connector.Connector{}
	_ = &search_index.SearchIndex{}
	_ = &iam_project.Project{}
	_ = &meta.Meta{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type CapabilityTemplate_FieldPath interface {
	gotenobject.FieldPath
	Selector() CapabilityTemplate_FieldPathSelector
	Get(source *CapabilityTemplate) []interface{}
	GetSingle(source *CapabilityTemplate) (interface{}, bool)
	ClearValue(item *CapabilityTemplate)

	// Those methods build corresponding CapabilityTemplate_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) CapabilityTemplate_FieldPathValue
	WithIArrayOfValues(values interface{}) CapabilityTemplate_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) CapabilityTemplate_FieldPathArrayItemValue
}

type CapabilityTemplate_FieldPathSelector int32

const (
	CapabilityTemplate_FieldPathSelectorName                   CapabilityTemplate_FieldPathSelector = 0
	CapabilityTemplate_FieldPathSelectorMetadata               CapabilityTemplate_FieldPathSelector = 1
	CapabilityTemplate_FieldPathSelectorDescription            CapabilityTemplate_FieldPathSelector = 2
	CapabilityTemplate_FieldPathSelectorConnectors             CapabilityTemplate_FieldPathSelector = 3
	CapabilityTemplate_FieldPathSelectorRagConfig              CapabilityTemplate_FieldPathSelector = 4
	CapabilityTemplate_FieldPathSelectorDisplayName            CapabilityTemplate_FieldPathSelector = 5
	CapabilityTemplate_FieldPathSelectorReasoning              CapabilityTemplate_FieldPathSelector = 6
	CapabilityTemplate_FieldPathSelectorMaxOutputTokens        CapabilityTemplate_FieldPathSelector = 7
	CapabilityTemplate_FieldPathSelectorSystemPrompt           CapabilityTemplate_FieldPathSelector = 8
	CapabilityTemplate_FieldPathSelectorSystemPromptAppend     CapabilityTemplate_FieldPathSelector = 9
	CapabilityTemplate_FieldPathSelectorDisableInputTokenCache CapabilityTemplate_FieldPathSelector = 10
	CapabilityTemplate_FieldPathSelectorAllowedModels          CapabilityTemplate_FieldPathSelector = 11
	CapabilityTemplate_FieldPathSelectorToolSafety             CapabilityTemplate_FieldPathSelector = 12
	CapabilityTemplate_FieldPathSelectorDefaultModel           CapabilityTemplate_FieldPathSelector = 13
)

func (s CapabilityTemplate_FieldPathSelector) String() string {
	switch s {
	case CapabilityTemplate_FieldPathSelectorName:
		return "name"
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return "metadata"
	case CapabilityTemplate_FieldPathSelectorDescription:
		return "description"
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return "connectors"
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return "rag_config"
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return "display_name"
	case CapabilityTemplate_FieldPathSelectorReasoning:
		return "reasoning"
	case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
		return "max_output_tokens"
	case CapabilityTemplate_FieldPathSelectorSystemPrompt:
		return "system_prompt"
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		return "system_prompt_append"
	case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
		return "disable_input_token_cache"
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		return "allowed_models"
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		return "tool_safety"
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return "default_model"
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", s))
	}
}

func BuildCapabilityTemplate_FieldPath(fp gotenobject.RawFieldPath) (CapabilityTemplate_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object CapabilityTemplate")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorName}, nil
		case "metadata":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMetadata}, nil
		case "description":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDescription}, nil
		case "connectors":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorConnectors}, nil
		case "rag_config", "ragConfig", "rag-config":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorRagConfig}, nil
		case "display_name", "displayName", "display-name":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDisplayName}, nil
		case "reasoning":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorReasoning}, nil
		case "max_output_tokens", "maxOutputTokens", "max-output-tokens":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorMaxOutputTokens}, nil
		case "system_prompt", "systemPrompt", "system-prompt":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorSystemPrompt}, nil
		case "system_prompt_append", "systemPromptAppend", "system-prompt-append":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorSystemPromptAppend}, nil
		case "disable_input_token_cache", "disableInputTokenCache", "disable-input-token-cache":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDisableInputTokenCache}, nil
		case "allowed_models", "allowedModels", "allowed-models":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorAllowedModels}, nil
		case "tool_safety", "toolSafety", "tool-safety":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorToolSafety}, nil
		case "default_model", "defaultModel", "default-model":
			return &CapabilityTemplate_FieldTerminalPath{selector: CapabilityTemplate_FieldPathSelectorDefaultModel}, nil
		}
	} else {
		switch fp[0] {
		case "metadata":
			if subpath, err := meta.BuildMeta_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorMetadata, subPath: subpath}, nil
			}
		case "rag_config", "ragConfig", "rag-config":
			if subpath, err := BuildRAGConfig_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorRagConfig, subPath: subpath}, nil
			}
		case "reasoning":
			if subpath, err := BuildReasoningConfig_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorReasoning, subPath: subpath}, nil
			}
		case "system_prompt_append", "systemPromptAppend", "system-prompt-append":
			if subpath, err := BuildPromptAppendTemplate_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorSystemPromptAppend, subPath: subpath}, nil
			}
		case "tool_safety", "toolSafety", "tool-safety":
			if subpath, err := BuildToolSafetyConfig_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &CapabilityTemplate_FieldSubPath{selector: CapabilityTemplate_FieldPathSelectorToolSafety, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object CapabilityTemplate", fp)
}

func ParseCapabilityTemplate_FieldPath(rawField string) (CapabilityTemplate_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildCapabilityTemplate_FieldPath(fp)
}

func MustParseCapabilityTemplate_FieldPath(rawField string) CapabilityTemplate_FieldPath {
	fp, err := ParseCapabilityTemplate_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type CapabilityTemplate_FieldTerminalPath struct {
	selector CapabilityTemplate_FieldPathSelector
}

var _ CapabilityTemplate_FieldPath = (*CapabilityTemplate_FieldTerminalPath)(nil)

func (fp *CapabilityTemplate_FieldTerminalPath) Selector() CapabilityTemplate_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *CapabilityTemplate_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *CapabilityTemplate_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source CapabilityTemplate
func (fp *CapabilityTemplate_FieldTerminalPath) Get(source *CapabilityTemplate) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case CapabilityTemplate_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		case CapabilityTemplate_FieldPathSelectorMetadata:
			if source.Metadata != nil {
				values = append(values, source.Metadata)
			}
		case CapabilityTemplate_FieldPathSelectorDescription:
			values = append(values, source.Description)
		case CapabilityTemplate_FieldPathSelectorConnectors:
			for _, value := range source.GetConnectors() {
				values = append(values, value)
			}
		case CapabilityTemplate_FieldPathSelectorRagConfig:
			if source.RagConfig != nil {
				values = append(values, source.RagConfig)
			}
		case CapabilityTemplate_FieldPathSelectorDisplayName:
			values = append(values, source.DisplayName)
		case CapabilityTemplate_FieldPathSelectorReasoning:
			if source.Reasoning != nil {
				values = append(values, source.Reasoning)
			}
		case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
			values = append(values, source.MaxOutputTokens)
		case CapabilityTemplate_FieldPathSelectorSystemPrompt:
			values = append(values, source.SystemPrompt)
		case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
			if source.SystemPromptAppend != nil {
				values = append(values, source.SystemPromptAppend)
			}
		case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
			values = append(values, source.DisableInputTokenCache)
		case CapabilityTemplate_FieldPathSelectorAllowedModels:
			for _, value := range source.GetAllowedModels() {
				values = append(values, value)
			}
		case CapabilityTemplate_FieldPathSelectorToolSafety:
			if source.ToolSafety != nil {
				values = append(values, source.ToolSafety)
			}
		case CapabilityTemplate_FieldPathSelectorDefaultModel:
			if source.DefaultModel != nil {
				values = append(values, source.DefaultModel)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
		}
	}
	return
}

func (fp *CapabilityTemplate_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*CapabilityTemplate))
}

// GetSingle returns value pointed by specific field of from source CapabilityTemplate
func (fp *CapabilityTemplate_FieldTerminalPath) GetSingle(source *CapabilityTemplate) (interface{}, bool) {
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorMetadata:
		res := source.GetMetadata()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorDescription:
		return source.GetDescription(), source != nil
	case CapabilityTemplate_FieldPathSelectorConnectors:
		res := source.GetConnectors()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		res := source.GetRagConfig()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return source.GetDisplayName(), source != nil
	case CapabilityTemplate_FieldPathSelectorReasoning:
		res := source.GetReasoning()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
		return source.GetMaxOutputTokens(), source != nil
	case CapabilityTemplate_FieldPathSelectorSystemPrompt:
		return source.GetSystemPrompt(), source != nil
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		res := source.GetSystemPromptAppend()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
		return source.GetDisableInputTokenCache(), source != nil
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		res := source.GetAllowedModels()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		res := source.GetToolSafety()
		return res, res != nil
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		res := source.GetDefaultModel()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*CapabilityTemplate))
}

// GetDefault returns a default value of the field type
func (fp *CapabilityTemplate_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		return (*Name)(nil)
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return (*meta.Meta)(nil)
	case CapabilityTemplate_FieldPathSelectorDescription:
		return ""
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return ([]*connector.Reference)(nil)
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return (*RAGConfig)(nil)
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return ""
	case CapabilityTemplate_FieldPathSelectorReasoning:
		return (*ReasoningConfig)(nil)
	case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
		return int32(0)
	case CapabilityTemplate_FieldPathSelectorSystemPrompt:
		return ""
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		return (*PromptAppendTemplate)(nil)
	case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
		return false
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		return ([]*chat_model.Reference)(nil)
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		return (*ToolSafetyConfig)(nil)
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return (*chat_model.Name)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) ClearValue(item *CapabilityTemplate) {
	if item != nil {
		switch fp.selector {
		case CapabilityTemplate_FieldPathSelectorName:
			item.Name = nil
		case CapabilityTemplate_FieldPathSelectorMetadata:
			item.Metadata = nil
		case CapabilityTemplate_FieldPathSelectorDescription:
			item.Description = ""
		case CapabilityTemplate_FieldPathSelectorConnectors:
			item.Connectors = nil
		case CapabilityTemplate_FieldPathSelectorRagConfig:
			item.RagConfig = nil
		case CapabilityTemplate_FieldPathSelectorDisplayName:
			item.DisplayName = ""
		case CapabilityTemplate_FieldPathSelectorReasoning:
			item.Reasoning = nil
		case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
			item.MaxOutputTokens = int32(0)
		case CapabilityTemplate_FieldPathSelectorSystemPrompt:
			item.SystemPrompt = ""
		case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
			item.SystemPromptAppend = nil
		case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
			item.DisableInputTokenCache = false
		case CapabilityTemplate_FieldPathSelectorAllowedModels:
			item.AllowedModels = nil
		case CapabilityTemplate_FieldPathSelectorToolSafety:
			item.ToolSafety = nil
		case CapabilityTemplate_FieldPathSelectorDefaultModel:
			item.DefaultModel = nil
		default:
			panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
		}
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*CapabilityTemplate))
}

// IsLeaf - whether field path is holds simple value
func (fp *CapabilityTemplate_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == CapabilityTemplate_FieldPathSelectorName ||
		fp.selector == CapabilityTemplate_FieldPathSelectorDescription ||
		fp.selector == CapabilityTemplate_FieldPathSelectorConnectors ||
		fp.selector == CapabilityTemplate_FieldPathSelectorDisplayName ||
		fp.selector == CapabilityTemplate_FieldPathSelectorMaxOutputTokens ||
		fp.selector == CapabilityTemplate_FieldPathSelectorSystemPrompt ||
		fp.selector == CapabilityTemplate_FieldPathSelectorDisableInputTokenCache ||
		fp.selector == CapabilityTemplate_FieldPathSelectorAllowedModels ||
		fp.selector == CapabilityTemplate_FieldPathSelectorDefaultModel
}

func (fp *CapabilityTemplate_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithIValue(value interface{}) CapabilityTemplate_FieldPathValue {
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*Name)}
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*meta.Meta)}
	case CapabilityTemplate_FieldPathSelectorDescription:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(string)}
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.([]*connector.Reference)}
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*RAGConfig)}
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(string)}
	case CapabilityTemplate_FieldPathSelectorReasoning:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*ReasoningConfig)}
	case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(int32)}
	case CapabilityTemplate_FieldPathSelectorSystemPrompt:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(string)}
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*PromptAppendTemplate)}
	case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(bool)}
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.([]*chat_model.Reference)}
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*ToolSafetyConfig)}
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return &CapabilityTemplate_FieldTerminalPathValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*chat_model.Name)}
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithIArrayOfValues(values interface{}) CapabilityTemplate_FieldPathArrayOfValues {
	fpaov := &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp}
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*Name)}
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*meta.Meta)}
	case CapabilityTemplate_FieldPathSelectorDescription:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]string)}
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([][]*connector.Reference)}
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*RAGConfig)}
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]string)}
	case CapabilityTemplate_FieldPathSelectorReasoning:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*ReasoningConfig)}
	case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]int32)}
	case CapabilityTemplate_FieldPathSelectorSystemPrompt:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]string)}
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*PromptAppendTemplate)}
	case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]bool)}
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([][]*chat_model.Reference)}
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*ToolSafetyConfig)}
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		return &CapabilityTemplate_FieldTerminalPathArrayOfValues{CapabilityTemplate_FieldTerminalPath: *fp, values: values.([]*chat_model.Name)}
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
	return fpaov
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithIArrayItemValue(value interface{}) CapabilityTemplate_FieldPathArrayItemValue {
	switch fp.selector {
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return &CapabilityTemplate_FieldTerminalPathArrayItemValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*connector.Reference)}
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		return &CapabilityTemplate_FieldTerminalPathArrayItemValue{CapabilityTemplate_FieldTerminalPath: *fp, value: value.(*chat_model.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fp.selector))
	}
}

func (fp *CapabilityTemplate_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type CapabilityTemplate_FieldSubPath struct {
	selector CapabilityTemplate_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ CapabilityTemplate_FieldPath = (*CapabilityTemplate_FieldSubPath)(nil)

func (fps *CapabilityTemplate_FieldSubPath) Selector() CapabilityTemplate_FieldPathSelector {
	return fps.selector
}
func (fps *CapabilityTemplate_FieldSubPath) AsMetadataSubPath() (meta.Meta_FieldPath, bool) {
	res, ok := fps.subPath.(meta.Meta_FieldPath)
	return res, ok
}
func (fps *CapabilityTemplate_FieldSubPath) AsRagConfigSubPath() (RAGConfig_FieldPath, bool) {
	res, ok := fps.subPath.(RAGConfig_FieldPath)
	return res, ok
}
func (fps *CapabilityTemplate_FieldSubPath) AsReasoningSubPath() (ReasoningConfig_FieldPath, bool) {
	res, ok := fps.subPath.(ReasoningConfig_FieldPath)
	return res, ok
}
func (fps *CapabilityTemplate_FieldSubPath) AsSystemPromptAppendSubPath() (PromptAppendTemplate_FieldPath, bool) {
	res, ok := fps.subPath.(PromptAppendTemplate_FieldPath)
	return res, ok
}
func (fps *CapabilityTemplate_FieldSubPath) AsToolSafetySubPath() (ToolSafetyConfig_FieldPath, bool) {
	res, ok := fps.subPath.(ToolSafetyConfig_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *CapabilityTemplate_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *CapabilityTemplate_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source CapabilityTemplate
func (fps *CapabilityTemplate_FieldSubPath) Get(source *CapabilityTemplate) (values []interface{}) {
	switch fps.selector {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		values = append(values, fps.subPath.GetRaw(source.GetMetadata())...)
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		values = append(values, fps.subPath.GetRaw(source.GetRagConfig())...)
	case CapabilityTemplate_FieldPathSelectorReasoning:
		values = append(values, fps.subPath.GetRaw(source.GetReasoning())...)
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		values = append(values, fps.subPath.GetRaw(source.GetSystemPromptAppend())...)
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		values = append(values, fps.subPath.GetRaw(source.GetToolSafety())...)
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fps.selector))
	}
	return
}

func (fps *CapabilityTemplate_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*CapabilityTemplate))
}

// GetSingle returns value of selected field from source CapabilityTemplate
func (fps *CapabilityTemplate_FieldSubPath) GetSingle(source *CapabilityTemplate) (interface{}, bool) {
	switch fps.selector {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		if source.GetMetadata() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetMetadata())
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		if source.GetRagConfig() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetRagConfig())
	case CapabilityTemplate_FieldPathSelectorReasoning:
		if source.GetReasoning() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetReasoning())
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		if source.GetSystemPromptAppend() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetSystemPromptAppend())
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		if source.GetToolSafety() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetToolSafety())
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fps.selector))
	}
}

func (fps *CapabilityTemplate_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*CapabilityTemplate))
}

// GetDefault returns a default value of the field type
func (fps *CapabilityTemplate_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *CapabilityTemplate_FieldSubPath) ClearValue(item *CapabilityTemplate) {
	if item != nil {
		switch fps.selector {
		case CapabilityTemplate_FieldPathSelectorMetadata:
			fps.subPath.ClearValueRaw(item.Metadata)
		case CapabilityTemplate_FieldPathSelectorRagConfig:
			fps.subPath.ClearValueRaw(item.RagConfig)
		case CapabilityTemplate_FieldPathSelectorReasoning:
			fps.subPath.ClearValueRaw(item.Reasoning)
		case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
			fps.subPath.ClearValueRaw(item.SystemPromptAppend)
		case CapabilityTemplate_FieldPathSelectorToolSafety:
			fps.subPath.ClearValueRaw(item.ToolSafety)
		default:
			panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fps.selector))
		}
	}
}

func (fps *CapabilityTemplate_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*CapabilityTemplate))
}

// IsLeaf - whether field path is holds simple value
func (fps *CapabilityTemplate_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *CapabilityTemplate_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&CapabilityTemplate_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *CapabilityTemplate_FieldSubPath) WithIValue(value interface{}) CapabilityTemplate_FieldPathValue {
	return &CapabilityTemplate_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *CapabilityTemplate_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *CapabilityTemplate_FieldSubPath) WithIArrayOfValues(values interface{}) CapabilityTemplate_FieldPathArrayOfValues {
	return &CapabilityTemplate_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *CapabilityTemplate_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *CapabilityTemplate_FieldSubPath) WithIArrayItemValue(value interface{}) CapabilityTemplate_FieldPathArrayItemValue {
	return &CapabilityTemplate_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *CapabilityTemplate_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// CapabilityTemplate_FieldPathValue allows storing values for CapabilityTemplate fields according to their type
type CapabilityTemplate_FieldPathValue interface {
	CapabilityTemplate_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **CapabilityTemplate)
	CompareWith(*CapabilityTemplate) (cmp int, comparable bool)
}

func ParseCapabilityTemplate_FieldPathValue(pathStr, valueStr string) (CapabilityTemplate_FieldPathValue, error) {
	fp, err := ParseCapabilityTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CapabilityTemplate field path value from %s: %v", valueStr, err)
	}
	return fpv.(CapabilityTemplate_FieldPathValue), nil
}

func MustParseCapabilityTemplate_FieldPathValue(pathStr, valueStr string) CapabilityTemplate_FieldPathValue {
	fpv, err := ParseCapabilityTemplate_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type CapabilityTemplate_FieldTerminalPathValue struct {
	CapabilityTemplate_FieldTerminalPath
	value interface{}
}

var _ CapabilityTemplate_FieldPathValue = (*CapabilityTemplate_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'CapabilityTemplate' as interface{}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsNameValue() (*Name, bool) {
	res, ok := fpv.value.(*Name)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsMetadataValue() (*meta.Meta, bool) {
	res, ok := fpv.value.(*meta.Meta)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsDescriptionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsConnectorsValue() ([]*connector.Reference, bool) {
	res, ok := fpv.value.([]*connector.Reference)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsRagConfigValue() (*RAGConfig, bool) {
	res, ok := fpv.value.(*RAGConfig)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsDisplayNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsReasoningValue() (*ReasoningConfig, bool) {
	res, ok := fpv.value.(*ReasoningConfig)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsMaxOutputTokensValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsSystemPromptValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsSystemPromptAppendValue() (*PromptAppendTemplate, bool) {
	res, ok := fpv.value.(*PromptAppendTemplate)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsDisableInputTokenCacheValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsAllowedModelsValue() ([]*chat_model.Reference, bool) {
	res, ok := fpv.value.([]*chat_model.Reference)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsToolSafetyValue() (*ToolSafetyConfig, bool) {
	res, ok := fpv.value.(*ToolSafetyConfig)
	return res, ok
}
func (fpv *CapabilityTemplate_FieldTerminalPathValue) AsDefaultModelValue() (*chat_model.Name, bool) {
	res, ok := fpv.value.(*chat_model.Name)
	return res, ok
}

// SetTo stores value for selected field for object CapabilityTemplate
func (fpv *CapabilityTemplate_FieldTerminalPathValue) SetTo(target **CapabilityTemplate) {
	if *target == nil {
		*target = new(CapabilityTemplate)
	}
	switch fpv.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		(*target).Name = fpv.value.(*Name)
	case CapabilityTemplate_FieldPathSelectorMetadata:
		(*target).Metadata = fpv.value.(*meta.Meta)
	case CapabilityTemplate_FieldPathSelectorDescription:
		(*target).Description = fpv.value.(string)
	case CapabilityTemplate_FieldPathSelectorConnectors:
		(*target).Connectors = fpv.value.([]*connector.Reference)
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		(*target).RagConfig = fpv.value.(*RAGConfig)
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		(*target).DisplayName = fpv.value.(string)
	case CapabilityTemplate_FieldPathSelectorReasoning:
		(*target).Reasoning = fpv.value.(*ReasoningConfig)
	case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
		(*target).MaxOutputTokens = fpv.value.(int32)
	case CapabilityTemplate_FieldPathSelectorSystemPrompt:
		(*target).SystemPrompt = fpv.value.(string)
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		(*target).SystemPromptAppend = fpv.value.(*PromptAppendTemplate)
	case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
		(*target).DisableInputTokenCache = fpv.value.(bool)
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		(*target).AllowedModels = fpv.value.([]*chat_model.Reference)
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		(*target).ToolSafety = fpv.value.(*ToolSafetyConfig)
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		(*target).DefaultModel = fpv.value.(*chat_model.Name)
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpv.selector))
	}
}

func (fpv *CapabilityTemplate_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*CapabilityTemplate)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'CapabilityTemplate_FieldTerminalPathValue' with the value under path in 'CapabilityTemplate'.
func (fpv *CapabilityTemplate_FieldTerminalPathValue) CompareWith(source *CapabilityTemplate) (int, bool) {
	switch fpv.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		leftValue := fpv.value.(*Name)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorDescription:
		leftValue := fpv.value.(string)
		rightValue := source.GetDescription()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorConnectors:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		leftValue := fpv.value.(string)
		rightValue := source.GetDisplayName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorReasoning:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
		leftValue := fpv.value.(int32)
		rightValue := source.GetMaxOutputTokens()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorSystemPrompt:
		leftValue := fpv.value.(string)
		rightValue := source.GetSystemPrompt()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
		leftValue := fpv.value.(bool)
		rightValue := source.GetDisableInputTokenCache()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		return 0, false
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		leftValue := fpv.value.(*chat_model.Name)
		rightValue := source.GetDefaultModel()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpv.selector))
	}
}

func (fpv *CapabilityTemplate_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*CapabilityTemplate))
}

type CapabilityTemplate_FieldSubPathValue struct {
	CapabilityTemplate_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ CapabilityTemplate_FieldPathValue = (*CapabilityTemplate_FieldSubPathValue)(nil)

func (fpvs *CapabilityTemplate_FieldSubPathValue) AsMetadataPathValue() (meta.Meta_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(meta.Meta_FieldPathValue)
	return res, ok
}
func (fpvs *CapabilityTemplate_FieldSubPathValue) AsRagConfigPathValue() (RAGConfig_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(RAGConfig_FieldPathValue)
	return res, ok
}
func (fpvs *CapabilityTemplate_FieldSubPathValue) AsReasoningPathValue() (ReasoningConfig_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ReasoningConfig_FieldPathValue)
	return res, ok
}
func (fpvs *CapabilityTemplate_FieldSubPathValue) AsSystemPromptAppendPathValue() (PromptAppendTemplate_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(PromptAppendTemplate_FieldPathValue)
	return res, ok
}
func (fpvs *CapabilityTemplate_FieldSubPathValue) AsToolSafetyPathValue() (ToolSafetyConfig_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ToolSafetyConfig_FieldPathValue)
	return res, ok
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) SetTo(target **CapabilityTemplate) {
	if *target == nil {
		*target = new(CapabilityTemplate)
	}
	switch fpvs.Selector() {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		fpvs.subPathValue.(meta.Meta_FieldPathValue).SetTo(&(*target).Metadata)
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		fpvs.subPathValue.(RAGConfig_FieldPathValue).SetTo(&(*target).RagConfig)
	case CapabilityTemplate_FieldPathSelectorReasoning:
		fpvs.subPathValue.(ReasoningConfig_FieldPathValue).SetTo(&(*target).Reasoning)
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		fpvs.subPathValue.(PromptAppendTemplate_FieldPathValue).SetTo(&(*target).SystemPromptAppend)
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		fpvs.subPathValue.(ToolSafetyConfig_FieldPathValue).SetTo(&(*target).ToolSafety)
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpvs.Selector()))
	}
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*CapabilityTemplate)
	fpvs.SetTo(&typedObject)
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) CompareWith(source *CapabilityTemplate) (int, bool) {
	switch fpvs.Selector() {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return fpvs.subPathValue.(meta.Meta_FieldPathValue).CompareWith(source.GetMetadata())
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return fpvs.subPathValue.(RAGConfig_FieldPathValue).CompareWith(source.GetRagConfig())
	case CapabilityTemplate_FieldPathSelectorReasoning:
		return fpvs.subPathValue.(ReasoningConfig_FieldPathValue).CompareWith(source.GetReasoning())
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		return fpvs.subPathValue.(PromptAppendTemplate_FieldPathValue).CompareWith(source.GetSystemPromptAppend())
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		return fpvs.subPathValue.(ToolSafetyConfig_FieldPathValue).CompareWith(source.GetToolSafety())
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpvs.Selector()))
	}
}

func (fpvs *CapabilityTemplate_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*CapabilityTemplate))
}

// CapabilityTemplate_FieldPathArrayItemValue allows storing single item in Path-specific values for CapabilityTemplate according to their type
// Present only for array (repeated) types.
type CapabilityTemplate_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	CapabilityTemplate_FieldPath
	ContainsValue(*CapabilityTemplate) bool
}

// ParseCapabilityTemplate_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseCapabilityTemplate_FieldPathArrayItemValue(pathStr, valueStr string) (CapabilityTemplate_FieldPathArrayItemValue, error) {
	fp, err := ParseCapabilityTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CapabilityTemplate field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(CapabilityTemplate_FieldPathArrayItemValue), nil
}

func MustParseCapabilityTemplate_FieldPathArrayItemValue(pathStr, valueStr string) CapabilityTemplate_FieldPathArrayItemValue {
	fpaiv, err := ParseCapabilityTemplate_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type CapabilityTemplate_FieldTerminalPathArrayItemValue struct {
	CapabilityTemplate_FieldTerminalPath
	value interface{}
}

var _ CapabilityTemplate_FieldPathArrayItemValue = (*CapabilityTemplate_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object CapabilityTemplate as interface{}
func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) AsConnectorsItemValue() (*connector.Reference, bool) {
	res, ok := fpaiv.value.(*connector.Reference)
	return res, ok
}
func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) AsAllowedModelsItemValue() (*chat_model.Reference, bool) {
	res, ok := fpaiv.value.(*chat_model.Reference)
	return res, ok
}

func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) GetSingle(source *CapabilityTemplate) (interface{}, bool) {
	return nil, false
}

func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*CapabilityTemplate))
}

// Contains returns a boolean indicating if value that is being held is present in given 'CapabilityTemplate'
func (fpaiv *CapabilityTemplate_FieldTerminalPathArrayItemValue) ContainsValue(source *CapabilityTemplate) bool {
	slice := fpaiv.CapabilityTemplate_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type CapabilityTemplate_FieldSubPathArrayItemValue struct {
	CapabilityTemplate_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) AsMetadataPathItemValue() (meta.Meta_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(meta.Meta_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) AsRagConfigPathItemValue() (RAGConfig_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(RAGConfig_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) AsReasoningPathItemValue() (ReasoningConfig_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ReasoningConfig_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) AsSystemPromptAppendPathItemValue() (PromptAppendTemplate_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(PromptAppendTemplate_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) AsToolSafetyPathItemValue() (ToolSafetyConfig_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ToolSafetyConfig_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'CapabilityTemplate'
func (fpaivs *CapabilityTemplate_FieldSubPathArrayItemValue) ContainsValue(source *CapabilityTemplate) bool {
	switch fpaivs.Selector() {
	case CapabilityTemplate_FieldPathSelectorMetadata:
		return fpaivs.subPathItemValue.(meta.Meta_FieldPathArrayItemValue).ContainsValue(source.GetMetadata())
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		return fpaivs.subPathItemValue.(RAGConfig_FieldPathArrayItemValue).ContainsValue(source.GetRagConfig())
	case CapabilityTemplate_FieldPathSelectorReasoning:
		return fpaivs.subPathItemValue.(ReasoningConfig_FieldPathArrayItemValue).ContainsValue(source.GetReasoning())
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		return fpaivs.subPathItemValue.(PromptAppendTemplate_FieldPathArrayItemValue).ContainsValue(source.GetSystemPromptAppend())
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		return fpaivs.subPathItemValue.(ToolSafetyConfig_FieldPathArrayItemValue).ContainsValue(source.GetToolSafety())
	default:
		panic(fmt.Sprintf("Invalid selector for CapabilityTemplate: %d", fpaivs.Selector()))
	}
}

// CapabilityTemplate_FieldPathArrayOfValues allows storing slice of values for CapabilityTemplate fields according to their type
type CapabilityTemplate_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	CapabilityTemplate_FieldPath
}

func ParseCapabilityTemplate_FieldPathArrayOfValues(pathStr, valuesStr string) (CapabilityTemplate_FieldPathArrayOfValues, error) {
	fp, err := ParseCapabilityTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CapabilityTemplate field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(CapabilityTemplate_FieldPathArrayOfValues), nil
}

func MustParseCapabilityTemplate_FieldPathArrayOfValues(pathStr, valuesStr string) CapabilityTemplate_FieldPathArrayOfValues {
	fpaov, err := ParseCapabilityTemplate_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type CapabilityTemplate_FieldTerminalPathArrayOfValues struct {
	CapabilityTemplate_FieldTerminalPath
	values interface{}
}

var _ CapabilityTemplate_FieldPathArrayOfValues = (*CapabilityTemplate_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case CapabilityTemplate_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*Name) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorMetadata:
		for _, v := range fpaov.values.([]*meta.Meta) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorDescription:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorConnectors:
		for _, v := range fpaov.values.([][]*connector.Reference) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorRagConfig:
		for _, v := range fpaov.values.([]*RAGConfig) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorDisplayName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorReasoning:
		for _, v := range fpaov.values.([]*ReasoningConfig) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorMaxOutputTokens:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorSystemPrompt:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorSystemPromptAppend:
		for _, v := range fpaov.values.([]*PromptAppendTemplate) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorDisableInputTokenCache:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorAllowedModels:
		for _, v := range fpaov.values.([][]*chat_model.Reference) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorToolSafety:
		for _, v := range fpaov.values.([]*ToolSafetyConfig) {
			values = append(values, v)
		}
	case CapabilityTemplate_FieldPathSelectorDefaultModel:
		for _, v := range fpaov.values.([]*chat_model.Name) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*Name, bool) {
	res, ok := fpaov.values.([]*Name)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsMetadataArrayOfValues() ([]*meta.Meta, bool) {
	res, ok := fpaov.values.([]*meta.Meta)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsDescriptionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsConnectorsArrayOfValues() ([][]*connector.Reference, bool) {
	res, ok := fpaov.values.([][]*connector.Reference)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsRagConfigArrayOfValues() ([]*RAGConfig, bool) {
	res, ok := fpaov.values.([]*RAGConfig)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsDisplayNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsReasoningArrayOfValues() ([]*ReasoningConfig, bool) {
	res, ok := fpaov.values.([]*ReasoningConfig)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsMaxOutputTokensArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsSystemPromptArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsSystemPromptAppendArrayOfValues() ([]*PromptAppendTemplate, bool) {
	res, ok := fpaov.values.([]*PromptAppendTemplate)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsDisableInputTokenCacheArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsAllowedModelsArrayOfValues() ([][]*chat_model.Reference, bool) {
	res, ok := fpaov.values.([][]*chat_model.Reference)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsToolSafetyArrayOfValues() ([]*ToolSafetyConfig, bool) {
	res, ok := fpaov.values.([]*ToolSafetyConfig)
	return res, ok
}
func (fpaov *CapabilityTemplate_FieldTerminalPathArrayOfValues) AsDefaultModelArrayOfValues() ([]*chat_model.Name, bool) {
	res, ok := fpaov.values.([]*chat_model.Name)
	return res, ok
}

type CapabilityTemplate_FieldSubPathArrayOfValues struct {
	CapabilityTemplate_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ CapabilityTemplate_FieldPathArrayOfValues = (*CapabilityTemplate_FieldSubPathArrayOfValues)(nil)

func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) AsMetadataPathArrayOfValues() (meta.Meta_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(meta.Meta_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) AsRagConfigPathArrayOfValues() (RAGConfig_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(RAGConfig_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) AsReasoningPathArrayOfValues() (ReasoningConfig_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ReasoningConfig_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) AsSystemPromptAppendPathArrayOfValues() (PromptAppendTemplate_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(PromptAppendTemplate_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *CapabilityTemplate_FieldSubPathArrayOfValues) AsToolSafetyPathArrayOfValues() (ToolSafetyConfig_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ToolSafetyConfig_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type PromptAppendTemplate_FieldPath interface {
	gotenobject.FieldPath
	Selector() PromptAppendTemplate_FieldPathSelector
	Get(source *PromptAppendTemplate) []interface{}
	GetSingle(source *PromptAppendTemplate) (interface{}, bool)
	ClearValue(item *PromptAppendTemplate)

	// Those methods build corresponding PromptAppendTemplate_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) PromptAppendTemplate_FieldPathValue
	WithIArrayOfValues(values interface{}) PromptAppendTemplate_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) PromptAppendTemplate_FieldPathArrayItemValue
}

type PromptAppendTemplate_FieldPathSelector int32

const (
	PromptAppendTemplate_FieldPathSelectorText      PromptAppendTemplate_FieldPathSelector = 0
	PromptAppendTemplate_FieldPathSelectorMode      PromptAppendTemplate_FieldPathSelector = 1
	PromptAppendTemplate_FieldPathSelectorOnMissing PromptAppendTemplate_FieldPathSelector = 2
)

func (s PromptAppendTemplate_FieldPathSelector) String() string {
	switch s {
	case PromptAppendTemplate_FieldPathSelectorText:
		return "text"
	case PromptAppendTemplate_FieldPathSelectorMode:
		return "mode"
	case PromptAppendTemplate_FieldPathSelectorOnMissing:
		return "on_missing"
	default:
		panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", s))
	}
}

func BuildPromptAppendTemplate_FieldPath(fp gotenobject.RawFieldPath) (PromptAppendTemplate_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object PromptAppendTemplate")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "text":
			return &PromptAppendTemplate_FieldTerminalPath{selector: PromptAppendTemplate_FieldPathSelectorText}, nil
		case "mode":
			return &PromptAppendTemplate_FieldTerminalPath{selector: PromptAppendTemplate_FieldPathSelectorMode}, nil
		case "on_missing", "onMissing", "on-missing":
			return &PromptAppendTemplate_FieldTerminalPath{selector: PromptAppendTemplate_FieldPathSelectorOnMissing}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object PromptAppendTemplate", fp)
}

func ParsePromptAppendTemplate_FieldPath(rawField string) (PromptAppendTemplate_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildPromptAppendTemplate_FieldPath(fp)
}

func MustParsePromptAppendTemplate_FieldPath(rawField string) PromptAppendTemplate_FieldPath {
	fp, err := ParsePromptAppendTemplate_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type PromptAppendTemplate_FieldTerminalPath struct {
	selector PromptAppendTemplate_FieldPathSelector
}

var _ PromptAppendTemplate_FieldPath = (*PromptAppendTemplate_FieldTerminalPath)(nil)

func (fp *PromptAppendTemplate_FieldTerminalPath) Selector() PromptAppendTemplate_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *PromptAppendTemplate_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *PromptAppendTemplate_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source PromptAppendTemplate
func (fp *PromptAppendTemplate_FieldTerminalPath) Get(source *PromptAppendTemplate) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case PromptAppendTemplate_FieldPathSelectorText:
			values = append(values, source.Text)
		case PromptAppendTemplate_FieldPathSelectorMode:
			values = append(values, source.Mode)
		case PromptAppendTemplate_FieldPathSelectorOnMissing:
			values = append(values, source.OnMissing)
		default:
			panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fp.selector))
		}
	}
	return
}

func (fp *PromptAppendTemplate_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*PromptAppendTemplate))
}

// GetSingle returns value pointed by specific field of from source PromptAppendTemplate
func (fp *PromptAppendTemplate_FieldTerminalPath) GetSingle(source *PromptAppendTemplate) (interface{}, bool) {
	switch fp.selector {
	case PromptAppendTemplate_FieldPathSelectorText:
		return source.GetText(), source != nil
	case PromptAppendTemplate_FieldPathSelectorMode:
		return source.GetMode(), source != nil
	case PromptAppendTemplate_FieldPathSelectorOnMissing:
		return source.GetOnMissing(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fp.selector))
	}
}

func (fp *PromptAppendTemplate_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*PromptAppendTemplate))
}

// GetDefault returns a default value of the field type
func (fp *PromptAppendTemplate_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case PromptAppendTemplate_FieldPathSelectorText:
		return ""
	case PromptAppendTemplate_FieldPathSelectorMode:
		return PromptVariableMode_MODE_SERVER
	case PromptAppendTemplate_FieldPathSelectorOnMissing:
		return PromptMissingVarPolicy_PROMPT_MISSING_VAR_POLICY_ERROR
	default:
		panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fp.selector))
	}
}

func (fp *PromptAppendTemplate_FieldTerminalPath) ClearValue(item *PromptAppendTemplate) {
	if item != nil {
		switch fp.selector {
		case PromptAppendTemplate_FieldPathSelectorText:
			item.Text = ""
		case PromptAppendTemplate_FieldPathSelectorMode:
			item.Mode = PromptVariableMode_MODE_SERVER
		case PromptAppendTemplate_FieldPathSelectorOnMissing:
			item.OnMissing = PromptMissingVarPolicy_PROMPT_MISSING_VAR_POLICY_ERROR
		default:
			panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fp.selector))
		}
	}
}

func (fp *PromptAppendTemplate_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*PromptAppendTemplate))
}

// IsLeaf - whether field path is holds simple value
func (fp *PromptAppendTemplate_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == PromptAppendTemplate_FieldPathSelectorText ||
		fp.selector == PromptAppendTemplate_FieldPathSelectorMode ||
		fp.selector == PromptAppendTemplate_FieldPathSelectorOnMissing
}

func (fp *PromptAppendTemplate_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *PromptAppendTemplate_FieldTerminalPath) WithIValue(value interface{}) PromptAppendTemplate_FieldPathValue {
	switch fp.selector {
	case PromptAppendTemplate_FieldPathSelectorText:
		return &PromptAppendTemplate_FieldTerminalPathValue{PromptAppendTemplate_FieldTerminalPath: *fp, value: value.(string)}
	case PromptAppendTemplate_FieldPathSelectorMode:
		return &PromptAppendTemplate_FieldTerminalPathValue{PromptAppendTemplate_FieldTerminalPath: *fp, value: value.(PromptVariableMode)}
	case PromptAppendTemplate_FieldPathSelectorOnMissing:
		return &PromptAppendTemplate_FieldTerminalPathValue{PromptAppendTemplate_FieldTerminalPath: *fp, value: value.(PromptMissingVarPolicy)}
	default:
		panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fp.selector))
	}
}

func (fp *PromptAppendTemplate_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *PromptAppendTemplate_FieldTerminalPath) WithIArrayOfValues(values interface{}) PromptAppendTemplate_FieldPathArrayOfValues {
	fpaov := &PromptAppendTemplate_FieldTerminalPathArrayOfValues{PromptAppendTemplate_FieldTerminalPath: *fp}
	switch fp.selector {
	case PromptAppendTemplate_FieldPathSelectorText:
		return &PromptAppendTemplate_FieldTerminalPathArrayOfValues{PromptAppendTemplate_FieldTerminalPath: *fp, values: values.([]string)}
	case PromptAppendTemplate_FieldPathSelectorMode:
		return &PromptAppendTemplate_FieldTerminalPathArrayOfValues{PromptAppendTemplate_FieldTerminalPath: *fp, values: values.([]PromptVariableMode)}
	case PromptAppendTemplate_FieldPathSelectorOnMissing:
		return &PromptAppendTemplate_FieldTerminalPathArrayOfValues{PromptAppendTemplate_FieldTerminalPath: *fp, values: values.([]PromptMissingVarPolicy)}
	default:
		panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fp.selector))
	}
	return fpaov
}

func (fp *PromptAppendTemplate_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *PromptAppendTemplate_FieldTerminalPath) WithIArrayItemValue(value interface{}) PromptAppendTemplate_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fp.selector))
	}
}

func (fp *PromptAppendTemplate_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// PromptAppendTemplate_FieldPathValue allows storing values for PromptAppendTemplate fields according to their type
type PromptAppendTemplate_FieldPathValue interface {
	PromptAppendTemplate_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **PromptAppendTemplate)
	CompareWith(*PromptAppendTemplate) (cmp int, comparable bool)
}

func ParsePromptAppendTemplate_FieldPathValue(pathStr, valueStr string) (PromptAppendTemplate_FieldPathValue, error) {
	fp, err := ParsePromptAppendTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PromptAppendTemplate field path value from %s: %v", valueStr, err)
	}
	return fpv.(PromptAppendTemplate_FieldPathValue), nil
}

func MustParsePromptAppendTemplate_FieldPathValue(pathStr, valueStr string) PromptAppendTemplate_FieldPathValue {
	fpv, err := ParsePromptAppendTemplate_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type PromptAppendTemplate_FieldTerminalPathValue struct {
	PromptAppendTemplate_FieldTerminalPath
	value interface{}
}

var _ PromptAppendTemplate_FieldPathValue = (*PromptAppendTemplate_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'PromptAppendTemplate' as interface{}
func (fpv *PromptAppendTemplate_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *PromptAppendTemplate_FieldTerminalPathValue) AsTextValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *PromptAppendTemplate_FieldTerminalPathValue) AsModeValue() (PromptVariableMode, bool) {
	res, ok := fpv.value.(PromptVariableMode)
	return res, ok
}
func (fpv *PromptAppendTemplate_FieldTerminalPathValue) AsOnMissingValue() (PromptMissingVarPolicy, bool) {
	res, ok := fpv.value.(PromptMissingVarPolicy)
	return res, ok
}

// SetTo stores value for selected field for object PromptAppendTemplate
func (fpv *PromptAppendTemplate_FieldTerminalPathValue) SetTo(target **PromptAppendTemplate) {
	if *target == nil {
		*target = new(PromptAppendTemplate)
	}
	switch fpv.selector {
	case PromptAppendTemplate_FieldPathSelectorText:
		(*target).Text = fpv.value.(string)
	case PromptAppendTemplate_FieldPathSelectorMode:
		(*target).Mode = fpv.value.(PromptVariableMode)
	case PromptAppendTemplate_FieldPathSelectorOnMissing:
		(*target).OnMissing = fpv.value.(PromptMissingVarPolicy)
	default:
		panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fpv.selector))
	}
}

func (fpv *PromptAppendTemplate_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*PromptAppendTemplate)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'PromptAppendTemplate_FieldTerminalPathValue' with the value under path in 'PromptAppendTemplate'.
func (fpv *PromptAppendTemplate_FieldTerminalPathValue) CompareWith(source *PromptAppendTemplate) (int, bool) {
	switch fpv.selector {
	case PromptAppendTemplate_FieldPathSelectorText:
		leftValue := fpv.value.(string)
		rightValue := source.GetText()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PromptAppendTemplate_FieldPathSelectorMode:
		leftValue := fpv.value.(PromptVariableMode)
		rightValue := source.GetMode()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case PromptAppendTemplate_FieldPathSelectorOnMissing:
		leftValue := fpv.value.(PromptMissingVarPolicy)
		rightValue := source.GetOnMissing()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for PromptAppendTemplate: %d", fpv.selector))
	}
}

func (fpv *PromptAppendTemplate_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*PromptAppendTemplate))
}

// PromptAppendTemplate_FieldPathArrayItemValue allows storing single item in Path-specific values for PromptAppendTemplate according to their type
// Present only for array (repeated) types.
type PromptAppendTemplate_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	PromptAppendTemplate_FieldPath
	ContainsValue(*PromptAppendTemplate) bool
}

// ParsePromptAppendTemplate_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParsePromptAppendTemplate_FieldPathArrayItemValue(pathStr, valueStr string) (PromptAppendTemplate_FieldPathArrayItemValue, error) {
	fp, err := ParsePromptAppendTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PromptAppendTemplate field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(PromptAppendTemplate_FieldPathArrayItemValue), nil
}

func MustParsePromptAppendTemplate_FieldPathArrayItemValue(pathStr, valueStr string) PromptAppendTemplate_FieldPathArrayItemValue {
	fpaiv, err := ParsePromptAppendTemplate_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type PromptAppendTemplate_FieldTerminalPathArrayItemValue struct {
	PromptAppendTemplate_FieldTerminalPath
	value interface{}
}

var _ PromptAppendTemplate_FieldPathArrayItemValue = (*PromptAppendTemplate_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object PromptAppendTemplate as interface{}
func (fpaiv *PromptAppendTemplate_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *PromptAppendTemplate_FieldTerminalPathArrayItemValue) GetSingle(source *PromptAppendTemplate) (interface{}, bool) {
	return nil, false
}

func (fpaiv *PromptAppendTemplate_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*PromptAppendTemplate))
}

// Contains returns a boolean indicating if value that is being held is present in given 'PromptAppendTemplate'
func (fpaiv *PromptAppendTemplate_FieldTerminalPathArrayItemValue) ContainsValue(source *PromptAppendTemplate) bool {
	slice := fpaiv.PromptAppendTemplate_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// PromptAppendTemplate_FieldPathArrayOfValues allows storing slice of values for PromptAppendTemplate fields according to their type
type PromptAppendTemplate_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	PromptAppendTemplate_FieldPath
}

func ParsePromptAppendTemplate_FieldPathArrayOfValues(pathStr, valuesStr string) (PromptAppendTemplate_FieldPathArrayOfValues, error) {
	fp, err := ParsePromptAppendTemplate_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PromptAppendTemplate field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(PromptAppendTemplate_FieldPathArrayOfValues), nil
}

func MustParsePromptAppendTemplate_FieldPathArrayOfValues(pathStr, valuesStr string) PromptAppendTemplate_FieldPathArrayOfValues {
	fpaov, err := ParsePromptAppendTemplate_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type PromptAppendTemplate_FieldTerminalPathArrayOfValues struct {
	PromptAppendTemplate_FieldTerminalPath
	values interface{}
}

var _ PromptAppendTemplate_FieldPathArrayOfValues = (*PromptAppendTemplate_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *PromptAppendTemplate_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case PromptAppendTemplate_FieldPathSelectorText:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case PromptAppendTemplate_FieldPathSelectorMode:
		for _, v := range fpaov.values.([]PromptVariableMode) {
			values = append(values, v)
		}
	case PromptAppendTemplate_FieldPathSelectorOnMissing:
		for _, v := range fpaov.values.([]PromptMissingVarPolicy) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *PromptAppendTemplate_FieldTerminalPathArrayOfValues) AsTextArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *PromptAppendTemplate_FieldTerminalPathArrayOfValues) AsModeArrayOfValues() ([]PromptVariableMode, bool) {
	res, ok := fpaov.values.([]PromptVariableMode)
	return res, ok
}
func (fpaov *PromptAppendTemplate_FieldTerminalPathArrayOfValues) AsOnMissingArrayOfValues() ([]PromptMissingVarPolicy, bool) {
	res, ok := fpaov.values.([]PromptMissingVarPolicy)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type RAGConfig_FieldPath interface {
	gotenobject.FieldPath
	Selector() RAGConfig_FieldPathSelector
	Get(source *RAGConfig) []interface{}
	GetSingle(source *RAGConfig) (interface{}, bool)
	ClearValue(item *RAGConfig)

	// Those methods build corresponding RAGConfig_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) RAGConfig_FieldPathValue
	WithIArrayOfValues(values interface{}) RAGConfig_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) RAGConfig_FieldPathArrayItemValue
}

type RAGConfig_FieldPathSelector int32

const (
	RAGConfig_FieldPathSelectorSearchIndices     RAGConfig_FieldPathSelector = 0
	RAGConfig_FieldPathSelectorIndexingPolicy    RAGConfig_FieldPathSelector = 1
	RAGConfig_FieldPathSelectorRetrievalLimits   RAGConfig_FieldPathSelector = 2
	RAGConfig_FieldPathSelectorUseAzureNativeRag RAGConfig_FieldPathSelector = 3
)

func (s RAGConfig_FieldPathSelector) String() string {
	switch s {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return "search_indices"
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return "indexing_policy"
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return "retrieval_limits"
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return "use_azure_native_rag"
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", s))
	}
}

func BuildRAGConfig_FieldPath(fp gotenobject.RawFieldPath) (RAGConfig_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object RAGConfig")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "search_indices", "searchIndices", "search-indices":
			return &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorSearchIndices}, nil
		case "indexing_policy", "indexingPolicy", "indexing-policy":
			return &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorIndexingPolicy}, nil
		case "retrieval_limits", "retrievalLimits", "retrieval-limits":
			return &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorRetrievalLimits}, nil
		case "use_azure_native_rag", "useAzureNativeRag", "use-azure-native-rag":
			return &RAGConfig_FieldTerminalPath{selector: RAGConfig_FieldPathSelectorUseAzureNativeRag}, nil
		}
	} else {
		switch fp[0] {
		case "indexing_policy", "indexingPolicy", "indexing-policy":
			if subpath, err := BuildIndexingPolicy_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &RAGConfig_FieldSubPath{selector: RAGConfig_FieldPathSelectorIndexingPolicy, subPath: subpath}, nil
			}
		case "retrieval_limits", "retrievalLimits", "retrieval-limits":
			if subpath, err := BuildRetrievalLimits_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &RAGConfig_FieldSubPath{selector: RAGConfig_FieldPathSelectorRetrievalLimits, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object RAGConfig", fp)
}

func ParseRAGConfig_FieldPath(rawField string) (RAGConfig_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildRAGConfig_FieldPath(fp)
}

func MustParseRAGConfig_FieldPath(rawField string) RAGConfig_FieldPath {
	fp, err := ParseRAGConfig_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type RAGConfig_FieldTerminalPath struct {
	selector RAGConfig_FieldPathSelector
}

var _ RAGConfig_FieldPath = (*RAGConfig_FieldTerminalPath)(nil)

func (fp *RAGConfig_FieldTerminalPath) Selector() RAGConfig_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *RAGConfig_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *RAGConfig_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source RAGConfig
func (fp *RAGConfig_FieldTerminalPath) Get(source *RAGConfig) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case RAGConfig_FieldPathSelectorSearchIndices:
			for _, value := range source.GetSearchIndices() {
				values = append(values, value)
			}
		case RAGConfig_FieldPathSelectorIndexingPolicy:
			if source.IndexingPolicy != nil {
				values = append(values, source.IndexingPolicy)
			}
		case RAGConfig_FieldPathSelectorRetrievalLimits:
			if source.RetrievalLimits != nil {
				values = append(values, source.RetrievalLimits)
			}
		case RAGConfig_FieldPathSelectorUseAzureNativeRag:
			values = append(values, source.UseAzureNativeRag)
		default:
			panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
		}
	}
	return
}

func (fp *RAGConfig_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*RAGConfig))
}

// GetSingle returns value pointed by specific field of from source RAGConfig
func (fp *RAGConfig_FieldTerminalPath) GetSingle(source *RAGConfig) (interface{}, bool) {
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		res := source.GetSearchIndices()
		return res, res != nil
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		res := source.GetIndexingPolicy()
		return res, res != nil
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		res := source.GetRetrievalLimits()
		return res, res != nil
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return source.GetUseAzureNativeRag(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
}

func (fp *RAGConfig_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*RAGConfig))
}

// GetDefault returns a default value of the field type
func (fp *RAGConfig_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return ([]*search_index.Reference)(nil)
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return (*IndexingPolicy)(nil)
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return (*RetrievalLimits)(nil)
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
}

func (fp *RAGConfig_FieldTerminalPath) ClearValue(item *RAGConfig) {
	if item != nil {
		switch fp.selector {
		case RAGConfig_FieldPathSelectorSearchIndices:
			item.SearchIndices = nil
		case RAGConfig_FieldPathSelectorIndexingPolicy:
			item.IndexingPolicy = nil
		case RAGConfig_FieldPathSelectorRetrievalLimits:
			item.RetrievalLimits = nil
		case RAGConfig_FieldPathSelectorUseAzureNativeRag:
			item.UseAzureNativeRag = false
		default:
			panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
		}
	}
}

func (fp *RAGConfig_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*RAGConfig))
}

// IsLeaf - whether field path is holds simple value
func (fp *RAGConfig_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == RAGConfig_FieldPathSelectorSearchIndices ||
		fp.selector == RAGConfig_FieldPathSelectorUseAzureNativeRag
}

func (fp *RAGConfig_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *RAGConfig_FieldTerminalPath) WithIValue(value interface{}) RAGConfig_FieldPathValue {
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return &RAGConfig_FieldTerminalPathValue{RAGConfig_FieldTerminalPath: *fp, value: value.([]*search_index.Reference)}
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return &RAGConfig_FieldTerminalPathValue{RAGConfig_FieldTerminalPath: *fp, value: value.(*IndexingPolicy)}
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return &RAGConfig_FieldTerminalPathValue{RAGConfig_FieldTerminalPath: *fp, value: value.(*RetrievalLimits)}
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return &RAGConfig_FieldTerminalPathValue{RAGConfig_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
}

func (fp *RAGConfig_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *RAGConfig_FieldTerminalPath) WithIArrayOfValues(values interface{}) RAGConfig_FieldPathArrayOfValues {
	fpaov := &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp}
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp, values: values.([][]*search_index.Reference)}
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp, values: values.([]*IndexingPolicy)}
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp, values: values.([]*RetrievalLimits)}
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		return &RAGConfig_FieldTerminalPathArrayOfValues{RAGConfig_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
	return fpaov
}

func (fp *RAGConfig_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *RAGConfig_FieldTerminalPath) WithIArrayItemValue(value interface{}) RAGConfig_FieldPathArrayItemValue {
	switch fp.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return &RAGConfig_FieldTerminalPathArrayItemValue{RAGConfig_FieldTerminalPath: *fp, value: value.(*search_index.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fp.selector))
	}
}

func (fp *RAGConfig_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type RAGConfig_FieldSubPath struct {
	selector RAGConfig_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ RAGConfig_FieldPath = (*RAGConfig_FieldSubPath)(nil)

func (fps *RAGConfig_FieldSubPath) Selector() RAGConfig_FieldPathSelector {
	return fps.selector
}
func (fps *RAGConfig_FieldSubPath) AsIndexingPolicySubPath() (IndexingPolicy_FieldPath, bool) {
	res, ok := fps.subPath.(IndexingPolicy_FieldPath)
	return res, ok
}
func (fps *RAGConfig_FieldSubPath) AsRetrievalLimitsSubPath() (RetrievalLimits_FieldPath, bool) {
	res, ok := fps.subPath.(RetrievalLimits_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *RAGConfig_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *RAGConfig_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source RAGConfig
func (fps *RAGConfig_FieldSubPath) Get(source *RAGConfig) (values []interface{}) {
	switch fps.selector {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		values = append(values, fps.subPath.GetRaw(source.GetIndexingPolicy())...)
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		values = append(values, fps.subPath.GetRaw(source.GetRetrievalLimits())...)
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fps.selector))
	}
	return
}

func (fps *RAGConfig_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*RAGConfig))
}

// GetSingle returns value of selected field from source RAGConfig
func (fps *RAGConfig_FieldSubPath) GetSingle(source *RAGConfig) (interface{}, bool) {
	switch fps.selector {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		if source.GetIndexingPolicy() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetIndexingPolicy())
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		if source.GetRetrievalLimits() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetRetrievalLimits())
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fps.selector))
	}
}

func (fps *RAGConfig_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*RAGConfig))
}

// GetDefault returns a default value of the field type
func (fps *RAGConfig_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *RAGConfig_FieldSubPath) ClearValue(item *RAGConfig) {
	if item != nil {
		switch fps.selector {
		case RAGConfig_FieldPathSelectorIndexingPolicy:
			fps.subPath.ClearValueRaw(item.IndexingPolicy)
		case RAGConfig_FieldPathSelectorRetrievalLimits:
			fps.subPath.ClearValueRaw(item.RetrievalLimits)
		default:
			panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fps.selector))
		}
	}
}

func (fps *RAGConfig_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*RAGConfig))
}

// IsLeaf - whether field path is holds simple value
func (fps *RAGConfig_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *RAGConfig_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&RAGConfig_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *RAGConfig_FieldSubPath) WithIValue(value interface{}) RAGConfig_FieldPathValue {
	return &RAGConfig_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *RAGConfig_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *RAGConfig_FieldSubPath) WithIArrayOfValues(values interface{}) RAGConfig_FieldPathArrayOfValues {
	return &RAGConfig_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *RAGConfig_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *RAGConfig_FieldSubPath) WithIArrayItemValue(value interface{}) RAGConfig_FieldPathArrayItemValue {
	return &RAGConfig_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *RAGConfig_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// RAGConfig_FieldPathValue allows storing values for RAGConfig fields according to their type
type RAGConfig_FieldPathValue interface {
	RAGConfig_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **RAGConfig)
	CompareWith(*RAGConfig) (cmp int, comparable bool)
}

func ParseRAGConfig_FieldPathValue(pathStr, valueStr string) (RAGConfig_FieldPathValue, error) {
	fp, err := ParseRAGConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RAGConfig field path value from %s: %v", valueStr, err)
	}
	return fpv.(RAGConfig_FieldPathValue), nil
}

func MustParseRAGConfig_FieldPathValue(pathStr, valueStr string) RAGConfig_FieldPathValue {
	fpv, err := ParseRAGConfig_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type RAGConfig_FieldTerminalPathValue struct {
	RAGConfig_FieldTerminalPath
	value interface{}
}

var _ RAGConfig_FieldPathValue = (*RAGConfig_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'RAGConfig' as interface{}
func (fpv *RAGConfig_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *RAGConfig_FieldTerminalPathValue) AsSearchIndicesValue() ([]*search_index.Reference, bool) {
	res, ok := fpv.value.([]*search_index.Reference)
	return res, ok
}
func (fpv *RAGConfig_FieldTerminalPathValue) AsIndexingPolicyValue() (*IndexingPolicy, bool) {
	res, ok := fpv.value.(*IndexingPolicy)
	return res, ok
}
func (fpv *RAGConfig_FieldTerminalPathValue) AsRetrievalLimitsValue() (*RetrievalLimits, bool) {
	res, ok := fpv.value.(*RetrievalLimits)
	return res, ok
}
func (fpv *RAGConfig_FieldTerminalPathValue) AsUseAzureNativeRagValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object RAGConfig
func (fpv *RAGConfig_FieldTerminalPathValue) SetTo(target **RAGConfig) {
	if *target == nil {
		*target = new(RAGConfig)
	}
	switch fpv.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		(*target).SearchIndices = fpv.value.([]*search_index.Reference)
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		(*target).IndexingPolicy = fpv.value.(*IndexingPolicy)
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		(*target).RetrievalLimits = fpv.value.(*RetrievalLimits)
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		(*target).UseAzureNativeRag = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpv.selector))
	}
}

func (fpv *RAGConfig_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*RAGConfig)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'RAGConfig_FieldTerminalPathValue' with the value under path in 'RAGConfig'.
func (fpv *RAGConfig_FieldTerminalPathValue) CompareWith(source *RAGConfig) (int, bool) {
	switch fpv.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		return 0, false
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return 0, false
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return 0, false
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		leftValue := fpv.value.(bool)
		rightValue := source.GetUseAzureNativeRag()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpv.selector))
	}
}

func (fpv *RAGConfig_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*RAGConfig))
}

type RAGConfig_FieldSubPathValue struct {
	RAGConfig_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ RAGConfig_FieldPathValue = (*RAGConfig_FieldSubPathValue)(nil)

func (fpvs *RAGConfig_FieldSubPathValue) AsIndexingPolicyPathValue() (IndexingPolicy_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(IndexingPolicy_FieldPathValue)
	return res, ok
}
func (fpvs *RAGConfig_FieldSubPathValue) AsRetrievalLimitsPathValue() (RetrievalLimits_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(RetrievalLimits_FieldPathValue)
	return res, ok
}

func (fpvs *RAGConfig_FieldSubPathValue) SetTo(target **RAGConfig) {
	if *target == nil {
		*target = new(RAGConfig)
	}
	switch fpvs.Selector() {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		fpvs.subPathValue.(IndexingPolicy_FieldPathValue).SetTo(&(*target).IndexingPolicy)
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		fpvs.subPathValue.(RetrievalLimits_FieldPathValue).SetTo(&(*target).RetrievalLimits)
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpvs.Selector()))
	}
}

func (fpvs *RAGConfig_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*RAGConfig)
	fpvs.SetTo(&typedObject)
}

func (fpvs *RAGConfig_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *RAGConfig_FieldSubPathValue) CompareWith(source *RAGConfig) (int, bool) {
	switch fpvs.Selector() {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return fpvs.subPathValue.(IndexingPolicy_FieldPathValue).CompareWith(source.GetIndexingPolicy())
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return fpvs.subPathValue.(RetrievalLimits_FieldPathValue).CompareWith(source.GetRetrievalLimits())
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpvs.Selector()))
	}
}

func (fpvs *RAGConfig_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*RAGConfig))
}

// RAGConfig_FieldPathArrayItemValue allows storing single item in Path-specific values for RAGConfig according to their type
// Present only for array (repeated) types.
type RAGConfig_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	RAGConfig_FieldPath
	ContainsValue(*RAGConfig) bool
}

// ParseRAGConfig_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseRAGConfig_FieldPathArrayItemValue(pathStr, valueStr string) (RAGConfig_FieldPathArrayItemValue, error) {
	fp, err := ParseRAGConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RAGConfig field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(RAGConfig_FieldPathArrayItemValue), nil
}

func MustParseRAGConfig_FieldPathArrayItemValue(pathStr, valueStr string) RAGConfig_FieldPathArrayItemValue {
	fpaiv, err := ParseRAGConfig_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type RAGConfig_FieldTerminalPathArrayItemValue struct {
	RAGConfig_FieldTerminalPath
	value interface{}
}

var _ RAGConfig_FieldPathArrayItemValue = (*RAGConfig_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object RAGConfig as interface{}
func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) AsSearchIndicesItemValue() (*search_index.Reference, bool) {
	res, ok := fpaiv.value.(*search_index.Reference)
	return res, ok
}

func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) GetSingle(source *RAGConfig) (interface{}, bool) {
	return nil, false
}

func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*RAGConfig))
}

// Contains returns a boolean indicating if value that is being held is present in given 'RAGConfig'
func (fpaiv *RAGConfig_FieldTerminalPathArrayItemValue) ContainsValue(source *RAGConfig) bool {
	slice := fpaiv.RAGConfig_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type RAGConfig_FieldSubPathArrayItemValue struct {
	RAGConfig_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *RAGConfig_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *RAGConfig_FieldSubPathArrayItemValue) AsIndexingPolicyPathItemValue() (IndexingPolicy_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(IndexingPolicy_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *RAGConfig_FieldSubPathArrayItemValue) AsRetrievalLimitsPathItemValue() (RetrievalLimits_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(RetrievalLimits_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'RAGConfig'
func (fpaivs *RAGConfig_FieldSubPathArrayItemValue) ContainsValue(source *RAGConfig) bool {
	switch fpaivs.Selector() {
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		return fpaivs.subPathItemValue.(IndexingPolicy_FieldPathArrayItemValue).ContainsValue(source.GetIndexingPolicy())
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		return fpaivs.subPathItemValue.(RetrievalLimits_FieldPathArrayItemValue).ContainsValue(source.GetRetrievalLimits())
	default:
		panic(fmt.Sprintf("Invalid selector for RAGConfig: %d", fpaivs.Selector()))
	}
}

// RAGConfig_FieldPathArrayOfValues allows storing slice of values for RAGConfig fields according to their type
type RAGConfig_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	RAGConfig_FieldPath
}

func ParseRAGConfig_FieldPathArrayOfValues(pathStr, valuesStr string) (RAGConfig_FieldPathArrayOfValues, error) {
	fp, err := ParseRAGConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RAGConfig field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(RAGConfig_FieldPathArrayOfValues), nil
}

func MustParseRAGConfig_FieldPathArrayOfValues(pathStr, valuesStr string) RAGConfig_FieldPathArrayOfValues {
	fpaov, err := ParseRAGConfig_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type RAGConfig_FieldTerminalPathArrayOfValues struct {
	RAGConfig_FieldTerminalPath
	values interface{}
}

var _ RAGConfig_FieldPathArrayOfValues = (*RAGConfig_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case RAGConfig_FieldPathSelectorSearchIndices:
		for _, v := range fpaov.values.([][]*search_index.Reference) {
			values = append(values, v)
		}
	case RAGConfig_FieldPathSelectorIndexingPolicy:
		for _, v := range fpaov.values.([]*IndexingPolicy) {
			values = append(values, v)
		}
	case RAGConfig_FieldPathSelectorRetrievalLimits:
		for _, v := range fpaov.values.([]*RetrievalLimits) {
			values = append(values, v)
		}
	case RAGConfig_FieldPathSelectorUseAzureNativeRag:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) AsSearchIndicesArrayOfValues() ([][]*search_index.Reference, bool) {
	res, ok := fpaov.values.([][]*search_index.Reference)
	return res, ok
}
func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) AsIndexingPolicyArrayOfValues() ([]*IndexingPolicy, bool) {
	res, ok := fpaov.values.([]*IndexingPolicy)
	return res, ok
}
func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) AsRetrievalLimitsArrayOfValues() ([]*RetrievalLimits, bool) {
	res, ok := fpaov.values.([]*RetrievalLimits)
	return res, ok
}
func (fpaov *RAGConfig_FieldTerminalPathArrayOfValues) AsUseAzureNativeRagArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

type RAGConfig_FieldSubPathArrayOfValues struct {
	RAGConfig_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ RAGConfig_FieldPathArrayOfValues = (*RAGConfig_FieldSubPathArrayOfValues)(nil)

func (fpsaov *RAGConfig_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *RAGConfig_FieldSubPathArrayOfValues) AsIndexingPolicyPathArrayOfValues() (IndexingPolicy_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(IndexingPolicy_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *RAGConfig_FieldSubPathArrayOfValues) AsRetrievalLimitsPathArrayOfValues() (RetrievalLimits_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(RetrievalLimits_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type IndexingPolicy_FieldPath interface {
	gotenobject.FieldPath
	Selector() IndexingPolicy_FieldPathSelector
	Get(source *IndexingPolicy) []interface{}
	GetSingle(source *IndexingPolicy) (interface{}, bool)
	ClearValue(item *IndexingPolicy)

	// Those methods build corresponding IndexingPolicy_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) IndexingPolicy_FieldPathValue
	WithIArrayOfValues(values interface{}) IndexingPolicy_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) IndexingPolicy_FieldPathArrayItemValue
}

type IndexingPolicy_FieldPathSelector int32

const (
	IndexingPolicy_FieldPathSelectorChunkSizeTokens    IndexingPolicy_FieldPathSelector = 0
	IndexingPolicy_FieldPathSelectorChunkOverlapTokens IndexingPolicy_FieldPathSelector = 1
	IndexingPolicy_FieldPathSelectorEmbeddingModel     IndexingPolicy_FieldPathSelector = 2
	IndexingPolicy_FieldPathSelectorChunkingStrategy   IndexingPolicy_FieldPathSelector = 3
)

func (s IndexingPolicy_FieldPathSelector) String() string {
	switch s {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return "chunk_size_tokens"
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return "chunk_overlap_tokens"
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return "embedding_model"
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return "chunking_strategy"
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", s))
	}
}

func BuildIndexingPolicy_FieldPath(fp gotenobject.RawFieldPath) (IndexingPolicy_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object IndexingPolicy")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "chunk_size_tokens", "chunkSizeTokens", "chunk-size-tokens":
			return &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkSizeTokens}, nil
		case "chunk_overlap_tokens", "chunkOverlapTokens", "chunk-overlap-tokens":
			return &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkOverlapTokens}, nil
		case "embedding_model", "embeddingModel", "embedding-model":
			return &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorEmbeddingModel}, nil
		case "chunking_strategy", "chunkingStrategy", "chunking-strategy":
			return &IndexingPolicy_FieldTerminalPath{selector: IndexingPolicy_FieldPathSelectorChunkingStrategy}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object IndexingPolicy", fp)
}

func ParseIndexingPolicy_FieldPath(rawField string) (IndexingPolicy_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildIndexingPolicy_FieldPath(fp)
}

func MustParseIndexingPolicy_FieldPath(rawField string) IndexingPolicy_FieldPath {
	fp, err := ParseIndexingPolicy_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type IndexingPolicy_FieldTerminalPath struct {
	selector IndexingPolicy_FieldPathSelector
}

var _ IndexingPolicy_FieldPath = (*IndexingPolicy_FieldTerminalPath)(nil)

func (fp *IndexingPolicy_FieldTerminalPath) Selector() IndexingPolicy_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *IndexingPolicy_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *IndexingPolicy_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source IndexingPolicy
func (fp *IndexingPolicy_FieldTerminalPath) Get(source *IndexingPolicy) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
			values = append(values, source.ChunkSizeTokens)
		case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
			values = append(values, source.ChunkOverlapTokens)
		case IndexingPolicy_FieldPathSelectorEmbeddingModel:
			values = append(values, source.EmbeddingModel)
		case IndexingPolicy_FieldPathSelectorChunkingStrategy:
			values = append(values, source.ChunkingStrategy)
		default:
			panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
		}
	}
	return
}

func (fp *IndexingPolicy_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*IndexingPolicy))
}

// GetSingle returns value pointed by specific field of from source IndexingPolicy
func (fp *IndexingPolicy_FieldTerminalPath) GetSingle(source *IndexingPolicy) (interface{}, bool) {
	switch fp.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return source.GetChunkSizeTokens(), source != nil
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return source.GetChunkOverlapTokens(), source != nil
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return source.GetEmbeddingModel(), source != nil
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return source.GetChunkingStrategy(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*IndexingPolicy))
}

// GetDefault returns a default value of the field type
func (fp *IndexingPolicy_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return uint32(0)
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return uint32(0)
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return ""
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) ClearValue(item *IndexingPolicy) {
	if item != nil {
		switch fp.selector {
		case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
			item.ChunkSizeTokens = uint32(0)
		case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
			item.ChunkOverlapTokens = uint32(0)
		case IndexingPolicy_FieldPathSelectorEmbeddingModel:
			item.EmbeddingModel = ""
		case IndexingPolicy_FieldPathSelectorChunkingStrategy:
			item.ChunkingStrategy = ""
		default:
			panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
		}
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*IndexingPolicy))
}

// IsLeaf - whether field path is holds simple value
func (fp *IndexingPolicy_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == IndexingPolicy_FieldPathSelectorChunkSizeTokens ||
		fp.selector == IndexingPolicy_FieldPathSelectorChunkOverlapTokens ||
		fp.selector == IndexingPolicy_FieldPathSelectorEmbeddingModel ||
		fp.selector == IndexingPolicy_FieldPathSelectorChunkingStrategy
}

func (fp *IndexingPolicy_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *IndexingPolicy_FieldTerminalPath) WithIValue(value interface{}) IndexingPolicy_FieldPathValue {
	switch fp.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return &IndexingPolicy_FieldTerminalPathValue{IndexingPolicy_FieldTerminalPath: *fp, value: value.(uint32)}
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return &IndexingPolicy_FieldTerminalPathValue{IndexingPolicy_FieldTerminalPath: *fp, value: value.(uint32)}
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return &IndexingPolicy_FieldTerminalPathValue{IndexingPolicy_FieldTerminalPath: *fp, value: value.(string)}
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return &IndexingPolicy_FieldTerminalPathValue{IndexingPolicy_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *IndexingPolicy_FieldTerminalPath) WithIArrayOfValues(values interface{}) IndexingPolicy_FieldPathArrayOfValues {
	fpaov := &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp}
	switch fp.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		return &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp, values: values.([]uint32)}
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		return &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp, values: values.([]uint32)}
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		return &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp, values: values.([]string)}
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		return &IndexingPolicy_FieldTerminalPathArrayOfValues{IndexingPolicy_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
	return fpaov
}

func (fp *IndexingPolicy_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *IndexingPolicy_FieldTerminalPath) WithIArrayItemValue(value interface{}) IndexingPolicy_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fp.selector))
	}
}

func (fp *IndexingPolicy_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// IndexingPolicy_FieldPathValue allows storing values for IndexingPolicy fields according to their type
type IndexingPolicy_FieldPathValue interface {
	IndexingPolicy_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **IndexingPolicy)
	CompareWith(*IndexingPolicy) (cmp int, comparable bool)
}

func ParseIndexingPolicy_FieldPathValue(pathStr, valueStr string) (IndexingPolicy_FieldPathValue, error) {
	fp, err := ParseIndexingPolicy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing IndexingPolicy field path value from %s: %v", valueStr, err)
	}
	return fpv.(IndexingPolicy_FieldPathValue), nil
}

func MustParseIndexingPolicy_FieldPathValue(pathStr, valueStr string) IndexingPolicy_FieldPathValue {
	fpv, err := ParseIndexingPolicy_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type IndexingPolicy_FieldTerminalPathValue struct {
	IndexingPolicy_FieldTerminalPath
	value interface{}
}

var _ IndexingPolicy_FieldPathValue = (*IndexingPolicy_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'IndexingPolicy' as interface{}
func (fpv *IndexingPolicy_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *IndexingPolicy_FieldTerminalPathValue) AsChunkSizeTokensValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *IndexingPolicy_FieldTerminalPathValue) AsChunkOverlapTokensValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *IndexingPolicy_FieldTerminalPathValue) AsEmbeddingModelValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *IndexingPolicy_FieldTerminalPathValue) AsChunkingStrategyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object IndexingPolicy
func (fpv *IndexingPolicy_FieldTerminalPathValue) SetTo(target **IndexingPolicy) {
	if *target == nil {
		*target = new(IndexingPolicy)
	}
	switch fpv.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		(*target).ChunkSizeTokens = fpv.value.(uint32)
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		(*target).ChunkOverlapTokens = fpv.value.(uint32)
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		(*target).EmbeddingModel = fpv.value.(string)
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		(*target).ChunkingStrategy = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fpv.selector))
	}
}

func (fpv *IndexingPolicy_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*IndexingPolicy)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'IndexingPolicy_FieldTerminalPathValue' with the value under path in 'IndexingPolicy'.
func (fpv *IndexingPolicy_FieldTerminalPathValue) CompareWith(source *IndexingPolicy) (int, bool) {
	switch fpv.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetChunkSizeTokens()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetChunkOverlapTokens()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		leftValue := fpv.value.(string)
		rightValue := source.GetEmbeddingModel()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		leftValue := fpv.value.(string)
		rightValue := source.GetChunkingStrategy()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for IndexingPolicy: %d", fpv.selector))
	}
}

func (fpv *IndexingPolicy_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*IndexingPolicy))
}

// IndexingPolicy_FieldPathArrayItemValue allows storing single item in Path-specific values for IndexingPolicy according to their type
// Present only for array (repeated) types.
type IndexingPolicy_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	IndexingPolicy_FieldPath
	ContainsValue(*IndexingPolicy) bool
}

// ParseIndexingPolicy_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseIndexingPolicy_FieldPathArrayItemValue(pathStr, valueStr string) (IndexingPolicy_FieldPathArrayItemValue, error) {
	fp, err := ParseIndexingPolicy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing IndexingPolicy field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(IndexingPolicy_FieldPathArrayItemValue), nil
}

func MustParseIndexingPolicy_FieldPathArrayItemValue(pathStr, valueStr string) IndexingPolicy_FieldPathArrayItemValue {
	fpaiv, err := ParseIndexingPolicy_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type IndexingPolicy_FieldTerminalPathArrayItemValue struct {
	IndexingPolicy_FieldTerminalPath
	value interface{}
}

var _ IndexingPolicy_FieldPathArrayItemValue = (*IndexingPolicy_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object IndexingPolicy as interface{}
func (fpaiv *IndexingPolicy_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *IndexingPolicy_FieldTerminalPathArrayItemValue) GetSingle(source *IndexingPolicy) (interface{}, bool) {
	return nil, false
}

func (fpaiv *IndexingPolicy_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*IndexingPolicy))
}

// Contains returns a boolean indicating if value that is being held is present in given 'IndexingPolicy'
func (fpaiv *IndexingPolicy_FieldTerminalPathArrayItemValue) ContainsValue(source *IndexingPolicy) bool {
	slice := fpaiv.IndexingPolicy_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// IndexingPolicy_FieldPathArrayOfValues allows storing slice of values for IndexingPolicy fields according to their type
type IndexingPolicy_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	IndexingPolicy_FieldPath
}

func ParseIndexingPolicy_FieldPathArrayOfValues(pathStr, valuesStr string) (IndexingPolicy_FieldPathArrayOfValues, error) {
	fp, err := ParseIndexingPolicy_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing IndexingPolicy field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(IndexingPolicy_FieldPathArrayOfValues), nil
}

func MustParseIndexingPolicy_FieldPathArrayOfValues(pathStr, valuesStr string) IndexingPolicy_FieldPathArrayOfValues {
	fpaov, err := ParseIndexingPolicy_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type IndexingPolicy_FieldTerminalPathArrayOfValues struct {
	IndexingPolicy_FieldTerminalPath
	values interface{}
}

var _ IndexingPolicy_FieldPathArrayOfValues = (*IndexingPolicy_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case IndexingPolicy_FieldPathSelectorChunkSizeTokens:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case IndexingPolicy_FieldPathSelectorChunkOverlapTokens:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case IndexingPolicy_FieldPathSelectorEmbeddingModel:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case IndexingPolicy_FieldPathSelectorChunkingStrategy:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) AsChunkSizeTokensArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) AsChunkOverlapTokensArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) AsEmbeddingModelArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *IndexingPolicy_FieldTerminalPathArrayOfValues) AsChunkingStrategyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type RetrievalLimits_FieldPath interface {
	gotenobject.FieldPath
	Selector() RetrievalLimits_FieldPathSelector
	Get(source *RetrievalLimits) []interface{}
	GetSingle(source *RetrievalLimits) (interface{}, bool)
	ClearValue(item *RetrievalLimits)

	// Those methods build corresponding RetrievalLimits_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) RetrievalLimits_FieldPathValue
	WithIArrayOfValues(values interface{}) RetrievalLimits_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) RetrievalLimits_FieldPathArrayItemValue
}

type RetrievalLimits_FieldPathSelector int32

const (
	RetrievalLimits_FieldPathSelectorMaxDocuments      RetrievalLimits_FieldPathSelector = 0
	RetrievalLimits_FieldPathSelectorMaxContextTokens  RetrievalLimits_FieldPathSelector = 1
	RetrievalLimits_FieldPathSelectorMinRelevanceScore RetrievalLimits_FieldPathSelector = 2
	RetrievalLimits_FieldPathSelectorRequireCitations  RetrievalLimits_FieldPathSelector = 3
)

func (s RetrievalLimits_FieldPathSelector) String() string {
	switch s {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return "max_documents"
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return "max_context_tokens"
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return "min_relevance_score"
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return "require_citations"
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", s))
	}
}

func BuildRetrievalLimits_FieldPath(fp gotenobject.RawFieldPath) (RetrievalLimits_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object RetrievalLimits")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "max_documents", "maxDocuments", "max-documents":
			return &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMaxDocuments}, nil
		case "max_context_tokens", "maxContextTokens", "max-context-tokens":
			return &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMaxContextTokens}, nil
		case "min_relevance_score", "minRelevanceScore", "min-relevance-score":
			return &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorMinRelevanceScore}, nil
		case "require_citations", "requireCitations", "require-citations":
			return &RetrievalLimits_FieldTerminalPath{selector: RetrievalLimits_FieldPathSelectorRequireCitations}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object RetrievalLimits", fp)
}

func ParseRetrievalLimits_FieldPath(rawField string) (RetrievalLimits_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildRetrievalLimits_FieldPath(fp)
}

func MustParseRetrievalLimits_FieldPath(rawField string) RetrievalLimits_FieldPath {
	fp, err := ParseRetrievalLimits_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type RetrievalLimits_FieldTerminalPath struct {
	selector RetrievalLimits_FieldPathSelector
}

var _ RetrievalLimits_FieldPath = (*RetrievalLimits_FieldTerminalPath)(nil)

func (fp *RetrievalLimits_FieldTerminalPath) Selector() RetrievalLimits_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *RetrievalLimits_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *RetrievalLimits_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source RetrievalLimits
func (fp *RetrievalLimits_FieldTerminalPath) Get(source *RetrievalLimits) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case RetrievalLimits_FieldPathSelectorMaxDocuments:
			values = append(values, source.MaxDocuments)
		case RetrievalLimits_FieldPathSelectorMaxContextTokens:
			values = append(values, source.MaxContextTokens)
		case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
			values = append(values, source.MinRelevanceScore)
		case RetrievalLimits_FieldPathSelectorRequireCitations:
			values = append(values, source.RequireCitations)
		default:
			panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
		}
	}
	return
}

func (fp *RetrievalLimits_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*RetrievalLimits))
}

// GetSingle returns value pointed by specific field of from source RetrievalLimits
func (fp *RetrievalLimits_FieldTerminalPath) GetSingle(source *RetrievalLimits) (interface{}, bool) {
	switch fp.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return source.GetMaxDocuments(), source != nil
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return source.GetMaxContextTokens(), source != nil
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return source.GetMinRelevanceScore(), source != nil
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return source.GetRequireCitations(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*RetrievalLimits))
}

// GetDefault returns a default value of the field type
func (fp *RetrievalLimits_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return uint32(0)
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return uint32(0)
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return float32(0)
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) ClearValue(item *RetrievalLimits) {
	if item != nil {
		switch fp.selector {
		case RetrievalLimits_FieldPathSelectorMaxDocuments:
			item.MaxDocuments = uint32(0)
		case RetrievalLimits_FieldPathSelectorMaxContextTokens:
			item.MaxContextTokens = uint32(0)
		case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
			item.MinRelevanceScore = float32(0)
		case RetrievalLimits_FieldPathSelectorRequireCitations:
			item.RequireCitations = false
		default:
			panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
		}
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*RetrievalLimits))
}

// IsLeaf - whether field path is holds simple value
func (fp *RetrievalLimits_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == RetrievalLimits_FieldPathSelectorMaxDocuments ||
		fp.selector == RetrievalLimits_FieldPathSelectorMaxContextTokens ||
		fp.selector == RetrievalLimits_FieldPathSelectorMinRelevanceScore ||
		fp.selector == RetrievalLimits_FieldPathSelectorRequireCitations
}

func (fp *RetrievalLimits_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *RetrievalLimits_FieldTerminalPath) WithIValue(value interface{}) RetrievalLimits_FieldPathValue {
	switch fp.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return &RetrievalLimits_FieldTerminalPathValue{RetrievalLimits_FieldTerminalPath: *fp, value: value.(uint32)}
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return &RetrievalLimits_FieldTerminalPathValue{RetrievalLimits_FieldTerminalPath: *fp, value: value.(uint32)}
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return &RetrievalLimits_FieldTerminalPathValue{RetrievalLimits_FieldTerminalPath: *fp, value: value.(float32)}
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return &RetrievalLimits_FieldTerminalPathValue{RetrievalLimits_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *RetrievalLimits_FieldTerminalPath) WithIArrayOfValues(values interface{}) RetrievalLimits_FieldPathArrayOfValues {
	fpaov := &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp}
	switch fp.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		return &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp, values: values.([]uint32)}
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		return &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp, values: values.([]uint32)}
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		return &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp, values: values.([]float32)}
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		return &RetrievalLimits_FieldTerminalPathArrayOfValues{RetrievalLimits_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
	return fpaov
}

func (fp *RetrievalLimits_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *RetrievalLimits_FieldTerminalPath) WithIArrayItemValue(value interface{}) RetrievalLimits_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fp.selector))
	}
}

func (fp *RetrievalLimits_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// RetrievalLimits_FieldPathValue allows storing values for RetrievalLimits fields according to their type
type RetrievalLimits_FieldPathValue interface {
	RetrievalLimits_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **RetrievalLimits)
	CompareWith(*RetrievalLimits) (cmp int, comparable bool)
}

func ParseRetrievalLimits_FieldPathValue(pathStr, valueStr string) (RetrievalLimits_FieldPathValue, error) {
	fp, err := ParseRetrievalLimits_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RetrievalLimits field path value from %s: %v", valueStr, err)
	}
	return fpv.(RetrievalLimits_FieldPathValue), nil
}

func MustParseRetrievalLimits_FieldPathValue(pathStr, valueStr string) RetrievalLimits_FieldPathValue {
	fpv, err := ParseRetrievalLimits_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type RetrievalLimits_FieldTerminalPathValue struct {
	RetrievalLimits_FieldTerminalPath
	value interface{}
}

var _ RetrievalLimits_FieldPathValue = (*RetrievalLimits_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'RetrievalLimits' as interface{}
func (fpv *RetrievalLimits_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *RetrievalLimits_FieldTerminalPathValue) AsMaxDocumentsValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *RetrievalLimits_FieldTerminalPathValue) AsMaxContextTokensValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *RetrievalLimits_FieldTerminalPathValue) AsMinRelevanceScoreValue() (float32, bool) {
	res, ok := fpv.value.(float32)
	return res, ok
}
func (fpv *RetrievalLimits_FieldTerminalPathValue) AsRequireCitationsValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object RetrievalLimits
func (fpv *RetrievalLimits_FieldTerminalPathValue) SetTo(target **RetrievalLimits) {
	if *target == nil {
		*target = new(RetrievalLimits)
	}
	switch fpv.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		(*target).MaxDocuments = fpv.value.(uint32)
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		(*target).MaxContextTokens = fpv.value.(uint32)
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		(*target).MinRelevanceScore = fpv.value.(float32)
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		(*target).RequireCitations = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fpv.selector))
	}
}

func (fpv *RetrievalLimits_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*RetrievalLimits)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'RetrievalLimits_FieldTerminalPathValue' with the value under path in 'RetrievalLimits'.
func (fpv *RetrievalLimits_FieldTerminalPathValue) CompareWith(source *RetrievalLimits) (int, bool) {
	switch fpv.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetMaxDocuments()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetMaxContextTokens()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		leftValue := fpv.value.(float32)
		rightValue := source.GetMinRelevanceScore()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		leftValue := fpv.value.(bool)
		rightValue := source.GetRequireCitations()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for RetrievalLimits: %d", fpv.selector))
	}
}

func (fpv *RetrievalLimits_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*RetrievalLimits))
}

// RetrievalLimits_FieldPathArrayItemValue allows storing single item in Path-specific values for RetrievalLimits according to their type
// Present only for array (repeated) types.
type RetrievalLimits_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	RetrievalLimits_FieldPath
	ContainsValue(*RetrievalLimits) bool
}

// ParseRetrievalLimits_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseRetrievalLimits_FieldPathArrayItemValue(pathStr, valueStr string) (RetrievalLimits_FieldPathArrayItemValue, error) {
	fp, err := ParseRetrievalLimits_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RetrievalLimits field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(RetrievalLimits_FieldPathArrayItemValue), nil
}

func MustParseRetrievalLimits_FieldPathArrayItemValue(pathStr, valueStr string) RetrievalLimits_FieldPathArrayItemValue {
	fpaiv, err := ParseRetrievalLimits_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type RetrievalLimits_FieldTerminalPathArrayItemValue struct {
	RetrievalLimits_FieldTerminalPath
	value interface{}
}

var _ RetrievalLimits_FieldPathArrayItemValue = (*RetrievalLimits_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object RetrievalLimits as interface{}
func (fpaiv *RetrievalLimits_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *RetrievalLimits_FieldTerminalPathArrayItemValue) GetSingle(source *RetrievalLimits) (interface{}, bool) {
	return nil, false
}

func (fpaiv *RetrievalLimits_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*RetrievalLimits))
}

// Contains returns a boolean indicating if value that is being held is present in given 'RetrievalLimits'
func (fpaiv *RetrievalLimits_FieldTerminalPathArrayItemValue) ContainsValue(source *RetrievalLimits) bool {
	slice := fpaiv.RetrievalLimits_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// RetrievalLimits_FieldPathArrayOfValues allows storing slice of values for RetrievalLimits fields according to their type
type RetrievalLimits_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	RetrievalLimits_FieldPath
}

func ParseRetrievalLimits_FieldPathArrayOfValues(pathStr, valuesStr string) (RetrievalLimits_FieldPathArrayOfValues, error) {
	fp, err := ParseRetrievalLimits_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing RetrievalLimits field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(RetrievalLimits_FieldPathArrayOfValues), nil
}

func MustParseRetrievalLimits_FieldPathArrayOfValues(pathStr, valuesStr string) RetrievalLimits_FieldPathArrayOfValues {
	fpaov, err := ParseRetrievalLimits_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type RetrievalLimits_FieldTerminalPathArrayOfValues struct {
	RetrievalLimits_FieldTerminalPath
	values interface{}
}

var _ RetrievalLimits_FieldPathArrayOfValues = (*RetrievalLimits_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case RetrievalLimits_FieldPathSelectorMaxDocuments:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case RetrievalLimits_FieldPathSelectorMaxContextTokens:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case RetrievalLimits_FieldPathSelectorMinRelevanceScore:
		for _, v := range fpaov.values.([]float32) {
			values = append(values, v)
		}
	case RetrievalLimits_FieldPathSelectorRequireCitations:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) AsMaxDocumentsArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) AsMaxContextTokensArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) AsMinRelevanceScoreArrayOfValues() ([]float32, bool) {
	res, ok := fpaov.values.([]float32)
	return res, ok
}
func (fpaov *RetrievalLimits_FieldTerminalPathArrayOfValues) AsRequireCitationsArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ReasoningConfig_FieldPath interface {
	gotenobject.FieldPath
	Selector() ReasoningConfig_FieldPathSelector
	Get(source *ReasoningConfig) []interface{}
	GetSingle(source *ReasoningConfig) (interface{}, bool)
	ClearValue(item *ReasoningConfig)

	// Those methods build corresponding ReasoningConfig_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ReasoningConfig_FieldPathValue
	WithIArrayOfValues(values interface{}) ReasoningConfig_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ReasoningConfig_FieldPathArrayItemValue
}

type ReasoningConfig_FieldPathSelector int32

const (
	ReasoningConfig_FieldPathSelectorMaxLevel     ReasoningConfig_FieldPathSelector = 0
	ReasoningConfig_FieldPathSelectorDefaultLevel ReasoningConfig_FieldPathSelector = 1
)

func (s ReasoningConfig_FieldPathSelector) String() string {
	switch s {
	case ReasoningConfig_FieldPathSelectorMaxLevel:
		return "max_level"
	case ReasoningConfig_FieldPathSelectorDefaultLevel:
		return "default_level"
	default:
		panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", s))
	}
}

func BuildReasoningConfig_FieldPath(fp gotenobject.RawFieldPath) (ReasoningConfig_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ReasoningConfig")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "max_level", "maxLevel", "max-level":
			return &ReasoningConfig_FieldTerminalPath{selector: ReasoningConfig_FieldPathSelectorMaxLevel}, nil
		case "default_level", "defaultLevel", "default-level":
			return &ReasoningConfig_FieldTerminalPath{selector: ReasoningConfig_FieldPathSelectorDefaultLevel}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ReasoningConfig", fp)
}

func ParseReasoningConfig_FieldPath(rawField string) (ReasoningConfig_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildReasoningConfig_FieldPath(fp)
}

func MustParseReasoningConfig_FieldPath(rawField string) ReasoningConfig_FieldPath {
	fp, err := ParseReasoningConfig_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ReasoningConfig_FieldTerminalPath struct {
	selector ReasoningConfig_FieldPathSelector
}

var _ ReasoningConfig_FieldPath = (*ReasoningConfig_FieldTerminalPath)(nil)

func (fp *ReasoningConfig_FieldTerminalPath) Selector() ReasoningConfig_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ReasoningConfig_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ReasoningConfig_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ReasoningConfig
func (fp *ReasoningConfig_FieldTerminalPath) Get(source *ReasoningConfig) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ReasoningConfig_FieldPathSelectorMaxLevel:
			values = append(values, source.MaxLevel)
		case ReasoningConfig_FieldPathSelectorDefaultLevel:
			values = append(values, source.DefaultLevel)
		default:
			panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fp.selector))
		}
	}
	return
}

func (fp *ReasoningConfig_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ReasoningConfig))
}

// GetSingle returns value pointed by specific field of from source ReasoningConfig
func (fp *ReasoningConfig_FieldTerminalPath) GetSingle(source *ReasoningConfig) (interface{}, bool) {
	switch fp.selector {
	case ReasoningConfig_FieldPathSelectorMaxLevel:
		return source.GetMaxLevel(), source != nil
	case ReasoningConfig_FieldPathSelectorDefaultLevel:
		return source.GetDefaultLevel(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fp.selector))
	}
}

func (fp *ReasoningConfig_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ReasoningConfig))
}

// GetDefault returns a default value of the field type
func (fp *ReasoningConfig_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ReasoningConfig_FieldPathSelectorMaxLevel:
		return common_client.ReasoningLevel_REASONING_LEVEL_DEFAULT
	case ReasoningConfig_FieldPathSelectorDefaultLevel:
		return common_client.ReasoningLevel_REASONING_LEVEL_DEFAULT
	default:
		panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fp.selector))
	}
}

func (fp *ReasoningConfig_FieldTerminalPath) ClearValue(item *ReasoningConfig) {
	if item != nil {
		switch fp.selector {
		case ReasoningConfig_FieldPathSelectorMaxLevel:
			item.MaxLevel = common_client.ReasoningLevel_REASONING_LEVEL_DEFAULT
		case ReasoningConfig_FieldPathSelectorDefaultLevel:
			item.DefaultLevel = common_client.ReasoningLevel_REASONING_LEVEL_DEFAULT
		default:
			panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fp.selector))
		}
	}
}

func (fp *ReasoningConfig_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ReasoningConfig))
}

// IsLeaf - whether field path is holds simple value
func (fp *ReasoningConfig_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ReasoningConfig_FieldPathSelectorMaxLevel ||
		fp.selector == ReasoningConfig_FieldPathSelectorDefaultLevel
}

func (fp *ReasoningConfig_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ReasoningConfig_FieldTerminalPath) WithIValue(value interface{}) ReasoningConfig_FieldPathValue {
	switch fp.selector {
	case ReasoningConfig_FieldPathSelectorMaxLevel:
		return &ReasoningConfig_FieldTerminalPathValue{ReasoningConfig_FieldTerminalPath: *fp, value: value.(common_client.ReasoningLevel)}
	case ReasoningConfig_FieldPathSelectorDefaultLevel:
		return &ReasoningConfig_FieldTerminalPathValue{ReasoningConfig_FieldTerminalPath: *fp, value: value.(common_client.ReasoningLevel)}
	default:
		panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fp.selector))
	}
}

func (fp *ReasoningConfig_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ReasoningConfig_FieldTerminalPath) WithIArrayOfValues(values interface{}) ReasoningConfig_FieldPathArrayOfValues {
	fpaov := &ReasoningConfig_FieldTerminalPathArrayOfValues{ReasoningConfig_FieldTerminalPath: *fp}
	switch fp.selector {
	case ReasoningConfig_FieldPathSelectorMaxLevel:
		return &ReasoningConfig_FieldTerminalPathArrayOfValues{ReasoningConfig_FieldTerminalPath: *fp, values: values.([]common_client.ReasoningLevel)}
	case ReasoningConfig_FieldPathSelectorDefaultLevel:
		return &ReasoningConfig_FieldTerminalPathArrayOfValues{ReasoningConfig_FieldTerminalPath: *fp, values: values.([]common_client.ReasoningLevel)}
	default:
		panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fp.selector))
	}
	return fpaov
}

func (fp *ReasoningConfig_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ReasoningConfig_FieldTerminalPath) WithIArrayItemValue(value interface{}) ReasoningConfig_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fp.selector))
	}
}

func (fp *ReasoningConfig_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ReasoningConfig_FieldPathValue allows storing values for ReasoningConfig fields according to their type
type ReasoningConfig_FieldPathValue interface {
	ReasoningConfig_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ReasoningConfig)
	CompareWith(*ReasoningConfig) (cmp int, comparable bool)
}

func ParseReasoningConfig_FieldPathValue(pathStr, valueStr string) (ReasoningConfig_FieldPathValue, error) {
	fp, err := ParseReasoningConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReasoningConfig field path value from %s: %v", valueStr, err)
	}
	return fpv.(ReasoningConfig_FieldPathValue), nil
}

func MustParseReasoningConfig_FieldPathValue(pathStr, valueStr string) ReasoningConfig_FieldPathValue {
	fpv, err := ParseReasoningConfig_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ReasoningConfig_FieldTerminalPathValue struct {
	ReasoningConfig_FieldTerminalPath
	value interface{}
}

var _ ReasoningConfig_FieldPathValue = (*ReasoningConfig_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ReasoningConfig' as interface{}
func (fpv *ReasoningConfig_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ReasoningConfig_FieldTerminalPathValue) AsMaxLevelValue() (common_client.ReasoningLevel, bool) {
	res, ok := fpv.value.(common_client.ReasoningLevel)
	return res, ok
}
func (fpv *ReasoningConfig_FieldTerminalPathValue) AsDefaultLevelValue() (common_client.ReasoningLevel, bool) {
	res, ok := fpv.value.(common_client.ReasoningLevel)
	return res, ok
}

// SetTo stores value for selected field for object ReasoningConfig
func (fpv *ReasoningConfig_FieldTerminalPathValue) SetTo(target **ReasoningConfig) {
	if *target == nil {
		*target = new(ReasoningConfig)
	}
	switch fpv.selector {
	case ReasoningConfig_FieldPathSelectorMaxLevel:
		(*target).MaxLevel = fpv.value.(common_client.ReasoningLevel)
	case ReasoningConfig_FieldPathSelectorDefaultLevel:
		(*target).DefaultLevel = fpv.value.(common_client.ReasoningLevel)
	default:
		panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fpv.selector))
	}
}

func (fpv *ReasoningConfig_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ReasoningConfig)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ReasoningConfig_FieldTerminalPathValue' with the value under path in 'ReasoningConfig'.
func (fpv *ReasoningConfig_FieldTerminalPathValue) CompareWith(source *ReasoningConfig) (int, bool) {
	switch fpv.selector {
	case ReasoningConfig_FieldPathSelectorMaxLevel:
		leftValue := fpv.value.(common_client.ReasoningLevel)
		rightValue := source.GetMaxLevel()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ReasoningConfig_FieldPathSelectorDefaultLevel:
		leftValue := fpv.value.(common_client.ReasoningLevel)
		rightValue := source.GetDefaultLevel()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ReasoningConfig: %d", fpv.selector))
	}
}

func (fpv *ReasoningConfig_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ReasoningConfig))
}

// ReasoningConfig_FieldPathArrayItemValue allows storing single item in Path-specific values for ReasoningConfig according to their type
// Present only for array (repeated) types.
type ReasoningConfig_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ReasoningConfig_FieldPath
	ContainsValue(*ReasoningConfig) bool
}

// ParseReasoningConfig_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseReasoningConfig_FieldPathArrayItemValue(pathStr, valueStr string) (ReasoningConfig_FieldPathArrayItemValue, error) {
	fp, err := ParseReasoningConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReasoningConfig field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ReasoningConfig_FieldPathArrayItemValue), nil
}

func MustParseReasoningConfig_FieldPathArrayItemValue(pathStr, valueStr string) ReasoningConfig_FieldPathArrayItemValue {
	fpaiv, err := ParseReasoningConfig_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ReasoningConfig_FieldTerminalPathArrayItemValue struct {
	ReasoningConfig_FieldTerminalPath
	value interface{}
}

var _ ReasoningConfig_FieldPathArrayItemValue = (*ReasoningConfig_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ReasoningConfig as interface{}
func (fpaiv *ReasoningConfig_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ReasoningConfig_FieldTerminalPathArrayItemValue) GetSingle(source *ReasoningConfig) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ReasoningConfig_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ReasoningConfig))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ReasoningConfig'
func (fpaiv *ReasoningConfig_FieldTerminalPathArrayItemValue) ContainsValue(source *ReasoningConfig) bool {
	slice := fpaiv.ReasoningConfig_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ReasoningConfig_FieldPathArrayOfValues allows storing slice of values for ReasoningConfig fields according to their type
type ReasoningConfig_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ReasoningConfig_FieldPath
}

func ParseReasoningConfig_FieldPathArrayOfValues(pathStr, valuesStr string) (ReasoningConfig_FieldPathArrayOfValues, error) {
	fp, err := ParseReasoningConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReasoningConfig field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ReasoningConfig_FieldPathArrayOfValues), nil
}

func MustParseReasoningConfig_FieldPathArrayOfValues(pathStr, valuesStr string) ReasoningConfig_FieldPathArrayOfValues {
	fpaov, err := ParseReasoningConfig_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ReasoningConfig_FieldTerminalPathArrayOfValues struct {
	ReasoningConfig_FieldTerminalPath
	values interface{}
}

var _ ReasoningConfig_FieldPathArrayOfValues = (*ReasoningConfig_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ReasoningConfig_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ReasoningConfig_FieldPathSelectorMaxLevel:
		for _, v := range fpaov.values.([]common_client.ReasoningLevel) {
			values = append(values, v)
		}
	case ReasoningConfig_FieldPathSelectorDefaultLevel:
		for _, v := range fpaov.values.([]common_client.ReasoningLevel) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ReasoningConfig_FieldTerminalPathArrayOfValues) AsMaxLevelArrayOfValues() ([]common_client.ReasoningLevel, bool) {
	res, ok := fpaov.values.([]common_client.ReasoningLevel)
	return res, ok
}
func (fpaov *ReasoningConfig_FieldTerminalPathArrayOfValues) AsDefaultLevelArrayOfValues() ([]common_client.ReasoningLevel, bool) {
	res, ok := fpaov.values.([]common_client.ReasoningLevel)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ToolSafetyConfig_FieldPath interface {
	gotenobject.FieldPath
	Selector() ToolSafetyConfig_FieldPathSelector
	Get(source *ToolSafetyConfig) []interface{}
	GetSingle(source *ToolSafetyConfig) (interface{}, bool)
	ClearValue(item *ToolSafetyConfig)

	// Those methods build corresponding ToolSafetyConfig_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ToolSafetyConfig_FieldPathValue
	WithIArrayOfValues(values interface{}) ToolSafetyConfig_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ToolSafetyConfig_FieldPathArrayItemValue
}

type ToolSafetyConfig_FieldPathSelector int32

const (
	ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls          ToolSafetyConfig_FieldPathSelector = 0
	ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls ToolSafetyConfig_FieldPathSelector = 1
	ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls      ToolSafetyConfig_FieldPathSelector = 2
)

func (s ToolSafetyConfig_FieldPathSelector) String() string {
	switch s {
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
		return "max_consecutive_tool_calls"
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
		return "max_consecutive_identical_tool_calls"
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
		return "max_consecutive_same_tool_calls"
	default:
		panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", s))
	}
}

func BuildToolSafetyConfig_FieldPath(fp gotenobject.RawFieldPath) (ToolSafetyConfig_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ToolSafetyConfig")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "max_consecutive_tool_calls", "maxConsecutiveToolCalls", "max-consecutive-tool-calls":
			return &ToolSafetyConfig_FieldTerminalPath{selector: ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls}, nil
		case "max_consecutive_identical_tool_calls", "maxConsecutiveIdenticalToolCalls", "max-consecutive-identical-tool-calls":
			return &ToolSafetyConfig_FieldTerminalPath{selector: ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls}, nil
		case "max_consecutive_same_tool_calls", "maxConsecutiveSameToolCalls", "max-consecutive-same-tool-calls":
			return &ToolSafetyConfig_FieldTerminalPath{selector: ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ToolSafetyConfig", fp)
}

func ParseToolSafetyConfig_FieldPath(rawField string) (ToolSafetyConfig_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildToolSafetyConfig_FieldPath(fp)
}

func MustParseToolSafetyConfig_FieldPath(rawField string) ToolSafetyConfig_FieldPath {
	fp, err := ParseToolSafetyConfig_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ToolSafetyConfig_FieldTerminalPath struct {
	selector ToolSafetyConfig_FieldPathSelector
}

var _ ToolSafetyConfig_FieldPath = (*ToolSafetyConfig_FieldTerminalPath)(nil)

func (fp *ToolSafetyConfig_FieldTerminalPath) Selector() ToolSafetyConfig_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ToolSafetyConfig_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ToolSafetyConfig_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ToolSafetyConfig
func (fp *ToolSafetyConfig_FieldTerminalPath) Get(source *ToolSafetyConfig) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
			values = append(values, source.MaxConsecutiveToolCalls)
		case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
			values = append(values, source.MaxConsecutiveIdenticalToolCalls)
		case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
			values = append(values, source.MaxConsecutiveSameToolCalls)
		default:
			panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fp.selector))
		}
	}
	return
}

func (fp *ToolSafetyConfig_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ToolSafetyConfig))
}

// GetSingle returns value pointed by specific field of from source ToolSafetyConfig
func (fp *ToolSafetyConfig_FieldTerminalPath) GetSingle(source *ToolSafetyConfig) (interface{}, bool) {
	switch fp.selector {
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
		return source.GetMaxConsecutiveToolCalls(), source != nil
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
		return source.GetMaxConsecutiveIdenticalToolCalls(), source != nil
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
		return source.GetMaxConsecutiveSameToolCalls(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fp.selector))
	}
}

func (fp *ToolSafetyConfig_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ToolSafetyConfig))
}

// GetDefault returns a default value of the field type
func (fp *ToolSafetyConfig_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
		return uint32(0)
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
		return uint32(0)
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
		return uint32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fp.selector))
	}
}

func (fp *ToolSafetyConfig_FieldTerminalPath) ClearValue(item *ToolSafetyConfig) {
	if item != nil {
		switch fp.selector {
		case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
			item.MaxConsecutiveToolCalls = uint32(0)
		case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
			item.MaxConsecutiveIdenticalToolCalls = uint32(0)
		case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
			item.MaxConsecutiveSameToolCalls = uint32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fp.selector))
		}
	}
}

func (fp *ToolSafetyConfig_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ToolSafetyConfig))
}

// IsLeaf - whether field path is holds simple value
func (fp *ToolSafetyConfig_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls ||
		fp.selector == ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls ||
		fp.selector == ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls
}

func (fp *ToolSafetyConfig_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ToolSafetyConfig_FieldTerminalPath) WithIValue(value interface{}) ToolSafetyConfig_FieldPathValue {
	switch fp.selector {
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
		return &ToolSafetyConfig_FieldTerminalPathValue{ToolSafetyConfig_FieldTerminalPath: *fp, value: value.(uint32)}
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
		return &ToolSafetyConfig_FieldTerminalPathValue{ToolSafetyConfig_FieldTerminalPath: *fp, value: value.(uint32)}
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
		return &ToolSafetyConfig_FieldTerminalPathValue{ToolSafetyConfig_FieldTerminalPath: *fp, value: value.(uint32)}
	default:
		panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fp.selector))
	}
}

func (fp *ToolSafetyConfig_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ToolSafetyConfig_FieldTerminalPath) WithIArrayOfValues(values interface{}) ToolSafetyConfig_FieldPathArrayOfValues {
	fpaov := &ToolSafetyConfig_FieldTerminalPathArrayOfValues{ToolSafetyConfig_FieldTerminalPath: *fp}
	switch fp.selector {
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
		return &ToolSafetyConfig_FieldTerminalPathArrayOfValues{ToolSafetyConfig_FieldTerminalPath: *fp, values: values.([]uint32)}
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
		return &ToolSafetyConfig_FieldTerminalPathArrayOfValues{ToolSafetyConfig_FieldTerminalPath: *fp, values: values.([]uint32)}
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
		return &ToolSafetyConfig_FieldTerminalPathArrayOfValues{ToolSafetyConfig_FieldTerminalPath: *fp, values: values.([]uint32)}
	default:
		panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fp.selector))
	}
	return fpaov
}

func (fp *ToolSafetyConfig_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ToolSafetyConfig_FieldTerminalPath) WithIArrayItemValue(value interface{}) ToolSafetyConfig_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fp.selector))
	}
}

func (fp *ToolSafetyConfig_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ToolSafetyConfig_FieldPathValue allows storing values for ToolSafetyConfig fields according to their type
type ToolSafetyConfig_FieldPathValue interface {
	ToolSafetyConfig_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ToolSafetyConfig)
	CompareWith(*ToolSafetyConfig) (cmp int, comparable bool)
}

func ParseToolSafetyConfig_FieldPathValue(pathStr, valueStr string) (ToolSafetyConfig_FieldPathValue, error) {
	fp, err := ParseToolSafetyConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ToolSafetyConfig field path value from %s: %v", valueStr, err)
	}
	return fpv.(ToolSafetyConfig_FieldPathValue), nil
}

func MustParseToolSafetyConfig_FieldPathValue(pathStr, valueStr string) ToolSafetyConfig_FieldPathValue {
	fpv, err := ParseToolSafetyConfig_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ToolSafetyConfig_FieldTerminalPathValue struct {
	ToolSafetyConfig_FieldTerminalPath
	value interface{}
}

var _ ToolSafetyConfig_FieldPathValue = (*ToolSafetyConfig_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ToolSafetyConfig' as interface{}
func (fpv *ToolSafetyConfig_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ToolSafetyConfig_FieldTerminalPathValue) AsMaxConsecutiveToolCallsValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *ToolSafetyConfig_FieldTerminalPathValue) AsMaxConsecutiveIdenticalToolCallsValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}
func (fpv *ToolSafetyConfig_FieldTerminalPathValue) AsMaxConsecutiveSameToolCallsValue() (uint32, bool) {
	res, ok := fpv.value.(uint32)
	return res, ok
}

// SetTo stores value for selected field for object ToolSafetyConfig
func (fpv *ToolSafetyConfig_FieldTerminalPathValue) SetTo(target **ToolSafetyConfig) {
	if *target == nil {
		*target = new(ToolSafetyConfig)
	}
	switch fpv.selector {
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
		(*target).MaxConsecutiveToolCalls = fpv.value.(uint32)
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
		(*target).MaxConsecutiveIdenticalToolCalls = fpv.value.(uint32)
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
		(*target).MaxConsecutiveSameToolCalls = fpv.value.(uint32)
	default:
		panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fpv.selector))
	}
}

func (fpv *ToolSafetyConfig_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ToolSafetyConfig)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ToolSafetyConfig_FieldTerminalPathValue' with the value under path in 'ToolSafetyConfig'.
func (fpv *ToolSafetyConfig_FieldTerminalPathValue) CompareWith(source *ToolSafetyConfig) (int, bool) {
	switch fpv.selector {
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetMaxConsecutiveToolCalls()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetMaxConsecutiveIdenticalToolCalls()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
		leftValue := fpv.value.(uint32)
		rightValue := source.GetMaxConsecutiveSameToolCalls()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ToolSafetyConfig: %d", fpv.selector))
	}
}

func (fpv *ToolSafetyConfig_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ToolSafetyConfig))
}

// ToolSafetyConfig_FieldPathArrayItemValue allows storing single item in Path-specific values for ToolSafetyConfig according to their type
// Present only for array (repeated) types.
type ToolSafetyConfig_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ToolSafetyConfig_FieldPath
	ContainsValue(*ToolSafetyConfig) bool
}

// ParseToolSafetyConfig_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseToolSafetyConfig_FieldPathArrayItemValue(pathStr, valueStr string) (ToolSafetyConfig_FieldPathArrayItemValue, error) {
	fp, err := ParseToolSafetyConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ToolSafetyConfig field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ToolSafetyConfig_FieldPathArrayItemValue), nil
}

func MustParseToolSafetyConfig_FieldPathArrayItemValue(pathStr, valueStr string) ToolSafetyConfig_FieldPathArrayItemValue {
	fpaiv, err := ParseToolSafetyConfig_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ToolSafetyConfig_FieldTerminalPathArrayItemValue struct {
	ToolSafetyConfig_FieldTerminalPath
	value interface{}
}

var _ ToolSafetyConfig_FieldPathArrayItemValue = (*ToolSafetyConfig_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ToolSafetyConfig as interface{}
func (fpaiv *ToolSafetyConfig_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ToolSafetyConfig_FieldTerminalPathArrayItemValue) GetSingle(source *ToolSafetyConfig) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ToolSafetyConfig_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ToolSafetyConfig))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ToolSafetyConfig'
func (fpaiv *ToolSafetyConfig_FieldTerminalPathArrayItemValue) ContainsValue(source *ToolSafetyConfig) bool {
	slice := fpaiv.ToolSafetyConfig_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ToolSafetyConfig_FieldPathArrayOfValues allows storing slice of values for ToolSafetyConfig fields according to their type
type ToolSafetyConfig_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ToolSafetyConfig_FieldPath
}

func ParseToolSafetyConfig_FieldPathArrayOfValues(pathStr, valuesStr string) (ToolSafetyConfig_FieldPathArrayOfValues, error) {
	fp, err := ParseToolSafetyConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ToolSafetyConfig field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ToolSafetyConfig_FieldPathArrayOfValues), nil
}

func MustParseToolSafetyConfig_FieldPathArrayOfValues(pathStr, valuesStr string) ToolSafetyConfig_FieldPathArrayOfValues {
	fpaov, err := ParseToolSafetyConfig_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ToolSafetyConfig_FieldTerminalPathArrayOfValues struct {
	ToolSafetyConfig_FieldTerminalPath
	values interface{}
}

var _ ToolSafetyConfig_FieldPathArrayOfValues = (*ToolSafetyConfig_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ToolSafetyConfig_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveToolCalls:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveIdenticalToolCalls:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	case ToolSafetyConfig_FieldPathSelectorMaxConsecutiveSameToolCalls:
		for _, v := range fpaov.values.([]uint32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ToolSafetyConfig_FieldTerminalPathArrayOfValues) AsMaxConsecutiveToolCallsArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *ToolSafetyConfig_FieldTerminalPathArrayOfValues) AsMaxConsecutiveIdenticalToolCallsArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
func (fpaov *ToolSafetyConfig_FieldTerminalPathArrayOfValues) AsMaxConsecutiveSameToolCallsArrayOfValues() ([]uint32, bool) {
	res, ok := fpaov.values.([]uint32)
	return res, ok
}
