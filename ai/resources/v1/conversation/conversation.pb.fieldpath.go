// Code generated by protoc-gen-goten-object
// File: edgelq/ai/proto/v1/conversation.proto
// DO NOT EDIT!!!

package conversation

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
	"github.com/cloudwan/goten-sdk/runtime/strcase"
)

// proto imports
import (
	common_client "github.com/cloudwan/edgelq-sdk/ai/client/v1/common"
	capability_template "github.com/cloudwan/edgelq-sdk/ai/resources/v1/capability_template"
	chat_model "github.com/cloudwan/edgelq-sdk/ai/resources/v1/chat_model"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1/project"
	iam_user "github.com/cloudwan/edgelq-sdk/iam/resources/v1/user"
	meta "github.com/cloudwan/goten-sdk/types/meta"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &capability_template.CapabilityTemplate{}
	_ = &chat_model.ChatModel{}
	_ = &common_client.Message{}
	_ = &iam_project.Project{}
	_ = &iam_user.User{}
	_ = &durationpb.Duration{}
	_ = &timestamppb.Timestamp{}
	_ = &meta.Meta{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Conversation_FieldPath interface {
	gotenobject.FieldPath
	Selector() Conversation_FieldPathSelector
	Get(source *Conversation) []interface{}
	GetSingle(source *Conversation) (interface{}, bool)
	ClearValue(item *Conversation)

	// Those methods build corresponding Conversation_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Conversation_FieldPathValue
	WithIArrayOfValues(values interface{}) Conversation_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Conversation_FieldPathArrayItemValue
}

type Conversation_FieldPathSelector int32

const (
	Conversation_FieldPathSelectorName               Conversation_FieldPathSelector = 0
	Conversation_FieldPathSelectorMetadata           Conversation_FieldPathSelector = 1
	Conversation_FieldPathSelectorTitle              Conversation_FieldPathSelector = 2
	Conversation_FieldPathSelectorConfiguredTitle    Conversation_FieldPathSelector = 3
	Conversation_FieldPathSelectorArchived           Conversation_FieldPathSelector = 4
	Conversation_FieldPathSelectorIsPrivate          Conversation_FieldPathSelector = 5
	Conversation_FieldPathSelectorLastActivityTime   Conversation_FieldPathSelector = 6
	Conversation_FieldPathSelectorTurns              Conversation_FieldPathSelector = 7
	Conversation_FieldPathSelectorUsageByModel       Conversation_FieldPathSelector = 8
	Conversation_FieldPathSelectorFailedTurns        Conversation_FieldPathSelector = 9
	Conversation_FieldPathSelectorReplacedTurnGroups Conversation_FieldPathSelector = 10
)

func (s Conversation_FieldPathSelector) String() string {
	switch s {
	case Conversation_FieldPathSelectorName:
		return "name"
	case Conversation_FieldPathSelectorMetadata:
		return "metadata"
	case Conversation_FieldPathSelectorTitle:
		return "title"
	case Conversation_FieldPathSelectorConfiguredTitle:
		return "configured_title"
	case Conversation_FieldPathSelectorArchived:
		return "archived"
	case Conversation_FieldPathSelectorIsPrivate:
		return "is_private"
	case Conversation_FieldPathSelectorLastActivityTime:
		return "last_activity_time"
	case Conversation_FieldPathSelectorTurns:
		return "turns"
	case Conversation_FieldPathSelectorUsageByModel:
		return "usage_by_model"
	case Conversation_FieldPathSelectorFailedTurns:
		return "failed_turns"
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		return "replaced_turn_groups"
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", s))
	}
}

func BuildConversation_FieldPath(fp gotenobject.RawFieldPath) (Conversation_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Conversation")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorName}, nil
		case "metadata":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorMetadata}, nil
		case "title":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorTitle}, nil
		case "configured_title", "configuredTitle", "configured-title":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorConfiguredTitle}, nil
		case "archived":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorArchived}, nil
		case "is_private", "isPrivate", "is-private":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorIsPrivate}, nil
		case "last_activity_time", "lastActivityTime", "last-activity-time":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorLastActivityTime}, nil
		case "turns":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorTurns}, nil
		case "usage_by_model", "usageByModel", "usage-by-model":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorUsageByModel}, nil
		case "failed_turns", "failedTurns", "failed-turns":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorFailedTurns}, nil
		case "replaced_turn_groups", "replacedTurnGroups", "replaced-turn-groups":
			return &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorReplacedTurnGroups}, nil
		}
	} else {
		switch fp[0] {
		case "metadata":
			if subpath, err := meta.BuildMeta_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Conversation_FieldSubPath{selector: Conversation_FieldPathSelectorMetadata, subPath: subpath}, nil
			}
		case "turns":
			if subpath, err := BuildConversationTurn_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Conversation_FieldSubPath{selector: Conversation_FieldPathSelectorTurns, subPath: subpath}, nil
			}
		case "failed_turns", "failedTurns", "failed-turns":
			if subpath, err := BuildConversationTurn_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Conversation_FieldSubPath{selector: Conversation_FieldPathSelectorFailedTurns, subPath: subpath}, nil
			}
		case "replaced_turn_groups", "replacedTurnGroups", "replaced-turn-groups":
			if subpath, err := BuildReplacedTurnGroup_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Conversation_FieldSubPath{selector: Conversation_FieldPathSelectorReplacedTurnGroups, subPath: subpath}, nil
			}
		case "usage_by_model", "usageByModel", "usage-by-model":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object Conversation)", fp)
			}
			return &Conversation_FieldPathMap{selector: Conversation_FieldPathSelectorUsageByModel, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Conversation", fp)
}

func ParseConversation_FieldPath(rawField string) (Conversation_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildConversation_FieldPath(fp)
}

func MustParseConversation_FieldPath(rawField string) Conversation_FieldPath {
	fp, err := ParseConversation_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Conversation_FieldTerminalPath struct {
	selector Conversation_FieldPathSelector
}

var _ Conversation_FieldPath = (*Conversation_FieldTerminalPath)(nil)

func (fp *Conversation_FieldTerminalPath) Selector() Conversation_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Conversation_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Conversation_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Conversation
func (fp *Conversation_FieldTerminalPath) Get(source *Conversation) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Conversation_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		case Conversation_FieldPathSelectorMetadata:
			if source.Metadata != nil {
				values = append(values, source.Metadata)
			}
		case Conversation_FieldPathSelectorTitle:
			values = append(values, source.Title)
		case Conversation_FieldPathSelectorConfiguredTitle:
			values = append(values, source.ConfiguredTitle)
		case Conversation_FieldPathSelectorArchived:
			values = append(values, source.Archived)
		case Conversation_FieldPathSelectorIsPrivate:
			values = append(values, source.IsPrivate)
		case Conversation_FieldPathSelectorLastActivityTime:
			if source.LastActivityTime != nil {
				values = append(values, source.LastActivityTime)
			}
		case Conversation_FieldPathSelectorTurns:
			for _, value := range source.GetTurns() {
				values = append(values, value)
			}
		case Conversation_FieldPathSelectorUsageByModel:
			if source.UsageByModel != nil {
				values = append(values, source.UsageByModel)
			}
		case Conversation_FieldPathSelectorFailedTurns:
			for _, value := range source.GetFailedTurns() {
				values = append(values, value)
			}
		case Conversation_FieldPathSelectorReplacedTurnGroups:
			for _, value := range source.GetReplacedTurnGroups() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Conversation: %d", fp.selector))
		}
	}
	return
}

func (fp *Conversation_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Conversation))
}

// GetSingle returns value pointed by specific field of from source Conversation
func (fp *Conversation_FieldTerminalPath) GetSingle(source *Conversation) (interface{}, bool) {
	switch fp.selector {
	case Conversation_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	case Conversation_FieldPathSelectorMetadata:
		res := source.GetMetadata()
		return res, res != nil
	case Conversation_FieldPathSelectorTitle:
		return source.GetTitle(), source != nil
	case Conversation_FieldPathSelectorConfiguredTitle:
		return source.GetConfiguredTitle(), source != nil
	case Conversation_FieldPathSelectorArchived:
		return source.GetArchived(), source != nil
	case Conversation_FieldPathSelectorIsPrivate:
		return source.GetIsPrivate(), source != nil
	case Conversation_FieldPathSelectorLastActivityTime:
		res := source.GetLastActivityTime()
		return res, res != nil
	case Conversation_FieldPathSelectorTurns:
		res := source.GetTurns()
		return res, res != nil
	case Conversation_FieldPathSelectorUsageByModel:
		res := source.GetUsageByModel()
		return res, res != nil
	case Conversation_FieldPathSelectorFailedTurns:
		res := source.GetFailedTurns()
		return res, res != nil
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		res := source.GetReplacedTurnGroups()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fp.selector))
	}
}

func (fp *Conversation_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Conversation))
}

// GetDefault returns a default value of the field type
func (fp *Conversation_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Conversation_FieldPathSelectorName:
		return (*Name)(nil)
	case Conversation_FieldPathSelectorMetadata:
		return (*meta.Meta)(nil)
	case Conversation_FieldPathSelectorTitle:
		return ""
	case Conversation_FieldPathSelectorConfiguredTitle:
		return ""
	case Conversation_FieldPathSelectorArchived:
		return false
	case Conversation_FieldPathSelectorIsPrivate:
		return false
	case Conversation_FieldPathSelectorLastActivityTime:
		return (*timestamppb.Timestamp)(nil)
	case Conversation_FieldPathSelectorTurns:
		return ([]*ConversationTurn)(nil)
	case Conversation_FieldPathSelectorUsageByModel:
		return (map[string]*ModelUsageStats)(nil)
	case Conversation_FieldPathSelectorFailedTurns:
		return ([]*ConversationTurn)(nil)
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		return ([]*ReplacedTurnGroup)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fp.selector))
	}
}

func (fp *Conversation_FieldTerminalPath) ClearValue(item *Conversation) {
	if item != nil {
		switch fp.selector {
		case Conversation_FieldPathSelectorName:
			item.Name = nil
		case Conversation_FieldPathSelectorMetadata:
			item.Metadata = nil
		case Conversation_FieldPathSelectorTitle:
			item.Title = ""
		case Conversation_FieldPathSelectorConfiguredTitle:
			item.ConfiguredTitle = ""
		case Conversation_FieldPathSelectorArchived:
			item.Archived = false
		case Conversation_FieldPathSelectorIsPrivate:
			item.IsPrivate = false
		case Conversation_FieldPathSelectorLastActivityTime:
			item.LastActivityTime = nil
		case Conversation_FieldPathSelectorTurns:
			item.Turns = nil
		case Conversation_FieldPathSelectorUsageByModel:
			item.UsageByModel = nil
		case Conversation_FieldPathSelectorFailedTurns:
			item.FailedTurns = nil
		case Conversation_FieldPathSelectorReplacedTurnGroups:
			item.ReplacedTurnGroups = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Conversation: %d", fp.selector))
		}
	}
}

func (fp *Conversation_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Conversation))
}

// IsLeaf - whether field path is holds simple value
func (fp *Conversation_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Conversation_FieldPathSelectorName ||
		fp.selector == Conversation_FieldPathSelectorTitle ||
		fp.selector == Conversation_FieldPathSelectorConfiguredTitle ||
		fp.selector == Conversation_FieldPathSelectorArchived ||
		fp.selector == Conversation_FieldPathSelectorIsPrivate ||
		fp.selector == Conversation_FieldPathSelectorLastActivityTime
}

func (fp *Conversation_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Conversation_FieldTerminalPath) WithIValue(value interface{}) Conversation_FieldPathValue {
	switch fp.selector {
	case Conversation_FieldPathSelectorName:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.(*Name)}
	case Conversation_FieldPathSelectorMetadata:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.(*meta.Meta)}
	case Conversation_FieldPathSelectorTitle:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.(string)}
	case Conversation_FieldPathSelectorConfiguredTitle:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.(string)}
	case Conversation_FieldPathSelectorArchived:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.(bool)}
	case Conversation_FieldPathSelectorIsPrivate:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.(bool)}
	case Conversation_FieldPathSelectorLastActivityTime:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	case Conversation_FieldPathSelectorTurns:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.([]*ConversationTurn)}
	case Conversation_FieldPathSelectorUsageByModel:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.(map[string]*ModelUsageStats)}
	case Conversation_FieldPathSelectorFailedTurns:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.([]*ConversationTurn)}
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		return &Conversation_FieldTerminalPathValue{Conversation_FieldTerminalPath: *fp, value: value.([]*ReplacedTurnGroup)}
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fp.selector))
	}
}

func (fp *Conversation_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Conversation_FieldTerminalPath) WithIArrayOfValues(values interface{}) Conversation_FieldPathArrayOfValues {
	fpaov := &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp}
	switch fp.selector {
	case Conversation_FieldPathSelectorName:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([]*Name)}
	case Conversation_FieldPathSelectorMetadata:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([]*meta.Meta)}
	case Conversation_FieldPathSelectorTitle:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([]string)}
	case Conversation_FieldPathSelectorConfiguredTitle:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([]string)}
	case Conversation_FieldPathSelectorArchived:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([]bool)}
	case Conversation_FieldPathSelectorIsPrivate:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([]bool)}
	case Conversation_FieldPathSelectorLastActivityTime:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	case Conversation_FieldPathSelectorTurns:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([][]*ConversationTurn)}
	case Conversation_FieldPathSelectorUsageByModel:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([]map[string]*ModelUsageStats)}
	case Conversation_FieldPathSelectorFailedTurns:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([][]*ConversationTurn)}
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		return &Conversation_FieldTerminalPathArrayOfValues{Conversation_FieldTerminalPath: *fp, values: values.([][]*ReplacedTurnGroup)}
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fp.selector))
	}
	return fpaov
}

func (fp *Conversation_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Conversation_FieldTerminalPath) WithIArrayItemValue(value interface{}) Conversation_FieldPathArrayItemValue {
	switch fp.selector {
	case Conversation_FieldPathSelectorTurns:
		return &Conversation_FieldTerminalPathArrayItemValue{Conversation_FieldTerminalPath: *fp, value: value.(*ConversationTurn)}
	case Conversation_FieldPathSelectorFailedTurns:
		return &Conversation_FieldTerminalPathArrayItemValue{Conversation_FieldTerminalPath: *fp, value: value.(*ConversationTurn)}
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		return &Conversation_FieldTerminalPathArrayItemValue{Conversation_FieldTerminalPath: *fp, value: value.(*ReplacedTurnGroup)}
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fp.selector))
	}
}

func (fp *Conversation_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type Conversation_FieldPathMap struct {
	key      string
	selector Conversation_FieldPathSelector
}

var _ Conversation_FieldPath = (*Conversation_FieldPathMap)(nil)

func (fpm *Conversation_FieldPathMap) Selector() Conversation_FieldPathSelector {
	return fpm.selector
}

func (fpm *Conversation_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *Conversation_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *Conversation_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source Conversation
func (fpm *Conversation_FieldPathMap) Get(source *Conversation) (values []interface{}) {
	switch fpm.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		if value, ok := source.GetUsageByModel()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpm.selector))
	}
	return
}

func (fpm *Conversation_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*Conversation))
}

// GetSingle returns value by selected field map key from source Conversation
func (fpm *Conversation_FieldPathMap) GetSingle(source *Conversation) (interface{}, bool) {
	switch fpm.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		res, ok := source.GetUsageByModel()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpm.selector))
	}
}

func (fpm *Conversation_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*Conversation))
}

// GetDefault returns a default value of the field type
func (fpm *Conversation_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		var v *ModelUsageStats
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpm.selector))
	}
}

func (fpm *Conversation_FieldPathMap) ClearValue(item *Conversation) {
	if item != nil {
		switch fpm.selector {
		case Conversation_FieldPathSelectorUsageByModel:
			delete(item.UsageByModel, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpm.selector))
		}
	}
}

func (fpm *Conversation_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*Conversation))
}

// IsLeaf - whether field path is holds simple value
func (fpm *Conversation_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpm.selector))
	}
}

func (fpm *Conversation_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *Conversation_FieldPathMap) WithIValue(value interface{}) Conversation_FieldPathValue {
	switch fpm.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		return &Conversation_FieldPathMapValue{Conversation_FieldPathMap: *fpm, value: value.(*ModelUsageStats)}
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpm.selector))
	}
}

func (fpm *Conversation_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *Conversation_FieldPathMap) WithIArrayOfValues(values interface{}) Conversation_FieldPathArrayOfValues {
	switch fpm.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		return &Conversation_FieldPathMapArrayOfValues{Conversation_FieldPathMap: *fpm, values: values.([]*ModelUsageStats)}
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpm.selector))
	}
}

func (fpm *Conversation_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *Conversation_FieldPathMap) WithIArrayItemValue(value interface{}) Conversation_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *Conversation_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

type Conversation_FieldSubPath struct {
	selector Conversation_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ Conversation_FieldPath = (*Conversation_FieldSubPath)(nil)

func (fps *Conversation_FieldSubPath) Selector() Conversation_FieldPathSelector {
	return fps.selector
}
func (fps *Conversation_FieldSubPath) AsMetadataSubPath() (meta.Meta_FieldPath, bool) {
	res, ok := fps.subPath.(meta.Meta_FieldPath)
	return res, ok
}
func (fps *Conversation_FieldSubPath) AsTurnsSubPath() (ConversationTurn_FieldPath, bool) {
	res, ok := fps.subPath.(ConversationTurn_FieldPath)
	return res, ok
}
func (fps *Conversation_FieldSubPath) AsFailedTurnsSubPath() (ConversationTurn_FieldPath, bool) {
	res, ok := fps.subPath.(ConversationTurn_FieldPath)
	return res, ok
}
func (fps *Conversation_FieldSubPath) AsReplacedTurnGroupsSubPath() (ReplacedTurnGroup_FieldPath, bool) {
	res, ok := fps.subPath.(ReplacedTurnGroup_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *Conversation_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *Conversation_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Conversation
func (fps *Conversation_FieldSubPath) Get(source *Conversation) (values []interface{}) {
	switch fps.selector {
	case Conversation_FieldPathSelectorMetadata:
		values = append(values, fps.subPath.GetRaw(source.GetMetadata())...)
	case Conversation_FieldPathSelectorTurns:
		for _, item := range source.GetTurns() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case Conversation_FieldPathSelectorFailedTurns:
		for _, item := range source.GetFailedTurns() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		for _, item := range source.GetReplacedTurnGroups() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fps.selector))
	}
	return
}

func (fps *Conversation_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Conversation))
}

// GetSingle returns value of selected field from source Conversation
func (fps *Conversation_FieldSubPath) GetSingle(source *Conversation) (interface{}, bool) {
	switch fps.selector {
	case Conversation_FieldPathSelectorMetadata:
		if source.GetMetadata() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetMetadata())
	case Conversation_FieldPathSelectorTurns:
		if len(source.GetTurns()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetTurns()[0])
	case Conversation_FieldPathSelectorFailedTurns:
		if len(source.GetFailedTurns()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetFailedTurns()[0])
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		if len(source.GetReplacedTurnGroups()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetReplacedTurnGroups()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fps.selector))
	}
}

func (fps *Conversation_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Conversation))
}

// GetDefault returns a default value of the field type
func (fps *Conversation_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *Conversation_FieldSubPath) ClearValue(item *Conversation) {
	if item != nil {
		switch fps.selector {
		case Conversation_FieldPathSelectorMetadata:
			fps.subPath.ClearValueRaw(item.Metadata)
		case Conversation_FieldPathSelectorTurns:
			for _, subItem := range item.Turns {
				fps.subPath.ClearValueRaw(subItem)
			}
		case Conversation_FieldPathSelectorFailedTurns:
			for _, subItem := range item.FailedTurns {
				fps.subPath.ClearValueRaw(subItem)
			}
		case Conversation_FieldPathSelectorReplacedTurnGroups:
			for _, subItem := range item.ReplacedTurnGroups {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Conversation: %d", fps.selector))
		}
	}
}

func (fps *Conversation_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Conversation))
}

// IsLeaf - whether field path is holds simple value
func (fps *Conversation_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *Conversation_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&Conversation_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *Conversation_FieldSubPath) WithIValue(value interface{}) Conversation_FieldPathValue {
	return &Conversation_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *Conversation_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *Conversation_FieldSubPath) WithIArrayOfValues(values interface{}) Conversation_FieldPathArrayOfValues {
	return &Conversation_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *Conversation_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *Conversation_FieldSubPath) WithIArrayItemValue(value interface{}) Conversation_FieldPathArrayItemValue {
	return &Conversation_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *Conversation_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// Conversation_FieldPathValue allows storing values for Conversation fields according to their type
type Conversation_FieldPathValue interface {
	Conversation_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Conversation)
	CompareWith(*Conversation) (cmp int, comparable bool)
}

func ParseConversation_FieldPathValue(pathStr, valueStr string) (Conversation_FieldPathValue, error) {
	fp, err := ParseConversation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Conversation field path value from %s: %v", valueStr, err)
	}
	return fpv.(Conversation_FieldPathValue), nil
}

func MustParseConversation_FieldPathValue(pathStr, valueStr string) Conversation_FieldPathValue {
	fpv, err := ParseConversation_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Conversation_FieldTerminalPathValue struct {
	Conversation_FieldTerminalPath
	value interface{}
}

var _ Conversation_FieldPathValue = (*Conversation_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Conversation' as interface{}
func (fpv *Conversation_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Conversation_FieldTerminalPathValue) AsNameValue() (*Name, bool) {
	res, ok := fpv.value.(*Name)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsMetadataValue() (*meta.Meta, bool) {
	res, ok := fpv.value.(*meta.Meta)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsTitleValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsConfiguredTitleValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsArchivedValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsIsPrivateValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsLastActivityTimeValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsTurnsValue() ([]*ConversationTurn, bool) {
	res, ok := fpv.value.([]*ConversationTurn)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsUsageByModelValue() (map[string]*ModelUsageStats, bool) {
	res, ok := fpv.value.(map[string]*ModelUsageStats)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsFailedTurnsValue() ([]*ConversationTurn, bool) {
	res, ok := fpv.value.([]*ConversationTurn)
	return res, ok
}
func (fpv *Conversation_FieldTerminalPathValue) AsReplacedTurnGroupsValue() ([]*ReplacedTurnGroup, bool) {
	res, ok := fpv.value.([]*ReplacedTurnGroup)
	return res, ok
}

// SetTo stores value for selected field for object Conversation
func (fpv *Conversation_FieldTerminalPathValue) SetTo(target **Conversation) {
	if *target == nil {
		*target = new(Conversation)
	}
	switch fpv.selector {
	case Conversation_FieldPathSelectorName:
		(*target).Name = fpv.value.(*Name)
	case Conversation_FieldPathSelectorMetadata:
		(*target).Metadata = fpv.value.(*meta.Meta)
	case Conversation_FieldPathSelectorTitle:
		(*target).Title = fpv.value.(string)
	case Conversation_FieldPathSelectorConfiguredTitle:
		(*target).ConfiguredTitle = fpv.value.(string)
	case Conversation_FieldPathSelectorArchived:
		(*target).Archived = fpv.value.(bool)
	case Conversation_FieldPathSelectorIsPrivate:
		(*target).IsPrivate = fpv.value.(bool)
	case Conversation_FieldPathSelectorLastActivityTime:
		(*target).LastActivityTime = fpv.value.(*timestamppb.Timestamp)
	case Conversation_FieldPathSelectorTurns:
		(*target).Turns = fpv.value.([]*ConversationTurn)
	case Conversation_FieldPathSelectorUsageByModel:
		(*target).UsageByModel = fpv.value.(map[string]*ModelUsageStats)
	case Conversation_FieldPathSelectorFailedTurns:
		(*target).FailedTurns = fpv.value.([]*ConversationTurn)
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		(*target).ReplacedTurnGroups = fpv.value.([]*ReplacedTurnGroup)
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpv.selector))
	}
}

func (fpv *Conversation_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Conversation)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Conversation_FieldTerminalPathValue' with the value under path in 'Conversation'.
func (fpv *Conversation_FieldTerminalPathValue) CompareWith(source *Conversation) (int, bool) {
	switch fpv.selector {
	case Conversation_FieldPathSelectorName:
		leftValue := fpv.value.(*Name)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case Conversation_FieldPathSelectorMetadata:
		return 0, false
	case Conversation_FieldPathSelectorTitle:
		leftValue := fpv.value.(string)
		rightValue := source.GetTitle()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Conversation_FieldPathSelectorConfiguredTitle:
		leftValue := fpv.value.(string)
		rightValue := source.GetConfiguredTitle()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Conversation_FieldPathSelectorArchived:
		leftValue := fpv.value.(bool)
		rightValue := source.GetArchived()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Conversation_FieldPathSelectorIsPrivate:
		leftValue := fpv.value.(bool)
		rightValue := source.GetIsPrivate()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Conversation_FieldPathSelectorLastActivityTime:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetLastActivityTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case Conversation_FieldPathSelectorTurns:
		return 0, false
	case Conversation_FieldPathSelectorUsageByModel:
		return 0, false
	case Conversation_FieldPathSelectorFailedTurns:
		return 0, false
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpv.selector))
	}
}

func (fpv *Conversation_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Conversation))
}

type Conversation_FieldPathMapValue struct {
	Conversation_FieldPathMap
	value interface{}
}

var _ Conversation_FieldPathValue = (*Conversation_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in Conversation as interface{}
func (fpmv *Conversation_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *Conversation_FieldPathMapValue) AsUsageByModelElementValue() (*ModelUsageStats, bool) {
	res, ok := fpmv.value.(*ModelUsageStats)
	return res, ok
}

// SetTo stores value for selected field in Conversation
func (fpmv *Conversation_FieldPathMapValue) SetTo(target **Conversation) {
	if *target == nil {
		*target = new(Conversation)
	}
	switch fpmv.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		if (*target).UsageByModel == nil {
			(*target).UsageByModel = make(map[string]*ModelUsageStats)
		}
		(*target).UsageByModel[fpmv.key] = fpmv.value.(*ModelUsageStats)
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpmv.selector))
	}
}

func (fpmv *Conversation_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Conversation)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Conversation_FieldPathMapValue' with the value under path in 'Conversation'.
func (fpmv *Conversation_FieldPathMapValue) CompareWith(source *Conversation) (int, bool) {
	switch fpmv.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpmv.selector))
	}
}

func (fpmv *Conversation_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*Conversation))
}

type Conversation_FieldSubPathValue struct {
	Conversation_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ Conversation_FieldPathValue = (*Conversation_FieldSubPathValue)(nil)

func (fpvs *Conversation_FieldSubPathValue) AsMetadataPathValue() (meta.Meta_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(meta.Meta_FieldPathValue)
	return res, ok
}
func (fpvs *Conversation_FieldSubPathValue) AsTurnsPathValue() (ConversationTurn_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ConversationTurn_FieldPathValue)
	return res, ok
}
func (fpvs *Conversation_FieldSubPathValue) AsFailedTurnsPathValue() (ConversationTurn_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ConversationTurn_FieldPathValue)
	return res, ok
}
func (fpvs *Conversation_FieldSubPathValue) AsReplacedTurnGroupsPathValue() (ReplacedTurnGroup_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ReplacedTurnGroup_FieldPathValue)
	return res, ok
}

func (fpvs *Conversation_FieldSubPathValue) SetTo(target **Conversation) {
	if *target == nil {
		*target = new(Conversation)
	}
	switch fpvs.Selector() {
	case Conversation_FieldPathSelectorMetadata:
		fpvs.subPathValue.(meta.Meta_FieldPathValue).SetTo(&(*target).Metadata)
	case Conversation_FieldPathSelectorTurns:
		panic("FieldPath setter is unsupported for array subpaths")
	case Conversation_FieldPathSelectorFailedTurns:
		panic("FieldPath setter is unsupported for array subpaths")
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpvs.Selector()))
	}
}

func (fpvs *Conversation_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Conversation)
	fpvs.SetTo(&typedObject)
}

func (fpvs *Conversation_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *Conversation_FieldSubPathValue) CompareWith(source *Conversation) (int, bool) {
	switch fpvs.Selector() {
	case Conversation_FieldPathSelectorMetadata:
		return fpvs.subPathValue.(meta.Meta_FieldPathValue).CompareWith(source.GetMetadata())
	case Conversation_FieldPathSelectorTurns:
		return 0, false // repeated field
	case Conversation_FieldPathSelectorFailedTurns:
		return 0, false // repeated field
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpvs.Selector()))
	}
}

func (fpvs *Conversation_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Conversation))
}

// Conversation_FieldPathArrayItemValue allows storing single item in Path-specific values for Conversation according to their type
// Present only for array (repeated) types.
type Conversation_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Conversation_FieldPath
	ContainsValue(*Conversation) bool
}

// ParseConversation_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseConversation_FieldPathArrayItemValue(pathStr, valueStr string) (Conversation_FieldPathArrayItemValue, error) {
	fp, err := ParseConversation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Conversation field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Conversation_FieldPathArrayItemValue), nil
}

func MustParseConversation_FieldPathArrayItemValue(pathStr, valueStr string) Conversation_FieldPathArrayItemValue {
	fpaiv, err := ParseConversation_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Conversation_FieldTerminalPathArrayItemValue struct {
	Conversation_FieldTerminalPath
	value interface{}
}

var _ Conversation_FieldPathArrayItemValue = (*Conversation_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Conversation as interface{}
func (fpaiv *Conversation_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Conversation_FieldTerminalPathArrayItemValue) AsTurnsItemValue() (*ConversationTurn, bool) {
	res, ok := fpaiv.value.(*ConversationTurn)
	return res, ok
}
func (fpaiv *Conversation_FieldTerminalPathArrayItemValue) AsFailedTurnsItemValue() (*ConversationTurn, bool) {
	res, ok := fpaiv.value.(*ConversationTurn)
	return res, ok
}
func (fpaiv *Conversation_FieldTerminalPathArrayItemValue) AsReplacedTurnGroupsItemValue() (*ReplacedTurnGroup, bool) {
	res, ok := fpaiv.value.(*ReplacedTurnGroup)
	return res, ok
}

func (fpaiv *Conversation_FieldTerminalPathArrayItemValue) GetSingle(source *Conversation) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Conversation_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Conversation))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Conversation'
func (fpaiv *Conversation_FieldTerminalPathArrayItemValue) ContainsValue(source *Conversation) bool {
	slice := fpaiv.Conversation_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type Conversation_FieldSubPathArrayItemValue struct {
	Conversation_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *Conversation_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *Conversation_FieldSubPathArrayItemValue) AsMetadataPathItemValue() (meta.Meta_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(meta.Meta_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Conversation_FieldSubPathArrayItemValue) AsTurnsPathItemValue() (ConversationTurn_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ConversationTurn_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Conversation_FieldSubPathArrayItemValue) AsFailedTurnsPathItemValue() (ConversationTurn_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ConversationTurn_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Conversation_FieldSubPathArrayItemValue) AsReplacedTurnGroupsPathItemValue() (ReplacedTurnGroup_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ReplacedTurnGroup_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'Conversation'
func (fpaivs *Conversation_FieldSubPathArrayItemValue) ContainsValue(source *Conversation) bool {
	switch fpaivs.Selector() {
	case Conversation_FieldPathSelectorMetadata:
		return fpaivs.subPathItemValue.(meta.Meta_FieldPathArrayItemValue).ContainsValue(source.GetMetadata())
	case Conversation_FieldPathSelectorTurns:
		return false // repeated/map field
	case Conversation_FieldPathSelectorFailedTurns:
		return false // repeated/map field
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for Conversation: %d", fpaivs.Selector()))
	}
}

// Conversation_FieldPathArrayOfValues allows storing slice of values for Conversation fields according to their type
type Conversation_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Conversation_FieldPath
}

func ParseConversation_FieldPathArrayOfValues(pathStr, valuesStr string) (Conversation_FieldPathArrayOfValues, error) {
	fp, err := ParseConversation_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Conversation field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Conversation_FieldPathArrayOfValues), nil
}

func MustParseConversation_FieldPathArrayOfValues(pathStr, valuesStr string) Conversation_FieldPathArrayOfValues {
	fpaov, err := ParseConversation_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Conversation_FieldTerminalPathArrayOfValues struct {
	Conversation_FieldTerminalPath
	values interface{}
}

var _ Conversation_FieldPathArrayOfValues = (*Conversation_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Conversation_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Conversation_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*Name) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorMetadata:
		for _, v := range fpaov.values.([]*meta.Meta) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorTitle:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorConfiguredTitle:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorArchived:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorIsPrivate:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorLastActivityTime:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorTurns:
		for _, v := range fpaov.values.([][]*ConversationTurn) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorUsageByModel:
		for _, v := range fpaov.values.([]map[string]*ModelUsageStats) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorFailedTurns:
		for _, v := range fpaov.values.([][]*ConversationTurn) {
			values = append(values, v)
		}
	case Conversation_FieldPathSelectorReplacedTurnGroups:
		for _, v := range fpaov.values.([][]*ReplacedTurnGroup) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*Name, bool) {
	res, ok := fpaov.values.([]*Name)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsMetadataArrayOfValues() ([]*meta.Meta, bool) {
	res, ok := fpaov.values.([]*meta.Meta)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsTitleArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsConfiguredTitleArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsArchivedArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsIsPrivateArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsLastActivityTimeArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsTurnsArrayOfValues() ([][]*ConversationTurn, bool) {
	res, ok := fpaov.values.([][]*ConversationTurn)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsUsageByModelArrayOfValues() ([]map[string]*ModelUsageStats, bool) {
	res, ok := fpaov.values.([]map[string]*ModelUsageStats)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsFailedTurnsArrayOfValues() ([][]*ConversationTurn, bool) {
	res, ok := fpaov.values.([][]*ConversationTurn)
	return res, ok
}
func (fpaov *Conversation_FieldTerminalPathArrayOfValues) AsReplacedTurnGroupsArrayOfValues() ([][]*ReplacedTurnGroup, bool) {
	res, ok := fpaov.values.([][]*ReplacedTurnGroup)
	return res, ok
}

type Conversation_FieldPathMapArrayOfValues struct {
	Conversation_FieldPathMap
	values interface{}
}

var _ Conversation_FieldPathArrayOfValues = (*Conversation_FieldPathMapArrayOfValues)(nil)

func (fpmaov *Conversation_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case Conversation_FieldPathSelectorUsageByModel:
		for _, v := range fpmaov.values.([]*ModelUsageStats) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *Conversation_FieldPathMapArrayOfValues) AsUsageByModelArrayOfElementValues() ([]*ModelUsageStats, bool) {
	res, ok := fpmaov.values.([]*ModelUsageStats)
	return res, ok
}

type Conversation_FieldSubPathArrayOfValues struct {
	Conversation_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ Conversation_FieldPathArrayOfValues = (*Conversation_FieldSubPathArrayOfValues)(nil)

func (fpsaov *Conversation_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *Conversation_FieldSubPathArrayOfValues) AsMetadataPathArrayOfValues() (meta.Meta_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(meta.Meta_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Conversation_FieldSubPathArrayOfValues) AsTurnsPathArrayOfValues() (ConversationTurn_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ConversationTurn_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Conversation_FieldSubPathArrayOfValues) AsFailedTurnsPathArrayOfValues() (ConversationTurn_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ConversationTurn_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Conversation_FieldSubPathArrayOfValues) AsReplacedTurnGroupsPathArrayOfValues() (ReplacedTurnGroup_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ReplacedTurnGroup_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ConversationTurn_FieldPath interface {
	gotenobject.FieldPath
	Selector() ConversationTurn_FieldPathSelector
	Get(source *ConversationTurn) []interface{}
	GetSingle(source *ConversationTurn) (interface{}, bool)
	ClearValue(item *ConversationTurn)

	// Those methods build corresponding ConversationTurn_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ConversationTurn_FieldPathValue
	WithIArrayOfValues(values interface{}) ConversationTurn_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ConversationTurn_FieldPathArrayItemValue
}

type ConversationTurn_FieldPathSelector int32

const (
	ConversationTurn_FieldPathSelectorTurnNumber             ConversationTurn_FieldPathSelector = 0
	ConversationTurn_FieldPathSelectorTimestamp              ConversationTurn_FieldPathSelector = 1
	ConversationTurn_FieldPathSelectorMessages               ConversationTurn_FieldPathSelector = 2
	ConversationTurn_FieldPathSelectorConfig                 ConversationTurn_FieldPathSelector = 3
	ConversationTurn_FieldPathSelectorUsage                  ConversationTurn_FieldPathSelector = 4
	ConversationTurn_FieldPathSelectorStopReason             ConversationTurn_FieldPathSelector = 5
	ConversationTurn_FieldPathSelectorDuration               ConversationTurn_FieldPathSelector = 6
	ConversationTurn_FieldPathSelectorAvailableToolsBySource ConversationTurn_FieldPathSelector = 7
	ConversationTurn_FieldPathSelectorReplacedTurnNumber     ConversationTurn_FieldPathSelector = 8
	ConversationTurn_FieldPathSelectorErrorDetails           ConversationTurn_FieldPathSelector = 9
)

func (s ConversationTurn_FieldPathSelector) String() string {
	switch s {
	case ConversationTurn_FieldPathSelectorTurnNumber:
		return "turn_number"
	case ConversationTurn_FieldPathSelectorTimestamp:
		return "timestamp"
	case ConversationTurn_FieldPathSelectorMessages:
		return "messages"
	case ConversationTurn_FieldPathSelectorConfig:
		return "config"
	case ConversationTurn_FieldPathSelectorUsage:
		return "usage"
	case ConversationTurn_FieldPathSelectorStopReason:
		return "stop_reason"
	case ConversationTurn_FieldPathSelectorDuration:
		return "duration"
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		return "available_tools_by_source"
	case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
		return "replaced_turn_number"
	case ConversationTurn_FieldPathSelectorErrorDetails:
		return "error_details"
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", s))
	}
}

func BuildConversationTurn_FieldPath(fp gotenobject.RawFieldPath) (ConversationTurn_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ConversationTurn")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "turn_number", "turnNumber", "turn-number":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorTurnNumber}, nil
		case "timestamp":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorTimestamp}, nil
		case "messages":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorMessages}, nil
		case "config":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorConfig}, nil
		case "usage":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorUsage}, nil
		case "stop_reason", "stopReason", "stop-reason":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorStopReason}, nil
		case "duration":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorDuration}, nil
		case "available_tools_by_source", "availableToolsBySource", "available-tools-by-source":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorAvailableToolsBySource}, nil
		case "replaced_turn_number", "replacedTurnNumber", "replaced-turn-number":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorReplacedTurnNumber}, nil
		case "error_details", "errorDetails", "error-details":
			return &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorErrorDetails}, nil
		}
	} else {
		switch fp[0] {
		case "config":
			if subpath, err := BuildTurnConfig_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ConversationTurn_FieldSubPath{selector: ConversationTurn_FieldPathSelectorConfig, subPath: subpath}, nil
			}
		case "available_tools_by_source", "availableToolsBySource", "available-tools-by-source":
			if subpath, err := BuildTurnToolsBySourceGroup_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ConversationTurn_FieldSubPath{selector: ConversationTurn_FieldPathSelectorAvailableToolsBySource, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ConversationTurn", fp)
}

func ParseConversationTurn_FieldPath(rawField string) (ConversationTurn_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildConversationTurn_FieldPath(fp)
}

func MustParseConversationTurn_FieldPath(rawField string) ConversationTurn_FieldPath {
	fp, err := ParseConversationTurn_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ConversationTurn_FieldTerminalPath struct {
	selector ConversationTurn_FieldPathSelector
}

var _ ConversationTurn_FieldPath = (*ConversationTurn_FieldTerminalPath)(nil)

func (fp *ConversationTurn_FieldTerminalPath) Selector() ConversationTurn_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ConversationTurn_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ConversationTurn_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ConversationTurn
func (fp *ConversationTurn_FieldTerminalPath) Get(source *ConversationTurn) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ConversationTurn_FieldPathSelectorTurnNumber:
			values = append(values, source.TurnNumber)
		case ConversationTurn_FieldPathSelectorTimestamp:
			if source.Timestamp != nil {
				values = append(values, source.Timestamp)
			}
		case ConversationTurn_FieldPathSelectorMessages:
			for _, value := range source.GetMessages() {
				values = append(values, value)
			}
		case ConversationTurn_FieldPathSelectorConfig:
			if source.Config != nil {
				values = append(values, source.Config)
			}
		case ConversationTurn_FieldPathSelectorUsage:
			if source.Usage != nil {
				values = append(values, source.Usage)
			}
		case ConversationTurn_FieldPathSelectorStopReason:
			values = append(values, source.StopReason)
		case ConversationTurn_FieldPathSelectorDuration:
			if source.Duration != nil {
				values = append(values, source.Duration)
			}
		case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
			for _, value := range source.GetAvailableToolsBySource() {
				values = append(values, value)
			}
		case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
			values = append(values, source.ReplacedTurnNumber)
		case ConversationTurn_FieldPathSelectorErrorDetails:
			values = append(values, source.ErrorDetails)
		default:
			panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fp.selector))
		}
	}
	return
}

func (fp *ConversationTurn_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ConversationTurn))
}

// GetSingle returns value pointed by specific field of from source ConversationTurn
func (fp *ConversationTurn_FieldTerminalPath) GetSingle(source *ConversationTurn) (interface{}, bool) {
	switch fp.selector {
	case ConversationTurn_FieldPathSelectorTurnNumber:
		return source.GetTurnNumber(), source != nil
	case ConversationTurn_FieldPathSelectorTimestamp:
		res := source.GetTimestamp()
		return res, res != nil
	case ConversationTurn_FieldPathSelectorMessages:
		res := source.GetMessages()
		return res, res != nil
	case ConversationTurn_FieldPathSelectorConfig:
		res := source.GetConfig()
		return res, res != nil
	case ConversationTurn_FieldPathSelectorUsage:
		res := source.GetUsage()
		return res, res != nil
	case ConversationTurn_FieldPathSelectorStopReason:
		return source.GetStopReason(), source != nil
	case ConversationTurn_FieldPathSelectorDuration:
		res := source.GetDuration()
		return res, res != nil
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		res := source.GetAvailableToolsBySource()
		return res, res != nil
	case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
		return source.GetReplacedTurnNumber(), source != nil
	case ConversationTurn_FieldPathSelectorErrorDetails:
		return source.GetErrorDetails(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fp.selector))
	}
}

func (fp *ConversationTurn_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ConversationTurn))
}

// GetDefault returns a default value of the field type
func (fp *ConversationTurn_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ConversationTurn_FieldPathSelectorTurnNumber:
		return int32(0)
	case ConversationTurn_FieldPathSelectorTimestamp:
		return (*timestamppb.Timestamp)(nil)
	case ConversationTurn_FieldPathSelectorMessages:
		return ([]*common_client.Message)(nil)
	case ConversationTurn_FieldPathSelectorConfig:
		return (*TurnConfig)(nil)
	case ConversationTurn_FieldPathSelectorUsage:
		return (*common_client.TokenUsage)(nil)
	case ConversationTurn_FieldPathSelectorStopReason:
		return common_client.StopReason_STOP_REASON_UNSPECIFIED
	case ConversationTurn_FieldPathSelectorDuration:
		return (*durationpb.Duration)(nil)
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		return ([]*TurnToolsBySourceGroup)(nil)
	case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
		return int32(0)
	case ConversationTurn_FieldPathSelectorErrorDetails:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fp.selector))
	}
}

func (fp *ConversationTurn_FieldTerminalPath) ClearValue(item *ConversationTurn) {
	if item != nil {
		switch fp.selector {
		case ConversationTurn_FieldPathSelectorTurnNumber:
			item.TurnNumber = int32(0)
		case ConversationTurn_FieldPathSelectorTimestamp:
			item.Timestamp = nil
		case ConversationTurn_FieldPathSelectorMessages:
			item.Messages = nil
		case ConversationTurn_FieldPathSelectorConfig:
			item.Config = nil
		case ConversationTurn_FieldPathSelectorUsage:
			item.Usage = nil
		case ConversationTurn_FieldPathSelectorStopReason:
			item.StopReason = common_client.StopReason_STOP_REASON_UNSPECIFIED
		case ConversationTurn_FieldPathSelectorDuration:
			item.Duration = nil
		case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
			item.AvailableToolsBySource = nil
		case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
			item.ReplacedTurnNumber = int32(0)
		case ConversationTurn_FieldPathSelectorErrorDetails:
			item.ErrorDetails = ""
		default:
			panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fp.selector))
		}
	}
}

func (fp *ConversationTurn_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ConversationTurn))
}

// IsLeaf - whether field path is holds simple value
func (fp *ConversationTurn_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ConversationTurn_FieldPathSelectorTurnNumber ||
		fp.selector == ConversationTurn_FieldPathSelectorTimestamp ||
		fp.selector == ConversationTurn_FieldPathSelectorMessages ||
		fp.selector == ConversationTurn_FieldPathSelectorUsage ||
		fp.selector == ConversationTurn_FieldPathSelectorStopReason ||
		fp.selector == ConversationTurn_FieldPathSelectorDuration ||
		fp.selector == ConversationTurn_FieldPathSelectorReplacedTurnNumber ||
		fp.selector == ConversationTurn_FieldPathSelectorErrorDetails
}

func (fp *ConversationTurn_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ConversationTurn_FieldTerminalPath) WithIValue(value interface{}) ConversationTurn_FieldPathValue {
	switch fp.selector {
	case ConversationTurn_FieldPathSelectorTurnNumber:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(int32)}
	case ConversationTurn_FieldPathSelectorTimestamp:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	case ConversationTurn_FieldPathSelectorMessages:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.([]*common_client.Message)}
	case ConversationTurn_FieldPathSelectorConfig:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(*TurnConfig)}
	case ConversationTurn_FieldPathSelectorUsage:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(*common_client.TokenUsage)}
	case ConversationTurn_FieldPathSelectorStopReason:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(common_client.StopReason)}
	case ConversationTurn_FieldPathSelectorDuration:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(*durationpb.Duration)}
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.([]*TurnToolsBySourceGroup)}
	case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(int32)}
	case ConversationTurn_FieldPathSelectorErrorDetails:
		return &ConversationTurn_FieldTerminalPathValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fp.selector))
	}
}

func (fp *ConversationTurn_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ConversationTurn_FieldTerminalPath) WithIArrayOfValues(values interface{}) ConversationTurn_FieldPathArrayOfValues {
	fpaov := &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp}
	switch fp.selector {
	case ConversationTurn_FieldPathSelectorTurnNumber:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([]int32)}
	case ConversationTurn_FieldPathSelectorTimestamp:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	case ConversationTurn_FieldPathSelectorMessages:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([][]*common_client.Message)}
	case ConversationTurn_FieldPathSelectorConfig:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([]*TurnConfig)}
	case ConversationTurn_FieldPathSelectorUsage:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([]*common_client.TokenUsage)}
	case ConversationTurn_FieldPathSelectorStopReason:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([]common_client.StopReason)}
	case ConversationTurn_FieldPathSelectorDuration:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([]*durationpb.Duration)}
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([][]*TurnToolsBySourceGroup)}
	case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([]int32)}
	case ConversationTurn_FieldPathSelectorErrorDetails:
		return &ConversationTurn_FieldTerminalPathArrayOfValues{ConversationTurn_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fp.selector))
	}
	return fpaov
}

func (fp *ConversationTurn_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ConversationTurn_FieldTerminalPath) WithIArrayItemValue(value interface{}) ConversationTurn_FieldPathArrayItemValue {
	switch fp.selector {
	case ConversationTurn_FieldPathSelectorMessages:
		return &ConversationTurn_FieldTerminalPathArrayItemValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(*common_client.Message)}
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		return &ConversationTurn_FieldTerminalPathArrayItemValue{ConversationTurn_FieldTerminalPath: *fp, value: value.(*TurnToolsBySourceGroup)}
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fp.selector))
	}
}

func (fp *ConversationTurn_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ConversationTurn_FieldSubPath struct {
	selector ConversationTurn_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ConversationTurn_FieldPath = (*ConversationTurn_FieldSubPath)(nil)

func (fps *ConversationTurn_FieldSubPath) Selector() ConversationTurn_FieldPathSelector {
	return fps.selector
}
func (fps *ConversationTurn_FieldSubPath) AsConfigSubPath() (TurnConfig_FieldPath, bool) {
	res, ok := fps.subPath.(TurnConfig_FieldPath)
	return res, ok
}
func (fps *ConversationTurn_FieldSubPath) AsAvailableToolsBySourceSubPath() (TurnToolsBySourceGroup_FieldPath, bool) {
	res, ok := fps.subPath.(TurnToolsBySourceGroup_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ConversationTurn_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ConversationTurn_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ConversationTurn
func (fps *ConversationTurn_FieldSubPath) Get(source *ConversationTurn) (values []interface{}) {
	switch fps.selector {
	case ConversationTurn_FieldPathSelectorConfig:
		values = append(values, fps.subPath.GetRaw(source.GetConfig())...)
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		for _, item := range source.GetAvailableToolsBySource() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fps.selector))
	}
	return
}

func (fps *ConversationTurn_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ConversationTurn))
}

// GetSingle returns value of selected field from source ConversationTurn
func (fps *ConversationTurn_FieldSubPath) GetSingle(source *ConversationTurn) (interface{}, bool) {
	switch fps.selector {
	case ConversationTurn_FieldPathSelectorConfig:
		if source.GetConfig() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetConfig())
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		if len(source.GetAvailableToolsBySource()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetAvailableToolsBySource()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fps.selector))
	}
}

func (fps *ConversationTurn_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ConversationTurn))
}

// GetDefault returns a default value of the field type
func (fps *ConversationTurn_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ConversationTurn_FieldSubPath) ClearValue(item *ConversationTurn) {
	if item != nil {
		switch fps.selector {
		case ConversationTurn_FieldPathSelectorConfig:
			fps.subPath.ClearValueRaw(item.Config)
		case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
			for _, subItem := range item.AvailableToolsBySource {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fps.selector))
		}
	}
}

func (fps *ConversationTurn_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ConversationTurn))
}

// IsLeaf - whether field path is holds simple value
func (fps *ConversationTurn_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ConversationTurn_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&ConversationTurn_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *ConversationTurn_FieldSubPath) WithIValue(value interface{}) ConversationTurn_FieldPathValue {
	return &ConversationTurn_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ConversationTurn_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ConversationTurn_FieldSubPath) WithIArrayOfValues(values interface{}) ConversationTurn_FieldPathArrayOfValues {
	return &ConversationTurn_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ConversationTurn_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ConversationTurn_FieldSubPath) WithIArrayItemValue(value interface{}) ConversationTurn_FieldPathArrayItemValue {
	return &ConversationTurn_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ConversationTurn_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ConversationTurn_FieldPathValue allows storing values for ConversationTurn fields according to their type
type ConversationTurn_FieldPathValue interface {
	ConversationTurn_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ConversationTurn)
	CompareWith(*ConversationTurn) (cmp int, comparable bool)
}

func ParseConversationTurn_FieldPathValue(pathStr, valueStr string) (ConversationTurn_FieldPathValue, error) {
	fp, err := ParseConversationTurn_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConversationTurn field path value from %s: %v", valueStr, err)
	}
	return fpv.(ConversationTurn_FieldPathValue), nil
}

func MustParseConversationTurn_FieldPathValue(pathStr, valueStr string) ConversationTurn_FieldPathValue {
	fpv, err := ParseConversationTurn_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ConversationTurn_FieldTerminalPathValue struct {
	ConversationTurn_FieldTerminalPath
	value interface{}
}

var _ ConversationTurn_FieldPathValue = (*ConversationTurn_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ConversationTurn' as interface{}
func (fpv *ConversationTurn_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsTurnNumberValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsTimestampValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsMessagesValue() ([]*common_client.Message, bool) {
	res, ok := fpv.value.([]*common_client.Message)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsConfigValue() (*TurnConfig, bool) {
	res, ok := fpv.value.(*TurnConfig)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsUsageValue() (*common_client.TokenUsage, bool) {
	res, ok := fpv.value.(*common_client.TokenUsage)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsStopReasonValue() (common_client.StopReason, bool) {
	res, ok := fpv.value.(common_client.StopReason)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsDurationValue() (*durationpb.Duration, bool) {
	res, ok := fpv.value.(*durationpb.Duration)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsAvailableToolsBySourceValue() ([]*TurnToolsBySourceGroup, bool) {
	res, ok := fpv.value.([]*TurnToolsBySourceGroup)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsReplacedTurnNumberValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ConversationTurn_FieldTerminalPathValue) AsErrorDetailsValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object ConversationTurn
func (fpv *ConversationTurn_FieldTerminalPathValue) SetTo(target **ConversationTurn) {
	if *target == nil {
		*target = new(ConversationTurn)
	}
	switch fpv.selector {
	case ConversationTurn_FieldPathSelectorTurnNumber:
		(*target).TurnNumber = fpv.value.(int32)
	case ConversationTurn_FieldPathSelectorTimestamp:
		(*target).Timestamp = fpv.value.(*timestamppb.Timestamp)
	case ConversationTurn_FieldPathSelectorMessages:
		(*target).Messages = fpv.value.([]*common_client.Message)
	case ConversationTurn_FieldPathSelectorConfig:
		(*target).Config = fpv.value.(*TurnConfig)
	case ConversationTurn_FieldPathSelectorUsage:
		(*target).Usage = fpv.value.(*common_client.TokenUsage)
	case ConversationTurn_FieldPathSelectorStopReason:
		(*target).StopReason = fpv.value.(common_client.StopReason)
	case ConversationTurn_FieldPathSelectorDuration:
		(*target).Duration = fpv.value.(*durationpb.Duration)
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		(*target).AvailableToolsBySource = fpv.value.([]*TurnToolsBySourceGroup)
	case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
		(*target).ReplacedTurnNumber = fpv.value.(int32)
	case ConversationTurn_FieldPathSelectorErrorDetails:
		(*target).ErrorDetails = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fpv.selector))
	}
}

func (fpv *ConversationTurn_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ConversationTurn)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ConversationTurn_FieldTerminalPathValue' with the value under path in 'ConversationTurn'.
func (fpv *ConversationTurn_FieldTerminalPathValue) CompareWith(source *ConversationTurn) (int, bool) {
	switch fpv.selector {
	case ConversationTurn_FieldPathSelectorTurnNumber:
		leftValue := fpv.value.(int32)
		rightValue := source.GetTurnNumber()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ConversationTurn_FieldPathSelectorTimestamp:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetTimestamp()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case ConversationTurn_FieldPathSelectorMessages:
		return 0, false
	case ConversationTurn_FieldPathSelectorConfig:
		return 0, false
	case ConversationTurn_FieldPathSelectorUsage:
		return 0, false
	case ConversationTurn_FieldPathSelectorStopReason:
		leftValue := fpv.value.(common_client.StopReason)
		rightValue := source.GetStopReason()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ConversationTurn_FieldPathSelectorDuration:
		leftValue := fpv.value.(*durationpb.Duration)
		rightValue := source.GetDuration()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsDuration() == rightValue.AsDuration() {
			return 0, true
		} else if leftValue.AsDuration() < rightValue.AsDuration() {
			return -1, true
		} else {
			return 1, true
		}
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		return 0, false
	case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
		leftValue := fpv.value.(int32)
		rightValue := source.GetReplacedTurnNumber()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ConversationTurn_FieldPathSelectorErrorDetails:
		leftValue := fpv.value.(string)
		rightValue := source.GetErrorDetails()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fpv.selector))
	}
}

func (fpv *ConversationTurn_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ConversationTurn))
}

type ConversationTurn_FieldSubPathValue struct {
	ConversationTurn_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ConversationTurn_FieldPathValue = (*ConversationTurn_FieldSubPathValue)(nil)

func (fpvs *ConversationTurn_FieldSubPathValue) AsConfigPathValue() (TurnConfig_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(TurnConfig_FieldPathValue)
	return res, ok
}
func (fpvs *ConversationTurn_FieldSubPathValue) AsAvailableToolsBySourcePathValue() (TurnToolsBySourceGroup_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(TurnToolsBySourceGroup_FieldPathValue)
	return res, ok
}

func (fpvs *ConversationTurn_FieldSubPathValue) SetTo(target **ConversationTurn) {
	if *target == nil {
		*target = new(ConversationTurn)
	}
	switch fpvs.Selector() {
	case ConversationTurn_FieldPathSelectorConfig:
		fpvs.subPathValue.(TurnConfig_FieldPathValue).SetTo(&(*target).Config)
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fpvs.Selector()))
	}
}

func (fpvs *ConversationTurn_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ConversationTurn)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ConversationTurn_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ConversationTurn_FieldSubPathValue) CompareWith(source *ConversationTurn) (int, bool) {
	switch fpvs.Selector() {
	case ConversationTurn_FieldPathSelectorConfig:
		return fpvs.subPathValue.(TurnConfig_FieldPathValue).CompareWith(source.GetConfig())
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fpvs.Selector()))
	}
}

func (fpvs *ConversationTurn_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ConversationTurn))
}

// ConversationTurn_FieldPathArrayItemValue allows storing single item in Path-specific values for ConversationTurn according to their type
// Present only for array (repeated) types.
type ConversationTurn_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ConversationTurn_FieldPath
	ContainsValue(*ConversationTurn) bool
}

// ParseConversationTurn_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseConversationTurn_FieldPathArrayItemValue(pathStr, valueStr string) (ConversationTurn_FieldPathArrayItemValue, error) {
	fp, err := ParseConversationTurn_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConversationTurn field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ConversationTurn_FieldPathArrayItemValue), nil
}

func MustParseConversationTurn_FieldPathArrayItemValue(pathStr, valueStr string) ConversationTurn_FieldPathArrayItemValue {
	fpaiv, err := ParseConversationTurn_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ConversationTurn_FieldTerminalPathArrayItemValue struct {
	ConversationTurn_FieldTerminalPath
	value interface{}
}

var _ ConversationTurn_FieldPathArrayItemValue = (*ConversationTurn_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ConversationTurn as interface{}
func (fpaiv *ConversationTurn_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *ConversationTurn_FieldTerminalPathArrayItemValue) AsMessagesItemValue() (*common_client.Message, bool) {
	res, ok := fpaiv.value.(*common_client.Message)
	return res, ok
}
func (fpaiv *ConversationTurn_FieldTerminalPathArrayItemValue) AsAvailableToolsBySourceItemValue() (*TurnToolsBySourceGroup, bool) {
	res, ok := fpaiv.value.(*TurnToolsBySourceGroup)
	return res, ok
}

func (fpaiv *ConversationTurn_FieldTerminalPathArrayItemValue) GetSingle(source *ConversationTurn) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ConversationTurn_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ConversationTurn))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ConversationTurn'
func (fpaiv *ConversationTurn_FieldTerminalPathArrayItemValue) ContainsValue(source *ConversationTurn) bool {
	slice := fpaiv.ConversationTurn_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ConversationTurn_FieldSubPathArrayItemValue struct {
	ConversationTurn_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ConversationTurn_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ConversationTurn_FieldSubPathArrayItemValue) AsConfigPathItemValue() (TurnConfig_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(TurnConfig_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *ConversationTurn_FieldSubPathArrayItemValue) AsAvailableToolsBySourcePathItemValue() (TurnToolsBySourceGroup_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(TurnToolsBySourceGroup_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ConversationTurn'
func (fpaivs *ConversationTurn_FieldSubPathArrayItemValue) ContainsValue(source *ConversationTurn) bool {
	switch fpaivs.Selector() {
	case ConversationTurn_FieldPathSelectorConfig:
		return fpaivs.subPathItemValue.(TurnConfig_FieldPathArrayItemValue).ContainsValue(source.GetConfig())
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for ConversationTurn: %d", fpaivs.Selector()))
	}
}

// ConversationTurn_FieldPathArrayOfValues allows storing slice of values for ConversationTurn fields according to their type
type ConversationTurn_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ConversationTurn_FieldPath
}

func ParseConversationTurn_FieldPathArrayOfValues(pathStr, valuesStr string) (ConversationTurn_FieldPathArrayOfValues, error) {
	fp, err := ParseConversationTurn_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ConversationTurn field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ConversationTurn_FieldPathArrayOfValues), nil
}

func MustParseConversationTurn_FieldPathArrayOfValues(pathStr, valuesStr string) ConversationTurn_FieldPathArrayOfValues {
	fpaov, err := ParseConversationTurn_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ConversationTurn_FieldTerminalPathArrayOfValues struct {
	ConversationTurn_FieldTerminalPath
	values interface{}
}

var _ ConversationTurn_FieldPathArrayOfValues = (*ConversationTurn_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ConversationTurn_FieldPathSelectorTurnNumber:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorTimestamp:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorMessages:
		for _, v := range fpaov.values.([][]*common_client.Message) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorConfig:
		for _, v := range fpaov.values.([]*TurnConfig) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorUsage:
		for _, v := range fpaov.values.([]*common_client.TokenUsage) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorStopReason:
		for _, v := range fpaov.values.([]common_client.StopReason) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorDuration:
		for _, v := range fpaov.values.([]*durationpb.Duration) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
		for _, v := range fpaov.values.([][]*TurnToolsBySourceGroup) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ConversationTurn_FieldPathSelectorErrorDetails:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsTurnNumberArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsTimestampArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsMessagesArrayOfValues() ([][]*common_client.Message, bool) {
	res, ok := fpaov.values.([][]*common_client.Message)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsConfigArrayOfValues() ([]*TurnConfig, bool) {
	res, ok := fpaov.values.([]*TurnConfig)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsUsageArrayOfValues() ([]*common_client.TokenUsage, bool) {
	res, ok := fpaov.values.([]*common_client.TokenUsage)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsStopReasonArrayOfValues() ([]common_client.StopReason, bool) {
	res, ok := fpaov.values.([]common_client.StopReason)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsDurationArrayOfValues() ([]*durationpb.Duration, bool) {
	res, ok := fpaov.values.([]*durationpb.Duration)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsAvailableToolsBySourceArrayOfValues() ([][]*TurnToolsBySourceGroup, bool) {
	res, ok := fpaov.values.([][]*TurnToolsBySourceGroup)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsReplacedTurnNumberArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ConversationTurn_FieldTerminalPathArrayOfValues) AsErrorDetailsArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

type ConversationTurn_FieldSubPathArrayOfValues struct {
	ConversationTurn_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ConversationTurn_FieldPathArrayOfValues = (*ConversationTurn_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ConversationTurn_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ConversationTurn_FieldSubPathArrayOfValues) AsConfigPathArrayOfValues() (TurnConfig_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(TurnConfig_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *ConversationTurn_FieldSubPathArrayOfValues) AsAvailableToolsBySourcePathArrayOfValues() (TurnToolsBySourceGroup_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(TurnToolsBySourceGroup_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type TurnToolsBySourceGroup_FieldPath interface {
	gotenobject.FieldPath
	Selector() TurnToolsBySourceGroup_FieldPathSelector
	Get(source *TurnToolsBySourceGroup) []interface{}
	GetSingle(source *TurnToolsBySourceGroup) (interface{}, bool)
	ClearValue(item *TurnToolsBySourceGroup)

	// Those methods build corresponding TurnToolsBySourceGroup_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) TurnToolsBySourceGroup_FieldPathValue
	WithIArrayOfValues(values interface{}) TurnToolsBySourceGroup_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) TurnToolsBySourceGroup_FieldPathArrayItemValue
}

type TurnToolsBySourceGroup_FieldPathSelector int32

const (
	TurnToolsBySourceGroup_FieldPathSelectorClient    TurnToolsBySourceGroup_FieldPathSelector = 0
	TurnToolsBySourceGroup_FieldPathSelectorConnector TurnToolsBySourceGroup_FieldPathSelector = 1
	TurnToolsBySourceGroup_FieldPathSelectorInternal  TurnToolsBySourceGroup_FieldPathSelector = 2
	TurnToolsBySourceGroup_FieldPathSelectorToolNames TurnToolsBySourceGroup_FieldPathSelector = 3
)

func (s TurnToolsBySourceGroup_FieldPathSelector) String() string {
	switch s {
	case TurnToolsBySourceGroup_FieldPathSelectorClient:
		return "client"
	case TurnToolsBySourceGroup_FieldPathSelectorConnector:
		return "connector"
	case TurnToolsBySourceGroup_FieldPathSelectorInternal:
		return "internal"
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		return "tool_names"
	default:
		panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", s))
	}
}

func BuildTurnToolsBySourceGroup_FieldPath(fp gotenobject.RawFieldPath) (TurnToolsBySourceGroup_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object TurnToolsBySourceGroup")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "client":
			return &TurnToolsBySourceGroup_FieldTerminalPath{selector: TurnToolsBySourceGroup_FieldPathSelectorClient}, nil
		case "connector":
			return &TurnToolsBySourceGroup_FieldTerminalPath{selector: TurnToolsBySourceGroup_FieldPathSelectorConnector}, nil
		case "internal":
			return &TurnToolsBySourceGroup_FieldTerminalPath{selector: TurnToolsBySourceGroup_FieldPathSelectorInternal}, nil
		case "tool_names", "toolNames", "tool-names":
			return &TurnToolsBySourceGroup_FieldTerminalPath{selector: TurnToolsBySourceGroup_FieldPathSelectorToolNames}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object TurnToolsBySourceGroup", fp)
}

func ParseTurnToolsBySourceGroup_FieldPath(rawField string) (TurnToolsBySourceGroup_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildTurnToolsBySourceGroup_FieldPath(fp)
}

func MustParseTurnToolsBySourceGroup_FieldPath(rawField string) TurnToolsBySourceGroup_FieldPath {
	fp, err := ParseTurnToolsBySourceGroup_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type TurnToolsBySourceGroup_FieldTerminalPath struct {
	selector TurnToolsBySourceGroup_FieldPathSelector
}

var _ TurnToolsBySourceGroup_FieldPath = (*TurnToolsBySourceGroup_FieldTerminalPath)(nil)

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) Selector() TurnToolsBySourceGroup_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *TurnToolsBySourceGroup_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *TurnToolsBySourceGroup_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source TurnToolsBySourceGroup
func (fp *TurnToolsBySourceGroup_FieldTerminalPath) Get(source *TurnToolsBySourceGroup) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case TurnToolsBySourceGroup_FieldPathSelectorClient:
			if source, ok := source.Source.(*TurnToolsBySourceGroup_Client); ok && source != nil {
				if source.Client != nil {
					values = append(values, source.Client)
				}
			}
		case TurnToolsBySourceGroup_FieldPathSelectorConnector:
			if source, ok := source.Source.(*TurnToolsBySourceGroup_Connector); ok && source != nil {
				if source.Connector != nil {
					values = append(values, source.Connector)
				}
			}
		case TurnToolsBySourceGroup_FieldPathSelectorInternal:
			if source, ok := source.Source.(*TurnToolsBySourceGroup_Internal); ok && source != nil {
				if source.Internal != nil {
					values = append(values, source.Internal)
				}
			}
		case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
			for _, value := range source.GetToolNames() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fp.selector))
		}
	}
	return
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*TurnToolsBySourceGroup))
}

// GetSingle returns value pointed by specific field of from source TurnToolsBySourceGroup
func (fp *TurnToolsBySourceGroup_FieldTerminalPath) GetSingle(source *TurnToolsBySourceGroup) (interface{}, bool) {
	switch fp.selector {
	case TurnToolsBySourceGroup_FieldPathSelectorClient:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetClient(), false
		}
		_, oneOfSelected := source.Source.(*TurnToolsBySourceGroup_Client)
		if !oneOfSelected {
			return source.GetClient(), false // to return "type" information
		}
		res := source.GetClient()
		return res, res != nil
	case TurnToolsBySourceGroup_FieldPathSelectorConnector:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetConnector(), false
		}
		_, oneOfSelected := source.Source.(*TurnToolsBySourceGroup_Connector)
		if !oneOfSelected {
			return source.GetConnector(), false // to return "type" information
		}
		res := source.GetConnector()
		return res, res != nil
	case TurnToolsBySourceGroup_FieldPathSelectorInternal:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetInternal(), false
		}
		_, oneOfSelected := source.Source.(*TurnToolsBySourceGroup_Internal)
		if !oneOfSelected {
			return source.GetInternal(), false // to return "type" information
		}
		res := source.GetInternal()
		return res, res != nil
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		res := source.GetToolNames()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fp.selector))
	}
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*TurnToolsBySourceGroup))
}

// GetDefault returns a default value of the field type
func (fp *TurnToolsBySourceGroup_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case TurnToolsBySourceGroup_FieldPathSelectorClient:
		return (*common_client.ClientToolSource)(nil)
	case TurnToolsBySourceGroup_FieldPathSelectorConnector:
		return (*common_client.ConnectorToolSource)(nil)
	case TurnToolsBySourceGroup_FieldPathSelectorInternal:
		return (*common_client.InternalToolSource)(nil)
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fp.selector))
	}
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) ClearValue(item *TurnToolsBySourceGroup) {
	if item != nil {
		switch fp.selector {
		case TurnToolsBySourceGroup_FieldPathSelectorClient:
			if item, ok := item.Source.(*TurnToolsBySourceGroup_Client); ok {
				item.Client = nil
			}
		case TurnToolsBySourceGroup_FieldPathSelectorConnector:
			if item, ok := item.Source.(*TurnToolsBySourceGroup_Connector); ok {
				item.Connector = nil
			}
		case TurnToolsBySourceGroup_FieldPathSelectorInternal:
			if item, ok := item.Source.(*TurnToolsBySourceGroup_Internal); ok {
				item.Internal = nil
			}
		case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
			item.ToolNames = nil
		default:
			panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fp.selector))
		}
	}
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*TurnToolsBySourceGroup))
}

// IsLeaf - whether field path is holds simple value
func (fp *TurnToolsBySourceGroup_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == TurnToolsBySourceGroup_FieldPathSelectorClient ||
		fp.selector == TurnToolsBySourceGroup_FieldPathSelectorConnector ||
		fp.selector == TurnToolsBySourceGroup_FieldPathSelectorInternal ||
		fp.selector == TurnToolsBySourceGroup_FieldPathSelectorToolNames
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) WithIValue(value interface{}) TurnToolsBySourceGroup_FieldPathValue {
	switch fp.selector {
	case TurnToolsBySourceGroup_FieldPathSelectorClient:
		return &TurnToolsBySourceGroup_FieldTerminalPathValue{TurnToolsBySourceGroup_FieldTerminalPath: *fp, value: value.(*common_client.ClientToolSource)}
	case TurnToolsBySourceGroup_FieldPathSelectorConnector:
		return &TurnToolsBySourceGroup_FieldTerminalPathValue{TurnToolsBySourceGroup_FieldTerminalPath: *fp, value: value.(*common_client.ConnectorToolSource)}
	case TurnToolsBySourceGroup_FieldPathSelectorInternal:
		return &TurnToolsBySourceGroup_FieldTerminalPathValue{TurnToolsBySourceGroup_FieldTerminalPath: *fp, value: value.(*common_client.InternalToolSource)}
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		return &TurnToolsBySourceGroup_FieldTerminalPathValue{TurnToolsBySourceGroup_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fp.selector))
	}
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) WithIArrayOfValues(values interface{}) TurnToolsBySourceGroup_FieldPathArrayOfValues {
	fpaov := &TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues{TurnToolsBySourceGroup_FieldTerminalPath: *fp}
	switch fp.selector {
	case TurnToolsBySourceGroup_FieldPathSelectorClient:
		return &TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues{TurnToolsBySourceGroup_FieldTerminalPath: *fp, values: values.([]*common_client.ClientToolSource)}
	case TurnToolsBySourceGroup_FieldPathSelectorConnector:
		return &TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues{TurnToolsBySourceGroup_FieldTerminalPath: *fp, values: values.([]*common_client.ConnectorToolSource)}
	case TurnToolsBySourceGroup_FieldPathSelectorInternal:
		return &TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues{TurnToolsBySourceGroup_FieldTerminalPath: *fp, values: values.([]*common_client.InternalToolSource)}
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		return &TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues{TurnToolsBySourceGroup_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fp.selector))
	}
	return fpaov
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) WithIArrayItemValue(value interface{}) TurnToolsBySourceGroup_FieldPathArrayItemValue {
	switch fp.selector {
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		return &TurnToolsBySourceGroup_FieldTerminalPathArrayItemValue{TurnToolsBySourceGroup_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fp.selector))
	}
}

func (fp *TurnToolsBySourceGroup_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// TurnToolsBySourceGroup_FieldPathValue allows storing values for TurnToolsBySourceGroup fields according to their type
type TurnToolsBySourceGroup_FieldPathValue interface {
	TurnToolsBySourceGroup_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **TurnToolsBySourceGroup)
	CompareWith(*TurnToolsBySourceGroup) (cmp int, comparable bool)
}

func ParseTurnToolsBySourceGroup_FieldPathValue(pathStr, valueStr string) (TurnToolsBySourceGroup_FieldPathValue, error) {
	fp, err := ParseTurnToolsBySourceGroup_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TurnToolsBySourceGroup field path value from %s: %v", valueStr, err)
	}
	return fpv.(TurnToolsBySourceGroup_FieldPathValue), nil
}

func MustParseTurnToolsBySourceGroup_FieldPathValue(pathStr, valueStr string) TurnToolsBySourceGroup_FieldPathValue {
	fpv, err := ParseTurnToolsBySourceGroup_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type TurnToolsBySourceGroup_FieldTerminalPathValue struct {
	TurnToolsBySourceGroup_FieldTerminalPath
	value interface{}
}

var _ TurnToolsBySourceGroup_FieldPathValue = (*TurnToolsBySourceGroup_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'TurnToolsBySourceGroup' as interface{}
func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) AsClientValue() (*common_client.ClientToolSource, bool) {
	res, ok := fpv.value.(*common_client.ClientToolSource)
	return res, ok
}
func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) AsConnectorValue() (*common_client.ConnectorToolSource, bool) {
	res, ok := fpv.value.(*common_client.ConnectorToolSource)
	return res, ok
}
func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) AsInternalValue() (*common_client.InternalToolSource, bool) {
	res, ok := fpv.value.(*common_client.InternalToolSource)
	return res, ok
}
func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) AsToolNamesValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object TurnToolsBySourceGroup
func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) SetTo(target **TurnToolsBySourceGroup) {
	if *target == nil {
		*target = new(TurnToolsBySourceGroup)
	}
	switch fpv.selector {
	case TurnToolsBySourceGroup_FieldPathSelectorClient:
		if _, ok := (*target).Source.(*TurnToolsBySourceGroup_Client); !ok {
			(*target).Source = &TurnToolsBySourceGroup_Client{}
		}
		(*target).Source.(*TurnToolsBySourceGroup_Client).Client = fpv.value.(*common_client.ClientToolSource)
	case TurnToolsBySourceGroup_FieldPathSelectorConnector:
		if _, ok := (*target).Source.(*TurnToolsBySourceGroup_Connector); !ok {
			(*target).Source = &TurnToolsBySourceGroup_Connector{}
		}
		(*target).Source.(*TurnToolsBySourceGroup_Connector).Connector = fpv.value.(*common_client.ConnectorToolSource)
	case TurnToolsBySourceGroup_FieldPathSelectorInternal:
		if _, ok := (*target).Source.(*TurnToolsBySourceGroup_Internal); !ok {
			(*target).Source = &TurnToolsBySourceGroup_Internal{}
		}
		(*target).Source.(*TurnToolsBySourceGroup_Internal).Internal = fpv.value.(*common_client.InternalToolSource)
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		(*target).ToolNames = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fpv.selector))
	}
}

func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TurnToolsBySourceGroup)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'TurnToolsBySourceGroup_FieldTerminalPathValue' with the value under path in 'TurnToolsBySourceGroup'.
func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) CompareWith(source *TurnToolsBySourceGroup) (int, bool) {
	switch fpv.selector {
	case TurnToolsBySourceGroup_FieldPathSelectorClient:
		return 0, false
	case TurnToolsBySourceGroup_FieldPathSelectorConnector:
		return 0, false
	case TurnToolsBySourceGroup_FieldPathSelectorInternal:
		return 0, false
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for TurnToolsBySourceGroup: %d", fpv.selector))
	}
}

func (fpv *TurnToolsBySourceGroup_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*TurnToolsBySourceGroup))
}

// TurnToolsBySourceGroup_FieldPathArrayItemValue allows storing single item in Path-specific values for TurnToolsBySourceGroup according to their type
// Present only for array (repeated) types.
type TurnToolsBySourceGroup_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	TurnToolsBySourceGroup_FieldPath
	ContainsValue(*TurnToolsBySourceGroup) bool
}

// ParseTurnToolsBySourceGroup_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseTurnToolsBySourceGroup_FieldPathArrayItemValue(pathStr, valueStr string) (TurnToolsBySourceGroup_FieldPathArrayItemValue, error) {
	fp, err := ParseTurnToolsBySourceGroup_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TurnToolsBySourceGroup field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(TurnToolsBySourceGroup_FieldPathArrayItemValue), nil
}

func MustParseTurnToolsBySourceGroup_FieldPathArrayItemValue(pathStr, valueStr string) TurnToolsBySourceGroup_FieldPathArrayItemValue {
	fpaiv, err := ParseTurnToolsBySourceGroup_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type TurnToolsBySourceGroup_FieldTerminalPathArrayItemValue struct {
	TurnToolsBySourceGroup_FieldTerminalPath
	value interface{}
}

var _ TurnToolsBySourceGroup_FieldPathArrayItemValue = (*TurnToolsBySourceGroup_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object TurnToolsBySourceGroup as interface{}
func (fpaiv *TurnToolsBySourceGroup_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *TurnToolsBySourceGroup_FieldTerminalPathArrayItemValue) AsToolNamesItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *TurnToolsBySourceGroup_FieldTerminalPathArrayItemValue) GetSingle(source *TurnToolsBySourceGroup) (interface{}, bool) {
	return nil, false
}

func (fpaiv *TurnToolsBySourceGroup_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*TurnToolsBySourceGroup))
}

// Contains returns a boolean indicating if value that is being held is present in given 'TurnToolsBySourceGroup'
func (fpaiv *TurnToolsBySourceGroup_FieldTerminalPathArrayItemValue) ContainsValue(source *TurnToolsBySourceGroup) bool {
	slice := fpaiv.TurnToolsBySourceGroup_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// TurnToolsBySourceGroup_FieldPathArrayOfValues allows storing slice of values for TurnToolsBySourceGroup fields according to their type
type TurnToolsBySourceGroup_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	TurnToolsBySourceGroup_FieldPath
}

func ParseTurnToolsBySourceGroup_FieldPathArrayOfValues(pathStr, valuesStr string) (TurnToolsBySourceGroup_FieldPathArrayOfValues, error) {
	fp, err := ParseTurnToolsBySourceGroup_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TurnToolsBySourceGroup field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(TurnToolsBySourceGroup_FieldPathArrayOfValues), nil
}

func MustParseTurnToolsBySourceGroup_FieldPathArrayOfValues(pathStr, valuesStr string) TurnToolsBySourceGroup_FieldPathArrayOfValues {
	fpaov, err := ParseTurnToolsBySourceGroup_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues struct {
	TurnToolsBySourceGroup_FieldTerminalPath
	values interface{}
}

var _ TurnToolsBySourceGroup_FieldPathArrayOfValues = (*TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case TurnToolsBySourceGroup_FieldPathSelectorClient:
		for _, v := range fpaov.values.([]*common_client.ClientToolSource) {
			values = append(values, v)
		}
	case TurnToolsBySourceGroup_FieldPathSelectorConnector:
		for _, v := range fpaov.values.([]*common_client.ConnectorToolSource) {
			values = append(values, v)
		}
	case TurnToolsBySourceGroup_FieldPathSelectorInternal:
		for _, v := range fpaov.values.([]*common_client.InternalToolSource) {
			values = append(values, v)
		}
	case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues) AsClientArrayOfValues() ([]*common_client.ClientToolSource, bool) {
	res, ok := fpaov.values.([]*common_client.ClientToolSource)
	return res, ok
}
func (fpaov *TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues) AsConnectorArrayOfValues() ([]*common_client.ConnectorToolSource, bool) {
	res, ok := fpaov.values.([]*common_client.ConnectorToolSource)
	return res, ok
}
func (fpaov *TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues) AsInternalArrayOfValues() ([]*common_client.InternalToolSource, bool) {
	res, ok := fpaov.values.([]*common_client.InternalToolSource)
	return res, ok
}
func (fpaov *TurnToolsBySourceGroup_FieldTerminalPathArrayOfValues) AsToolNamesArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type TurnConfig_FieldPath interface {
	gotenobject.FieldPath
	Selector() TurnConfig_FieldPathSelector
	Get(source *TurnConfig) []interface{}
	GetSingle(source *TurnConfig) (interface{}, bool)
	ClearValue(item *TurnConfig)

	// Those methods build corresponding TurnConfig_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) TurnConfig_FieldPathValue
	WithIArrayOfValues(values interface{}) TurnConfig_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) TurnConfig_FieldPathArrayItemValue
}

type TurnConfig_FieldPathSelector int32

const (
	TurnConfig_FieldPathSelectorModel              TurnConfig_FieldPathSelector = 0
	TurnConfig_FieldPathSelectorModelUsed          TurnConfig_FieldPathSelector = 1
	TurnConfig_FieldPathSelectorTemperature        TurnConfig_FieldPathSelector = 2
	TurnConfig_FieldPathSelectorMaxTokens          TurnConfig_FieldPathSelector = 3
	TurnConfig_FieldPathSelectorReasoningLevel     TurnConfig_FieldPathSelector = 4
	TurnConfig_FieldPathSelectorCapabilityTemplate TurnConfig_FieldPathSelector = 5
	TurnConfig_FieldPathSelectorConnectors         TurnConfig_FieldPathSelector = 6
)

func (s TurnConfig_FieldPathSelector) String() string {
	switch s {
	case TurnConfig_FieldPathSelectorModel:
		return "model"
	case TurnConfig_FieldPathSelectorModelUsed:
		return "model_used"
	case TurnConfig_FieldPathSelectorTemperature:
		return "temperature"
	case TurnConfig_FieldPathSelectorMaxTokens:
		return "max_tokens"
	case TurnConfig_FieldPathSelectorReasoningLevel:
		return "reasoning_level"
	case TurnConfig_FieldPathSelectorCapabilityTemplate:
		return "capability_template"
	case TurnConfig_FieldPathSelectorConnectors:
		return "connectors"
	default:
		panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", s))
	}
}

func BuildTurnConfig_FieldPath(fp gotenobject.RawFieldPath) (TurnConfig_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object TurnConfig")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "model":
			return &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorModel}, nil
		case "model_used", "modelUsed", "model-used":
			return &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorModelUsed}, nil
		case "temperature":
			return &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorTemperature}, nil
		case "max_tokens", "maxTokens", "max-tokens":
			return &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorMaxTokens}, nil
		case "reasoning_level", "reasoningLevel", "reasoning-level":
			return &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorReasoningLevel}, nil
		case "capability_template", "capabilityTemplate", "capability-template":
			return &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorCapabilityTemplate}, nil
		case "connectors":
			return &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorConnectors}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object TurnConfig", fp)
}

func ParseTurnConfig_FieldPath(rawField string) (TurnConfig_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildTurnConfig_FieldPath(fp)
}

func MustParseTurnConfig_FieldPath(rawField string) TurnConfig_FieldPath {
	fp, err := ParseTurnConfig_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type TurnConfig_FieldTerminalPath struct {
	selector TurnConfig_FieldPathSelector
}

var _ TurnConfig_FieldPath = (*TurnConfig_FieldTerminalPath)(nil)

func (fp *TurnConfig_FieldTerminalPath) Selector() TurnConfig_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *TurnConfig_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *TurnConfig_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source TurnConfig
func (fp *TurnConfig_FieldTerminalPath) Get(source *TurnConfig) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case TurnConfig_FieldPathSelectorModel:
			if source.Model != nil {
				values = append(values, source.Model)
			}
		case TurnConfig_FieldPathSelectorModelUsed:
			values = append(values, source.ModelUsed)
		case TurnConfig_FieldPathSelectorTemperature:
			values = append(values, source.Temperature)
		case TurnConfig_FieldPathSelectorMaxTokens:
			values = append(values, source.MaxTokens)
		case TurnConfig_FieldPathSelectorReasoningLevel:
			values = append(values, source.ReasoningLevel)
		case TurnConfig_FieldPathSelectorCapabilityTemplate:
			if source, ok := source.ServerToolsConfig.(*TurnConfig_CapabilityTemplate); ok && source != nil {
				if source.CapabilityTemplate != nil {
					values = append(values, source.CapabilityTemplate)
				}
			}
		case TurnConfig_FieldPathSelectorConnectors:
			if source, ok := source.ServerToolsConfig.(*TurnConfig_Connectors); ok && source != nil {
				if source.Connectors != nil {
					values = append(values, source.Connectors)
				}
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fp.selector))
		}
	}
	return
}

func (fp *TurnConfig_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*TurnConfig))
}

// GetSingle returns value pointed by specific field of from source TurnConfig
func (fp *TurnConfig_FieldTerminalPath) GetSingle(source *TurnConfig) (interface{}, bool) {
	switch fp.selector {
	case TurnConfig_FieldPathSelectorModel:
		res := source.GetModel()
		return res, res != nil
	case TurnConfig_FieldPathSelectorModelUsed:
		return source.GetModelUsed(), source != nil
	case TurnConfig_FieldPathSelectorTemperature:
		return source.GetTemperature(), source != nil
	case TurnConfig_FieldPathSelectorMaxTokens:
		return source.GetMaxTokens(), source != nil
	case TurnConfig_FieldPathSelectorReasoningLevel:
		return source.GetReasoningLevel(), source != nil
	case TurnConfig_FieldPathSelectorCapabilityTemplate:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetCapabilityTemplate(), false
		}
		_, oneOfSelected := source.ServerToolsConfig.(*TurnConfig_CapabilityTemplate)
		if !oneOfSelected {
			return source.GetCapabilityTemplate(), false // to return "type" information
		}
		res := source.GetCapabilityTemplate()
		return res, res != nil
	case TurnConfig_FieldPathSelectorConnectors:
		// if object nil or oneof not active, return "default" type with false flag.
		if source == nil {
			return source.GetConnectors(), false
		}
		_, oneOfSelected := source.ServerToolsConfig.(*TurnConfig_Connectors)
		if !oneOfSelected {
			return source.GetConnectors(), false // to return "type" information
		}
		res := source.GetConnectors()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fp.selector))
	}
}

func (fp *TurnConfig_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*TurnConfig))
}

// GetDefault returns a default value of the field type
func (fp *TurnConfig_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case TurnConfig_FieldPathSelectorModel:
		return (*chat_model.Name)(nil)
	case TurnConfig_FieldPathSelectorModelUsed:
		return ""
	case TurnConfig_FieldPathSelectorTemperature:
		return float32(0)
	case TurnConfig_FieldPathSelectorMaxTokens:
		return int32(0)
	case TurnConfig_FieldPathSelectorReasoningLevel:
		return common_client.ReasoningLevel_REASONING_LEVEL_DEFAULT
	case TurnConfig_FieldPathSelectorCapabilityTemplate:
		return (*capability_template.Name)(nil)
	case TurnConfig_FieldPathSelectorConnectors:
		return (*common_client.ConnectorsList)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fp.selector))
	}
}

func (fp *TurnConfig_FieldTerminalPath) ClearValue(item *TurnConfig) {
	if item != nil {
		switch fp.selector {
		case TurnConfig_FieldPathSelectorModel:
			item.Model = nil
		case TurnConfig_FieldPathSelectorModelUsed:
			item.ModelUsed = ""
		case TurnConfig_FieldPathSelectorTemperature:
			item.Temperature = float32(0)
		case TurnConfig_FieldPathSelectorMaxTokens:
			item.MaxTokens = int32(0)
		case TurnConfig_FieldPathSelectorReasoningLevel:
			item.ReasoningLevel = common_client.ReasoningLevel_REASONING_LEVEL_DEFAULT
		case TurnConfig_FieldPathSelectorCapabilityTemplate:
			if item, ok := item.ServerToolsConfig.(*TurnConfig_CapabilityTemplate); ok {
				item.CapabilityTemplate = nil
			}
		case TurnConfig_FieldPathSelectorConnectors:
			if item, ok := item.ServerToolsConfig.(*TurnConfig_Connectors); ok {
				item.Connectors = nil
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fp.selector))
		}
	}
}

func (fp *TurnConfig_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*TurnConfig))
}

// IsLeaf - whether field path is holds simple value
func (fp *TurnConfig_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == TurnConfig_FieldPathSelectorModel ||
		fp.selector == TurnConfig_FieldPathSelectorModelUsed ||
		fp.selector == TurnConfig_FieldPathSelectorTemperature ||
		fp.selector == TurnConfig_FieldPathSelectorMaxTokens ||
		fp.selector == TurnConfig_FieldPathSelectorReasoningLevel ||
		fp.selector == TurnConfig_FieldPathSelectorCapabilityTemplate ||
		fp.selector == TurnConfig_FieldPathSelectorConnectors
}

func (fp *TurnConfig_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *TurnConfig_FieldTerminalPath) WithIValue(value interface{}) TurnConfig_FieldPathValue {
	switch fp.selector {
	case TurnConfig_FieldPathSelectorModel:
		return &TurnConfig_FieldTerminalPathValue{TurnConfig_FieldTerminalPath: *fp, value: value.(*chat_model.Name)}
	case TurnConfig_FieldPathSelectorModelUsed:
		return &TurnConfig_FieldTerminalPathValue{TurnConfig_FieldTerminalPath: *fp, value: value.(string)}
	case TurnConfig_FieldPathSelectorTemperature:
		return &TurnConfig_FieldTerminalPathValue{TurnConfig_FieldTerminalPath: *fp, value: value.(float32)}
	case TurnConfig_FieldPathSelectorMaxTokens:
		return &TurnConfig_FieldTerminalPathValue{TurnConfig_FieldTerminalPath: *fp, value: value.(int32)}
	case TurnConfig_FieldPathSelectorReasoningLevel:
		return &TurnConfig_FieldTerminalPathValue{TurnConfig_FieldTerminalPath: *fp, value: value.(common_client.ReasoningLevel)}
	case TurnConfig_FieldPathSelectorCapabilityTemplate:
		return &TurnConfig_FieldTerminalPathValue{TurnConfig_FieldTerminalPath: *fp, value: value.(*capability_template.Name)}
	case TurnConfig_FieldPathSelectorConnectors:
		return &TurnConfig_FieldTerminalPathValue{TurnConfig_FieldTerminalPath: *fp, value: value.(*common_client.ConnectorsList)}
	default:
		panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fp.selector))
	}
}

func (fp *TurnConfig_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *TurnConfig_FieldTerminalPath) WithIArrayOfValues(values interface{}) TurnConfig_FieldPathArrayOfValues {
	fpaov := &TurnConfig_FieldTerminalPathArrayOfValues{TurnConfig_FieldTerminalPath: *fp}
	switch fp.selector {
	case TurnConfig_FieldPathSelectorModel:
		return &TurnConfig_FieldTerminalPathArrayOfValues{TurnConfig_FieldTerminalPath: *fp, values: values.([]*chat_model.Name)}
	case TurnConfig_FieldPathSelectorModelUsed:
		return &TurnConfig_FieldTerminalPathArrayOfValues{TurnConfig_FieldTerminalPath: *fp, values: values.([]string)}
	case TurnConfig_FieldPathSelectorTemperature:
		return &TurnConfig_FieldTerminalPathArrayOfValues{TurnConfig_FieldTerminalPath: *fp, values: values.([]float32)}
	case TurnConfig_FieldPathSelectorMaxTokens:
		return &TurnConfig_FieldTerminalPathArrayOfValues{TurnConfig_FieldTerminalPath: *fp, values: values.([]int32)}
	case TurnConfig_FieldPathSelectorReasoningLevel:
		return &TurnConfig_FieldTerminalPathArrayOfValues{TurnConfig_FieldTerminalPath: *fp, values: values.([]common_client.ReasoningLevel)}
	case TurnConfig_FieldPathSelectorCapabilityTemplate:
		return &TurnConfig_FieldTerminalPathArrayOfValues{TurnConfig_FieldTerminalPath: *fp, values: values.([]*capability_template.Name)}
	case TurnConfig_FieldPathSelectorConnectors:
		return &TurnConfig_FieldTerminalPathArrayOfValues{TurnConfig_FieldTerminalPath: *fp, values: values.([]*common_client.ConnectorsList)}
	default:
		panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fp.selector))
	}
	return fpaov
}

func (fp *TurnConfig_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *TurnConfig_FieldTerminalPath) WithIArrayItemValue(value interface{}) TurnConfig_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fp.selector))
	}
}

func (fp *TurnConfig_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// TurnConfig_FieldPathValue allows storing values for TurnConfig fields according to their type
type TurnConfig_FieldPathValue interface {
	TurnConfig_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **TurnConfig)
	CompareWith(*TurnConfig) (cmp int, comparable bool)
}

func ParseTurnConfig_FieldPathValue(pathStr, valueStr string) (TurnConfig_FieldPathValue, error) {
	fp, err := ParseTurnConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TurnConfig field path value from %s: %v", valueStr, err)
	}
	return fpv.(TurnConfig_FieldPathValue), nil
}

func MustParseTurnConfig_FieldPathValue(pathStr, valueStr string) TurnConfig_FieldPathValue {
	fpv, err := ParseTurnConfig_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type TurnConfig_FieldTerminalPathValue struct {
	TurnConfig_FieldTerminalPath
	value interface{}
}

var _ TurnConfig_FieldPathValue = (*TurnConfig_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'TurnConfig' as interface{}
func (fpv *TurnConfig_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *TurnConfig_FieldTerminalPathValue) AsModelValue() (*chat_model.Name, bool) {
	res, ok := fpv.value.(*chat_model.Name)
	return res, ok
}
func (fpv *TurnConfig_FieldTerminalPathValue) AsModelUsedValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *TurnConfig_FieldTerminalPathValue) AsTemperatureValue() (float32, bool) {
	res, ok := fpv.value.(float32)
	return res, ok
}
func (fpv *TurnConfig_FieldTerminalPathValue) AsMaxTokensValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *TurnConfig_FieldTerminalPathValue) AsReasoningLevelValue() (common_client.ReasoningLevel, bool) {
	res, ok := fpv.value.(common_client.ReasoningLevel)
	return res, ok
}
func (fpv *TurnConfig_FieldTerminalPathValue) AsCapabilityTemplateValue() (*capability_template.Name, bool) {
	res, ok := fpv.value.(*capability_template.Name)
	return res, ok
}
func (fpv *TurnConfig_FieldTerminalPathValue) AsConnectorsValue() (*common_client.ConnectorsList, bool) {
	res, ok := fpv.value.(*common_client.ConnectorsList)
	return res, ok
}

// SetTo stores value for selected field for object TurnConfig
func (fpv *TurnConfig_FieldTerminalPathValue) SetTo(target **TurnConfig) {
	if *target == nil {
		*target = new(TurnConfig)
	}
	switch fpv.selector {
	case TurnConfig_FieldPathSelectorModel:
		(*target).Model = fpv.value.(*chat_model.Name)
	case TurnConfig_FieldPathSelectorModelUsed:
		(*target).ModelUsed = fpv.value.(string)
	case TurnConfig_FieldPathSelectorTemperature:
		(*target).Temperature = fpv.value.(float32)
	case TurnConfig_FieldPathSelectorMaxTokens:
		(*target).MaxTokens = fpv.value.(int32)
	case TurnConfig_FieldPathSelectorReasoningLevel:
		(*target).ReasoningLevel = fpv.value.(common_client.ReasoningLevel)
	case TurnConfig_FieldPathSelectorCapabilityTemplate:
		if _, ok := (*target).ServerToolsConfig.(*TurnConfig_CapabilityTemplate); !ok {
			(*target).ServerToolsConfig = &TurnConfig_CapabilityTemplate{}
		}
		(*target).ServerToolsConfig.(*TurnConfig_CapabilityTemplate).CapabilityTemplate = fpv.value.(*capability_template.Name)
	case TurnConfig_FieldPathSelectorConnectors:
		if _, ok := (*target).ServerToolsConfig.(*TurnConfig_Connectors); !ok {
			(*target).ServerToolsConfig = &TurnConfig_Connectors{}
		}
		(*target).ServerToolsConfig.(*TurnConfig_Connectors).Connectors = fpv.value.(*common_client.ConnectorsList)
	default:
		panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fpv.selector))
	}
}

func (fpv *TurnConfig_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TurnConfig)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'TurnConfig_FieldTerminalPathValue' with the value under path in 'TurnConfig'.
func (fpv *TurnConfig_FieldTerminalPathValue) CompareWith(source *TurnConfig) (int, bool) {
	switch fpv.selector {
	case TurnConfig_FieldPathSelectorModel:
		leftValue := fpv.value.(*chat_model.Name)
		rightValue := source.GetModel()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case TurnConfig_FieldPathSelectorModelUsed:
		leftValue := fpv.value.(string)
		rightValue := source.GetModelUsed()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case TurnConfig_FieldPathSelectorTemperature:
		leftValue := fpv.value.(float32)
		rightValue := source.GetTemperature()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case TurnConfig_FieldPathSelectorMaxTokens:
		leftValue := fpv.value.(int32)
		rightValue := source.GetMaxTokens()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case TurnConfig_FieldPathSelectorReasoningLevel:
		leftValue := fpv.value.(common_client.ReasoningLevel)
		rightValue := source.GetReasoningLevel()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case TurnConfig_FieldPathSelectorCapabilityTemplate:
		leftValue := fpv.value.(*capability_template.Name)
		rightValue := source.GetCapabilityTemplate()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case TurnConfig_FieldPathSelectorConnectors:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for TurnConfig: %d", fpv.selector))
	}
}

func (fpv *TurnConfig_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*TurnConfig))
}

// TurnConfig_FieldPathArrayItemValue allows storing single item in Path-specific values for TurnConfig according to their type
// Present only for array (repeated) types.
type TurnConfig_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	TurnConfig_FieldPath
	ContainsValue(*TurnConfig) bool
}

// ParseTurnConfig_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseTurnConfig_FieldPathArrayItemValue(pathStr, valueStr string) (TurnConfig_FieldPathArrayItemValue, error) {
	fp, err := ParseTurnConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TurnConfig field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(TurnConfig_FieldPathArrayItemValue), nil
}

func MustParseTurnConfig_FieldPathArrayItemValue(pathStr, valueStr string) TurnConfig_FieldPathArrayItemValue {
	fpaiv, err := ParseTurnConfig_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type TurnConfig_FieldTerminalPathArrayItemValue struct {
	TurnConfig_FieldTerminalPath
	value interface{}
}

var _ TurnConfig_FieldPathArrayItemValue = (*TurnConfig_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object TurnConfig as interface{}
func (fpaiv *TurnConfig_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *TurnConfig_FieldTerminalPathArrayItemValue) GetSingle(source *TurnConfig) (interface{}, bool) {
	return nil, false
}

func (fpaiv *TurnConfig_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*TurnConfig))
}

// Contains returns a boolean indicating if value that is being held is present in given 'TurnConfig'
func (fpaiv *TurnConfig_FieldTerminalPathArrayItemValue) ContainsValue(source *TurnConfig) bool {
	slice := fpaiv.TurnConfig_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// TurnConfig_FieldPathArrayOfValues allows storing slice of values for TurnConfig fields according to their type
type TurnConfig_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	TurnConfig_FieldPath
}

func ParseTurnConfig_FieldPathArrayOfValues(pathStr, valuesStr string) (TurnConfig_FieldPathArrayOfValues, error) {
	fp, err := ParseTurnConfig_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TurnConfig field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(TurnConfig_FieldPathArrayOfValues), nil
}

func MustParseTurnConfig_FieldPathArrayOfValues(pathStr, valuesStr string) TurnConfig_FieldPathArrayOfValues {
	fpaov, err := ParseTurnConfig_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type TurnConfig_FieldTerminalPathArrayOfValues struct {
	TurnConfig_FieldTerminalPath
	values interface{}
}

var _ TurnConfig_FieldPathArrayOfValues = (*TurnConfig_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *TurnConfig_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case TurnConfig_FieldPathSelectorModel:
		for _, v := range fpaov.values.([]*chat_model.Name) {
			values = append(values, v)
		}
	case TurnConfig_FieldPathSelectorModelUsed:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case TurnConfig_FieldPathSelectorTemperature:
		for _, v := range fpaov.values.([]float32) {
			values = append(values, v)
		}
	case TurnConfig_FieldPathSelectorMaxTokens:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case TurnConfig_FieldPathSelectorReasoningLevel:
		for _, v := range fpaov.values.([]common_client.ReasoningLevel) {
			values = append(values, v)
		}
	case TurnConfig_FieldPathSelectorCapabilityTemplate:
		for _, v := range fpaov.values.([]*capability_template.Name) {
			values = append(values, v)
		}
	case TurnConfig_FieldPathSelectorConnectors:
		for _, v := range fpaov.values.([]*common_client.ConnectorsList) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *TurnConfig_FieldTerminalPathArrayOfValues) AsModelArrayOfValues() ([]*chat_model.Name, bool) {
	res, ok := fpaov.values.([]*chat_model.Name)
	return res, ok
}
func (fpaov *TurnConfig_FieldTerminalPathArrayOfValues) AsModelUsedArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *TurnConfig_FieldTerminalPathArrayOfValues) AsTemperatureArrayOfValues() ([]float32, bool) {
	res, ok := fpaov.values.([]float32)
	return res, ok
}
func (fpaov *TurnConfig_FieldTerminalPathArrayOfValues) AsMaxTokensArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *TurnConfig_FieldTerminalPathArrayOfValues) AsReasoningLevelArrayOfValues() ([]common_client.ReasoningLevel, bool) {
	res, ok := fpaov.values.([]common_client.ReasoningLevel)
	return res, ok
}
func (fpaov *TurnConfig_FieldTerminalPathArrayOfValues) AsCapabilityTemplateArrayOfValues() ([]*capability_template.Name, bool) {
	res, ok := fpaov.values.([]*capability_template.Name)
	return res, ok
}
func (fpaov *TurnConfig_FieldTerminalPathArrayOfValues) AsConnectorsArrayOfValues() ([]*common_client.ConnectorsList, bool) {
	res, ok := fpaov.values.([]*common_client.ConnectorsList)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ModelUsageStats_FieldPath interface {
	gotenobject.FieldPath
	Selector() ModelUsageStats_FieldPathSelector
	Get(source *ModelUsageStats) []interface{}
	GetSingle(source *ModelUsageStats) (interface{}, bool)
	ClearValue(item *ModelUsageStats)

	// Those methods build corresponding ModelUsageStats_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ModelUsageStats_FieldPathValue
	WithIArrayOfValues(values interface{}) ModelUsageStats_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ModelUsageStats_FieldPathArrayItemValue
}

type ModelUsageStats_FieldPathSelector int32

const (
	ModelUsageStats_FieldPathSelectorTurnCount       ModelUsageStats_FieldPathSelector = 0
	ModelUsageStats_FieldPathSelectorAggregatedUsage ModelUsageStats_FieldPathSelector = 1
)

func (s ModelUsageStats_FieldPathSelector) String() string {
	switch s {
	case ModelUsageStats_FieldPathSelectorTurnCount:
		return "turn_count"
	case ModelUsageStats_FieldPathSelectorAggregatedUsage:
		return "aggregated_usage"
	default:
		panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", s))
	}
}

func BuildModelUsageStats_FieldPath(fp gotenobject.RawFieldPath) (ModelUsageStats_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ModelUsageStats")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "turn_count", "turnCount", "turn-count":
			return &ModelUsageStats_FieldTerminalPath{selector: ModelUsageStats_FieldPathSelectorTurnCount}, nil
		case "aggregated_usage", "aggregatedUsage", "aggregated-usage":
			return &ModelUsageStats_FieldTerminalPath{selector: ModelUsageStats_FieldPathSelectorAggregatedUsage}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ModelUsageStats", fp)
}

func ParseModelUsageStats_FieldPath(rawField string) (ModelUsageStats_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildModelUsageStats_FieldPath(fp)
}

func MustParseModelUsageStats_FieldPath(rawField string) ModelUsageStats_FieldPath {
	fp, err := ParseModelUsageStats_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ModelUsageStats_FieldTerminalPath struct {
	selector ModelUsageStats_FieldPathSelector
}

var _ ModelUsageStats_FieldPath = (*ModelUsageStats_FieldTerminalPath)(nil)

func (fp *ModelUsageStats_FieldTerminalPath) Selector() ModelUsageStats_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ModelUsageStats_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ModelUsageStats_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ModelUsageStats
func (fp *ModelUsageStats_FieldTerminalPath) Get(source *ModelUsageStats) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ModelUsageStats_FieldPathSelectorTurnCount:
			values = append(values, source.TurnCount)
		case ModelUsageStats_FieldPathSelectorAggregatedUsage:
			if source.AggregatedUsage != nil {
				values = append(values, source.AggregatedUsage)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fp.selector))
		}
	}
	return
}

func (fp *ModelUsageStats_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ModelUsageStats))
}

// GetSingle returns value pointed by specific field of from source ModelUsageStats
func (fp *ModelUsageStats_FieldTerminalPath) GetSingle(source *ModelUsageStats) (interface{}, bool) {
	switch fp.selector {
	case ModelUsageStats_FieldPathSelectorTurnCount:
		return source.GetTurnCount(), source != nil
	case ModelUsageStats_FieldPathSelectorAggregatedUsage:
		res := source.GetAggregatedUsage()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fp.selector))
	}
}

func (fp *ModelUsageStats_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ModelUsageStats))
}

// GetDefault returns a default value of the field type
func (fp *ModelUsageStats_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ModelUsageStats_FieldPathSelectorTurnCount:
		return int32(0)
	case ModelUsageStats_FieldPathSelectorAggregatedUsage:
		return (*common_client.TokenUsage)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fp.selector))
	}
}

func (fp *ModelUsageStats_FieldTerminalPath) ClearValue(item *ModelUsageStats) {
	if item != nil {
		switch fp.selector {
		case ModelUsageStats_FieldPathSelectorTurnCount:
			item.TurnCount = int32(0)
		case ModelUsageStats_FieldPathSelectorAggregatedUsage:
			item.AggregatedUsage = nil
		default:
			panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fp.selector))
		}
	}
}

func (fp *ModelUsageStats_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ModelUsageStats))
}

// IsLeaf - whether field path is holds simple value
func (fp *ModelUsageStats_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ModelUsageStats_FieldPathSelectorTurnCount ||
		fp.selector == ModelUsageStats_FieldPathSelectorAggregatedUsage
}

func (fp *ModelUsageStats_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ModelUsageStats_FieldTerminalPath) WithIValue(value interface{}) ModelUsageStats_FieldPathValue {
	switch fp.selector {
	case ModelUsageStats_FieldPathSelectorTurnCount:
		return &ModelUsageStats_FieldTerminalPathValue{ModelUsageStats_FieldTerminalPath: *fp, value: value.(int32)}
	case ModelUsageStats_FieldPathSelectorAggregatedUsage:
		return &ModelUsageStats_FieldTerminalPathValue{ModelUsageStats_FieldTerminalPath: *fp, value: value.(*common_client.TokenUsage)}
	default:
		panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fp.selector))
	}
}

func (fp *ModelUsageStats_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ModelUsageStats_FieldTerminalPath) WithIArrayOfValues(values interface{}) ModelUsageStats_FieldPathArrayOfValues {
	fpaov := &ModelUsageStats_FieldTerminalPathArrayOfValues{ModelUsageStats_FieldTerminalPath: *fp}
	switch fp.selector {
	case ModelUsageStats_FieldPathSelectorTurnCount:
		return &ModelUsageStats_FieldTerminalPathArrayOfValues{ModelUsageStats_FieldTerminalPath: *fp, values: values.([]int32)}
	case ModelUsageStats_FieldPathSelectorAggregatedUsage:
		return &ModelUsageStats_FieldTerminalPathArrayOfValues{ModelUsageStats_FieldTerminalPath: *fp, values: values.([]*common_client.TokenUsage)}
	default:
		panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fp.selector))
	}
	return fpaov
}

func (fp *ModelUsageStats_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ModelUsageStats_FieldTerminalPath) WithIArrayItemValue(value interface{}) ModelUsageStats_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fp.selector))
	}
}

func (fp *ModelUsageStats_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ModelUsageStats_FieldPathValue allows storing values for ModelUsageStats fields according to their type
type ModelUsageStats_FieldPathValue interface {
	ModelUsageStats_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ModelUsageStats)
	CompareWith(*ModelUsageStats) (cmp int, comparable bool)
}

func ParseModelUsageStats_FieldPathValue(pathStr, valueStr string) (ModelUsageStats_FieldPathValue, error) {
	fp, err := ParseModelUsageStats_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ModelUsageStats field path value from %s: %v", valueStr, err)
	}
	return fpv.(ModelUsageStats_FieldPathValue), nil
}

func MustParseModelUsageStats_FieldPathValue(pathStr, valueStr string) ModelUsageStats_FieldPathValue {
	fpv, err := ParseModelUsageStats_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ModelUsageStats_FieldTerminalPathValue struct {
	ModelUsageStats_FieldTerminalPath
	value interface{}
}

var _ ModelUsageStats_FieldPathValue = (*ModelUsageStats_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ModelUsageStats' as interface{}
func (fpv *ModelUsageStats_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ModelUsageStats_FieldTerminalPathValue) AsTurnCountValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ModelUsageStats_FieldTerminalPathValue) AsAggregatedUsageValue() (*common_client.TokenUsage, bool) {
	res, ok := fpv.value.(*common_client.TokenUsage)
	return res, ok
}

// SetTo stores value for selected field for object ModelUsageStats
func (fpv *ModelUsageStats_FieldTerminalPathValue) SetTo(target **ModelUsageStats) {
	if *target == nil {
		*target = new(ModelUsageStats)
	}
	switch fpv.selector {
	case ModelUsageStats_FieldPathSelectorTurnCount:
		(*target).TurnCount = fpv.value.(int32)
	case ModelUsageStats_FieldPathSelectorAggregatedUsage:
		(*target).AggregatedUsage = fpv.value.(*common_client.TokenUsage)
	default:
		panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fpv.selector))
	}
}

func (fpv *ModelUsageStats_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ModelUsageStats)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ModelUsageStats_FieldTerminalPathValue' with the value under path in 'ModelUsageStats'.
func (fpv *ModelUsageStats_FieldTerminalPathValue) CompareWith(source *ModelUsageStats) (int, bool) {
	switch fpv.selector {
	case ModelUsageStats_FieldPathSelectorTurnCount:
		leftValue := fpv.value.(int32)
		rightValue := source.GetTurnCount()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ModelUsageStats_FieldPathSelectorAggregatedUsage:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for ModelUsageStats: %d", fpv.selector))
	}
}

func (fpv *ModelUsageStats_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ModelUsageStats))
}

// ModelUsageStats_FieldPathArrayItemValue allows storing single item in Path-specific values for ModelUsageStats according to their type
// Present only for array (repeated) types.
type ModelUsageStats_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ModelUsageStats_FieldPath
	ContainsValue(*ModelUsageStats) bool
}

// ParseModelUsageStats_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseModelUsageStats_FieldPathArrayItemValue(pathStr, valueStr string) (ModelUsageStats_FieldPathArrayItemValue, error) {
	fp, err := ParseModelUsageStats_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ModelUsageStats field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ModelUsageStats_FieldPathArrayItemValue), nil
}

func MustParseModelUsageStats_FieldPathArrayItemValue(pathStr, valueStr string) ModelUsageStats_FieldPathArrayItemValue {
	fpaiv, err := ParseModelUsageStats_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ModelUsageStats_FieldTerminalPathArrayItemValue struct {
	ModelUsageStats_FieldTerminalPath
	value interface{}
}

var _ ModelUsageStats_FieldPathArrayItemValue = (*ModelUsageStats_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ModelUsageStats as interface{}
func (fpaiv *ModelUsageStats_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ModelUsageStats_FieldTerminalPathArrayItemValue) GetSingle(source *ModelUsageStats) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ModelUsageStats_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ModelUsageStats))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ModelUsageStats'
func (fpaiv *ModelUsageStats_FieldTerminalPathArrayItemValue) ContainsValue(source *ModelUsageStats) bool {
	slice := fpaiv.ModelUsageStats_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ModelUsageStats_FieldPathArrayOfValues allows storing slice of values for ModelUsageStats fields according to their type
type ModelUsageStats_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ModelUsageStats_FieldPath
}

func ParseModelUsageStats_FieldPathArrayOfValues(pathStr, valuesStr string) (ModelUsageStats_FieldPathArrayOfValues, error) {
	fp, err := ParseModelUsageStats_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ModelUsageStats field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ModelUsageStats_FieldPathArrayOfValues), nil
}

func MustParseModelUsageStats_FieldPathArrayOfValues(pathStr, valuesStr string) ModelUsageStats_FieldPathArrayOfValues {
	fpaov, err := ParseModelUsageStats_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ModelUsageStats_FieldTerminalPathArrayOfValues struct {
	ModelUsageStats_FieldTerminalPath
	values interface{}
}

var _ ModelUsageStats_FieldPathArrayOfValues = (*ModelUsageStats_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ModelUsageStats_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ModelUsageStats_FieldPathSelectorTurnCount:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ModelUsageStats_FieldPathSelectorAggregatedUsage:
		for _, v := range fpaov.values.([]*common_client.TokenUsage) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ModelUsageStats_FieldTerminalPathArrayOfValues) AsTurnCountArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ModelUsageStats_FieldTerminalPathArrayOfValues) AsAggregatedUsageArrayOfValues() ([]*common_client.TokenUsage, bool) {
	res, ok := fpaov.values.([]*common_client.TokenUsage)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ReplacedTurnGroup_FieldPath interface {
	gotenobject.FieldPath
	Selector() ReplacedTurnGroup_FieldPathSelector
	Get(source *ReplacedTurnGroup) []interface{}
	GetSingle(source *ReplacedTurnGroup) (interface{}, bool)
	ClearValue(item *ReplacedTurnGroup)

	// Those methods build corresponding ReplacedTurnGroup_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ReplacedTurnGroup_FieldPathValue
	WithIArrayOfValues(values interface{}) ReplacedTurnGroup_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ReplacedTurnGroup_FieldPathArrayItemValue
}

type ReplacedTurnGroup_FieldPathSelector int32

const (
	ReplacedTurnGroup_FieldPathSelectorReplacedAt      ReplacedTurnGroup_FieldPathSelector = 0
	ReplacedTurnGroup_FieldPathSelectorResumedFromTurn ReplacedTurnGroup_FieldPathSelector = 1
	ReplacedTurnGroup_FieldPathSelectorTurns           ReplacedTurnGroup_FieldPathSelector = 2
	ReplacedTurnGroup_FieldPathSelectorHadMessageEdit  ReplacedTurnGroup_FieldPathSelector = 3
	ReplacedTurnGroup_FieldPathSelectorResumeReason    ReplacedTurnGroup_FieldPathSelector = 4
)

func (s ReplacedTurnGroup_FieldPathSelector) String() string {
	switch s {
	case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
		return "replaced_at"
	case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
		return "resumed_from_turn"
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		return "turns"
	case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
		return "had_message_edit"
	case ReplacedTurnGroup_FieldPathSelectorResumeReason:
		return "resume_reason"
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", s))
	}
}

func BuildReplacedTurnGroup_FieldPath(fp gotenobject.RawFieldPath) (ReplacedTurnGroup_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ReplacedTurnGroup")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "replaced_at", "replacedAt", "replaced-at":
			return &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorReplacedAt}, nil
		case "resumed_from_turn", "resumedFromTurn", "resumed-from-turn":
			return &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorResumedFromTurn}, nil
		case "turns":
			return &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorTurns}, nil
		case "had_message_edit", "hadMessageEdit", "had-message-edit":
			return &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorHadMessageEdit}, nil
		case "resume_reason", "resumeReason", "resume-reason":
			return &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorResumeReason}, nil
		}
	} else {
		switch fp[0] {
		case "turns":
			if subpath, err := BuildConversationTurn_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ReplacedTurnGroup_FieldSubPath{selector: ReplacedTurnGroup_FieldPathSelectorTurns, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ReplacedTurnGroup", fp)
}

func ParseReplacedTurnGroup_FieldPath(rawField string) (ReplacedTurnGroup_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildReplacedTurnGroup_FieldPath(fp)
}

func MustParseReplacedTurnGroup_FieldPath(rawField string) ReplacedTurnGroup_FieldPath {
	fp, err := ParseReplacedTurnGroup_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ReplacedTurnGroup_FieldTerminalPath struct {
	selector ReplacedTurnGroup_FieldPathSelector
}

var _ ReplacedTurnGroup_FieldPath = (*ReplacedTurnGroup_FieldTerminalPath)(nil)

func (fp *ReplacedTurnGroup_FieldTerminalPath) Selector() ReplacedTurnGroup_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ReplacedTurnGroup_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ReplacedTurnGroup_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ReplacedTurnGroup
func (fp *ReplacedTurnGroup_FieldTerminalPath) Get(source *ReplacedTurnGroup) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
			if source.ReplacedAt != nil {
				values = append(values, source.ReplacedAt)
			}
		case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
			values = append(values, source.ResumedFromTurn)
		case ReplacedTurnGroup_FieldPathSelectorTurns:
			for _, value := range source.GetTurns() {
				values = append(values, value)
			}
		case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
			values = append(values, source.HadMessageEdit)
		case ReplacedTurnGroup_FieldPathSelectorResumeReason:
			values = append(values, source.ResumeReason)
		default:
			panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fp.selector))
		}
	}
	return
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ReplacedTurnGroup))
}

// GetSingle returns value pointed by specific field of from source ReplacedTurnGroup
func (fp *ReplacedTurnGroup_FieldTerminalPath) GetSingle(source *ReplacedTurnGroup) (interface{}, bool) {
	switch fp.selector {
	case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
		res := source.GetReplacedAt()
		return res, res != nil
	case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
		return source.GetResumedFromTurn(), source != nil
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		res := source.GetTurns()
		return res, res != nil
	case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
		return source.GetHadMessageEdit(), source != nil
	case ReplacedTurnGroup_FieldPathSelectorResumeReason:
		return source.GetResumeReason(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fp.selector))
	}
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ReplacedTurnGroup))
}

// GetDefault returns a default value of the field type
func (fp *ReplacedTurnGroup_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
		return (*timestamppb.Timestamp)(nil)
	case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
		return int32(0)
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		return ([]*ConversationTurn)(nil)
	case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
		return false
	case ReplacedTurnGroup_FieldPathSelectorResumeReason:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fp.selector))
	}
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) ClearValue(item *ReplacedTurnGroup) {
	if item != nil {
		switch fp.selector {
		case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
			item.ReplacedAt = nil
		case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
			item.ResumedFromTurn = int32(0)
		case ReplacedTurnGroup_FieldPathSelectorTurns:
			item.Turns = nil
		case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
			item.HadMessageEdit = false
		case ReplacedTurnGroup_FieldPathSelectorResumeReason:
			item.ResumeReason = ""
		default:
			panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fp.selector))
		}
	}
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ReplacedTurnGroup))
}

// IsLeaf - whether field path is holds simple value
func (fp *ReplacedTurnGroup_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ReplacedTurnGroup_FieldPathSelectorReplacedAt ||
		fp.selector == ReplacedTurnGroup_FieldPathSelectorResumedFromTurn ||
		fp.selector == ReplacedTurnGroup_FieldPathSelectorHadMessageEdit ||
		fp.selector == ReplacedTurnGroup_FieldPathSelectorResumeReason
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) WithIValue(value interface{}) ReplacedTurnGroup_FieldPathValue {
	switch fp.selector {
	case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
		return &ReplacedTurnGroup_FieldTerminalPathValue{ReplacedTurnGroup_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
		return &ReplacedTurnGroup_FieldTerminalPathValue{ReplacedTurnGroup_FieldTerminalPath: *fp, value: value.(int32)}
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		return &ReplacedTurnGroup_FieldTerminalPathValue{ReplacedTurnGroup_FieldTerminalPath: *fp, value: value.([]*ConversationTurn)}
	case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
		return &ReplacedTurnGroup_FieldTerminalPathValue{ReplacedTurnGroup_FieldTerminalPath: *fp, value: value.(bool)}
	case ReplacedTurnGroup_FieldPathSelectorResumeReason:
		return &ReplacedTurnGroup_FieldTerminalPathValue{ReplacedTurnGroup_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fp.selector))
	}
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) WithIArrayOfValues(values interface{}) ReplacedTurnGroup_FieldPathArrayOfValues {
	fpaov := &ReplacedTurnGroup_FieldTerminalPathArrayOfValues{ReplacedTurnGroup_FieldTerminalPath: *fp}
	switch fp.selector {
	case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
		return &ReplacedTurnGroup_FieldTerminalPathArrayOfValues{ReplacedTurnGroup_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
		return &ReplacedTurnGroup_FieldTerminalPathArrayOfValues{ReplacedTurnGroup_FieldTerminalPath: *fp, values: values.([]int32)}
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		return &ReplacedTurnGroup_FieldTerminalPathArrayOfValues{ReplacedTurnGroup_FieldTerminalPath: *fp, values: values.([][]*ConversationTurn)}
	case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
		return &ReplacedTurnGroup_FieldTerminalPathArrayOfValues{ReplacedTurnGroup_FieldTerminalPath: *fp, values: values.([]bool)}
	case ReplacedTurnGroup_FieldPathSelectorResumeReason:
		return &ReplacedTurnGroup_FieldTerminalPathArrayOfValues{ReplacedTurnGroup_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fp.selector))
	}
	return fpaov
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) WithIArrayItemValue(value interface{}) ReplacedTurnGroup_FieldPathArrayItemValue {
	switch fp.selector {
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		return &ReplacedTurnGroup_FieldTerminalPathArrayItemValue{ReplacedTurnGroup_FieldTerminalPath: *fp, value: value.(*ConversationTurn)}
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fp.selector))
	}
}

func (fp *ReplacedTurnGroup_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ReplacedTurnGroup_FieldSubPath struct {
	selector ReplacedTurnGroup_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ReplacedTurnGroup_FieldPath = (*ReplacedTurnGroup_FieldSubPath)(nil)

func (fps *ReplacedTurnGroup_FieldSubPath) Selector() ReplacedTurnGroup_FieldPathSelector {
	return fps.selector
}
func (fps *ReplacedTurnGroup_FieldSubPath) AsTurnsSubPath() (ConversationTurn_FieldPath, bool) {
	res, ok := fps.subPath.(ConversationTurn_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ReplacedTurnGroup_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ReplacedTurnGroup_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ReplacedTurnGroup
func (fps *ReplacedTurnGroup_FieldSubPath) Get(source *ReplacedTurnGroup) (values []interface{}) {
	switch fps.selector {
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		for _, item := range source.GetTurns() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fps.selector))
	}
	return
}

func (fps *ReplacedTurnGroup_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ReplacedTurnGroup))
}

// GetSingle returns value of selected field from source ReplacedTurnGroup
func (fps *ReplacedTurnGroup_FieldSubPath) GetSingle(source *ReplacedTurnGroup) (interface{}, bool) {
	switch fps.selector {
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		if len(source.GetTurns()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetTurns()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fps.selector))
	}
}

func (fps *ReplacedTurnGroup_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ReplacedTurnGroup))
}

// GetDefault returns a default value of the field type
func (fps *ReplacedTurnGroup_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ReplacedTurnGroup_FieldSubPath) ClearValue(item *ReplacedTurnGroup) {
	if item != nil {
		switch fps.selector {
		case ReplacedTurnGroup_FieldPathSelectorTurns:
			for _, subItem := range item.Turns {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fps.selector))
		}
	}
}

func (fps *ReplacedTurnGroup_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ReplacedTurnGroup))
}

// IsLeaf - whether field path is holds simple value
func (fps *ReplacedTurnGroup_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ReplacedTurnGroup_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&ReplacedTurnGroup_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *ReplacedTurnGroup_FieldSubPath) WithIValue(value interface{}) ReplacedTurnGroup_FieldPathValue {
	return &ReplacedTurnGroup_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ReplacedTurnGroup_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ReplacedTurnGroup_FieldSubPath) WithIArrayOfValues(values interface{}) ReplacedTurnGroup_FieldPathArrayOfValues {
	return &ReplacedTurnGroup_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ReplacedTurnGroup_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ReplacedTurnGroup_FieldSubPath) WithIArrayItemValue(value interface{}) ReplacedTurnGroup_FieldPathArrayItemValue {
	return &ReplacedTurnGroup_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ReplacedTurnGroup_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ReplacedTurnGroup_FieldPathValue allows storing values for ReplacedTurnGroup fields according to their type
type ReplacedTurnGroup_FieldPathValue interface {
	ReplacedTurnGroup_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ReplacedTurnGroup)
	CompareWith(*ReplacedTurnGroup) (cmp int, comparable bool)
}

func ParseReplacedTurnGroup_FieldPathValue(pathStr, valueStr string) (ReplacedTurnGroup_FieldPathValue, error) {
	fp, err := ParseReplacedTurnGroup_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReplacedTurnGroup field path value from %s: %v", valueStr, err)
	}
	return fpv.(ReplacedTurnGroup_FieldPathValue), nil
}

func MustParseReplacedTurnGroup_FieldPathValue(pathStr, valueStr string) ReplacedTurnGroup_FieldPathValue {
	fpv, err := ParseReplacedTurnGroup_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ReplacedTurnGroup_FieldTerminalPathValue struct {
	ReplacedTurnGroup_FieldTerminalPath
	value interface{}
}

var _ ReplacedTurnGroup_FieldPathValue = (*ReplacedTurnGroup_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ReplacedTurnGroup' as interface{}
func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) AsReplacedAtValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}
func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) AsResumedFromTurnValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) AsTurnsValue() ([]*ConversationTurn, bool) {
	res, ok := fpv.value.([]*ConversationTurn)
	return res, ok
}
func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) AsHadMessageEditValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) AsResumeReasonValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object ReplacedTurnGroup
func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) SetTo(target **ReplacedTurnGroup) {
	if *target == nil {
		*target = new(ReplacedTurnGroup)
	}
	switch fpv.selector {
	case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
		(*target).ReplacedAt = fpv.value.(*timestamppb.Timestamp)
	case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
		(*target).ResumedFromTurn = fpv.value.(int32)
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		(*target).Turns = fpv.value.([]*ConversationTurn)
	case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
		(*target).HadMessageEdit = fpv.value.(bool)
	case ReplacedTurnGroup_FieldPathSelectorResumeReason:
		(*target).ResumeReason = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fpv.selector))
	}
}

func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ReplacedTurnGroup)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ReplacedTurnGroup_FieldTerminalPathValue' with the value under path in 'ReplacedTurnGroup'.
func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) CompareWith(source *ReplacedTurnGroup) (int, bool) {
	switch fpv.selector {
	case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetReplacedAt()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
		leftValue := fpv.value.(int32)
		rightValue := source.GetResumedFromTurn()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		return 0, false
	case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
		leftValue := fpv.value.(bool)
		rightValue := source.GetHadMessageEdit()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ReplacedTurnGroup_FieldPathSelectorResumeReason:
		leftValue := fpv.value.(string)
		rightValue := source.GetResumeReason()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fpv.selector))
	}
}

func (fpv *ReplacedTurnGroup_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ReplacedTurnGroup))
}

type ReplacedTurnGroup_FieldSubPathValue struct {
	ReplacedTurnGroup_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ReplacedTurnGroup_FieldPathValue = (*ReplacedTurnGroup_FieldSubPathValue)(nil)

func (fpvs *ReplacedTurnGroup_FieldSubPathValue) AsTurnsPathValue() (ConversationTurn_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(ConversationTurn_FieldPathValue)
	return res, ok
}

func (fpvs *ReplacedTurnGroup_FieldSubPathValue) SetTo(target **ReplacedTurnGroup) {
	if *target == nil {
		*target = new(ReplacedTurnGroup)
	}
	switch fpvs.Selector() {
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fpvs.Selector()))
	}
}

func (fpvs *ReplacedTurnGroup_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ReplacedTurnGroup)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ReplacedTurnGroup_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ReplacedTurnGroup_FieldSubPathValue) CompareWith(source *ReplacedTurnGroup) (int, bool) {
	switch fpvs.Selector() {
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fpvs.Selector()))
	}
}

func (fpvs *ReplacedTurnGroup_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ReplacedTurnGroup))
}

// ReplacedTurnGroup_FieldPathArrayItemValue allows storing single item in Path-specific values for ReplacedTurnGroup according to their type
// Present only for array (repeated) types.
type ReplacedTurnGroup_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ReplacedTurnGroup_FieldPath
	ContainsValue(*ReplacedTurnGroup) bool
}

// ParseReplacedTurnGroup_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseReplacedTurnGroup_FieldPathArrayItemValue(pathStr, valueStr string) (ReplacedTurnGroup_FieldPathArrayItemValue, error) {
	fp, err := ParseReplacedTurnGroup_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReplacedTurnGroup field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ReplacedTurnGroup_FieldPathArrayItemValue), nil
}

func MustParseReplacedTurnGroup_FieldPathArrayItemValue(pathStr, valueStr string) ReplacedTurnGroup_FieldPathArrayItemValue {
	fpaiv, err := ParseReplacedTurnGroup_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ReplacedTurnGroup_FieldTerminalPathArrayItemValue struct {
	ReplacedTurnGroup_FieldTerminalPath
	value interface{}
}

var _ ReplacedTurnGroup_FieldPathArrayItemValue = (*ReplacedTurnGroup_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ReplacedTurnGroup as interface{}
func (fpaiv *ReplacedTurnGroup_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *ReplacedTurnGroup_FieldTerminalPathArrayItemValue) AsTurnsItemValue() (*ConversationTurn, bool) {
	res, ok := fpaiv.value.(*ConversationTurn)
	return res, ok
}

func (fpaiv *ReplacedTurnGroup_FieldTerminalPathArrayItemValue) GetSingle(source *ReplacedTurnGroup) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ReplacedTurnGroup_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ReplacedTurnGroup))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ReplacedTurnGroup'
func (fpaiv *ReplacedTurnGroup_FieldTerminalPathArrayItemValue) ContainsValue(source *ReplacedTurnGroup) bool {
	slice := fpaiv.ReplacedTurnGroup_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ReplacedTurnGroup_FieldSubPathArrayItemValue struct {
	ReplacedTurnGroup_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ReplacedTurnGroup_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ReplacedTurnGroup_FieldSubPathArrayItemValue) AsTurnsPathItemValue() (ConversationTurn_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(ConversationTurn_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ReplacedTurnGroup'
func (fpaivs *ReplacedTurnGroup_FieldSubPathArrayItemValue) ContainsValue(source *ReplacedTurnGroup) bool {
	switch fpaivs.Selector() {
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for ReplacedTurnGroup: %d", fpaivs.Selector()))
	}
}

// ReplacedTurnGroup_FieldPathArrayOfValues allows storing slice of values for ReplacedTurnGroup fields according to their type
type ReplacedTurnGroup_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ReplacedTurnGroup_FieldPath
}

func ParseReplacedTurnGroup_FieldPathArrayOfValues(pathStr, valuesStr string) (ReplacedTurnGroup_FieldPathArrayOfValues, error) {
	fp, err := ParseReplacedTurnGroup_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ReplacedTurnGroup field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ReplacedTurnGroup_FieldPathArrayOfValues), nil
}

func MustParseReplacedTurnGroup_FieldPathArrayOfValues(pathStr, valuesStr string) ReplacedTurnGroup_FieldPathArrayOfValues {
	fpaov, err := ParseReplacedTurnGroup_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ReplacedTurnGroup_FieldTerminalPathArrayOfValues struct {
	ReplacedTurnGroup_FieldTerminalPath
	values interface{}
}

var _ ReplacedTurnGroup_FieldPathArrayOfValues = (*ReplacedTurnGroup_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ReplacedTurnGroup_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ReplacedTurnGroup_FieldPathSelectorTurns:
		for _, v := range fpaov.values.([][]*ConversationTurn) {
			values = append(values, v)
		}
	case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case ReplacedTurnGroup_FieldPathSelectorResumeReason:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ReplacedTurnGroup_FieldTerminalPathArrayOfValues) AsReplacedAtArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}
func (fpaov *ReplacedTurnGroup_FieldTerminalPathArrayOfValues) AsResumedFromTurnArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ReplacedTurnGroup_FieldTerminalPathArrayOfValues) AsTurnsArrayOfValues() ([][]*ConversationTurn, bool) {
	res, ok := fpaov.values.([][]*ConversationTurn)
	return res, ok
}
func (fpaov *ReplacedTurnGroup_FieldTerminalPathArrayOfValues) AsHadMessageEditArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *ReplacedTurnGroup_FieldTerminalPathArrayOfValues) AsResumeReasonArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

type ReplacedTurnGroup_FieldSubPathArrayOfValues struct {
	ReplacedTurnGroup_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ReplacedTurnGroup_FieldPathArrayOfValues = (*ReplacedTurnGroup_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ReplacedTurnGroup_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ReplacedTurnGroup_FieldSubPathArrayOfValues) AsTurnsPathArrayOfValues() (ConversationTurn_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(ConversationTurn_FieldPathArrayOfValues)
	return res, ok
}
