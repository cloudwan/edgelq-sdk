// Code generated by protoc-gen-goten-object
// File: edgelq/ai/proto/v1/conversation.proto
// DO NOT EDIT!!!

package conversation

import (
	"encoding/json"
	"strings"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	common_client "github.com/cloudwan/edgelq-sdk/ai/client/v1/common"
	capability_template "github.com/cloudwan/edgelq-sdk/ai/resources/v1/capability_template"
	chat_model "github.com/cloudwan/edgelq-sdk/ai/resources/v1/chat_model"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1/project"
	iam_user "github.com/cloudwan/edgelq-sdk/iam/resources/v1/user"
	meta "github.com/cloudwan/goten-sdk/types/meta"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &capability_template.CapabilityTemplate{}
	_ = &chat_model.ChatModel{}
	_ = &common_client.Message{}
	_ = &iam_project.Project{}
	_ = &iam_user.User{}
	_ = &durationpb.Duration{}
	_ = &timestamppb.Timestamp{}
	_ = &meta.Meta{}
)

type Conversation_FieldMask struct {
	Paths []Conversation_FieldPath
}

func FullConversation_FieldMask() *Conversation_FieldMask {
	res := &Conversation_FieldMask{}
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorTitle})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorArchived})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorLastActivityTime})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorTurns})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorUsageByModel})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorTotalUsage})
	return res
}

func (fieldMask *Conversation_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *Conversation_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Conversation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Conversation_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConversation_FieldPath(raw)
	})
}

func (fieldMask *Conversation_FieldMask) ProtoMessage() {}

func (fieldMask *Conversation_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Conversation_FieldMask) Subtract(other *Conversation_FieldMask) *Conversation_FieldMask {
	result := &Conversation_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[Conversation_FieldPathSelector]gotenobject.FieldMask{
		Conversation_FieldPathSelectorMetadata:   &meta.Meta_FieldMask{},
		Conversation_FieldPathSelectorTurns:      &ConversationTurn_FieldMask{},
		Conversation_FieldPathSelectorTotalUsage: &TotalUsageStats_FieldMask{},
	}
	mySubMasks := map[Conversation_FieldPathSelector]gotenobject.FieldMask{
		Conversation_FieldPathSelectorMetadata:   &meta.Meta_FieldMask{},
		Conversation_FieldPathSelectorTurns:      &ConversationTurn_FieldMask{},
		Conversation_FieldPathSelectorTotalUsage: &TotalUsageStats_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Conversation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Conversation_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Conversation_FieldTerminalPath); ok {
					switch tp.selector {
					case Conversation_FieldPathSelectorMetadata:
						mySubMasks[Conversation_FieldPathSelectorMetadata] = meta.FullMeta_FieldMask()
					case Conversation_FieldPathSelectorTurns:
						mySubMasks[Conversation_FieldPathSelectorTurns] = FullConversationTurn_FieldMask()
					case Conversation_FieldPathSelectorTotalUsage:
						mySubMasks[Conversation_FieldPathSelectorTotalUsage] = FullTotalUsageStats_FieldMask()
					}
				} else if tp, ok := path.(*Conversation_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Conversation_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Conversation_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Conversation_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Conversation_FieldMask) FilterInputFields() *Conversation_FieldMask {
	result := &Conversation_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case Conversation_FieldPathSelectorMetadata:
			if _, ok := path.(*Conversation_FieldTerminalPath); ok {
				for _, subpath := range meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Conversation_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Conversation_FieldSubPath); ok {
				selectedMask := &meta.Meta_FieldMask{
					Paths: []meta.Meta_FieldPath{sub.subPath.(meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Conversation_FieldSubPath{selector: Conversation_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Conversation_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Conversation_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Conversation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConversation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Conversation_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Conversation_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Conversation_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Conversation_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Conversation_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Conversation_FieldMask) AppendPath(path Conversation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Conversation_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Conversation_FieldPath))
}

func (fieldMask *Conversation_FieldMask) GetPaths() []Conversation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Conversation_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Conversation_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConversation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Conversation_FieldMask) Set(target, source *Conversation) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Conversation_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Conversation), source.(*Conversation))
}

func (fieldMask *Conversation_FieldMask) Project(source *Conversation) *Conversation {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Conversation{}
	metadataMask := &meta.Meta_FieldMask{}
	wholeMetadataAccepted := false
	turnsMask := &ConversationTurn_FieldMask{}
	wholeTurnsAccepted := false
	totalUsageMask := &TotalUsageStats_FieldMask{}
	wholeTotalUsageAccepted := false
	var usageByModelMapKeys []string
	wholeUsageByModelAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Conversation_FieldTerminalPath:
			switch tp.selector {
			case Conversation_FieldPathSelectorName:
				result.Name = source.Name
			case Conversation_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case Conversation_FieldPathSelectorTitle:
				result.Title = source.Title
			case Conversation_FieldPathSelectorArchived:
				result.Archived = source.Archived
			case Conversation_FieldPathSelectorLastActivityTime:
				result.LastActivityTime = source.LastActivityTime
			case Conversation_FieldPathSelectorTurns:
				result.Turns = source.Turns
				wholeTurnsAccepted = true
			case Conversation_FieldPathSelectorUsageByModel:
				result.UsageByModel = source.UsageByModel
				wholeUsageByModelAccepted = true
			case Conversation_FieldPathSelectorTotalUsage:
				result.TotalUsage = source.TotalUsage
				wholeTotalUsageAccepted = true
			}
		case *Conversation_FieldSubPath:
			switch tp.selector {
			case Conversation_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(meta.Meta_FieldPath))
			case Conversation_FieldPathSelectorTurns:
				turnsMask.AppendPath(tp.subPath.(ConversationTurn_FieldPath))
			case Conversation_FieldPathSelectorTotalUsage:
				totalUsageMask.AppendPath(tp.subPath.(TotalUsageStats_FieldPath))
			}
		case *Conversation_FieldPathMap:
			switch tp.selector {
			case Conversation_FieldPathSelectorUsageByModel:
				usageByModelMapKeys = append(usageByModelMapKeys, tp.key)
			}
		}
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	if wholeTurnsAccepted == false && len(turnsMask.Paths) > 0 {
		for _, sourceItem := range source.GetTurns() {
			result.Turns = append(result.Turns, turnsMask.Project(sourceItem))
		}
	}
	if wholeUsageByModelAccepted == false && len(usageByModelMapKeys) > 0 && source.GetUsageByModel() != nil {
		copiedMap := map[string]*ModelUsageStats{}
		sourceMap := source.GetUsageByModel()
		for _, key := range usageByModelMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.UsageByModel = copiedMap
	}
	if wholeTotalUsageAccepted == false && len(totalUsageMask.Paths) > 0 {
		result.TotalUsage = totalUsageMask.Project(source.GetTotalUsage())
	}
	return result
}

func (fieldMask *Conversation_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Conversation))
}

func (fieldMask *Conversation_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConversationTurn_FieldMask struct {
	Paths []ConversationTurn_FieldPath
}

func FullConversationTurn_FieldMask() *ConversationTurn_FieldMask {
	res := &ConversationTurn_FieldMask{}
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorTurnNumber})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorTimestamp})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorMessages})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorConfig})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorUsage})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorStopReason})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorDuration})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorAvailableTools})
	return res
}

func (fieldMask *ConversationTurn_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ConversationTurn_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConversationTurn_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConversationTurn_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConversationTurn_FieldPath(raw)
	})
}

func (fieldMask *ConversationTurn_FieldMask) ProtoMessage() {}

func (fieldMask *ConversationTurn_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConversationTurn_FieldMask) Subtract(other *ConversationTurn_FieldMask) *ConversationTurn_FieldMask {
	result := &ConversationTurn_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[ConversationTurn_FieldPathSelector]gotenobject.FieldMask{
		ConversationTurn_FieldPathSelectorConfig: &TurnConfig_FieldMask{},
	}
	mySubMasks := map[ConversationTurn_FieldPathSelector]gotenobject.FieldMask{
		ConversationTurn_FieldPathSelectorConfig: &TurnConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConversationTurn_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConversationTurn_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConversationTurn_FieldTerminalPath); ok {
					switch tp.selector {
					case ConversationTurn_FieldPathSelectorConfig:
						mySubMasks[ConversationTurn_FieldPathSelectorConfig] = FullTurnConfig_FieldMask()
					}
				} else if tp, ok := path.(*ConversationTurn_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConversationTurn_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConversationTurn_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConversationTurn_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConversationTurn_FieldMask) FilterInputFields() *ConversationTurn_FieldMask {
	result := &ConversationTurn_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConversationTurn_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConversationTurn_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConversationTurn_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConversationTurn_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConversationTurn_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConversationTurn_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConversationTurn_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConversationTurn_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConversationTurn_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConversationTurn_FieldMask) AppendPath(path ConversationTurn_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConversationTurn_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConversationTurn_FieldPath))
}

func (fieldMask *ConversationTurn_FieldMask) GetPaths() []ConversationTurn_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConversationTurn_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConversationTurn_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConversationTurn_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConversationTurn_FieldMask) Set(target, source *ConversationTurn) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConversationTurn_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConversationTurn), source.(*ConversationTurn))
}

func (fieldMask *ConversationTurn_FieldMask) Project(source *ConversationTurn) *ConversationTurn {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConversationTurn{}
	configMask := &TurnConfig_FieldMask{}
	wholeConfigAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConversationTurn_FieldTerminalPath:
			switch tp.selector {
			case ConversationTurn_FieldPathSelectorTurnNumber:
				result.TurnNumber = source.TurnNumber
			case ConversationTurn_FieldPathSelectorTimestamp:
				result.Timestamp = source.Timestamp
			case ConversationTurn_FieldPathSelectorMessages:
				result.Messages = source.Messages
			case ConversationTurn_FieldPathSelectorConfig:
				result.Config = source.Config
				wholeConfigAccepted = true
			case ConversationTurn_FieldPathSelectorUsage:
				result.Usage = source.Usage
			case ConversationTurn_FieldPathSelectorStopReason:
				result.StopReason = source.StopReason
			case ConversationTurn_FieldPathSelectorDuration:
				result.Duration = source.Duration
			case ConversationTurn_FieldPathSelectorAvailableTools:
				result.AvailableTools = source.AvailableTools
			}
		case *ConversationTurn_FieldSubPath:
			switch tp.selector {
			case ConversationTurn_FieldPathSelectorConfig:
				configMask.AppendPath(tp.subPath.(TurnConfig_FieldPath))
			}
		}
	}
	if wholeConfigAccepted == false && len(configMask.Paths) > 0 {
		result.Config = configMask.Project(source.GetConfig())
	}
	return result
}

func (fieldMask *ConversationTurn_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConversationTurn))
}

func (fieldMask *ConversationTurn_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TurnConfig_FieldMask struct {
	Paths []TurnConfig_FieldPath
}

func FullTurnConfig_FieldMask() *TurnConfig_FieldMask {
	res := &TurnConfig_FieldMask{}
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorModelUsed})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorTemperature})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorMaxTokens})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorReasoningLevel})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorCapabilityTemplate})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorConnectors})
	return res
}

func (fieldMask *TurnConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TurnConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TurnConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TurnConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTurnConfig_FieldPath(raw)
	})
}

func (fieldMask *TurnConfig_FieldMask) ProtoMessage() {}

func (fieldMask *TurnConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TurnConfig_FieldMask) Subtract(other *TurnConfig_FieldMask) *TurnConfig_FieldMask {
	result := &TurnConfig_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TurnConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TurnConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TurnConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TurnConfig_FieldMask) FilterInputFields() *TurnConfig_FieldMask {
	result := &TurnConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TurnConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TurnConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TurnConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTurnConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TurnConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TurnConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TurnConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TurnConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TurnConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TurnConfig_FieldMask) AppendPath(path TurnConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TurnConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TurnConfig_FieldPath))
}

func (fieldMask *TurnConfig_FieldMask) GetPaths() []TurnConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TurnConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TurnConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTurnConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TurnConfig_FieldMask) Set(target, source *TurnConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TurnConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TurnConfig), source.(*TurnConfig))
}

func (fieldMask *TurnConfig_FieldMask) Project(source *TurnConfig) *TurnConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TurnConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TurnConfig_FieldTerminalPath:
			switch tp.selector {
			case TurnConfig_FieldPathSelectorModel:
				result.Model = source.Model
			case TurnConfig_FieldPathSelectorModelUsed:
				result.ModelUsed = source.ModelUsed
			case TurnConfig_FieldPathSelectorTemperature:
				result.Temperature = source.Temperature
			case TurnConfig_FieldPathSelectorMaxTokens:
				result.MaxTokens = source.MaxTokens
			case TurnConfig_FieldPathSelectorReasoningLevel:
				result.ReasoningLevel = source.ReasoningLevel
			case TurnConfig_FieldPathSelectorCapabilityTemplate:
				if source, ok := source.ServerToolsConfig.(*TurnConfig_CapabilityTemplate); ok {
					result.ServerToolsConfig = &TurnConfig_CapabilityTemplate{
						CapabilityTemplate: source.CapabilityTemplate,
					}
				}
			case TurnConfig_FieldPathSelectorConnectors:
				if source, ok := source.ServerToolsConfig.(*TurnConfig_Connectors); ok {
					result.ServerToolsConfig = &TurnConfig_Connectors{
						Connectors: source.Connectors,
					}
				}
			}
		}
	}
	return result
}

func (fieldMask *TurnConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TurnConfig))
}

func (fieldMask *TurnConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ModelUsageStats_FieldMask struct {
	Paths []ModelUsageStats_FieldPath
}

func FullModelUsageStats_FieldMask() *ModelUsageStats_FieldMask {
	res := &ModelUsageStats_FieldMask{}
	res.Paths = append(res.Paths, &ModelUsageStats_FieldTerminalPath{selector: ModelUsageStats_FieldPathSelectorTurnCount})
	res.Paths = append(res.Paths, &ModelUsageStats_FieldTerminalPath{selector: ModelUsageStats_FieldPathSelectorAggregatedUsage})
	return res
}

func (fieldMask *ModelUsageStats_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ModelUsageStats_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ModelUsageStats_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ModelUsageStats_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseModelUsageStats_FieldPath(raw)
	})
}

func (fieldMask *ModelUsageStats_FieldMask) ProtoMessage() {}

func (fieldMask *ModelUsageStats_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ModelUsageStats_FieldMask) Subtract(other *ModelUsageStats_FieldMask) *ModelUsageStats_FieldMask {
	result := &ModelUsageStats_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ModelUsageStats_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ModelUsageStats_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ModelUsageStats_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ModelUsageStats_FieldMask) FilterInputFields() *ModelUsageStats_FieldMask {
	result := &ModelUsageStats_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ModelUsageStats_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ModelUsageStats_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ModelUsageStats_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseModelUsageStats_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ModelUsageStats_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ModelUsageStats_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ModelUsageStats_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ModelUsageStats_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ModelUsageStats_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ModelUsageStats_FieldMask) AppendPath(path ModelUsageStats_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ModelUsageStats_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ModelUsageStats_FieldPath))
}

func (fieldMask *ModelUsageStats_FieldMask) GetPaths() []ModelUsageStats_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ModelUsageStats_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ModelUsageStats_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseModelUsageStats_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ModelUsageStats_FieldMask) Set(target, source *ModelUsageStats) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ModelUsageStats_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ModelUsageStats), source.(*ModelUsageStats))
}

func (fieldMask *ModelUsageStats_FieldMask) Project(source *ModelUsageStats) *ModelUsageStats {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ModelUsageStats{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ModelUsageStats_FieldTerminalPath:
			switch tp.selector {
			case ModelUsageStats_FieldPathSelectorTurnCount:
				result.TurnCount = source.TurnCount
			case ModelUsageStats_FieldPathSelectorAggregatedUsage:
				result.AggregatedUsage = source.AggregatedUsage
			}
		}
	}
	return result
}

func (fieldMask *ModelUsageStats_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ModelUsageStats))
}

func (fieldMask *ModelUsageStats_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TotalUsageStats_FieldMask struct {
	Paths []TotalUsageStats_FieldPath
}

func FullTotalUsageStats_FieldMask() *TotalUsageStats_FieldMask {
	res := &TotalUsageStats_FieldMask{}
	res.Paths = append(res.Paths, &TotalUsageStats_FieldTerminalPath{selector: TotalUsageStats_FieldPathSelectorTotalTurns})
	res.Paths = append(res.Paths, &TotalUsageStats_FieldTerminalPath{selector: TotalUsageStats_FieldPathSelectorTotalMessages})
	res.Paths = append(res.Paths, &TotalUsageStats_FieldTerminalPath{selector: TotalUsageStats_FieldPathSelectorAggregatedUsage})
	return res
}

func (fieldMask *TotalUsageStats_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TotalUsageStats_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TotalUsageStats_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TotalUsageStats_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTotalUsageStats_FieldPath(raw)
	})
}

func (fieldMask *TotalUsageStats_FieldMask) ProtoMessage() {}

func (fieldMask *TotalUsageStats_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TotalUsageStats_FieldMask) Subtract(other *TotalUsageStats_FieldMask) *TotalUsageStats_FieldMask {
	result := &TotalUsageStats_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TotalUsageStats_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TotalUsageStats_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TotalUsageStats_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TotalUsageStats_FieldMask) FilterInputFields() *TotalUsageStats_FieldMask {
	result := &TotalUsageStats_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TotalUsageStats_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TotalUsageStats_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TotalUsageStats_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTotalUsageStats_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TotalUsageStats_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TotalUsageStats_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TotalUsageStats_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TotalUsageStats_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TotalUsageStats_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TotalUsageStats_FieldMask) AppendPath(path TotalUsageStats_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TotalUsageStats_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TotalUsageStats_FieldPath))
}

func (fieldMask *TotalUsageStats_FieldMask) GetPaths() []TotalUsageStats_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TotalUsageStats_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TotalUsageStats_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTotalUsageStats_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TotalUsageStats_FieldMask) Set(target, source *TotalUsageStats) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TotalUsageStats_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TotalUsageStats), source.(*TotalUsageStats))
}

func (fieldMask *TotalUsageStats_FieldMask) Project(source *TotalUsageStats) *TotalUsageStats {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TotalUsageStats{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TotalUsageStats_FieldTerminalPath:
			switch tp.selector {
			case TotalUsageStats_FieldPathSelectorTotalTurns:
				result.TotalTurns = source.TotalTurns
			case TotalUsageStats_FieldPathSelectorTotalMessages:
				result.TotalMessages = source.TotalMessages
			case TotalUsageStats_FieldPathSelectorAggregatedUsage:
				result.AggregatedUsage = source.AggregatedUsage
			}
		}
	}
	return result
}

func (fieldMask *TotalUsageStats_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TotalUsageStats))
}

func (fieldMask *TotalUsageStats_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
