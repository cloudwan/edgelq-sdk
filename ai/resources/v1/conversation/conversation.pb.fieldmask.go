// Code generated by protoc-gen-goten-object
// File: edgelq/ai/proto/v1/conversation.proto
// DO NOT EDIT!!!

package conversation

import (
	"encoding/json"
	"strings"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	common_client "github.com/cloudwan/edgelq-sdk/ai/client/v1/common"
	capability_template "github.com/cloudwan/edgelq-sdk/ai/resources/v1/capability_template"
	chat_model "github.com/cloudwan/edgelq-sdk/ai/resources/v1/chat_model"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1/project"
	iam_user "github.com/cloudwan/edgelq-sdk/iam/resources/v1/user"
	meta "github.com/cloudwan/goten-sdk/types/meta"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &capability_template.CapabilityTemplate{}
	_ = &chat_model.ChatModel{}
	_ = &common_client.Message{}
	_ = &iam_project.Project{}
	_ = &iam_user.User{}
	_ = &durationpb.Duration{}
	_ = &timestamppb.Timestamp{}
	_ = &meta.Meta{}
)

type Conversation_FieldMask struct {
	Paths []Conversation_FieldPath
}

func FullConversation_FieldMask() *Conversation_FieldMask {
	res := &Conversation_FieldMask{}
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorTitle})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorConfiguredTitle})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorArchived})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorIsPrivate})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorLastActivityTime})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorTurns})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorUsageByModel})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorFailedTurns})
	res.Paths = append(res.Paths, &Conversation_FieldTerminalPath{selector: Conversation_FieldPathSelectorReplacedTurnGroups})
	return res
}

func (fieldMask *Conversation_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *Conversation_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Conversation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Conversation_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConversation_FieldPath(raw)
	})
}

func (fieldMask *Conversation_FieldMask) ProtoMessage() {}

func (fieldMask *Conversation_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Conversation_FieldMask) Subtract(other *Conversation_FieldMask) *Conversation_FieldMask {
	result := &Conversation_FieldMask{}
	removedSelectors := make([]bool, 11)
	otherSubMasks := map[Conversation_FieldPathSelector]gotenobject.FieldMask{
		Conversation_FieldPathSelectorMetadata:           &meta.Meta_FieldMask{},
		Conversation_FieldPathSelectorTurns:              &ConversationTurn_FieldMask{},
		Conversation_FieldPathSelectorFailedTurns:        &ConversationTurn_FieldMask{},
		Conversation_FieldPathSelectorReplacedTurnGroups: &ReplacedTurnGroup_FieldMask{},
	}
	mySubMasks := map[Conversation_FieldPathSelector]gotenobject.FieldMask{
		Conversation_FieldPathSelectorMetadata:           &meta.Meta_FieldMask{},
		Conversation_FieldPathSelectorTurns:              &ConversationTurn_FieldMask{},
		Conversation_FieldPathSelectorFailedTurns:        &ConversationTurn_FieldMask{},
		Conversation_FieldPathSelectorReplacedTurnGroups: &ReplacedTurnGroup_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Conversation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Conversation_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Conversation_FieldTerminalPath); ok {
					switch tp.selector {
					case Conversation_FieldPathSelectorMetadata:
						mySubMasks[Conversation_FieldPathSelectorMetadata] = meta.FullMeta_FieldMask()
					case Conversation_FieldPathSelectorTurns:
						mySubMasks[Conversation_FieldPathSelectorTurns] = FullConversationTurn_FieldMask()
					case Conversation_FieldPathSelectorFailedTurns:
						mySubMasks[Conversation_FieldPathSelectorFailedTurns] = FullConversationTurn_FieldMask()
					case Conversation_FieldPathSelectorReplacedTurnGroups:
						mySubMasks[Conversation_FieldPathSelectorReplacedTurnGroups] = FullReplacedTurnGroup_FieldMask()
					}
				} else if tp, ok := path.(*Conversation_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Conversation_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Conversation_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Conversation_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Conversation_FieldMask) FilterInputFields() *Conversation_FieldMask {
	result := &Conversation_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case Conversation_FieldPathSelectorMetadata:
			if _, ok := path.(*Conversation_FieldTerminalPath); ok {
				for _, subpath := range meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Conversation_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Conversation_FieldSubPath); ok {
				selectedMask := &meta.Meta_FieldMask{
					Paths: []meta.Meta_FieldPath{sub.subPath.(meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Conversation_FieldSubPath{selector: Conversation_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Conversation_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Conversation_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Conversation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConversation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Conversation_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Conversation_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Conversation_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Conversation_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Conversation_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Conversation_FieldMask) AppendPath(path Conversation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Conversation_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Conversation_FieldPath))
}

func (fieldMask *Conversation_FieldMask) GetPaths() []Conversation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Conversation_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Conversation_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConversation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Conversation_FieldMask) Set(target, source *Conversation) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Conversation_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Conversation), source.(*Conversation))
}

func (fieldMask *Conversation_FieldMask) Project(source *Conversation) *Conversation {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Conversation{}
	metadataMask := &meta.Meta_FieldMask{}
	wholeMetadataAccepted := false
	turnsMask := &ConversationTurn_FieldMask{}
	wholeTurnsAccepted := false
	failedTurnsMask := &ConversationTurn_FieldMask{}
	wholeFailedTurnsAccepted := false
	replacedTurnGroupsMask := &ReplacedTurnGroup_FieldMask{}
	wholeReplacedTurnGroupsAccepted := false
	var usageByModelMapKeys []string
	wholeUsageByModelAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Conversation_FieldTerminalPath:
			switch tp.selector {
			case Conversation_FieldPathSelectorName:
				result.Name = source.Name
			case Conversation_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case Conversation_FieldPathSelectorTitle:
				result.Title = source.Title
			case Conversation_FieldPathSelectorConfiguredTitle:
				result.ConfiguredTitle = source.ConfiguredTitle
			case Conversation_FieldPathSelectorArchived:
				result.Archived = source.Archived
			case Conversation_FieldPathSelectorIsPrivate:
				result.IsPrivate = source.IsPrivate
			case Conversation_FieldPathSelectorLastActivityTime:
				result.LastActivityTime = source.LastActivityTime
			case Conversation_FieldPathSelectorTurns:
				result.Turns = source.Turns
				wholeTurnsAccepted = true
			case Conversation_FieldPathSelectorUsageByModel:
				result.UsageByModel = source.UsageByModel
				wholeUsageByModelAccepted = true
			case Conversation_FieldPathSelectorFailedTurns:
				result.FailedTurns = source.FailedTurns
				wholeFailedTurnsAccepted = true
			case Conversation_FieldPathSelectorReplacedTurnGroups:
				result.ReplacedTurnGroups = source.ReplacedTurnGroups
				wholeReplacedTurnGroupsAccepted = true
			}
		case *Conversation_FieldSubPath:
			switch tp.selector {
			case Conversation_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(meta.Meta_FieldPath))
			case Conversation_FieldPathSelectorTurns:
				turnsMask.AppendPath(tp.subPath.(ConversationTurn_FieldPath))
			case Conversation_FieldPathSelectorFailedTurns:
				failedTurnsMask.AppendPath(tp.subPath.(ConversationTurn_FieldPath))
			case Conversation_FieldPathSelectorReplacedTurnGroups:
				replacedTurnGroupsMask.AppendPath(tp.subPath.(ReplacedTurnGroup_FieldPath))
			}
		case *Conversation_FieldPathMap:
			switch tp.selector {
			case Conversation_FieldPathSelectorUsageByModel:
				usageByModelMapKeys = append(usageByModelMapKeys, tp.key)
			}
		}
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	if wholeTurnsAccepted == false && len(turnsMask.Paths) > 0 {
		for _, sourceItem := range source.GetTurns() {
			result.Turns = append(result.Turns, turnsMask.Project(sourceItem))
		}
	}
	if wholeUsageByModelAccepted == false && len(usageByModelMapKeys) > 0 && source.GetUsageByModel() != nil {
		copiedMap := map[string]*ModelUsageStats{}
		sourceMap := source.GetUsageByModel()
		for _, key := range usageByModelMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.UsageByModel = copiedMap
	}
	if wholeFailedTurnsAccepted == false && len(failedTurnsMask.Paths) > 0 {
		for _, sourceItem := range source.GetFailedTurns() {
			result.FailedTurns = append(result.FailedTurns, failedTurnsMask.Project(sourceItem))
		}
	}
	if wholeReplacedTurnGroupsAccepted == false && len(replacedTurnGroupsMask.Paths) > 0 {
		for _, sourceItem := range source.GetReplacedTurnGroups() {
			result.ReplacedTurnGroups = append(result.ReplacedTurnGroups, replacedTurnGroupsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Conversation_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Conversation))
}

func (fieldMask *Conversation_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConversationTurn_FieldMask struct {
	Paths []ConversationTurn_FieldPath
}

func FullConversationTurn_FieldMask() *ConversationTurn_FieldMask {
	res := &ConversationTurn_FieldMask{}
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorTurnNumber})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorTimestamp})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorMessages})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorConfig})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorUsage})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorStopReason})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorDuration})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorAvailableToolsBySource})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorReplacedTurnNumber})
	res.Paths = append(res.Paths, &ConversationTurn_FieldTerminalPath{selector: ConversationTurn_FieldPathSelectorErrorDetails})
	return res
}

func (fieldMask *ConversationTurn_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ConversationTurn_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConversationTurn_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConversationTurn_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConversationTurn_FieldPath(raw)
	})
}

func (fieldMask *ConversationTurn_FieldMask) ProtoMessage() {}

func (fieldMask *ConversationTurn_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConversationTurn_FieldMask) Subtract(other *ConversationTurn_FieldMask) *ConversationTurn_FieldMask {
	result := &ConversationTurn_FieldMask{}
	removedSelectors := make([]bool, 10)
	otherSubMasks := map[ConversationTurn_FieldPathSelector]gotenobject.FieldMask{
		ConversationTurn_FieldPathSelectorConfig:                 &TurnConfig_FieldMask{},
		ConversationTurn_FieldPathSelectorAvailableToolsBySource: &TurnToolsBySourceGroup_FieldMask{},
	}
	mySubMasks := map[ConversationTurn_FieldPathSelector]gotenobject.FieldMask{
		ConversationTurn_FieldPathSelectorConfig:                 &TurnConfig_FieldMask{},
		ConversationTurn_FieldPathSelectorAvailableToolsBySource: &TurnToolsBySourceGroup_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConversationTurn_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConversationTurn_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConversationTurn_FieldTerminalPath); ok {
					switch tp.selector {
					case ConversationTurn_FieldPathSelectorConfig:
						mySubMasks[ConversationTurn_FieldPathSelectorConfig] = FullTurnConfig_FieldMask()
					case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
						mySubMasks[ConversationTurn_FieldPathSelectorAvailableToolsBySource] = FullTurnToolsBySourceGroup_FieldMask()
					}
				} else if tp, ok := path.(*ConversationTurn_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConversationTurn_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConversationTurn_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConversationTurn_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConversationTurn_FieldMask) FilterInputFields() *ConversationTurn_FieldMask {
	result := &ConversationTurn_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConversationTurn_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConversationTurn_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConversationTurn_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConversationTurn_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConversationTurn_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConversationTurn_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConversationTurn_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConversationTurn_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConversationTurn_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConversationTurn_FieldMask) AppendPath(path ConversationTurn_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConversationTurn_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConversationTurn_FieldPath))
}

func (fieldMask *ConversationTurn_FieldMask) GetPaths() []ConversationTurn_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConversationTurn_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConversationTurn_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConversationTurn_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConversationTurn_FieldMask) Set(target, source *ConversationTurn) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConversationTurn_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConversationTurn), source.(*ConversationTurn))
}

func (fieldMask *ConversationTurn_FieldMask) Project(source *ConversationTurn) *ConversationTurn {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConversationTurn{}
	configMask := &TurnConfig_FieldMask{}
	wholeConfigAccepted := false
	availableToolsBySourceMask := &TurnToolsBySourceGroup_FieldMask{}
	wholeAvailableToolsBySourceAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConversationTurn_FieldTerminalPath:
			switch tp.selector {
			case ConversationTurn_FieldPathSelectorTurnNumber:
				result.TurnNumber = source.TurnNumber
			case ConversationTurn_FieldPathSelectorTimestamp:
				result.Timestamp = source.Timestamp
			case ConversationTurn_FieldPathSelectorMessages:
				result.Messages = source.Messages
			case ConversationTurn_FieldPathSelectorConfig:
				result.Config = source.Config
				wholeConfigAccepted = true
			case ConversationTurn_FieldPathSelectorUsage:
				result.Usage = source.Usage
			case ConversationTurn_FieldPathSelectorStopReason:
				result.StopReason = source.StopReason
			case ConversationTurn_FieldPathSelectorDuration:
				result.Duration = source.Duration
			case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
				result.AvailableToolsBySource = source.AvailableToolsBySource
				wholeAvailableToolsBySourceAccepted = true
			case ConversationTurn_FieldPathSelectorReplacedTurnNumber:
				result.ReplacedTurnNumber = source.ReplacedTurnNumber
			case ConversationTurn_FieldPathSelectorErrorDetails:
				result.ErrorDetails = source.ErrorDetails
			}
		case *ConversationTurn_FieldSubPath:
			switch tp.selector {
			case ConversationTurn_FieldPathSelectorConfig:
				configMask.AppendPath(tp.subPath.(TurnConfig_FieldPath))
			case ConversationTurn_FieldPathSelectorAvailableToolsBySource:
				availableToolsBySourceMask.AppendPath(tp.subPath.(TurnToolsBySourceGroup_FieldPath))
			}
		}
	}
	if wholeConfigAccepted == false && len(configMask.Paths) > 0 {
		result.Config = configMask.Project(source.GetConfig())
	}
	if wholeAvailableToolsBySourceAccepted == false && len(availableToolsBySourceMask.Paths) > 0 {
		for _, sourceItem := range source.GetAvailableToolsBySource() {
			result.AvailableToolsBySource = append(result.AvailableToolsBySource, availableToolsBySourceMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ConversationTurn_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConversationTurn))
}

func (fieldMask *ConversationTurn_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TurnToolsBySourceGroup_FieldMask struct {
	Paths []TurnToolsBySourceGroup_FieldPath
}

func FullTurnToolsBySourceGroup_FieldMask() *TurnToolsBySourceGroup_FieldMask {
	res := &TurnToolsBySourceGroup_FieldMask{}
	res.Paths = append(res.Paths, &TurnToolsBySourceGroup_FieldTerminalPath{selector: TurnToolsBySourceGroup_FieldPathSelectorClient})
	res.Paths = append(res.Paths, &TurnToolsBySourceGroup_FieldTerminalPath{selector: TurnToolsBySourceGroup_FieldPathSelectorConnector})
	res.Paths = append(res.Paths, &TurnToolsBySourceGroup_FieldTerminalPath{selector: TurnToolsBySourceGroup_FieldPathSelectorInternal})
	res.Paths = append(res.Paths, &TurnToolsBySourceGroup_FieldTerminalPath{selector: TurnToolsBySourceGroup_FieldPathSelectorToolNames})
	return res
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TurnToolsBySourceGroup_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTurnToolsBySourceGroup_FieldPath(raw)
	})
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) ProtoMessage() {}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) Subtract(other *TurnToolsBySourceGroup_FieldMask) *TurnToolsBySourceGroup_FieldMask {
	result := &TurnToolsBySourceGroup_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TurnToolsBySourceGroup_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TurnToolsBySourceGroup_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TurnToolsBySourceGroup_FieldMask) FilterInputFields() *TurnToolsBySourceGroup_FieldMask {
	result := &TurnToolsBySourceGroup_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TurnToolsBySourceGroup_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TurnToolsBySourceGroup_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTurnToolsBySourceGroup_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TurnToolsBySourceGroup_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TurnToolsBySourceGroup_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) AppendPath(path TurnToolsBySourceGroup_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TurnToolsBySourceGroup_FieldPath))
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) GetPaths() []TurnToolsBySourceGroup_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTurnToolsBySourceGroup_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) Set(target, source *TurnToolsBySourceGroup) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TurnToolsBySourceGroup), source.(*TurnToolsBySourceGroup))
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) Project(source *TurnToolsBySourceGroup) *TurnToolsBySourceGroup {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TurnToolsBySourceGroup{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TurnToolsBySourceGroup_FieldTerminalPath:
			switch tp.selector {
			case TurnToolsBySourceGroup_FieldPathSelectorClient:
				if source, ok := source.Source.(*TurnToolsBySourceGroup_Client); ok {
					result.Source = &TurnToolsBySourceGroup_Client{
						Client: source.Client,
					}
				}
			case TurnToolsBySourceGroup_FieldPathSelectorConnector:
				if source, ok := source.Source.(*TurnToolsBySourceGroup_Connector); ok {
					result.Source = &TurnToolsBySourceGroup_Connector{
						Connector: source.Connector,
					}
				}
			case TurnToolsBySourceGroup_FieldPathSelectorInternal:
				if source, ok := source.Source.(*TurnToolsBySourceGroup_Internal); ok {
					result.Source = &TurnToolsBySourceGroup_Internal{
						Internal: source.Internal,
					}
				}
			case TurnToolsBySourceGroup_FieldPathSelectorToolNames:
				result.ToolNames = source.ToolNames
			}
		}
	}
	return result
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TurnToolsBySourceGroup))
}

func (fieldMask *TurnToolsBySourceGroup_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TurnConfig_FieldMask struct {
	Paths []TurnConfig_FieldPath
}

func FullTurnConfig_FieldMask() *TurnConfig_FieldMask {
	res := &TurnConfig_FieldMask{}
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorModelUsed})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorTemperature})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorMaxTokens})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorReasoningLevel})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorCapabilityTemplate})
	res.Paths = append(res.Paths, &TurnConfig_FieldTerminalPath{selector: TurnConfig_FieldPathSelectorConnectors})
	return res
}

func (fieldMask *TurnConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TurnConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TurnConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TurnConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTurnConfig_FieldPath(raw)
	})
}

func (fieldMask *TurnConfig_FieldMask) ProtoMessage() {}

func (fieldMask *TurnConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TurnConfig_FieldMask) Subtract(other *TurnConfig_FieldMask) *TurnConfig_FieldMask {
	result := &TurnConfig_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TurnConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TurnConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TurnConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TurnConfig_FieldMask) FilterInputFields() *TurnConfig_FieldMask {
	result := &TurnConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TurnConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TurnConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TurnConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTurnConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TurnConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TurnConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TurnConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TurnConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TurnConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TurnConfig_FieldMask) AppendPath(path TurnConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TurnConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TurnConfig_FieldPath))
}

func (fieldMask *TurnConfig_FieldMask) GetPaths() []TurnConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TurnConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TurnConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTurnConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TurnConfig_FieldMask) Set(target, source *TurnConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TurnConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TurnConfig), source.(*TurnConfig))
}

func (fieldMask *TurnConfig_FieldMask) Project(source *TurnConfig) *TurnConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TurnConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TurnConfig_FieldTerminalPath:
			switch tp.selector {
			case TurnConfig_FieldPathSelectorModel:
				result.Model = source.Model
			case TurnConfig_FieldPathSelectorModelUsed:
				result.ModelUsed = source.ModelUsed
			case TurnConfig_FieldPathSelectorTemperature:
				result.Temperature = source.Temperature
			case TurnConfig_FieldPathSelectorMaxTokens:
				result.MaxTokens = source.MaxTokens
			case TurnConfig_FieldPathSelectorReasoningLevel:
				result.ReasoningLevel = source.ReasoningLevel
			case TurnConfig_FieldPathSelectorCapabilityTemplate:
				if source, ok := source.ServerToolsConfig.(*TurnConfig_CapabilityTemplate); ok {
					result.ServerToolsConfig = &TurnConfig_CapabilityTemplate{
						CapabilityTemplate: source.CapabilityTemplate,
					}
				}
			case TurnConfig_FieldPathSelectorConnectors:
				if source, ok := source.ServerToolsConfig.(*TurnConfig_Connectors); ok {
					result.ServerToolsConfig = &TurnConfig_Connectors{
						Connectors: source.Connectors,
					}
				}
			}
		}
	}
	return result
}

func (fieldMask *TurnConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TurnConfig))
}

func (fieldMask *TurnConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ModelUsageStats_FieldMask struct {
	Paths []ModelUsageStats_FieldPath
}

func FullModelUsageStats_FieldMask() *ModelUsageStats_FieldMask {
	res := &ModelUsageStats_FieldMask{}
	res.Paths = append(res.Paths, &ModelUsageStats_FieldTerminalPath{selector: ModelUsageStats_FieldPathSelectorTurnCount})
	res.Paths = append(res.Paths, &ModelUsageStats_FieldTerminalPath{selector: ModelUsageStats_FieldPathSelectorAggregatedUsage})
	return res
}

func (fieldMask *ModelUsageStats_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ModelUsageStats_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ModelUsageStats_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ModelUsageStats_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseModelUsageStats_FieldPath(raw)
	})
}

func (fieldMask *ModelUsageStats_FieldMask) ProtoMessage() {}

func (fieldMask *ModelUsageStats_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ModelUsageStats_FieldMask) Subtract(other *ModelUsageStats_FieldMask) *ModelUsageStats_FieldMask {
	result := &ModelUsageStats_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ModelUsageStats_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ModelUsageStats_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ModelUsageStats_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ModelUsageStats_FieldMask) FilterInputFields() *ModelUsageStats_FieldMask {
	result := &ModelUsageStats_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ModelUsageStats_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ModelUsageStats_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ModelUsageStats_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseModelUsageStats_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ModelUsageStats_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ModelUsageStats_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ModelUsageStats_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ModelUsageStats_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ModelUsageStats_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ModelUsageStats_FieldMask) AppendPath(path ModelUsageStats_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ModelUsageStats_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ModelUsageStats_FieldPath))
}

func (fieldMask *ModelUsageStats_FieldMask) GetPaths() []ModelUsageStats_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ModelUsageStats_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ModelUsageStats_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseModelUsageStats_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ModelUsageStats_FieldMask) Set(target, source *ModelUsageStats) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ModelUsageStats_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ModelUsageStats), source.(*ModelUsageStats))
}

func (fieldMask *ModelUsageStats_FieldMask) Project(source *ModelUsageStats) *ModelUsageStats {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ModelUsageStats{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ModelUsageStats_FieldTerminalPath:
			switch tp.selector {
			case ModelUsageStats_FieldPathSelectorTurnCount:
				result.TurnCount = source.TurnCount
			case ModelUsageStats_FieldPathSelectorAggregatedUsage:
				result.AggregatedUsage = source.AggregatedUsage
			}
		}
	}
	return result
}

func (fieldMask *ModelUsageStats_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ModelUsageStats))
}

func (fieldMask *ModelUsageStats_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ReplacedTurnGroup_FieldMask struct {
	Paths []ReplacedTurnGroup_FieldPath
}

func FullReplacedTurnGroup_FieldMask() *ReplacedTurnGroup_FieldMask {
	res := &ReplacedTurnGroup_FieldMask{}
	res.Paths = append(res.Paths, &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorReplacedAt})
	res.Paths = append(res.Paths, &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorResumedFromTurn})
	res.Paths = append(res.Paths, &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorTurns})
	res.Paths = append(res.Paths, &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorHadMessageEdit})
	res.Paths = append(res.Paths, &ReplacedTurnGroup_FieldTerminalPath{selector: ReplacedTurnGroup_FieldPathSelectorResumeReason})
	return res
}

func (fieldMask *ReplacedTurnGroup_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *ReplacedTurnGroup_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ReplacedTurnGroup_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ReplacedTurnGroup_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseReplacedTurnGroup_FieldPath(raw)
	})
}

func (fieldMask *ReplacedTurnGroup_FieldMask) ProtoMessage() {}

func (fieldMask *ReplacedTurnGroup_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ReplacedTurnGroup_FieldMask) Subtract(other *ReplacedTurnGroup_FieldMask) *ReplacedTurnGroup_FieldMask {
	result := &ReplacedTurnGroup_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ReplacedTurnGroup_FieldPathSelector]gotenobject.FieldMask{
		ReplacedTurnGroup_FieldPathSelectorTurns: &ConversationTurn_FieldMask{},
	}
	mySubMasks := map[ReplacedTurnGroup_FieldPathSelector]gotenobject.FieldMask{
		ReplacedTurnGroup_FieldPathSelectorTurns: &ConversationTurn_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ReplacedTurnGroup_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ReplacedTurnGroup_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ReplacedTurnGroup_FieldTerminalPath); ok {
					switch tp.selector {
					case ReplacedTurnGroup_FieldPathSelectorTurns:
						mySubMasks[ReplacedTurnGroup_FieldPathSelectorTurns] = FullConversationTurn_FieldMask()
					}
				} else if tp, ok := path.(*ReplacedTurnGroup_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ReplacedTurnGroup_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ReplacedTurnGroup_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ReplacedTurnGroup_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ReplacedTurnGroup_FieldMask) FilterInputFields() *ReplacedTurnGroup_FieldMask {
	result := &ReplacedTurnGroup_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ReplacedTurnGroup_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ReplacedTurnGroup_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ReplacedTurnGroup_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseReplacedTurnGroup_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ReplacedTurnGroup_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ReplacedTurnGroup_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ReplacedTurnGroup_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ReplacedTurnGroup_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ReplacedTurnGroup_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ReplacedTurnGroup_FieldMask) AppendPath(path ReplacedTurnGroup_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ReplacedTurnGroup_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ReplacedTurnGroup_FieldPath))
}

func (fieldMask *ReplacedTurnGroup_FieldMask) GetPaths() []ReplacedTurnGroup_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ReplacedTurnGroup_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ReplacedTurnGroup_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseReplacedTurnGroup_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ReplacedTurnGroup_FieldMask) Set(target, source *ReplacedTurnGroup) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ReplacedTurnGroup_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ReplacedTurnGroup), source.(*ReplacedTurnGroup))
}

func (fieldMask *ReplacedTurnGroup_FieldMask) Project(source *ReplacedTurnGroup) *ReplacedTurnGroup {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ReplacedTurnGroup{}
	turnsMask := &ConversationTurn_FieldMask{}
	wholeTurnsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ReplacedTurnGroup_FieldTerminalPath:
			switch tp.selector {
			case ReplacedTurnGroup_FieldPathSelectorReplacedAt:
				result.ReplacedAt = source.ReplacedAt
			case ReplacedTurnGroup_FieldPathSelectorResumedFromTurn:
				result.ResumedFromTurn = source.ResumedFromTurn
			case ReplacedTurnGroup_FieldPathSelectorTurns:
				result.Turns = source.Turns
				wholeTurnsAccepted = true
			case ReplacedTurnGroup_FieldPathSelectorHadMessageEdit:
				result.HadMessageEdit = source.HadMessageEdit
			case ReplacedTurnGroup_FieldPathSelectorResumeReason:
				result.ResumeReason = source.ResumeReason
			}
		case *ReplacedTurnGroup_FieldSubPath:
			switch tp.selector {
			case ReplacedTurnGroup_FieldPathSelectorTurns:
				turnsMask.AppendPath(tp.subPath.(ConversationTurn_FieldPath))
			}
		}
	}
	if wholeTurnsAccepted == false && len(turnsMask.Paths) > 0 {
		for _, sourceItem := range source.GetTurns() {
			result.Turns = append(result.Turns, turnsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ReplacedTurnGroup_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ReplacedTurnGroup))
}

func (fieldMask *ReplacedTurnGroup_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
