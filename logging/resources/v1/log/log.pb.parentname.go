// Code generated by protoc-gen-goten-resource
// Resource: Log
// DO NOT EDIT!!!

package log

import (
	"fmt"
	"net/url"
	"reflect"
	"regexp"
	"strings"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"

	"github.com/cloudwan/goten-sdk/runtime/goten"
	gotenresource "github.com/cloudwan/goten-sdk/runtime/resource"
)

// proto imports
import (
	iam_organization "github.com/cloudwan/edgelq-sdk/iam/resources/v1/organization"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1/project"
	bucket "github.com/cloudwan/edgelq-sdk/logging/resources/v1/bucket"
	log_descriptor "github.com/cloudwan/edgelq-sdk/logging/resources/v1/log_descriptor"
	meta_service "github.com/cloudwan/goten-sdk/meta-service/resources/v1/service"
	meta "github.com/cloudwan/goten-sdk/types/meta"
	anypb "google.golang.org/protobuf/types/known/anypb"
	structpb "google.golang.org/protobuf/types/known/structpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = codes.NotFound
	_ = new(fmt.Stringer)
	_ = new(proto.Message)
	_ = status.Status{}
	_ = url.URL{}
	_ = strings.Builder{}

	_ = new(goten.GotenMessage)
	_ = new(gotenresource.ListQuery)
)

// make sure we're using proto imports
var (
	_ = &iam_organization.Organization{}
	_ = &iam_project.Project{}
	_ = &bucket.Bucket{}
	_ = &log_descriptor.LogDescriptor{}
	_ = &anypb.Any{}
	_ = &structpb.Struct{}
	_ = &timestamppb.Timestamp{}
	_ = &meta_service.Service{}
	_ = &meta.Meta{}
)

var parentRegexPath_Project = regexp.MustCompile("^projects/(?P<project_id>-|[\\w][\\w.-]{0,127})$")
var parentRegexPath_Organization = regexp.MustCompile("^organizations/(?P<organization_id>-|[\\w][\\w.-]{0,127})$")
var parentRegexPath_Service = regexp.MustCompile("^services/(?P<service_id>-|[a-z][a-z0-9\\-.]{0,28}[a-z0-9])$")
var parentRegexPath_Project_Region_Bucket = regexp.MustCompile("^projects/(?P<project_id>-|[\\w][\\w.-]{0,127})/regions/(?P<region_id>-|[a-z][a-z0-9\\-]{0,28}[a-z0-9])/buckets/(?P<bucket_id>-|[\\w./-]{2,128})$")
var parentRegexPath_Organization_Region_Bucket = regexp.MustCompile("^organizations/(?P<organization_id>-|[\\w][\\w.-]{0,127})/regions/(?P<region_id>-|[a-z][a-z0-9\\-]{0,28}[a-z0-9])/buckets/(?P<bucket_id>-|[\\w./-]{2,128})$")
var parentRegexPath_Service_Region_Bucket = regexp.MustCompile("^services/(?P<service_id>-|[a-z][a-z0-9\\-.]{0,28}[a-z0-9])/regions/(?P<region_id>-|[a-z][a-z0-9\\-]{0,28}[a-z0-9])/buckets/(?P<bucket_id>-|[\\w./-]{2,128})$")

type ParentName struct {
	NamePattern
	ProjectId      string `firestore:"projectId"`
	OrganizationId string `firestore:"organizationId"`
	ServiceId      string `firestore:"serviceId"`
	RegionId       string `firestore:"regionId"`
	BucketId       string `firestore:"bucketId"`
}

func ParseParentName(name string) (*ParentName, error) {
	var matches []string
	if matches = parentRegexPath_Project.FindStringSubmatch(name); matches != nil {
		return NewNameBuilder().
			SetProjectId(matches[1]).
			Parent(), nil
	}
	if matches = parentRegexPath_Organization.FindStringSubmatch(name); matches != nil {
		return NewNameBuilder().
			SetOrganizationId(matches[1]).
			Parent(), nil
	}
	if matches = parentRegexPath_Service.FindStringSubmatch(name); matches != nil {
		return NewNameBuilder().
			SetServiceId(matches[1]).
			Parent(), nil
	}
	if matches = parentRegexPath_Project_Region_Bucket.FindStringSubmatch(name); matches != nil {
		return NewNameBuilder().
			SetProjectId(matches[1]).
			SetRegionId(matches[2]).
			SetBucketId(matches[3]).
			Parent(), nil
	}
	if matches = parentRegexPath_Organization_Region_Bucket.FindStringSubmatch(name); matches != nil {
		return NewNameBuilder().
			SetOrganizationId(matches[1]).
			SetRegionId(matches[2]).
			SetBucketId(matches[3]).
			Parent(), nil
	}
	if matches = parentRegexPath_Service_Region_Bucket.FindStringSubmatch(name); matches != nil {
		return NewNameBuilder().
			SetServiceId(matches[1]).
			SetRegionId(matches[2]).
			SetBucketId(matches[3]).
			Parent(), nil
	}

	return nil, status.Errorf(codes.InvalidArgument, "unable to parse '%s' as Log parent name", name)
}

func MustParseParentName(name string) *ParentName {
	result, err := ParseParentName(name)
	if err != nil {
		panic(err)
	}
	return result
}

func (name *ParentName) SetFromSegments(segments gotenresource.NameSegments) error {
	if len(segments) == 1 && segments[0].CollectionLowerJson == "projects" {
		name.Pattern = NamePattern_Project
		name.ProjectId = segments[0].Id
		return nil
	} else if len(segments) == 1 && segments[0].CollectionLowerJson == "organizations" {
		name.Pattern = NamePattern_Organization
		name.OrganizationId = segments[0].Id
		return nil
	} else if len(segments) == 1 && segments[0].CollectionLowerJson == "services" {
		name.Pattern = NamePattern_Service
		name.ServiceId = segments[0].Id
		return nil
	} else if len(segments) == 3 && segments[0].CollectionLowerJson == "projects" && segments[1].CollectionLowerJson == "regions" && segments[2].CollectionLowerJson == "buckets" {
		name.Pattern = NamePattern_Project_Region_Bucket
		name.ProjectId = segments[0].Id
		name.RegionId = segments[1].Id
		name.BucketId = segments[2].Id
		return nil
	} else if len(segments) == 3 && segments[0].CollectionLowerJson == "organizations" && segments[1].CollectionLowerJson == "regions" && segments[2].CollectionLowerJson == "buckets" {
		name.Pattern = NamePattern_Organization_Region_Bucket
		name.OrganizationId = segments[0].Id
		name.RegionId = segments[1].Id
		name.BucketId = segments[2].Id
		return nil
	} else if len(segments) == 3 && segments[0].CollectionLowerJson == "services" && segments[1].CollectionLowerJson == "regions" && segments[2].CollectionLowerJson == "buckets" {
		name.Pattern = NamePattern_Service_Region_Bucket
		name.ServiceId = segments[0].Id
		name.RegionId = segments[1].Id
		name.BucketId = segments[2].Id
		return nil
	}
	return status.Errorf(codes.InvalidArgument, "unable to use segments %s to form Log parent name", segments)
}

func (name *ParentName) GetProjectName() *iam_project.Name {
	if name == nil {
		return nil
	}

	switch name.Pattern {
	case NamePattern_Project:
		return iam_project.NewNameBuilder().
			SetId(name.ProjectId).
			Name()
	default:
		return nil
	}
}

func (name *ParentName) GetOrganizationName() *iam_organization.Name {
	if name == nil {
		return nil
	}

	switch name.Pattern {
	case NamePattern_Organization:
		return iam_organization.NewNameBuilder().
			SetId(name.OrganizationId).
			Name()
	default:
		return nil
	}
}

func (name *ParentName) GetServiceName() *meta_service.Name {
	if name == nil {
		return nil
	}

	switch name.Pattern {
	case NamePattern_Service:
		return meta_service.NewNameBuilder().
			SetId(name.ServiceId).
			Name()
	default:
		return nil
	}
}

func (name *ParentName) GetBucketName() *bucket.Name {
	if name == nil {
		return nil
	}

	switch name.Pattern {
	case NamePattern_Project_Region_Bucket:
		return bucket.NewNameBuilder().
			SetId(name.BucketId).
			SetProjectId(name.ProjectId).
			SetRegionId(name.RegionId).
			SetOrganizationId(name.OrganizationId).
			SetServiceId(name.ServiceId).
			Name()
	case NamePattern_Organization_Region_Bucket:
		return bucket.NewNameBuilder().
			SetId(name.BucketId).
			SetProjectId(name.ProjectId).
			SetRegionId(name.RegionId).
			SetOrganizationId(name.OrganizationId).
			SetServiceId(name.ServiceId).
			Name()
	case NamePattern_Service_Region_Bucket:
		return bucket.NewNameBuilder().
			SetId(name.BucketId).
			SetProjectId(name.ProjectId).
			SetRegionId(name.RegionId).
			SetOrganizationId(name.OrganizationId).
			SetServiceId(name.ServiceId).
			Name()
	default:
		return nil
	}
}

func (name *ParentName) IsSpecified() bool {
	if name == nil || name.Pattern == "" {
		return false
	}
	switch name.Pattern {
	case NamePattern_Project:
		return name.ProjectId != ""
	case NamePattern_Organization:
		return name.OrganizationId != ""
	case NamePattern_Service:
		return name.ServiceId != ""
	case NamePattern_Project_Region_Bucket:
		return name.ProjectId != "" && name.RegionId != "" && name.BucketId != ""
	case NamePattern_Organization_Region_Bucket:
		return name.OrganizationId != "" && name.RegionId != "" && name.BucketId != ""
	case NamePattern_Service_Region_Bucket:
		return name.ServiceId != "" && name.RegionId != "" && name.BucketId != ""
	}
	return false
}

func (name *ParentName) IsFullyQualified() bool {
	if name == nil || name.Pattern == "" {
		return false
	}

	switch name.Pattern {
	case NamePattern_Project:
		return name.ProjectId != "" && name.ProjectId != gotenresource.WildcardId
	case NamePattern_Organization:
		return name.OrganizationId != "" && name.OrganizationId != gotenresource.WildcardId
	case NamePattern_Service:
		return name.ServiceId != "" && name.ServiceId != gotenresource.WildcardId
	case NamePattern_Project_Region_Bucket:
		return name.ProjectId != "" && name.ProjectId != gotenresource.WildcardId && name.RegionId != "" && name.RegionId != gotenresource.WildcardId && name.BucketId != "" && name.BucketId != gotenresource.WildcardId
	case NamePattern_Organization_Region_Bucket:
		return name.OrganizationId != "" && name.OrganizationId != gotenresource.WildcardId && name.RegionId != "" && name.RegionId != gotenresource.WildcardId && name.BucketId != "" && name.BucketId != gotenresource.WildcardId
	case NamePattern_Service_Region_Bucket:
		return name.ServiceId != "" && name.ServiceId != gotenresource.WildcardId && name.RegionId != "" && name.RegionId != gotenresource.WildcardId && name.BucketId != "" && name.BucketId != gotenresource.WildcardId
	}

	return false
}

func (name *ParentName) FullyQualifiedName() (string, error) {
	if !name.IsFullyQualified() {
		return "", status.Errorf(codes.InvalidArgument, "Parent name for Log is not fully qualified")
	}
	return fmt.Sprintf("//logging.edgelq.com/%s", name.String()), nil
}

func (name *ParentName) GetResourceDescriptor() gotenresource.Descriptor {
	return descriptor
}

func (name *ParentName) GetPattern() gotenresource.NamePattern {
	if name == nil {
		return ""
	}
	return name.Pattern
}

func (name *ParentName) GetIdParts() map[string]string {
	if name != nil {
		return map[string]string{
			"projectId":      name.ProjectId,
			"organizationId": name.OrganizationId,
			"serviceId":      name.ServiceId,
			"regionId":       name.RegionId,
			"bucketId":       name.BucketId,
		}
	}
	return map[string]string{
		"projectId":      "",
		"organizationId": "",
		"serviceId":      "",
		"regionId":       "",
		"bucketId":       "",
	}
}

func (name *ParentName) GetSegments() gotenresource.NameSegments {
	if name == nil {
		return nil
	}

	switch name.Pattern {
	case NamePattern_Project:
		return gotenresource.NameSegments{
			gotenresource.NameSegment{
				CollectionLowerJson: "projects",
				Id:                  name.ProjectId,
			},
		}
	case NamePattern_Organization:
		return gotenresource.NameSegments{
			gotenresource.NameSegment{
				CollectionLowerJson: "organizations",
				Id:                  name.OrganizationId,
			},
		}
	case NamePattern_Service:
		return gotenresource.NameSegments{
			gotenresource.NameSegment{
				CollectionLowerJson: "services",
				Id:                  name.ServiceId,
			},
		}
	case NamePattern_Project_Region_Bucket:
		return gotenresource.NameSegments{
			gotenresource.NameSegment{
				CollectionLowerJson: "projects",
				Id:                  name.ProjectId,
			},
			gotenresource.NameSegment{
				CollectionLowerJson: "regions",
				Id:                  name.RegionId,
			},
			gotenresource.NameSegment{
				CollectionLowerJson: "buckets",
				Id:                  name.BucketId,
			},
		}
	case NamePattern_Organization_Region_Bucket:
		return gotenresource.NameSegments{
			gotenresource.NameSegment{
				CollectionLowerJson: "organizations",
				Id:                  name.OrganizationId,
			},
			gotenresource.NameSegment{
				CollectionLowerJson: "regions",
				Id:                  name.RegionId,
			},
			gotenresource.NameSegment{
				CollectionLowerJson: "buckets",
				Id:                  name.BucketId,
			},
		}
	case NamePattern_Service_Region_Bucket:
		return gotenresource.NameSegments{
			gotenresource.NameSegment{
				CollectionLowerJson: "services",
				Id:                  name.ServiceId,
			},
			gotenresource.NameSegment{
				CollectionLowerJson: "regions",
				Id:                  name.RegionId,
			},
			gotenresource.NameSegment{
				CollectionLowerJson: "buckets",
				Id:                  name.BucketId,
			},
		}
	}
	return nil
}

func (name *ParentName) GetIParentName() gotenresource.Name {
	return nil
}

func (name *ParentName) GetIUnderlyingParentName() gotenresource.Name {
	return nil
}

func (name *ParentName) String() string {
	if name == nil {
		return "<nil>"
	}

	if valueStr, err := name.ProtoString(); err != nil {
		panic(err)
	} else {
		return valueStr
	}
}

func (name *ParentName) DescendsFrom(ancestor string) bool {
	if name == nil {
		return false
	}

	switch name.Pattern {
	case NamePattern_Project:
		return ancestor == "projects"
	case NamePattern_Organization:
		return ancestor == "organizations"
	case NamePattern_Service:
		return ancestor == "services"
	case NamePattern_Project_Region_Bucket:
		return ancestor == "projects" || ancestor == "regions" || ancestor == "buckets"
	case NamePattern_Organization_Region_Bucket:
		return ancestor == "organizations" || ancestor == "regions" || ancestor == "buckets"
	case NamePattern_Service_Region_Bucket:
		return ancestor == "services" || ancestor == "regions" || ancestor == "buckets"
	}

	return false
}

func (name *ParentName) AsReference() *ParentReference {
	return &ParentReference{ParentName: *name}
}

func (name *ParentName) AsRawReference() gotenresource.Reference {
	return name.AsReference()
}

// implement methods required by protobuf-go library for string-struct conversion

func (name *ParentName) ProtoString() (string, error) {
	if name == nil {
		return "", nil
	}
	switch name.Pattern {
	case NamePattern_Project:
		return "projects/" + name.ProjectId, nil
	case NamePattern_Organization:
		return "organizations/" + name.OrganizationId, nil
	case NamePattern_Service:
		return "services/" + name.ServiceId, nil
	case NamePattern_Project_Region_Bucket:
		return "projects/" + name.ProjectId + "/regions/" + name.RegionId + "/buckets/" + name.BucketId, nil
	case NamePattern_Organization_Region_Bucket:
		return "organizations/" + name.OrganizationId + "/regions/" + name.RegionId + "/buckets/" + name.BucketId, nil
	case NamePattern_Service_Region_Bucket:
		return "services/" + name.ServiceId + "/regions/" + name.RegionId + "/buckets/" + name.BucketId, nil
	}
	return "", nil
}

func (name *ParentName) ParseProtoString(data string) error {
	parsed, err := ParseParentName(data)
	if err != nil {
		return err
	}
	*name = *parsed
	return nil
}

// GotenEqual returns true if other is of same type and paths are equal (implements goten.Equaler interface)
func (name *ParentName) GotenEqual(other interface{}) bool {
	if other == nil {
		return name == nil
	}
	other1, ok := other.(*ParentName)
	if !ok {
		other2, ok := other.(ParentName)
		if ok {
			other1 = &other2
		} else {
			return false
		}
	}
	if other1 == nil {
		return name == nil
	} else if name == nil {
		return false
	}
	if name.ProjectId != other1.ProjectId {
		return false
	}
	if name.OrganizationId != other1.OrganizationId {
		return false
	}
	if name.ServiceId != other1.ServiceId {
		return false
	}
	if name.RegionId != other1.RegionId {
		return false
	}
	if name.BucketId != other1.BucketId {
		return false
	}
	if name.Pattern != other1.Pattern {
		return false
	}

	return true
}

// Matches is same as GotenEqual, but also will accept "other" if name is wildcard.
func (name *ParentName) Matches(other interface{}) bool {
	if other == nil {
		return name == nil
	}
	other1, ok := other.(*ParentName)
	if !ok {
		other2, ok := other.(ParentName)
		if ok {
			other1 = &other2
		} else {
			return false
		}
	}
	if other1 == nil {
		return name == nil
	} else if name == nil {
		return false
	}

	if name.Pattern != other1.Pattern {
		return false
	}
	switch name.Pattern {
	case NamePattern_Project:
		if name.ProjectId != other1.ProjectId &&
			name.ProjectId != gotenresource.WildcardId {
			return false
		}
	case NamePattern_Organization:
		if name.OrganizationId != other1.OrganizationId &&
			name.OrganizationId != gotenresource.WildcardId {
			return false
		}
	case NamePattern_Service:
		if name.ServiceId != other1.ServiceId &&
			name.ServiceId != gotenresource.WildcardId {
			return false
		}
	case NamePattern_Project_Region_Bucket:
		if name.ProjectId != other1.ProjectId &&
			name.ProjectId != gotenresource.WildcardId {
			return false
		}
		if name.RegionId != other1.RegionId &&
			name.RegionId != gotenresource.WildcardId {
			return false
		}
		if name.BucketId != other1.BucketId &&
			name.BucketId != gotenresource.WildcardId {
			return false
		}
	case NamePattern_Organization_Region_Bucket:
		if name.OrganizationId != other1.OrganizationId &&
			name.OrganizationId != gotenresource.WildcardId {
			return false
		}
		if name.RegionId != other1.RegionId &&
			name.RegionId != gotenresource.WildcardId {
			return false
		}
		if name.BucketId != other1.BucketId &&
			name.BucketId != gotenresource.WildcardId {
			return false
		}
	case NamePattern_Service_Region_Bucket:
		if name.ServiceId != other1.ServiceId &&
			name.ServiceId != gotenresource.WildcardId {
			return false
		}
		if name.RegionId != other1.RegionId &&
			name.RegionId != gotenresource.WildcardId {
			return false
		}
		if name.BucketId != other1.BucketId &&
			name.BucketId != gotenresource.WildcardId {
			return false
		}
	}

	return true
}

// implement CustomTypeCliValue method
func (name *ParentName) SetFromCliFlag(raw string) error {
	parsedName, err := ParseParentName(raw)
	if err != nil {
		return err
	}
	*name = *parsedName
	return nil
}

type ParentReference struct {
	ParentName
	project      *iam_project.Project
	organization *iam_organization.Organization
	service      *meta_service.Service
	bucket       *bucket.Bucket
}

func MakeParentReference(name *ParentName) (*ParentReference, error) {
	return &ParentReference{
		ParentName: *name,
	}, nil
}

func ParseParentReference(name string) (*ParentReference, error) {
	parsedName, err := ParseParentName(name)
	if err != nil {
		return nil, err
	}
	return MakeParentReference(parsedName)
}

func MustParseParentReference(name string) *ParentReference {
	result, err := ParseParentReference(name)
	if err != nil {
		panic(err)
	}
	return result
}
func (ref *ParentReference) GetProjectReference() *iam_project.Reference {
	if ref == nil {
		return nil
	}

	switch ref.Pattern {
	case NamePattern_Project:
		return iam_project.NewNameBuilder().
			SetId(ref.ProjectId).
			Reference()
	default:
		return nil
	}
}
func (ref *ParentReference) GetOrganizationReference() *iam_organization.Reference {
	if ref == nil {
		return nil
	}

	switch ref.Pattern {
	case NamePattern_Organization:
		return iam_organization.NewNameBuilder().
			SetId(ref.OrganizationId).
			Reference()
	default:
		return nil
	}
}
func (ref *ParentReference) GetServiceReference() *meta_service.Reference {
	if ref == nil {
		return nil
	}

	switch ref.Pattern {
	case NamePattern_Service:
		return meta_service.NewNameBuilder().
			SetId(ref.ServiceId).
			Reference()
	default:
		return nil
	}
}
func (ref *ParentReference) GetBucketReference() *bucket.Reference {
	if ref == nil {
		return nil
	}

	switch ref.Pattern {
	case NamePattern_Project_Region_Bucket:
		return bucket.NewNameBuilder().
			SetId(ref.BucketId).
			SetProjectId(ref.ProjectId).
			SetRegionId(ref.RegionId).
			SetOrganizationId(ref.OrganizationId).
			SetServiceId(ref.ServiceId).
			Reference()
	case NamePattern_Organization_Region_Bucket:
		return bucket.NewNameBuilder().
			SetId(ref.BucketId).
			SetProjectId(ref.ProjectId).
			SetRegionId(ref.RegionId).
			SetOrganizationId(ref.OrganizationId).
			SetServiceId(ref.ServiceId).
			Reference()
	case NamePattern_Service_Region_Bucket:
		return bucket.NewNameBuilder().
			SetId(ref.BucketId).
			SetProjectId(ref.ProjectId).
			SetRegionId(ref.RegionId).
			SetOrganizationId(ref.OrganizationId).
			SetServiceId(ref.ServiceId).
			Reference()
	default:
		return nil
	}
}

func (ref *ParentReference) GetUnderlyingReference() gotenresource.Reference {
	if ref == nil {
		return nil
	}
	projectRef := ref.GetProjectReference()
	if projectRef != nil {
		return projectRef
	}
	organizationRef := ref.GetOrganizationReference()
	if organizationRef != nil {
		return organizationRef
	}
	serviceRef := ref.GetServiceReference()
	if serviceRef != nil {
		return serviceRef
	}
	bucketRef := ref.GetBucketReference()
	if bucketRef != nil {
		return bucketRef
	}

	return nil
}

func (ref *ParentReference) ResolveRaw(res gotenresource.Resource) error {
	switch typedRes := res.(type) {
	case *iam_project.Project:
		if name := ref.GetProjectName(); name == nil {
			return status.Errorf(codes.InvalidArgument, "cannot set Project as parent of Log, because pattern does not match")
		}
		ref.project = typedRes
		return nil
	case *iam_organization.Organization:
		if name := ref.GetOrganizationName(); name == nil {
			return status.Errorf(codes.InvalidArgument, "cannot set Organization as parent of Log, because pattern does not match")
		}
		ref.organization = typedRes
		return nil
	case *meta_service.Service:
		if name := ref.GetServiceName(); name == nil {
			return status.Errorf(codes.InvalidArgument, "cannot set Service as parent of Log, because pattern does not match")
		}
		ref.service = typedRes
		return nil
	case *bucket.Bucket:
		if name := ref.GetBucketName(); name == nil {
			return status.Errorf(codes.InvalidArgument, "cannot set Bucket as parent of Log, because pattern does not match")
		}
		ref.bucket = typedRes
		return nil
	default:
		return status.Errorf(codes.Internal, "Invalid parent type for Log, got %s", reflect.TypeOf(res).Elem().Name())
	}
}

func (ref *ParentReference) Resolved() bool {
	if name := ref.GetProjectName(); name != nil {
		return ref.project != nil
	}
	if name := ref.GetOrganizationName(); name != nil {
		return ref.organization != nil
	}
	if name := ref.GetServiceName(); name != nil {
		return ref.service != nil
	}
	if name := ref.GetBucketName(); name != nil {
		return ref.bucket != nil
	}
	return true
}

func (ref *ParentReference) ClearCached() {
	ref.project = nil
	ref.organization = nil
	ref.service = nil
	ref.bucket = nil
}

func (ref *ParentReference) GetProject() *iam_project.Project {
	if ref == nil {
		return nil
	}
	return ref.project
}
func (ref *ParentReference) GetOrganization() *iam_organization.Organization {
	if ref == nil {
		return nil
	}
	return ref.organization
}
func (ref *ParentReference) GetService() *meta_service.Service {
	if ref == nil {
		return nil
	}
	return ref.service
}
func (ref *ParentReference) GetBucket() *bucket.Bucket {
	if ref == nil {
		return nil
	}
	return ref.bucket
}

func (ref *ParentReference) GetRawResource() gotenresource.Resource {
	if name := ref.ParentName.GetProjectName(); name != nil {
		return ref.project
	}
	if name := ref.ParentName.GetOrganizationName(); name != nil {
		return ref.organization
	}
	if name := ref.ParentName.GetServiceName(); name != nil {
		return ref.service
	}
	if name := ref.ParentName.GetBucketName(); name != nil {
		return ref.bucket
	}
	return nil
}

func (ref *ParentReference) IsFullyQualified() bool {
	if ref == nil {
		return false
	}
	return ref.ParentName.IsFullyQualified()
}

func (ref *ParentReference) IsSpecified() bool {
	if ref == nil {
		return false
	}
	return ref.ParentName.IsSpecified()
}

func (ref *ParentReference) GetResourceDescriptor() gotenresource.Descriptor {
	return descriptor
}

func (ref *ParentReference) GetPattern() gotenresource.NamePattern {
	if ref == nil {
		return ""
	}
	return ref.Pattern
}

func (ref *ParentReference) GetIdParts() map[string]string {
	if ref != nil {
		return ref.ParentName.GetIdParts()
	}
	return map[string]string{
		"projectId":      "",
		"organizationId": "",
		"serviceId":      "",
		"regionId":       "",
		"bucketId":       "",
	}
}

func (ref *ParentReference) GetSegments() gotenresource.NameSegments {
	if ref != nil {
		return ref.ParentName.GetSegments()
	}
	return nil
}

func (ref *ParentReference) GetIParentName() gotenresource.Name {
	return nil
}

func (ref *ParentReference) GetIUnderlyingParentName() gotenresource.Name {
	return nil
}

func (ref *ParentReference) String() string {
	if ref == nil {
		return "<nil>"
	}
	return ref.ParentName.String()
}

// implement methods required by protobuf-go library for string-struct conversion

func (ref *ParentReference) ProtoString() (string, error) {
	if ref == nil {
		return "", nil
	}
	return ref.ParentName.ProtoString()
}

func (ref *ParentReference) ParseProtoString(data string) error {
	parsed, err := ParseParentReference(data)
	if err != nil {
		return err
	}
	*ref = *parsed
	return nil
}

// GotenEqual returns true if other is of same type and paths are equal (implements goten.Equaler interface)
func (ref *ParentReference) GotenEqual(other interface{}) bool {
	if other == nil {
		return ref == nil
	}
	other1, ok := other.(*ParentReference)
	if !ok {
		other2, ok := other.(ParentReference)
		if ok {
			other1 = &other2
		} else {
			return false
		}
	}
	if other1 == nil {
		return ref == nil
	} else if ref == nil {
		return false
	}
	if ref.project != other1.project {
		return false
	}
	if ref.organization != other1.organization {
		return false
	}
	if ref.service != other1.service {
		return false
	}
	if ref.bucket != other1.bucket {
		return false
	}

	return ref.ParentName.GotenEqual(other1.ParentName)
}

// Matches is same as GotenEqual, but also will accept "other" if name is wildcard.
func (name *ParentReference) Matches(other interface{}) bool {
	if other == nil {
		return name == nil
	}
	other1, ok := other.(*ParentReference)
	if !ok {
		other2, ok := other.(ParentReference)
		if ok {
			other1 = &other2
		} else {
			return false
		}
	}
	if other1 == nil {
		return name == nil
	} else if name == nil {
		return false
	}
	return name.ParentName.Matches(&other1.ParentName)
}

// implement CustomTypeCliValue method
func (ref *ParentReference) SetFromCliFlag(raw string) error {
	parsedRef, err := ParseParentReference(raw)
	if err != nil {
		return err
	}
	*ref = *parsedRef
	return nil
}
