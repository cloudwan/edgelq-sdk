// Code generated by protoc-gen-goten-object
// File: edgelq/logging/proto/v1alpha2/log_descriptor_service.proto
// DO NOT EDIT!!!

package log_descriptor_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	iam_organization "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/organization"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/project"
	log_descriptor "github.com/cloudwan/edgelq-sdk/logging/resources/v1alpha2/log_descriptor"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &iam_organization.Organization{}
	_ = &iam_project.Project{}
	_ = &log_descriptor.LogDescriptor{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetLogDescriptorRequest_FieldMask struct {
	Paths []GetLogDescriptorRequest_FieldPath
}

func FullGetLogDescriptorRequest_FieldMask() *GetLogDescriptorRequest_FieldMask {
	res := &GetLogDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetLogDescriptorRequest_FieldTerminalPath{selector: GetLogDescriptorRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetLogDescriptorRequest_FieldTerminalPath{selector: GetLogDescriptorRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetLogDescriptorRequest_FieldTerminalPath{selector: GetLogDescriptorRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetLogDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetLogDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetLogDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetLogDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetLogDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) Subtract(other *GetLogDescriptorRequest_FieldMask) *GetLogDescriptorRequest_FieldMask {
	result := &GetLogDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetLogDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetLogDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetLogDescriptorRequest_FieldMask) FilterInputFields() *GetLogDescriptorRequest_FieldMask {
	result := &GetLogDescriptorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetLogDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetLogDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetLogDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetLogDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetLogDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) AppendPath(path GetLogDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetLogDescriptorRequest_FieldPath))
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) GetPaths() []GetLogDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetLogDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) Set(target, source *GetLogDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetLogDescriptorRequest), source.(*GetLogDescriptorRequest))
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) Project(source *GetLogDescriptorRequest) *GetLogDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetLogDescriptorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetLogDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case GetLogDescriptorRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetLogDescriptorRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetLogDescriptorRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetLogDescriptorRequest))
}

func (fieldMask *GetLogDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetLogDescriptorsRequest_FieldMask struct {
	Paths []BatchGetLogDescriptorsRequest_FieldPath
}

func FullBatchGetLogDescriptorsRequest_FieldMask() *BatchGetLogDescriptorsRequest_FieldMask {
	res := &BatchGetLogDescriptorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetLogDescriptorsRequest_FieldTerminalPath{selector: BatchGetLogDescriptorsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetLogDescriptorsRequest_FieldTerminalPath{selector: BatchGetLogDescriptorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetLogDescriptorsRequest_FieldTerminalPath{selector: BatchGetLogDescriptorsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetLogDescriptorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetLogDescriptorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetLogDescriptorsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) Subtract(other *BatchGetLogDescriptorsRequest_FieldMask) *BatchGetLogDescriptorsRequest_FieldMask {
	result := &BatchGetLogDescriptorsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetLogDescriptorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetLogDescriptorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) FilterInputFields() *BatchGetLogDescriptorsRequest_FieldMask {
	result := &BatchGetLogDescriptorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetLogDescriptorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetLogDescriptorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetLogDescriptorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetLogDescriptorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) AppendPath(path BatchGetLogDescriptorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetLogDescriptorsRequest_FieldPath))
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) GetPaths() []BatchGetLogDescriptorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetLogDescriptorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) Set(target, source *BatchGetLogDescriptorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetLogDescriptorsRequest), source.(*BatchGetLogDescriptorsRequest))
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) Project(source *BatchGetLogDescriptorsRequest) *BatchGetLogDescriptorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetLogDescriptorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetLogDescriptorsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetLogDescriptorsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetLogDescriptorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetLogDescriptorsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetLogDescriptorsRequest))
}

func (fieldMask *BatchGetLogDescriptorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetLogDescriptorsResponse_FieldMask struct {
	Paths []BatchGetLogDescriptorsResponse_FieldPath
}

func FullBatchGetLogDescriptorsResponse_FieldMask() *BatchGetLogDescriptorsResponse_FieldMask {
	res := &BatchGetLogDescriptorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetLogDescriptorsResponse_FieldTerminalPath{selector: BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors})
	res.Paths = append(res.Paths, &BatchGetLogDescriptorsResponse_FieldTerminalPath{selector: BatchGetLogDescriptorsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetLogDescriptorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetLogDescriptorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetLogDescriptorsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) Subtract(other *BatchGetLogDescriptorsResponse_FieldMask) *BatchGetLogDescriptorsResponse_FieldMask {
	result := &BatchGetLogDescriptorsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetLogDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors: &log_descriptor.LogDescriptor_FieldMask{},
	}
	mySubMasks := map[BatchGetLogDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors: &log_descriptor.LogDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetLogDescriptorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetLogDescriptorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetLogDescriptorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors:
						mySubMasks[BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors] = log_descriptor.FullLogDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetLogDescriptorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetLogDescriptorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetLogDescriptorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) FilterInputFields() *BatchGetLogDescriptorsResponse_FieldMask {
	result := &BatchGetLogDescriptorsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors:
			if _, ok := path.(*BatchGetLogDescriptorsResponse_FieldTerminalPath); ok {
				for _, subpath := range log_descriptor.FullLogDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetLogDescriptorsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetLogDescriptorsResponse_FieldSubPath); ok {
				selectedMask := &log_descriptor.LogDescriptor_FieldMask{
					Paths: []log_descriptor.LogDescriptor_FieldPath{sub.subPath.(log_descriptor.LogDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetLogDescriptorsResponse_FieldSubPath{selector: BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetLogDescriptorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetLogDescriptorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetLogDescriptorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetLogDescriptorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) AppendPath(path BatchGetLogDescriptorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetLogDescriptorsResponse_FieldPath))
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) GetPaths() []BatchGetLogDescriptorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetLogDescriptorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) Set(target, source *BatchGetLogDescriptorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetLogDescriptorsResponse), source.(*BatchGetLogDescriptorsResponse))
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) Project(source *BatchGetLogDescriptorsResponse) *BatchGetLogDescriptorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetLogDescriptorsResponse{}
	logDescriptorsMask := &log_descriptor.LogDescriptor_FieldMask{}
	wholeLogDescriptorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetLogDescriptorsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors:
				result.LogDescriptors = source.LogDescriptors
				wholeLogDescriptorsAccepted = true
			case BatchGetLogDescriptorsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetLogDescriptorsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetLogDescriptorsResponse_FieldPathSelectorLogDescriptors:
				logDescriptorsMask.AppendPath(tp.subPath.(log_descriptor.LogDescriptor_FieldPath))
			}
		}
	}
	if wholeLogDescriptorsAccepted == false && len(logDescriptorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetLogDescriptors() {
			result.LogDescriptors = append(result.LogDescriptors, logDescriptorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetLogDescriptorsResponse))
}

func (fieldMask *BatchGetLogDescriptorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListLogDescriptorsRequest_FieldMask struct {
	Paths []ListLogDescriptorsRequest_FieldPath
}

func FullListLogDescriptorsRequest_FieldMask() *ListLogDescriptorsRequest_FieldMask {
	res := &ListLogDescriptorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListLogDescriptorsRequest_FieldTerminalPath{selector: ListLogDescriptorsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListLogDescriptorsRequest_FieldTerminalPath{selector: ListLogDescriptorsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListLogDescriptorsRequest_FieldTerminalPath{selector: ListLogDescriptorsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListLogDescriptorsRequest_FieldTerminalPath{selector: ListLogDescriptorsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListLogDescriptorsRequest_FieldTerminalPath{selector: ListLogDescriptorsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListLogDescriptorsRequest_FieldTerminalPath{selector: ListLogDescriptorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListLogDescriptorsRequest_FieldTerminalPath{selector: ListLogDescriptorsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListLogDescriptorsRequest_FieldTerminalPath{selector: ListLogDescriptorsRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListLogDescriptorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListLogDescriptorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListLogDescriptorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListLogDescriptorsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) Subtract(other *ListLogDescriptorsRequest_FieldMask) *ListLogDescriptorsRequest_FieldMask {
	result := &ListLogDescriptorsRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListLogDescriptorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListLogDescriptorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListLogDescriptorsRequest_FieldMask) FilterInputFields() *ListLogDescriptorsRequest_FieldMask {
	result := &ListLogDescriptorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListLogDescriptorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListLogDescriptorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListLogDescriptorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListLogDescriptorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListLogDescriptorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) AppendPath(path ListLogDescriptorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListLogDescriptorsRequest_FieldPath))
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) GetPaths() []ListLogDescriptorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListLogDescriptorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) Set(target, source *ListLogDescriptorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListLogDescriptorsRequest), source.(*ListLogDescriptorsRequest))
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) Project(source *ListLogDescriptorsRequest) *ListLogDescriptorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListLogDescriptorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListLogDescriptorsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListLogDescriptorsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListLogDescriptorsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListLogDescriptorsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListLogDescriptorsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListLogDescriptorsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListLogDescriptorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListLogDescriptorsRequest_FieldPathSelectorView:
				result.View = source.View
			case ListLogDescriptorsRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListLogDescriptorsRequest))
}

func (fieldMask *ListLogDescriptorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListLogDescriptorsResponse_FieldMask struct {
	Paths []ListLogDescriptorsResponse_FieldPath
}

func FullListLogDescriptorsResponse_FieldMask() *ListLogDescriptorsResponse_FieldMask {
	res := &ListLogDescriptorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListLogDescriptorsResponse_FieldTerminalPath{selector: ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors})
	res.Paths = append(res.Paths, &ListLogDescriptorsResponse_FieldTerminalPath{selector: ListLogDescriptorsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListLogDescriptorsResponse_FieldTerminalPath{selector: ListLogDescriptorsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListLogDescriptorsResponse_FieldTerminalPath{selector: ListLogDescriptorsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListLogDescriptorsResponse_FieldTerminalPath{selector: ListLogDescriptorsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListLogDescriptorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListLogDescriptorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListLogDescriptorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListLogDescriptorsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) Subtract(other *ListLogDescriptorsResponse_FieldMask) *ListLogDescriptorsResponse_FieldMask {
	result := &ListLogDescriptorsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListLogDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors: &log_descriptor.LogDescriptor_FieldMask{},
	}
	mySubMasks := map[ListLogDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors: &log_descriptor.LogDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListLogDescriptorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListLogDescriptorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListLogDescriptorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors:
						mySubMasks[ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors] = log_descriptor.FullLogDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*ListLogDescriptorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListLogDescriptorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListLogDescriptorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListLogDescriptorsResponse_FieldMask) FilterInputFields() *ListLogDescriptorsResponse_FieldMask {
	result := &ListLogDescriptorsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors:
			if _, ok := path.(*ListLogDescriptorsResponse_FieldTerminalPath); ok {
				for _, subpath := range log_descriptor.FullLogDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListLogDescriptorsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListLogDescriptorsResponse_FieldSubPath); ok {
				selectedMask := &log_descriptor.LogDescriptor_FieldMask{
					Paths: []log_descriptor.LogDescriptor_FieldPath{sub.subPath.(log_descriptor.LogDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListLogDescriptorsResponse_FieldSubPath{selector: ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListLogDescriptorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListLogDescriptorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListLogDescriptorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListLogDescriptorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListLogDescriptorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) AppendPath(path ListLogDescriptorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListLogDescriptorsResponse_FieldPath))
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) GetPaths() []ListLogDescriptorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListLogDescriptorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) Set(target, source *ListLogDescriptorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListLogDescriptorsResponse), source.(*ListLogDescriptorsResponse))
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) Project(source *ListLogDescriptorsResponse) *ListLogDescriptorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListLogDescriptorsResponse{}
	logDescriptorsMask := &log_descriptor.LogDescriptor_FieldMask{}
	wholeLogDescriptorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListLogDescriptorsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors:
				result.LogDescriptors = source.LogDescriptors
				wholeLogDescriptorsAccepted = true
			case ListLogDescriptorsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListLogDescriptorsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListLogDescriptorsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListLogDescriptorsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListLogDescriptorsResponse_FieldSubPath:
			switch tp.selector {
			case ListLogDescriptorsResponse_FieldPathSelectorLogDescriptors:
				logDescriptorsMask.AppendPath(tp.subPath.(log_descriptor.LogDescriptor_FieldPath))
			}
		}
	}
	if wholeLogDescriptorsAccepted == false && len(logDescriptorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetLogDescriptors() {
			result.LogDescriptors = append(result.LogDescriptors, logDescriptorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListLogDescriptorsResponse))
}

func (fieldMask *ListLogDescriptorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLogDescriptorRequest_FieldMask struct {
	Paths []WatchLogDescriptorRequest_FieldPath
}

func FullWatchLogDescriptorRequest_FieldMask() *WatchLogDescriptorRequest_FieldMask {
	res := &WatchLogDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchLogDescriptorRequest_FieldTerminalPath{selector: WatchLogDescriptorRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchLogDescriptorRequest_FieldTerminalPath{selector: WatchLogDescriptorRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchLogDescriptorRequest_FieldTerminalPath{selector: WatchLogDescriptorRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLogDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLogDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLogDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLogDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) Subtract(other *WatchLogDescriptorRequest_FieldMask) *WatchLogDescriptorRequest_FieldMask {
	result := &WatchLogDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLogDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLogDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLogDescriptorRequest_FieldMask) FilterInputFields() *WatchLogDescriptorRequest_FieldMask {
	result := &WatchLogDescriptorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLogDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLogDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLogDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLogDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLogDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) AppendPath(path WatchLogDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLogDescriptorRequest_FieldPath))
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) GetPaths() []WatchLogDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLogDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) Set(target, source *WatchLogDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLogDescriptorRequest), source.(*WatchLogDescriptorRequest))
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) Project(source *WatchLogDescriptorRequest) *WatchLogDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLogDescriptorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLogDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchLogDescriptorRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchLogDescriptorRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchLogDescriptorRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLogDescriptorRequest))
}

func (fieldMask *WatchLogDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLogDescriptorResponse_FieldMask struct {
	Paths []WatchLogDescriptorResponse_FieldPath
}

func FullWatchLogDescriptorResponse_FieldMask() *WatchLogDescriptorResponse_FieldMask {
	res := &WatchLogDescriptorResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchLogDescriptorResponse_FieldTerminalPath{selector: WatchLogDescriptorResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLogDescriptorResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLogDescriptorResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLogDescriptorResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLogDescriptorResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) Subtract(other *WatchLogDescriptorResponse_FieldMask) *WatchLogDescriptorResponse_FieldMask {
	result := &WatchLogDescriptorResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLogDescriptorResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLogDescriptorResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLogDescriptorResponse_FieldMask) FilterInputFields() *WatchLogDescriptorResponse_FieldMask {
	result := &WatchLogDescriptorResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLogDescriptorResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLogDescriptorResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLogDescriptorResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLogDescriptorResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLogDescriptorResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) AppendPath(path WatchLogDescriptorResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLogDescriptorResponse_FieldPath))
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) GetPaths() []WatchLogDescriptorResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLogDescriptorResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) Set(target, source *WatchLogDescriptorResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLogDescriptorResponse), source.(*WatchLogDescriptorResponse))
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) Project(source *WatchLogDescriptorResponse) *WatchLogDescriptorResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLogDescriptorResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLogDescriptorResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchLogDescriptorResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLogDescriptorResponse))
}

func (fieldMask *WatchLogDescriptorResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLogDescriptorsRequest_FieldMask struct {
	Paths []WatchLogDescriptorsRequest_FieldPath
}

func FullWatchLogDescriptorsRequest_FieldMask() *WatchLogDescriptorsRequest_FieldMask {
	res := &WatchLogDescriptorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchLogDescriptorsRequest_FieldTerminalPath{selector: WatchLogDescriptorsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLogDescriptorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLogDescriptorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLogDescriptorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLogDescriptorsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) Subtract(other *WatchLogDescriptorsRequest_FieldMask) *WatchLogDescriptorsRequest_FieldMask {
	result := &WatchLogDescriptorsRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLogDescriptorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLogDescriptorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLogDescriptorsRequest_FieldMask) FilterInputFields() *WatchLogDescriptorsRequest_FieldMask {
	result := &WatchLogDescriptorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLogDescriptorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLogDescriptorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLogDescriptorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLogDescriptorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLogDescriptorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) AppendPath(path WatchLogDescriptorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLogDescriptorsRequest_FieldPath))
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) GetPaths() []WatchLogDescriptorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLogDescriptorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) Set(target, source *WatchLogDescriptorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLogDescriptorsRequest), source.(*WatchLogDescriptorsRequest))
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) Project(source *WatchLogDescriptorsRequest) *WatchLogDescriptorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLogDescriptorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLogDescriptorsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchLogDescriptorsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchLogDescriptorsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchLogDescriptorsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchLogDescriptorsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchLogDescriptorsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchLogDescriptorsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchLogDescriptorsRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchLogDescriptorsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchLogDescriptorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchLogDescriptorsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchLogDescriptorsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLogDescriptorsRequest))
}

func (fieldMask *WatchLogDescriptorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLogDescriptorsResponse_FieldMask struct {
	Paths []WatchLogDescriptorsResponse_FieldPath
}

func FullWatchLogDescriptorsResponse_FieldMask() *WatchLogDescriptorsResponse_FieldMask {
	res := &WatchLogDescriptorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponse_FieldTerminalPath{selector: WatchLogDescriptorsResponse_FieldPathSelectorLogDescriptorChanges})
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponse_FieldTerminalPath{selector: WatchLogDescriptorsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponse_FieldTerminalPath{selector: WatchLogDescriptorsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponse_FieldTerminalPath{selector: WatchLogDescriptorsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponse_FieldTerminalPath{selector: WatchLogDescriptorsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponse_FieldTerminalPath{selector: WatchLogDescriptorsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponse_FieldTerminalPath{selector: WatchLogDescriptorsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLogDescriptorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLogDescriptorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLogDescriptorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLogDescriptorsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) Subtract(other *WatchLogDescriptorsResponse_FieldMask) *WatchLogDescriptorsResponse_FieldMask {
	result := &WatchLogDescriptorsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchLogDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchLogDescriptorsResponse_FieldPathSelectorPageTokenChange: &WatchLogDescriptorsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchLogDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchLogDescriptorsResponse_FieldPathSelectorPageTokenChange: &WatchLogDescriptorsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLogDescriptorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchLogDescriptorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchLogDescriptorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchLogDescriptorsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchLogDescriptorsResponse_FieldPathSelectorPageTokenChange] = FullWatchLogDescriptorsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchLogDescriptorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchLogDescriptorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLogDescriptorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLogDescriptorsResponse_FieldMask) FilterInputFields() *WatchLogDescriptorsResponse_FieldMask {
	result := &WatchLogDescriptorsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLogDescriptorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLogDescriptorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLogDescriptorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLogDescriptorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLogDescriptorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) AppendPath(path WatchLogDescriptorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLogDescriptorsResponse_FieldPath))
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) GetPaths() []WatchLogDescriptorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLogDescriptorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) Set(target, source *WatchLogDescriptorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLogDescriptorsResponse), source.(*WatchLogDescriptorsResponse))
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) Project(source *WatchLogDescriptorsResponse) *WatchLogDescriptorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLogDescriptorsResponse{}
	pageTokenChangeMask := &WatchLogDescriptorsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLogDescriptorsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchLogDescriptorsResponse_FieldPathSelectorLogDescriptorChanges:
				result.LogDescriptorChanges = source.LogDescriptorChanges
			case WatchLogDescriptorsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchLogDescriptorsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchLogDescriptorsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchLogDescriptorsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchLogDescriptorsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchLogDescriptorsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchLogDescriptorsResponse_FieldSubPath:
			switch tp.selector {
			case WatchLogDescriptorsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchLogDescriptorsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLogDescriptorsResponse))
}

func (fieldMask *WatchLogDescriptorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLogDescriptorsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchLogDescriptorsResponsePageTokenChange_FieldPath
}

func FullWatchLogDescriptorsResponse_PageTokenChange_FieldMask() *WatchLogDescriptorsResponse_PageTokenChange_FieldMask {
	res := &WatchLogDescriptorsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponsePageTokenChange_FieldTerminalPath{selector: WatchLogDescriptorsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchLogDescriptorsResponsePageTokenChange_FieldTerminalPath{selector: WatchLogDescriptorsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLogDescriptorsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLogDescriptorsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLogDescriptorsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) Subtract(other *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) *WatchLogDescriptorsResponse_PageTokenChange_FieldMask {
	result := &WatchLogDescriptorsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLogDescriptorsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLogDescriptorsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchLogDescriptorsResponse_PageTokenChange_FieldMask {
	result := &WatchLogDescriptorsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLogDescriptorsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLogDescriptorsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLogDescriptorsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLogDescriptorsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) AppendPath(path WatchLogDescriptorsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLogDescriptorsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) GetPaths() []WatchLogDescriptorsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLogDescriptorsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) Set(target, source *WatchLogDescriptorsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLogDescriptorsResponse_PageTokenChange), source.(*WatchLogDescriptorsResponse_PageTokenChange))
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) Project(source *WatchLogDescriptorsResponse_PageTokenChange) *WatchLogDescriptorsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLogDescriptorsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLogDescriptorsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchLogDescriptorsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchLogDescriptorsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLogDescriptorsResponse_PageTokenChange))
}

func (fieldMask *WatchLogDescriptorsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateLogDescriptorRequest_FieldMask struct {
	Paths []CreateLogDescriptorRequest_FieldPath
}

func FullCreateLogDescriptorRequest_FieldMask() *CreateLogDescriptorRequest_FieldMask {
	res := &CreateLogDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateLogDescriptorRequest_FieldTerminalPath{selector: CreateLogDescriptorRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateLogDescriptorRequest_FieldTerminalPath{selector: CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor})
	return res
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateLogDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateLogDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateLogDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateLogDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) Subtract(other *CreateLogDescriptorRequest_FieldMask) *CreateLogDescriptorRequest_FieldMask {
	result := &CreateLogDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateLogDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor: &log_descriptor.LogDescriptor_FieldMask{},
	}
	mySubMasks := map[CreateLogDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor: &log_descriptor.LogDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateLogDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateLogDescriptorRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateLogDescriptorRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor:
						mySubMasks[CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor] = log_descriptor.FullLogDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*CreateLogDescriptorRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateLogDescriptorRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateLogDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateLogDescriptorRequest_FieldMask) FilterInputFields() *CreateLogDescriptorRequest_FieldMask {
	result := &CreateLogDescriptorRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor:
			if _, ok := path.(*CreateLogDescriptorRequest_FieldTerminalPath); ok {
				for _, subpath := range log_descriptor.FullLogDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateLogDescriptorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateLogDescriptorRequest_FieldSubPath); ok {
				selectedMask := &log_descriptor.LogDescriptor_FieldMask{
					Paths: []log_descriptor.LogDescriptor_FieldPath{sub.subPath.(log_descriptor.LogDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateLogDescriptorRequest_FieldSubPath{selector: CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateLogDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateLogDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateLogDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateLogDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateLogDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) AppendPath(path CreateLogDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateLogDescriptorRequest_FieldPath))
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) GetPaths() []CreateLogDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateLogDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) Set(target, source *CreateLogDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateLogDescriptorRequest), source.(*CreateLogDescriptorRequest))
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) Project(source *CreateLogDescriptorRequest) *CreateLogDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateLogDescriptorRequest{}
	logDescriptorMask := &log_descriptor.LogDescriptor_FieldMask{}
	wholeLogDescriptorAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateLogDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateLogDescriptorRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor:
				result.LogDescriptor = source.LogDescriptor
				wholeLogDescriptorAccepted = true
			}
		case *CreateLogDescriptorRequest_FieldSubPath:
			switch tp.selector {
			case CreateLogDescriptorRequest_FieldPathSelectorLogDescriptor:
				logDescriptorMask.AppendPath(tp.subPath.(log_descriptor.LogDescriptor_FieldPath))
			}
		}
	}
	if wholeLogDescriptorAccepted == false && len(logDescriptorMask.Paths) > 0 {
		result.LogDescriptor = logDescriptorMask.Project(source.GetLogDescriptor())
	}
	return result
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateLogDescriptorRequest))
}

func (fieldMask *CreateLogDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateLogDescriptorRequest_FieldMask struct {
	Paths []UpdateLogDescriptorRequest_FieldPath
}

func FullUpdateLogDescriptorRequest_FieldMask() *UpdateLogDescriptorRequest_FieldMask {
	res := &UpdateLogDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateLogDescriptorRequest_FieldTerminalPath{selector: UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor})
	res.Paths = append(res.Paths, &UpdateLogDescriptorRequest_FieldTerminalPath{selector: UpdateLogDescriptorRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateLogDescriptorRequest_FieldTerminalPath{selector: UpdateLogDescriptorRequest_FieldPathSelectorCas})
	res.Paths = append(res.Paths, &UpdateLogDescriptorRequest_FieldTerminalPath{selector: UpdateLogDescriptorRequest_FieldPathSelectorAllowMissing})
	return res
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateLogDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateLogDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateLogDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateLogDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) Subtract(other *UpdateLogDescriptorRequest_FieldMask) *UpdateLogDescriptorRequest_FieldMask {
	result := &UpdateLogDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[UpdateLogDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor: &log_descriptor.LogDescriptor_FieldMask{},
		UpdateLogDescriptorRequest_FieldPathSelectorCas:           &UpdateLogDescriptorRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateLogDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor: &log_descriptor.LogDescriptor_FieldMask{},
		UpdateLogDescriptorRequest_FieldPathSelectorCas:           &UpdateLogDescriptorRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateLogDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateLogDescriptorRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateLogDescriptorRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor:
						mySubMasks[UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor] = log_descriptor.FullLogDescriptor_FieldMask()
					case UpdateLogDescriptorRequest_FieldPathSelectorCas:
						mySubMasks[UpdateLogDescriptorRequest_FieldPathSelectorCas] = FullUpdateLogDescriptorRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateLogDescriptorRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateLogDescriptorRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateLogDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateLogDescriptorRequest_FieldMask) FilterInputFields() *UpdateLogDescriptorRequest_FieldMask {
	result := &UpdateLogDescriptorRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor:
			if _, ok := path.(*UpdateLogDescriptorRequest_FieldTerminalPath); ok {
				for _, subpath := range log_descriptor.FullLogDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLogDescriptorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateLogDescriptorRequest_FieldSubPath); ok {
				selectedMask := &log_descriptor.LogDescriptor_FieldMask{
					Paths: []log_descriptor.LogDescriptor_FieldPath{sub.subPath.(log_descriptor.LogDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLogDescriptorRequest_FieldSubPath{selector: UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor, subPath: allowedPath})
				}
			}
		case UpdateLogDescriptorRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateLogDescriptorRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateLogDescriptorRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLogDescriptorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateLogDescriptorRequest_FieldSubPath); ok {
				selectedMask := &UpdateLogDescriptorRequest_CAS_FieldMask{
					Paths: []UpdateLogDescriptorRequestCAS_FieldPath{sub.subPath.(UpdateLogDescriptorRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLogDescriptorRequest_FieldSubPath{selector: UpdateLogDescriptorRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateLogDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateLogDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateLogDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateLogDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateLogDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) AppendPath(path UpdateLogDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateLogDescriptorRequest_FieldPath))
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) GetPaths() []UpdateLogDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateLogDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) Set(target, source *UpdateLogDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateLogDescriptorRequest), source.(*UpdateLogDescriptorRequest))
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) Project(source *UpdateLogDescriptorRequest) *UpdateLogDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateLogDescriptorRequest{}
	logDescriptorMask := &log_descriptor.LogDescriptor_FieldMask{}
	wholeLogDescriptorAccepted := false
	casMask := &UpdateLogDescriptorRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateLogDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor:
				result.LogDescriptor = source.LogDescriptor
				wholeLogDescriptorAccepted = true
			case UpdateLogDescriptorRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateLogDescriptorRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			case UpdateLogDescriptorRequest_FieldPathSelectorAllowMissing:
				result.AllowMissing = source.AllowMissing
			}
		case *UpdateLogDescriptorRequest_FieldSubPath:
			switch tp.selector {
			case UpdateLogDescriptorRequest_FieldPathSelectorLogDescriptor:
				logDescriptorMask.AppendPath(tp.subPath.(log_descriptor.LogDescriptor_FieldPath))
			case UpdateLogDescriptorRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateLogDescriptorRequestCAS_FieldPath))
			}
		}
	}
	if wholeLogDescriptorAccepted == false && len(logDescriptorMask.Paths) > 0 {
		result.LogDescriptor = logDescriptorMask.Project(source.GetLogDescriptor())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateLogDescriptorRequest))
}

func (fieldMask *UpdateLogDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateLogDescriptorRequest_CAS_FieldMask struct {
	Paths []UpdateLogDescriptorRequestCAS_FieldPath
}

func FullUpdateLogDescriptorRequest_CAS_FieldMask() *UpdateLogDescriptorRequest_CAS_FieldMask {
	res := &UpdateLogDescriptorRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateLogDescriptorRequestCAS_FieldTerminalPath{selector: UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateLogDescriptorRequestCAS_FieldTerminalPath{selector: UpdateLogDescriptorRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateLogDescriptorRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateLogDescriptorRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateLogDescriptorRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) Subtract(other *UpdateLogDescriptorRequest_CAS_FieldMask) *UpdateLogDescriptorRequest_CAS_FieldMask {
	result := &UpdateLogDescriptorRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateLogDescriptorRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState: &log_descriptor.LogDescriptor_FieldMask{},
	}
	mySubMasks := map[UpdateLogDescriptorRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState: &log_descriptor.LogDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateLogDescriptorRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateLogDescriptorRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateLogDescriptorRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState] = log_descriptor.FullLogDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*UpdateLogDescriptorRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateLogDescriptorRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateLogDescriptorRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) FilterInputFields() *UpdateLogDescriptorRequest_CAS_FieldMask {
	result := &UpdateLogDescriptorRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateLogDescriptorRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range log_descriptor.FullLogDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLogDescriptorRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateLogDescriptorRequestCAS_FieldSubPath); ok {
				selectedMask := &log_descriptor.LogDescriptor_FieldMask{
					Paths: []log_descriptor.LogDescriptor_FieldPath{sub.subPath.(log_descriptor.LogDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLogDescriptorRequestCAS_FieldSubPath{selector: UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateLogDescriptorRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateLogDescriptorRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateLogDescriptorRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateLogDescriptorRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) AppendPath(path UpdateLogDescriptorRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateLogDescriptorRequestCAS_FieldPath))
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) GetPaths() []UpdateLogDescriptorRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateLogDescriptorRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) Set(target, source *UpdateLogDescriptorRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateLogDescriptorRequest_CAS), source.(*UpdateLogDescriptorRequest_CAS))
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) Project(source *UpdateLogDescriptorRequest_CAS) *UpdateLogDescriptorRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateLogDescriptorRequest_CAS{}
	conditionalStateMask := &log_descriptor.LogDescriptor_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateLogDescriptorRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateLogDescriptorRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateLogDescriptorRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateLogDescriptorRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(log_descriptor.LogDescriptor_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateLogDescriptorRequest_CAS))
}

func (fieldMask *UpdateLogDescriptorRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteLogDescriptorRequest_FieldMask struct {
	Paths []DeleteLogDescriptorRequest_FieldPath
}

func FullDeleteLogDescriptorRequest_FieldMask() *DeleteLogDescriptorRequest_FieldMask {
	res := &DeleteLogDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteLogDescriptorRequest_FieldTerminalPath{selector: DeleteLogDescriptorRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteLogDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteLogDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteLogDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteLogDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) Subtract(other *DeleteLogDescriptorRequest_FieldMask) *DeleteLogDescriptorRequest_FieldMask {
	result := &DeleteLogDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteLogDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteLogDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteLogDescriptorRequest_FieldMask) FilterInputFields() *DeleteLogDescriptorRequest_FieldMask {
	result := &DeleteLogDescriptorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteLogDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteLogDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteLogDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteLogDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteLogDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) AppendPath(path DeleteLogDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteLogDescriptorRequest_FieldPath))
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) GetPaths() []DeleteLogDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteLogDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) Set(target, source *DeleteLogDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteLogDescriptorRequest), source.(*DeleteLogDescriptorRequest))
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) Project(source *DeleteLogDescriptorRequest) *DeleteLogDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteLogDescriptorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteLogDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteLogDescriptorRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteLogDescriptorRequest))
}

func (fieldMask *DeleteLogDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
