// Code generated by protoc-gen-goten-object
// File: edgelq/audit/proto/v1alpha2/method_descriptor_service.proto
// DO NOT EDIT!!!

package method_descriptor_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	method_descriptor "github.com/cloudwan/edgelq-sdk/audit/resources/v1alpha2/method_descriptor"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &method_descriptor.MethodDescriptor{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetMethodDescriptorRequest_FieldMask struct {
	Paths []GetMethodDescriptorRequest_FieldPath
}

func FullGetMethodDescriptorRequest_FieldMask() *GetMethodDescriptorRequest_FieldMask {
	res := &GetMethodDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetMethodDescriptorRequest_FieldTerminalPath{selector: GetMethodDescriptorRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetMethodDescriptorRequest_FieldTerminalPath{selector: GetMethodDescriptorRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetMethodDescriptorRequest_FieldTerminalPath{selector: GetMethodDescriptorRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetMethodDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetMethodDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetMethodDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetMethodDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) Subtract(other *GetMethodDescriptorRequest_FieldMask) *GetMethodDescriptorRequest_FieldMask {
	result := &GetMethodDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetMethodDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetMethodDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetMethodDescriptorRequest_FieldMask) FilterInputFields() *GetMethodDescriptorRequest_FieldMask {
	result := &GetMethodDescriptorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetMethodDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetMethodDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetMethodDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetMethodDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetMethodDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) AppendPath(path GetMethodDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetMethodDescriptorRequest_FieldPath))
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) GetPaths() []GetMethodDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetMethodDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) Set(target, source *GetMethodDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetMethodDescriptorRequest), source.(*GetMethodDescriptorRequest))
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) Project(source *GetMethodDescriptorRequest) *GetMethodDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetMethodDescriptorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetMethodDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case GetMethodDescriptorRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetMethodDescriptorRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetMethodDescriptorRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetMethodDescriptorRequest))
}

func (fieldMask *GetMethodDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetMethodDescriptorsRequest_FieldMask struct {
	Paths []BatchGetMethodDescriptorsRequest_FieldPath
}

func FullBatchGetMethodDescriptorsRequest_FieldMask() *BatchGetMethodDescriptorsRequest_FieldMask {
	res := &BatchGetMethodDescriptorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetMethodDescriptorsRequest_FieldTerminalPath{selector: BatchGetMethodDescriptorsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetMethodDescriptorsRequest_FieldTerminalPath{selector: BatchGetMethodDescriptorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetMethodDescriptorsRequest_FieldTerminalPath{selector: BatchGetMethodDescriptorsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetMethodDescriptorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetMethodDescriptorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetMethodDescriptorsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) Subtract(other *BatchGetMethodDescriptorsRequest_FieldMask) *BatchGetMethodDescriptorsRequest_FieldMask {
	result := &BatchGetMethodDescriptorsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetMethodDescriptorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetMethodDescriptorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) FilterInputFields() *BatchGetMethodDescriptorsRequest_FieldMask {
	result := &BatchGetMethodDescriptorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetMethodDescriptorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetMethodDescriptorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetMethodDescriptorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetMethodDescriptorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) AppendPath(path BatchGetMethodDescriptorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetMethodDescriptorsRequest_FieldPath))
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) GetPaths() []BatchGetMethodDescriptorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetMethodDescriptorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) Set(target, source *BatchGetMethodDescriptorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetMethodDescriptorsRequest), source.(*BatchGetMethodDescriptorsRequest))
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) Project(source *BatchGetMethodDescriptorsRequest) *BatchGetMethodDescriptorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetMethodDescriptorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetMethodDescriptorsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetMethodDescriptorsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetMethodDescriptorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetMethodDescriptorsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetMethodDescriptorsRequest))
}

func (fieldMask *BatchGetMethodDescriptorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetMethodDescriptorsResponse_FieldMask struct {
	Paths []BatchGetMethodDescriptorsResponse_FieldPath
}

func FullBatchGetMethodDescriptorsResponse_FieldMask() *BatchGetMethodDescriptorsResponse_FieldMask {
	res := &BatchGetMethodDescriptorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetMethodDescriptorsResponse_FieldTerminalPath{selector: BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors})
	res.Paths = append(res.Paths, &BatchGetMethodDescriptorsResponse_FieldTerminalPath{selector: BatchGetMethodDescriptorsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetMethodDescriptorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetMethodDescriptorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetMethodDescriptorsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) Subtract(other *BatchGetMethodDescriptorsResponse_FieldMask) *BatchGetMethodDescriptorsResponse_FieldMask {
	result := &BatchGetMethodDescriptorsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetMethodDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors: &method_descriptor.MethodDescriptor_FieldMask{},
	}
	mySubMasks := map[BatchGetMethodDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors: &method_descriptor.MethodDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetMethodDescriptorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetMethodDescriptorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetMethodDescriptorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors:
						mySubMasks[BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors] = method_descriptor.FullMethodDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetMethodDescriptorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetMethodDescriptorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetMethodDescriptorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) FilterInputFields() *BatchGetMethodDescriptorsResponse_FieldMask {
	result := &BatchGetMethodDescriptorsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors:
			if _, ok := path.(*BatchGetMethodDescriptorsResponse_FieldTerminalPath); ok {
				for _, subpath := range method_descriptor.FullMethodDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetMethodDescriptorsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetMethodDescriptorsResponse_FieldSubPath); ok {
				selectedMask := &method_descriptor.MethodDescriptor_FieldMask{
					Paths: []method_descriptor.MethodDescriptor_FieldPath{sub.subPath.(method_descriptor.MethodDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetMethodDescriptorsResponse_FieldSubPath{selector: BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetMethodDescriptorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetMethodDescriptorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetMethodDescriptorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetMethodDescriptorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) AppendPath(path BatchGetMethodDescriptorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetMethodDescriptorsResponse_FieldPath))
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) GetPaths() []BatchGetMethodDescriptorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetMethodDescriptorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) Set(target, source *BatchGetMethodDescriptorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetMethodDescriptorsResponse), source.(*BatchGetMethodDescriptorsResponse))
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) Project(source *BatchGetMethodDescriptorsResponse) *BatchGetMethodDescriptorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetMethodDescriptorsResponse{}
	methodDescriptorsMask := &method_descriptor.MethodDescriptor_FieldMask{}
	wholeMethodDescriptorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetMethodDescriptorsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors:
				result.MethodDescriptors = source.MethodDescriptors
				wholeMethodDescriptorsAccepted = true
			case BatchGetMethodDescriptorsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetMethodDescriptorsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors:
				methodDescriptorsMask.AppendPath(tp.subPath.(method_descriptor.MethodDescriptor_FieldPath))
			}
		}
	}
	if wholeMethodDescriptorsAccepted == false && len(methodDescriptorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetMethodDescriptors() {
			result.MethodDescriptors = append(result.MethodDescriptors, methodDescriptorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetMethodDescriptorsResponse))
}

func (fieldMask *BatchGetMethodDescriptorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListMethodDescriptorsRequest_FieldMask struct {
	Paths []ListMethodDescriptorsRequest_FieldPath
}

func FullListMethodDescriptorsRequest_FieldMask() *ListMethodDescriptorsRequest_FieldMask {
	res := &ListMethodDescriptorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListMethodDescriptorsRequest_FieldTerminalPath{selector: ListMethodDescriptorsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListMethodDescriptorsRequest_FieldTerminalPath{selector: ListMethodDescriptorsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListMethodDescriptorsRequest_FieldTerminalPath{selector: ListMethodDescriptorsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListMethodDescriptorsRequest_FieldTerminalPath{selector: ListMethodDescriptorsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListMethodDescriptorsRequest_FieldTerminalPath{selector: ListMethodDescriptorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListMethodDescriptorsRequest_FieldTerminalPath{selector: ListMethodDescriptorsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListMethodDescriptorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListMethodDescriptorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListMethodDescriptorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListMethodDescriptorsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) Subtract(other *ListMethodDescriptorsRequest_FieldMask) *ListMethodDescriptorsRequest_FieldMask {
	result := &ListMethodDescriptorsRequest_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListMethodDescriptorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListMethodDescriptorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListMethodDescriptorsRequest_FieldMask) FilterInputFields() *ListMethodDescriptorsRequest_FieldMask {
	result := &ListMethodDescriptorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListMethodDescriptorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListMethodDescriptorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListMethodDescriptorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListMethodDescriptorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListMethodDescriptorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) AppendPath(path ListMethodDescriptorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListMethodDescriptorsRequest_FieldPath))
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) GetPaths() []ListMethodDescriptorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListMethodDescriptorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) Set(target, source *ListMethodDescriptorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListMethodDescriptorsRequest), source.(*ListMethodDescriptorsRequest))
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) Project(source *ListMethodDescriptorsRequest) *ListMethodDescriptorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListMethodDescriptorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListMethodDescriptorsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListMethodDescriptorsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListMethodDescriptorsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListMethodDescriptorsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListMethodDescriptorsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListMethodDescriptorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListMethodDescriptorsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListMethodDescriptorsRequest))
}

func (fieldMask *ListMethodDescriptorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListMethodDescriptorsResponse_FieldMask struct {
	Paths []ListMethodDescriptorsResponse_FieldPath
}

func FullListMethodDescriptorsResponse_FieldMask() *ListMethodDescriptorsResponse_FieldMask {
	res := &ListMethodDescriptorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListMethodDescriptorsResponse_FieldTerminalPath{selector: ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors})
	res.Paths = append(res.Paths, &ListMethodDescriptorsResponse_FieldTerminalPath{selector: ListMethodDescriptorsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListMethodDescriptorsResponse_FieldTerminalPath{selector: ListMethodDescriptorsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListMethodDescriptorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListMethodDescriptorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListMethodDescriptorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListMethodDescriptorsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) Subtract(other *ListMethodDescriptorsResponse_FieldMask) *ListMethodDescriptorsResponse_FieldMask {
	result := &ListMethodDescriptorsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListMethodDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors: &method_descriptor.MethodDescriptor_FieldMask{},
	}
	mySubMasks := map[ListMethodDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors: &method_descriptor.MethodDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListMethodDescriptorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListMethodDescriptorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListMethodDescriptorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors:
						mySubMasks[ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors] = method_descriptor.FullMethodDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*ListMethodDescriptorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListMethodDescriptorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListMethodDescriptorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListMethodDescriptorsResponse_FieldMask) FilterInputFields() *ListMethodDescriptorsResponse_FieldMask {
	result := &ListMethodDescriptorsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors:
			if _, ok := path.(*ListMethodDescriptorsResponse_FieldTerminalPath); ok {
				for _, subpath := range method_descriptor.FullMethodDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListMethodDescriptorsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListMethodDescriptorsResponse_FieldSubPath); ok {
				selectedMask := &method_descriptor.MethodDescriptor_FieldMask{
					Paths: []method_descriptor.MethodDescriptor_FieldPath{sub.subPath.(method_descriptor.MethodDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListMethodDescriptorsResponse_FieldSubPath{selector: ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListMethodDescriptorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListMethodDescriptorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListMethodDescriptorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListMethodDescriptorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListMethodDescriptorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) AppendPath(path ListMethodDescriptorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListMethodDescriptorsResponse_FieldPath))
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) GetPaths() []ListMethodDescriptorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListMethodDescriptorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) Set(target, source *ListMethodDescriptorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListMethodDescriptorsResponse), source.(*ListMethodDescriptorsResponse))
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) Project(source *ListMethodDescriptorsResponse) *ListMethodDescriptorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListMethodDescriptorsResponse{}
	methodDescriptorsMask := &method_descriptor.MethodDescriptor_FieldMask{}
	wholeMethodDescriptorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListMethodDescriptorsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors:
				result.MethodDescriptors = source.MethodDescriptors
				wholeMethodDescriptorsAccepted = true
			case ListMethodDescriptorsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListMethodDescriptorsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListMethodDescriptorsResponse_FieldSubPath:
			switch tp.selector {
			case ListMethodDescriptorsResponse_FieldPathSelectorMethodDescriptors:
				methodDescriptorsMask.AppendPath(tp.subPath.(method_descriptor.MethodDescriptor_FieldPath))
			}
		}
	}
	if wholeMethodDescriptorsAccepted == false && len(methodDescriptorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetMethodDescriptors() {
			result.MethodDescriptors = append(result.MethodDescriptors, methodDescriptorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListMethodDescriptorsResponse))
}

func (fieldMask *ListMethodDescriptorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMethodDescriptorRequest_FieldMask struct {
	Paths []WatchMethodDescriptorRequest_FieldPath
}

func FullWatchMethodDescriptorRequest_FieldMask() *WatchMethodDescriptorRequest_FieldMask {
	res := &WatchMethodDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchMethodDescriptorRequest_FieldTerminalPath{selector: WatchMethodDescriptorRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchMethodDescriptorRequest_FieldTerminalPath{selector: WatchMethodDescriptorRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchMethodDescriptorRequest_FieldTerminalPath{selector: WatchMethodDescriptorRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMethodDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMethodDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMethodDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMethodDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) Subtract(other *WatchMethodDescriptorRequest_FieldMask) *WatchMethodDescriptorRequest_FieldMask {
	result := &WatchMethodDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMethodDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMethodDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMethodDescriptorRequest_FieldMask) FilterInputFields() *WatchMethodDescriptorRequest_FieldMask {
	result := &WatchMethodDescriptorRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMethodDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMethodDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMethodDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMethodDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMethodDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) AppendPath(path WatchMethodDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMethodDescriptorRequest_FieldPath))
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) GetPaths() []WatchMethodDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMethodDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) Set(target, source *WatchMethodDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMethodDescriptorRequest), source.(*WatchMethodDescriptorRequest))
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) Project(source *WatchMethodDescriptorRequest) *WatchMethodDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMethodDescriptorRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMethodDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchMethodDescriptorRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchMethodDescriptorRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchMethodDescriptorRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMethodDescriptorRequest))
}

func (fieldMask *WatchMethodDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMethodDescriptorResponse_FieldMask struct {
	Paths []WatchMethodDescriptorResponse_FieldPath
}

func FullWatchMethodDescriptorResponse_FieldMask() *WatchMethodDescriptorResponse_FieldMask {
	res := &WatchMethodDescriptorResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchMethodDescriptorResponse_FieldTerminalPath{selector: WatchMethodDescriptorResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMethodDescriptorResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMethodDescriptorResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMethodDescriptorResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMethodDescriptorResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) Subtract(other *WatchMethodDescriptorResponse_FieldMask) *WatchMethodDescriptorResponse_FieldMask {
	result := &WatchMethodDescriptorResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMethodDescriptorResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMethodDescriptorResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMethodDescriptorResponse_FieldMask) FilterInputFields() *WatchMethodDescriptorResponse_FieldMask {
	result := &WatchMethodDescriptorResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMethodDescriptorResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMethodDescriptorResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMethodDescriptorResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMethodDescriptorResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMethodDescriptorResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) AppendPath(path WatchMethodDescriptorResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMethodDescriptorResponse_FieldPath))
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) GetPaths() []WatchMethodDescriptorResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMethodDescriptorResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) Set(target, source *WatchMethodDescriptorResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMethodDescriptorResponse), source.(*WatchMethodDescriptorResponse))
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) Project(source *WatchMethodDescriptorResponse) *WatchMethodDescriptorResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMethodDescriptorResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMethodDescriptorResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchMethodDescriptorResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMethodDescriptorResponse))
}

func (fieldMask *WatchMethodDescriptorResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMethodDescriptorsRequest_FieldMask struct {
	Paths []WatchMethodDescriptorsRequest_FieldPath
}

func FullWatchMethodDescriptorsRequest_FieldMask() *WatchMethodDescriptorsRequest_FieldMask {
	res := &WatchMethodDescriptorsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsRequest_FieldTerminalPath{selector: WatchMethodDescriptorsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMethodDescriptorsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMethodDescriptorsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMethodDescriptorsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) Subtract(other *WatchMethodDescriptorsRequest_FieldMask) *WatchMethodDescriptorsRequest_FieldMask {
	result := &WatchMethodDescriptorsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMethodDescriptorsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMethodDescriptorsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) FilterInputFields() *WatchMethodDescriptorsRequest_FieldMask {
	result := &WatchMethodDescriptorsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMethodDescriptorsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMethodDescriptorsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMethodDescriptorsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMethodDescriptorsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) AppendPath(path WatchMethodDescriptorsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMethodDescriptorsRequest_FieldPath))
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) GetPaths() []WatchMethodDescriptorsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMethodDescriptorsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) Set(target, source *WatchMethodDescriptorsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMethodDescriptorsRequest), source.(*WatchMethodDescriptorsRequest))
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) Project(source *WatchMethodDescriptorsRequest) *WatchMethodDescriptorsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMethodDescriptorsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMethodDescriptorsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchMethodDescriptorsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchMethodDescriptorsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchMethodDescriptorsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchMethodDescriptorsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchMethodDescriptorsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchMethodDescriptorsRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchMethodDescriptorsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchMethodDescriptorsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchMethodDescriptorsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchMethodDescriptorsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMethodDescriptorsRequest))
}

func (fieldMask *WatchMethodDescriptorsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMethodDescriptorsResponse_FieldMask struct {
	Paths []WatchMethodDescriptorsResponse_FieldPath
}

func FullWatchMethodDescriptorsResponse_FieldMask() *WatchMethodDescriptorsResponse_FieldMask {
	res := &WatchMethodDescriptorsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponse_FieldTerminalPath{selector: WatchMethodDescriptorsResponse_FieldPathSelectorMethodDescriptorChanges})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponse_FieldTerminalPath{selector: WatchMethodDescriptorsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponse_FieldTerminalPath{selector: WatchMethodDescriptorsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponse_FieldTerminalPath{selector: WatchMethodDescriptorsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponse_FieldTerminalPath{selector: WatchMethodDescriptorsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponse_FieldTerminalPath{selector: WatchMethodDescriptorsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponse_FieldTerminalPath{selector: WatchMethodDescriptorsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMethodDescriptorsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMethodDescriptorsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMethodDescriptorsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) Subtract(other *WatchMethodDescriptorsResponse_FieldMask) *WatchMethodDescriptorsResponse_FieldMask {
	result := &WatchMethodDescriptorsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchMethodDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchMethodDescriptorsResponse_FieldPathSelectorPageTokenChange: &WatchMethodDescriptorsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchMethodDescriptorsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchMethodDescriptorsResponse_FieldPathSelectorPageTokenChange: &WatchMethodDescriptorsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMethodDescriptorsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchMethodDescriptorsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchMethodDescriptorsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchMethodDescriptorsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchMethodDescriptorsResponse_FieldPathSelectorPageTokenChange] = FullWatchMethodDescriptorsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchMethodDescriptorsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchMethodDescriptorsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMethodDescriptorsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) FilterInputFields() *WatchMethodDescriptorsResponse_FieldMask {
	result := &WatchMethodDescriptorsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMethodDescriptorsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMethodDescriptorsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMethodDescriptorsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMethodDescriptorsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) AppendPath(path WatchMethodDescriptorsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMethodDescriptorsResponse_FieldPath))
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) GetPaths() []WatchMethodDescriptorsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMethodDescriptorsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) Set(target, source *WatchMethodDescriptorsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMethodDescriptorsResponse), source.(*WatchMethodDescriptorsResponse))
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) Project(source *WatchMethodDescriptorsResponse) *WatchMethodDescriptorsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMethodDescriptorsResponse{}
	pageTokenChangeMask := &WatchMethodDescriptorsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMethodDescriptorsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchMethodDescriptorsResponse_FieldPathSelectorMethodDescriptorChanges:
				result.MethodDescriptorChanges = source.MethodDescriptorChanges
			case WatchMethodDescriptorsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchMethodDescriptorsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchMethodDescriptorsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchMethodDescriptorsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchMethodDescriptorsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchMethodDescriptorsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchMethodDescriptorsResponse_FieldSubPath:
			switch tp.selector {
			case WatchMethodDescriptorsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchMethodDescriptorsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMethodDescriptorsResponse))
}

func (fieldMask *WatchMethodDescriptorsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchMethodDescriptorsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchMethodDescriptorsResponsePageTokenChange_FieldPath
}

func FullWatchMethodDescriptorsResponse_PageTokenChange_FieldMask() *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask {
	res := &WatchMethodDescriptorsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponsePageTokenChange_FieldTerminalPath{selector: WatchMethodDescriptorsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchMethodDescriptorsResponsePageTokenChange_FieldTerminalPath{selector: WatchMethodDescriptorsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchMethodDescriptorsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchMethodDescriptorsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchMethodDescriptorsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) Subtract(other *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask {
	result := &WatchMethodDescriptorsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchMethodDescriptorsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchMethodDescriptorsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask {
	result := &WatchMethodDescriptorsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchMethodDescriptorsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchMethodDescriptorsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) AppendPath(path WatchMethodDescriptorsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchMethodDescriptorsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) GetPaths() []WatchMethodDescriptorsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchMethodDescriptorsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) Set(target, source *WatchMethodDescriptorsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchMethodDescriptorsResponse_PageTokenChange), source.(*WatchMethodDescriptorsResponse_PageTokenChange))
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) Project(source *WatchMethodDescriptorsResponse_PageTokenChange) *WatchMethodDescriptorsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchMethodDescriptorsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchMethodDescriptorsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchMethodDescriptorsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchMethodDescriptorsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchMethodDescriptorsResponse_PageTokenChange))
}

func (fieldMask *WatchMethodDescriptorsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateMethodDescriptorRequest_FieldMask struct {
	Paths []CreateMethodDescriptorRequest_FieldPath
}

func FullCreateMethodDescriptorRequest_FieldMask() *CreateMethodDescriptorRequest_FieldMask {
	res := &CreateMethodDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateMethodDescriptorRequest_FieldTerminalPath{selector: CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor})
	return res
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateMethodDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateMethodDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateMethodDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateMethodDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) Subtract(other *CreateMethodDescriptorRequest_FieldMask) *CreateMethodDescriptorRequest_FieldMask {
	result := &CreateMethodDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[CreateMethodDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor: &method_descriptor.MethodDescriptor_FieldMask{},
	}
	mySubMasks := map[CreateMethodDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor: &method_descriptor.MethodDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateMethodDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateMethodDescriptorRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateMethodDescriptorRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor:
						mySubMasks[CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor] = method_descriptor.FullMethodDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*CreateMethodDescriptorRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateMethodDescriptorRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateMethodDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateMethodDescriptorRequest_FieldMask) FilterInputFields() *CreateMethodDescriptorRequest_FieldMask {
	result := &CreateMethodDescriptorRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor:
			if _, ok := path.(*CreateMethodDescriptorRequest_FieldTerminalPath); ok {
				for _, subpath := range method_descriptor.FullMethodDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateMethodDescriptorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateMethodDescriptorRequest_FieldSubPath); ok {
				selectedMask := &method_descriptor.MethodDescriptor_FieldMask{
					Paths: []method_descriptor.MethodDescriptor_FieldPath{sub.subPath.(method_descriptor.MethodDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateMethodDescriptorRequest_FieldSubPath{selector: CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateMethodDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateMethodDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateMethodDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateMethodDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateMethodDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) AppendPath(path CreateMethodDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateMethodDescriptorRequest_FieldPath))
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) GetPaths() []CreateMethodDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateMethodDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) Set(target, source *CreateMethodDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateMethodDescriptorRequest), source.(*CreateMethodDescriptorRequest))
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) Project(source *CreateMethodDescriptorRequest) *CreateMethodDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateMethodDescriptorRequest{}
	methodDescriptorMask := &method_descriptor.MethodDescriptor_FieldMask{}
	wholeMethodDescriptorAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateMethodDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor:
				result.MethodDescriptor = source.MethodDescriptor
				wholeMethodDescriptorAccepted = true
			}
		case *CreateMethodDescriptorRequest_FieldSubPath:
			switch tp.selector {
			case CreateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor:
				methodDescriptorMask.AppendPath(tp.subPath.(method_descriptor.MethodDescriptor_FieldPath))
			}
		}
	}
	if wholeMethodDescriptorAccepted == false && len(methodDescriptorMask.Paths) > 0 {
		result.MethodDescriptor = methodDescriptorMask.Project(source.GetMethodDescriptor())
	}
	return result
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateMethodDescriptorRequest))
}

func (fieldMask *CreateMethodDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateMethodDescriptorRequest_FieldMask struct {
	Paths []UpdateMethodDescriptorRequest_FieldPath
}

func FullUpdateMethodDescriptorRequest_FieldMask() *UpdateMethodDescriptorRequest_FieldMask {
	res := &UpdateMethodDescriptorRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateMethodDescriptorRequest_FieldTerminalPath{selector: UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor})
	res.Paths = append(res.Paths, &UpdateMethodDescriptorRequest_FieldTerminalPath{selector: UpdateMethodDescriptorRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateMethodDescriptorRequest_FieldTerminalPath{selector: UpdateMethodDescriptorRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateMethodDescriptorRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateMethodDescriptorRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateMethodDescriptorRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) Subtract(other *UpdateMethodDescriptorRequest_FieldMask) *UpdateMethodDescriptorRequest_FieldMask {
	result := &UpdateMethodDescriptorRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateMethodDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor: &method_descriptor.MethodDescriptor_FieldMask{},
		UpdateMethodDescriptorRequest_FieldPathSelectorCas:              &UpdateMethodDescriptorRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateMethodDescriptorRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor: &method_descriptor.MethodDescriptor_FieldMask{},
		UpdateMethodDescriptorRequest_FieldPathSelectorCas:              &UpdateMethodDescriptorRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateMethodDescriptorRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateMethodDescriptorRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateMethodDescriptorRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor:
						mySubMasks[UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor] = method_descriptor.FullMethodDescriptor_FieldMask()
					case UpdateMethodDescriptorRequest_FieldPathSelectorCas:
						mySubMasks[UpdateMethodDescriptorRequest_FieldPathSelectorCas] = FullUpdateMethodDescriptorRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateMethodDescriptorRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateMethodDescriptorRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateMethodDescriptorRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) FilterInputFields() *UpdateMethodDescriptorRequest_FieldMask {
	result := &UpdateMethodDescriptorRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor:
			if _, ok := path.(*UpdateMethodDescriptorRequest_FieldTerminalPath); ok {
				for _, subpath := range method_descriptor.FullMethodDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMethodDescriptorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateMethodDescriptorRequest_FieldSubPath); ok {
				selectedMask := &method_descriptor.MethodDescriptor_FieldMask{
					Paths: []method_descriptor.MethodDescriptor_FieldPath{sub.subPath.(method_descriptor.MethodDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMethodDescriptorRequest_FieldSubPath{selector: UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor, subPath: allowedPath})
				}
			}
		case UpdateMethodDescriptorRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateMethodDescriptorRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateMethodDescriptorRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMethodDescriptorRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateMethodDescriptorRequest_FieldSubPath); ok {
				selectedMask := &UpdateMethodDescriptorRequest_CAS_FieldMask{
					Paths: []UpdateMethodDescriptorRequestCAS_FieldPath{sub.subPath.(UpdateMethodDescriptorRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMethodDescriptorRequest_FieldSubPath{selector: UpdateMethodDescriptorRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateMethodDescriptorRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateMethodDescriptorRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateMethodDescriptorRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateMethodDescriptorRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) AppendPath(path UpdateMethodDescriptorRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateMethodDescriptorRequest_FieldPath))
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) GetPaths() []UpdateMethodDescriptorRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateMethodDescriptorRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) Set(target, source *UpdateMethodDescriptorRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateMethodDescriptorRequest), source.(*UpdateMethodDescriptorRequest))
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) Project(source *UpdateMethodDescriptorRequest) *UpdateMethodDescriptorRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateMethodDescriptorRequest{}
	methodDescriptorMask := &method_descriptor.MethodDescriptor_FieldMask{}
	wholeMethodDescriptorAccepted := false
	casMask := &UpdateMethodDescriptorRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateMethodDescriptorRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor:
				result.MethodDescriptor = source.MethodDescriptor
				wholeMethodDescriptorAccepted = true
			case UpdateMethodDescriptorRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateMethodDescriptorRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateMethodDescriptorRequest_FieldSubPath:
			switch tp.selector {
			case UpdateMethodDescriptorRequest_FieldPathSelectorMethodDescriptor:
				methodDescriptorMask.AppendPath(tp.subPath.(method_descriptor.MethodDescriptor_FieldPath))
			case UpdateMethodDescriptorRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateMethodDescriptorRequestCAS_FieldPath))
			}
		}
	}
	if wholeMethodDescriptorAccepted == false && len(methodDescriptorMask.Paths) > 0 {
		result.MethodDescriptor = methodDescriptorMask.Project(source.GetMethodDescriptor())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateMethodDescriptorRequest))
}

func (fieldMask *UpdateMethodDescriptorRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateMethodDescriptorRequest_CAS_FieldMask struct {
	Paths []UpdateMethodDescriptorRequestCAS_FieldPath
}

func FullUpdateMethodDescriptorRequest_CAS_FieldMask() *UpdateMethodDescriptorRequest_CAS_FieldMask {
	res := &UpdateMethodDescriptorRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateMethodDescriptorRequestCAS_FieldTerminalPath{selector: UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateMethodDescriptorRequestCAS_FieldTerminalPath{selector: UpdateMethodDescriptorRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateMethodDescriptorRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateMethodDescriptorRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateMethodDescriptorRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) Subtract(other *UpdateMethodDescriptorRequest_CAS_FieldMask) *UpdateMethodDescriptorRequest_CAS_FieldMask {
	result := &UpdateMethodDescriptorRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateMethodDescriptorRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState: &method_descriptor.MethodDescriptor_FieldMask{},
	}
	mySubMasks := map[UpdateMethodDescriptorRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState: &method_descriptor.MethodDescriptor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateMethodDescriptorRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateMethodDescriptorRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateMethodDescriptorRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState] = method_descriptor.FullMethodDescriptor_FieldMask()
					}
				} else if tp, ok := path.(*UpdateMethodDescriptorRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateMethodDescriptorRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateMethodDescriptorRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) FilterInputFields() *UpdateMethodDescriptorRequest_CAS_FieldMask {
	result := &UpdateMethodDescriptorRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateMethodDescriptorRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range method_descriptor.FullMethodDescriptor_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMethodDescriptorRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateMethodDescriptorRequestCAS_FieldSubPath); ok {
				selectedMask := &method_descriptor.MethodDescriptor_FieldMask{
					Paths: []method_descriptor.MethodDescriptor_FieldPath{sub.subPath.(method_descriptor.MethodDescriptor_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateMethodDescriptorRequestCAS_FieldSubPath{selector: UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateMethodDescriptorRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateMethodDescriptorRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateMethodDescriptorRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateMethodDescriptorRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) AppendPath(path UpdateMethodDescriptorRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateMethodDescriptorRequestCAS_FieldPath))
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) GetPaths() []UpdateMethodDescriptorRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateMethodDescriptorRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) Set(target, source *UpdateMethodDescriptorRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateMethodDescriptorRequest_CAS), source.(*UpdateMethodDescriptorRequest_CAS))
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) Project(source *UpdateMethodDescriptorRequest_CAS) *UpdateMethodDescriptorRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateMethodDescriptorRequest_CAS{}
	conditionalStateMask := &method_descriptor.MethodDescriptor_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateMethodDescriptorRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateMethodDescriptorRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateMethodDescriptorRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateMethodDescriptorRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(method_descriptor.MethodDescriptor_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateMethodDescriptorRequest_CAS))
}

func (fieldMask *UpdateMethodDescriptorRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
