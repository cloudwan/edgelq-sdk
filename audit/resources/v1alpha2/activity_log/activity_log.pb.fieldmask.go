// Code generated by protoc-gen-goten-object
// File: edgelq/audit/proto/v1alpha2/activity_log.proto
// DO NOT EDIT!!!

package activity_log

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	common "github.com/cloudwan/edgelq-sdk/audit/resources/v1alpha2/common"
	rpc "github.com/cloudwan/edgelq-sdk/common/rpc"
	iam_organization "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/organization"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/project"
	anypb "google.golang.org/protobuf/types/known/anypb"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &common.Authentication{}
	_ = &rpc.Status{}
	_ = &iam_organization.Organization{}
	_ = &iam_project.Project{}
	_ = &anypb.Any{}
	_ = &fieldmaskpb.FieldMask{}
	_ = &timestamppb.Timestamp{}
)

type ActivityLog_FieldMask struct {
	Paths []ActivityLog_FieldPath
}

func FullActivityLog_FieldMask() *ActivityLog_FieldMask {
	res := &ActivityLog_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorScope})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorRequestId})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorAuthentication})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorAuthorization})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorService})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorMethod})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorRequestMetadata})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorRequestRouting})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorResource})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorCategory})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorLabels})
	res.Paths = append(res.Paths, &ActivityLog_FieldTerminalPath{selector: ActivityLog_FieldPathSelectorEvents})
	return res
}

func (fieldMask *ActivityLog_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLog_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 13)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLog_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLog_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_FieldMask) Subtract(other *ActivityLog_FieldMask) *ActivityLog_FieldMask {
	result := &ActivityLog_FieldMask{}
	removedSelectors := make([]bool, 13)
	otherSubMasks := map[ActivityLog_FieldPathSelector]gotenobject.FieldMask{
		ActivityLog_FieldPathSelectorAuthentication:  &common.Authentication_FieldMask{},
		ActivityLog_FieldPathSelectorAuthorization:   &common.Authorization_FieldMask{},
		ActivityLog_FieldPathSelectorService:         &common.ServiceData_FieldMask{},
		ActivityLog_FieldPathSelectorMethod:          &ActivityLog_Method_FieldMask{},
		ActivityLog_FieldPathSelectorRequestMetadata: &ActivityLog_RequestMetadata_FieldMask{},
		ActivityLog_FieldPathSelectorRequestRouting:  &ActivityLog_RequestRouting_FieldMask{},
		ActivityLog_FieldPathSelectorResource:        &ActivityLog_Resource_FieldMask{},
		ActivityLog_FieldPathSelectorEvents:          &ActivityLog_Event_FieldMask{},
	}
	mySubMasks := map[ActivityLog_FieldPathSelector]gotenobject.FieldMask{
		ActivityLog_FieldPathSelectorAuthentication:  &common.Authentication_FieldMask{},
		ActivityLog_FieldPathSelectorAuthorization:   &common.Authorization_FieldMask{},
		ActivityLog_FieldPathSelectorService:         &common.ServiceData_FieldMask{},
		ActivityLog_FieldPathSelectorMethod:          &ActivityLog_Method_FieldMask{},
		ActivityLog_FieldPathSelectorRequestMetadata: &ActivityLog_RequestMetadata_FieldMask{},
		ActivityLog_FieldPathSelectorRequestRouting:  &ActivityLog_RequestRouting_FieldMask{},
		ActivityLog_FieldPathSelectorResource:        &ActivityLog_Resource_FieldMask{},
		ActivityLog_FieldPathSelectorEvents:          &ActivityLog_Event_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLog_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivityLog_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivityLog_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivityLog_FieldPathSelectorAuthentication:
						mySubMasks[ActivityLog_FieldPathSelectorAuthentication] = common.FullAuthentication_FieldMask()
					case ActivityLog_FieldPathSelectorAuthorization:
						mySubMasks[ActivityLog_FieldPathSelectorAuthorization] = common.FullAuthorization_FieldMask()
					case ActivityLog_FieldPathSelectorService:
						mySubMasks[ActivityLog_FieldPathSelectorService] = common.FullServiceData_FieldMask()
					case ActivityLog_FieldPathSelectorMethod:
						mySubMasks[ActivityLog_FieldPathSelectorMethod] = FullActivityLog_Method_FieldMask()
					case ActivityLog_FieldPathSelectorRequestMetadata:
						mySubMasks[ActivityLog_FieldPathSelectorRequestMetadata] = FullActivityLog_RequestMetadata_FieldMask()
					case ActivityLog_FieldPathSelectorRequestRouting:
						mySubMasks[ActivityLog_FieldPathSelectorRequestRouting] = FullActivityLog_RequestRouting_FieldMask()
					case ActivityLog_FieldPathSelectorResource:
						mySubMasks[ActivityLog_FieldPathSelectorResource] = FullActivityLog_Resource_FieldMask()
					case ActivityLog_FieldPathSelectorEvents:
						mySubMasks[ActivityLog_FieldPathSelectorEvents] = FullActivityLog_Event_FieldMask()
					}
				} else if tp, ok := path.(*ActivityLog_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivityLog_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_FieldMask) FilterInputFields() *ActivityLog_FieldMask {
	result := &ActivityLog_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLog_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLog_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_FieldMask) AppendPath(path ActivityLog_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLog_FieldPath))
}

func (fieldMask *ActivityLog_FieldMask) GetPaths() []ActivityLog_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLog_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_FieldMask) Set(target, source *ActivityLog) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog), source.(*ActivityLog))
}

func (fieldMask *ActivityLog_FieldMask) Project(source *ActivityLog) *ActivityLog {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog{}
	authenticationMask := &common.Authentication_FieldMask{}
	wholeAuthenticationAccepted := false
	authorizationMask := &common.Authorization_FieldMask{}
	wholeAuthorizationAccepted := false
	serviceMask := &common.ServiceData_FieldMask{}
	wholeServiceAccepted := false
	methodMask := &ActivityLog_Method_FieldMask{}
	wholeMethodAccepted := false
	requestMetadataMask := &ActivityLog_RequestMetadata_FieldMask{}
	wholeRequestMetadataAccepted := false
	requestRoutingMask := &ActivityLog_RequestRouting_FieldMask{}
	wholeRequestRoutingAccepted := false
	resourceMask := &ActivityLog_Resource_FieldMask{}
	wholeResourceAccepted := false
	eventsMask := &ActivityLog_Event_FieldMask{}
	wholeEventsAccepted := false
	var labelsMapKeys []string
	wholeLabelsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLog_FieldTerminalPath:
			switch tp.selector {
			case ActivityLog_FieldPathSelectorName:
				result.Name = source.Name
			case ActivityLog_FieldPathSelectorScope:
				result.Scope = source.Scope
			case ActivityLog_FieldPathSelectorRequestId:
				result.RequestId = source.RequestId
			case ActivityLog_FieldPathSelectorAuthentication:
				result.Authentication = source.Authentication
				wholeAuthenticationAccepted = true
			case ActivityLog_FieldPathSelectorAuthorization:
				result.Authorization = source.Authorization
				wholeAuthorizationAccepted = true
			case ActivityLog_FieldPathSelectorService:
				result.Service = source.Service
				wholeServiceAccepted = true
			case ActivityLog_FieldPathSelectorMethod:
				result.Method = source.Method
				wholeMethodAccepted = true
			case ActivityLog_FieldPathSelectorRequestMetadata:
				result.RequestMetadata = source.RequestMetadata
				wholeRequestMetadataAccepted = true
			case ActivityLog_FieldPathSelectorRequestRouting:
				result.RequestRouting = source.RequestRouting
				wholeRequestRoutingAccepted = true
			case ActivityLog_FieldPathSelectorResource:
				result.Resource = source.Resource
				wholeResourceAccepted = true
			case ActivityLog_FieldPathSelectorCategory:
				result.Category = source.Category
			case ActivityLog_FieldPathSelectorLabels:
				result.Labels = source.Labels
				wholeLabelsAccepted = true
			case ActivityLog_FieldPathSelectorEvents:
				result.Events = source.Events
				wholeEventsAccepted = true
			}
		case *ActivityLog_FieldSubPath:
			switch tp.selector {
			case ActivityLog_FieldPathSelectorAuthentication:
				authenticationMask.AppendPath(tp.subPath.(common.Authentication_FieldPath))
			case ActivityLog_FieldPathSelectorAuthorization:
				authorizationMask.AppendPath(tp.subPath.(common.Authorization_FieldPath))
			case ActivityLog_FieldPathSelectorService:
				serviceMask.AppendPath(tp.subPath.(common.ServiceData_FieldPath))
			case ActivityLog_FieldPathSelectorMethod:
				methodMask.AppendPath(tp.subPath.(ActivityLogMethod_FieldPath))
			case ActivityLog_FieldPathSelectorRequestMetadata:
				requestMetadataMask.AppendPath(tp.subPath.(ActivityLogRequestMetadata_FieldPath))
			case ActivityLog_FieldPathSelectorRequestRouting:
				requestRoutingMask.AppendPath(tp.subPath.(ActivityLogRequestRouting_FieldPath))
			case ActivityLog_FieldPathSelectorResource:
				resourceMask.AppendPath(tp.subPath.(ActivityLogResource_FieldPath))
			case ActivityLog_FieldPathSelectorEvents:
				eventsMask.AppendPath(tp.subPath.(ActivityLogEvent_FieldPath))
			}
		case *ActivityLog_FieldPathMap:
			switch tp.selector {
			case ActivityLog_FieldPathSelectorLabels:
				labelsMapKeys = append(labelsMapKeys, tp.key)
			}
		}
	}
	if wholeAuthenticationAccepted == false && len(authenticationMask.Paths) > 0 {
		result.Authentication = authenticationMask.Project(source.GetAuthentication())
	}
	if wholeAuthorizationAccepted == false && len(authorizationMask.Paths) > 0 {
		result.Authorization = authorizationMask.Project(source.GetAuthorization())
	}
	if wholeServiceAccepted == false && len(serviceMask.Paths) > 0 {
		result.Service = serviceMask.Project(source.GetService())
	}
	if wholeMethodAccepted == false && len(methodMask.Paths) > 0 {
		result.Method = methodMask.Project(source.GetMethod())
	}
	if wholeRequestMetadataAccepted == false && len(requestMetadataMask.Paths) > 0 {
		result.RequestMetadata = requestMetadataMask.Project(source.GetRequestMetadata())
	}
	if wholeRequestRoutingAccepted == false && len(requestRoutingMask.Paths) > 0 {
		result.RequestRouting = requestRoutingMask.Project(source.GetRequestRouting())
	}
	if wholeResourceAccepted == false && len(resourceMask.Paths) > 0 {
		result.Resource = resourceMask.Project(source.GetResource())
	}
	if wholeLabelsAccepted == false && len(labelsMapKeys) > 0 && source.GetLabels() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetLabels()
		for _, key := range labelsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Labels = copiedMap
	}
	if wholeEventsAccepted == false && len(eventsMask.Paths) > 0 {
		for _, sourceItem := range source.GetEvents() {
			result.Events = append(result.Events, eventsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ActivityLog_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog))
}

func (fieldMask *ActivityLog_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Event_FieldMask struct {
	Paths []ActivityLogEvent_FieldPath
}

func FullActivityLog_Event_FieldMask() *ActivityLog_Event_FieldMask {
	res := &ActivityLog_Event_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogEvent_FieldTerminalPath{selector: ActivityLogEvent_FieldPathSelectorClientMessage})
	res.Paths = append(res.Paths, &ActivityLogEvent_FieldTerminalPath{selector: ActivityLogEvent_FieldPathSelectorServerMessage})
	res.Paths = append(res.Paths, &ActivityLogEvent_FieldTerminalPath{selector: ActivityLogEvent_FieldPathSelectorExit})
	res.Paths = append(res.Paths, &ActivityLogEvent_FieldTerminalPath{selector: ActivityLogEvent_FieldPathSelectorRegionalServerMessage})
	res.Paths = append(res.Paths, &ActivityLogEvent_FieldTerminalPath{selector: ActivityLogEvent_FieldPathSelectorRegionalExit})
	return res
}

func (fieldMask *ActivityLog_Event_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Event_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Event_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogEvent_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Event_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogEvent_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Event_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogEvent_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Event_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Event_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Event_FieldMask) Subtract(other *ActivityLog_Event_FieldMask) *ActivityLog_Event_FieldMask {
	result := &ActivityLog_Event_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ActivityLogEvent_FieldPathSelector]gotenobject.FieldMask{
		ActivityLogEvent_FieldPathSelectorClientMessage:         &ActivityLog_Event_ClientMsgEvent_FieldMask{},
		ActivityLogEvent_FieldPathSelectorServerMessage:         &ActivityLog_Event_ServerMsgEvent_FieldMask{},
		ActivityLogEvent_FieldPathSelectorExit:                  &ActivityLog_Event_ExitEvent_FieldMask{},
		ActivityLogEvent_FieldPathSelectorRegionalServerMessage: &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{},
		ActivityLogEvent_FieldPathSelectorRegionalExit:          &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{},
	}
	mySubMasks := map[ActivityLogEvent_FieldPathSelector]gotenobject.FieldMask{
		ActivityLogEvent_FieldPathSelectorClientMessage:         &ActivityLog_Event_ClientMsgEvent_FieldMask{},
		ActivityLogEvent_FieldPathSelectorServerMessage:         &ActivityLog_Event_ServerMsgEvent_FieldMask{},
		ActivityLogEvent_FieldPathSelectorExit:                  &ActivityLog_Event_ExitEvent_FieldMask{},
		ActivityLogEvent_FieldPathSelectorRegionalServerMessage: &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{},
		ActivityLogEvent_FieldPathSelectorRegionalExit:          &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogEvent_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivityLogEvent_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivityLogEvent_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivityLogEvent_FieldPathSelectorClientMessage:
						mySubMasks[ActivityLogEvent_FieldPathSelectorClientMessage] = FullActivityLog_Event_ClientMsgEvent_FieldMask()
					case ActivityLogEvent_FieldPathSelectorServerMessage:
						mySubMasks[ActivityLogEvent_FieldPathSelectorServerMessage] = FullActivityLog_Event_ServerMsgEvent_FieldMask()
					case ActivityLogEvent_FieldPathSelectorExit:
						mySubMasks[ActivityLogEvent_FieldPathSelectorExit] = FullActivityLog_Event_ExitEvent_FieldMask()
					case ActivityLogEvent_FieldPathSelectorRegionalServerMessage:
						mySubMasks[ActivityLogEvent_FieldPathSelectorRegionalServerMessage] = FullActivityLog_Event_RegionalServerMsgEvent_FieldMask()
					case ActivityLogEvent_FieldPathSelectorRegionalExit:
						mySubMasks[ActivityLogEvent_FieldPathSelectorRegionalExit] = FullActivityLog_Event_RegionalServerMsgEvent_FieldMask()
					}
				} else if tp, ok := path.(*ActivityLogEvent_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivityLogEvent_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Event_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Event_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Event_FieldMask) FilterInputFields() *ActivityLog_Event_FieldMask {
	result := &ActivityLog_Event_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Event_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Event_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogEvent_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogEvent_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Event_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Event_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Event_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Event_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_FieldMask) AppendPath(path ActivityLogEvent_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Event_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogEvent_FieldPath))
}

func (fieldMask *ActivityLog_Event_FieldMask) GetPaths() []ActivityLogEvent_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Event_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Event_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogEvent_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Event_FieldMask) Set(target, source *ActivityLog_Event) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Event_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Event), source.(*ActivityLog_Event))
}

func (fieldMask *ActivityLog_Event_FieldMask) Project(source *ActivityLog_Event) *ActivityLog_Event {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Event{}
	clientMessageMask := &ActivityLog_Event_ClientMsgEvent_FieldMask{}
	wholeClientMessageAccepted := false
	serverMessageMask := &ActivityLog_Event_ServerMsgEvent_FieldMask{}
	wholeServerMessageAccepted := false
	exitMask := &ActivityLog_Event_ExitEvent_FieldMask{}
	wholeExitAccepted := false
	regionalServerMessageMask := &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{}
	wholeRegionalServerMessageAccepted := false
	regionalExitMask := &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{}
	wholeRegionalExitAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogEvent_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogEvent_FieldPathSelectorClientMessage:
				if source, ok := source.Evt.(*ActivityLog_Event_ClientMessage); ok {
					result.Evt = &ActivityLog_Event_ClientMessage{
						ClientMessage: source.ClientMessage,
					}
				}
				wholeClientMessageAccepted = true
			case ActivityLogEvent_FieldPathSelectorServerMessage:
				if source, ok := source.Evt.(*ActivityLog_Event_ServerMessage); ok {
					result.Evt = &ActivityLog_Event_ServerMessage{
						ServerMessage: source.ServerMessage,
					}
				}
				wholeServerMessageAccepted = true
			case ActivityLogEvent_FieldPathSelectorExit:
				if source, ok := source.Evt.(*ActivityLog_Event_Exit); ok {
					result.Evt = &ActivityLog_Event_Exit{
						Exit: source.Exit,
					}
				}
				wholeExitAccepted = true
			case ActivityLogEvent_FieldPathSelectorRegionalServerMessage:
				if source, ok := source.Evt.(*ActivityLog_Event_RegionalServerMessage); ok {
					result.Evt = &ActivityLog_Event_RegionalServerMessage{
						RegionalServerMessage: source.RegionalServerMessage,
					}
				}
				wholeRegionalServerMessageAccepted = true
			case ActivityLogEvent_FieldPathSelectorRegionalExit:
				if source, ok := source.Evt.(*ActivityLog_Event_RegionalExit); ok {
					result.Evt = &ActivityLog_Event_RegionalExit{
						RegionalExit: source.RegionalExit,
					}
				}
				wholeRegionalExitAccepted = true
			}
		case *ActivityLogEvent_FieldSubPath:
			switch tp.selector {
			case ActivityLogEvent_FieldPathSelectorClientMessage:
				clientMessageMask.AppendPath(tp.subPath.(ActivityLogEventClientMsgEvent_FieldPath))
			case ActivityLogEvent_FieldPathSelectorServerMessage:
				serverMessageMask.AppendPath(tp.subPath.(ActivityLogEventServerMsgEvent_FieldPath))
			case ActivityLogEvent_FieldPathSelectorExit:
				exitMask.AppendPath(tp.subPath.(ActivityLogEventExitEvent_FieldPath))
			case ActivityLogEvent_FieldPathSelectorRegionalServerMessage:
				regionalServerMessageMask.AppendPath(tp.subPath.(ActivityLogEventRegionalServerMsgEvent_FieldPath))
			case ActivityLogEvent_FieldPathSelectorRegionalExit:
				regionalExitMask.AppendPath(tp.subPath.(ActivityLogEventRegionalServerMsgEvent_FieldPath))
			}
		}
	}
	if wholeClientMessageAccepted == false && len(clientMessageMask.Paths) > 0 {
		if asOneOf, ok := source.Evt.(*ActivityLog_Event_ClientMessage); ok {
			result.Evt = (*ActivityLog_Event_ClientMessage)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivityLog_Event_ClientMessage{}
				oneOfRes.ClientMessage = clientMessageMask.Project(asOneOf.ClientMessage)
				result.Evt = oneOfRes
			}
		}
	}
	if wholeServerMessageAccepted == false && len(serverMessageMask.Paths) > 0 {
		if asOneOf, ok := source.Evt.(*ActivityLog_Event_ServerMessage); ok {
			result.Evt = (*ActivityLog_Event_ServerMessage)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivityLog_Event_ServerMessage{}
				oneOfRes.ServerMessage = serverMessageMask.Project(asOneOf.ServerMessage)
				result.Evt = oneOfRes
			}
		}
	}
	if wholeExitAccepted == false && len(exitMask.Paths) > 0 {
		if asOneOf, ok := source.Evt.(*ActivityLog_Event_Exit); ok {
			result.Evt = (*ActivityLog_Event_Exit)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivityLog_Event_Exit{}
				oneOfRes.Exit = exitMask.Project(asOneOf.Exit)
				result.Evt = oneOfRes
			}
		}
	}
	if wholeRegionalServerMessageAccepted == false && len(regionalServerMessageMask.Paths) > 0 {
		if asOneOf, ok := source.Evt.(*ActivityLog_Event_RegionalServerMessage); ok {
			result.Evt = (*ActivityLog_Event_RegionalServerMessage)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivityLog_Event_RegionalServerMessage{}
				oneOfRes.RegionalServerMessage = regionalServerMessageMask.Project(asOneOf.RegionalServerMessage)
				result.Evt = oneOfRes
			}
		}
	}
	if wholeRegionalExitAccepted == false && len(regionalExitMask.Paths) > 0 {
		if asOneOf, ok := source.Evt.(*ActivityLog_Event_RegionalExit); ok {
			result.Evt = (*ActivityLog_Event_RegionalExit)(nil)
			if asOneOf != nil {
				oneOfRes := &ActivityLog_Event_RegionalExit{}
				oneOfRes.RegionalExit = regionalExitMask.Project(asOneOf.RegionalExit)
				result.Evt = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ActivityLog_Event_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Event))
}

func (fieldMask *ActivityLog_Event_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Method_FieldMask struct {
	Paths []ActivityLogMethod_FieldPath
}

func FullActivityLog_Method_FieldMask() *ActivityLog_Method_FieldMask {
	res := &ActivityLog_Method_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogMethod_FieldTerminalPath{selector: ActivityLogMethod_FieldPathSelectorType})
	res.Paths = append(res.Paths, &ActivityLogMethod_FieldTerminalPath{selector: ActivityLogMethod_FieldPathSelectorVersion})
	return res
}

func (fieldMask *ActivityLog_Method_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Method_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Method_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogMethod_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Method_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogMethod_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Method_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogMethod_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Method_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Method_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Method_FieldMask) Subtract(other *ActivityLog_Method_FieldMask) *ActivityLog_Method_FieldMask {
	result := &ActivityLog_Method_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogMethod_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Method_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Method_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Method_FieldMask) FilterInputFields() *ActivityLog_Method_FieldMask {
	result := &ActivityLog_Method_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Method_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Method_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogMethod_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogMethod_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Method_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Method_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Method_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Method_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Method_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Method_FieldMask) AppendPath(path ActivityLogMethod_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Method_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogMethod_FieldPath))
}

func (fieldMask *ActivityLog_Method_FieldMask) GetPaths() []ActivityLogMethod_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Method_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Method_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogMethod_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Method_FieldMask) Set(target, source *ActivityLog_Method) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Method_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Method), source.(*ActivityLog_Method))
}

func (fieldMask *ActivityLog_Method_FieldMask) Project(source *ActivityLog_Method) *ActivityLog_Method {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Method{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogMethod_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogMethod_FieldPathSelectorType:
				result.Type = source.Type
			case ActivityLogMethod_FieldPathSelectorVersion:
				result.Version = source.Version
			}
		}
	}
	return result
}

func (fieldMask *ActivityLog_Method_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Method))
}

func (fieldMask *ActivityLog_Method_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_RequestMetadata_FieldMask struct {
	Paths []ActivityLogRequestMetadata_FieldPath
}

func FullActivityLog_RequestMetadata_FieldMask() *ActivityLog_RequestMetadata_FieldMask {
	res := &ActivityLog_RequestMetadata_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogRequestMetadata_FieldTerminalPath{selector: ActivityLogRequestMetadata_FieldPathSelectorIpAddress})
	res.Paths = append(res.Paths, &ActivityLogRequestMetadata_FieldTerminalPath{selector: ActivityLogRequestMetadata_FieldPathSelectorUserAgent})
	return res
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_RequestMetadata_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogRequestMetadata_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogRequestMetadata_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogRequestMetadata_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) Subtract(other *ActivityLog_RequestMetadata_FieldMask) *ActivityLog_RequestMetadata_FieldMask {
	result := &ActivityLog_RequestMetadata_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogRequestMetadata_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_RequestMetadata_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_RequestMetadata_FieldMask) FilterInputFields() *ActivityLog_RequestMetadata_FieldMask {
	result := &ActivityLog_RequestMetadata_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_RequestMetadata_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogRequestMetadata_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogRequestMetadata_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_RequestMetadata_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_RequestMetadata_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) AppendPath(path ActivityLogRequestMetadata_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogRequestMetadata_FieldPath))
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) GetPaths() []ActivityLogRequestMetadata_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogRequestMetadata_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) Set(target, source *ActivityLog_RequestMetadata) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_RequestMetadata), source.(*ActivityLog_RequestMetadata))
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) Project(source *ActivityLog_RequestMetadata) *ActivityLog_RequestMetadata {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_RequestMetadata{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogRequestMetadata_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogRequestMetadata_FieldPathSelectorIpAddress:
				result.IpAddress = source.IpAddress
			case ActivityLogRequestMetadata_FieldPathSelectorUserAgent:
				result.UserAgent = source.UserAgent
			}
		}
	}
	return result
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_RequestMetadata))
}

func (fieldMask *ActivityLog_RequestMetadata_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_RequestRouting_FieldMask struct {
	Paths []ActivityLogRequestRouting_FieldPath
}

func FullActivityLog_RequestRouting_FieldMask() *ActivityLog_RequestRouting_FieldMask {
	res := &ActivityLog_RequestRouting_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogRequestRouting_FieldTerminalPath{selector: ActivityLogRequestRouting_FieldPathSelectorViaRegion})
	res.Paths = append(res.Paths, &ActivityLogRequestRouting_FieldTerminalPath{selector: ActivityLogRequestRouting_FieldPathSelectorDestRegions})
	return res
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_RequestRouting_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogRequestRouting_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogRequestRouting_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogRequestRouting_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) Subtract(other *ActivityLog_RequestRouting_FieldMask) *ActivityLog_RequestRouting_FieldMask {
	result := &ActivityLog_RequestRouting_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogRequestRouting_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_RequestRouting_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_RequestRouting_FieldMask) FilterInputFields() *ActivityLog_RequestRouting_FieldMask {
	result := &ActivityLog_RequestRouting_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_RequestRouting_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogRequestRouting_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogRequestRouting_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_RequestRouting_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_RequestRouting_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) AppendPath(path ActivityLogRequestRouting_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogRequestRouting_FieldPath))
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) GetPaths() []ActivityLogRequestRouting_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogRequestRouting_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) Set(target, source *ActivityLog_RequestRouting) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_RequestRouting), source.(*ActivityLog_RequestRouting))
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) Project(source *ActivityLog_RequestRouting) *ActivityLog_RequestRouting {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_RequestRouting{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogRequestRouting_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogRequestRouting_FieldPathSelectorViaRegion:
				result.ViaRegion = source.ViaRegion
			case ActivityLogRequestRouting_FieldPathSelectorDestRegions:
				result.DestRegions = source.DestRegions
			}
		}
	}
	return result
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_RequestRouting))
}

func (fieldMask *ActivityLog_RequestRouting_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Resource_FieldMask struct {
	Paths []ActivityLogResource_FieldPath
}

func FullActivityLog_Resource_FieldMask() *ActivityLog_Resource_FieldMask {
	res := &ActivityLog_Resource_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogResource_FieldTerminalPath{selector: ActivityLogResource_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ActivityLogResource_FieldTerminalPath{selector: ActivityLogResource_FieldPathSelectorDifference})
	return res
}

func (fieldMask *ActivityLog_Resource_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Resource_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Resource_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogResource_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Resource_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogResource_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Resource_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogResource_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Resource_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Resource_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Resource_FieldMask) Subtract(other *ActivityLog_Resource_FieldMask) *ActivityLog_Resource_FieldMask {
	result := &ActivityLog_Resource_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[ActivityLogResource_FieldPathSelector]gotenobject.FieldMask{
		ActivityLogResource_FieldPathSelectorDifference: &ActivityLog_Resource_Difference_FieldMask{},
	}
	mySubMasks := map[ActivityLogResource_FieldPathSelector]gotenobject.FieldMask{
		ActivityLogResource_FieldPathSelectorDifference: &ActivityLog_Resource_Difference_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogResource_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivityLogResource_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivityLogResource_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivityLogResource_FieldPathSelectorDifference:
						mySubMasks[ActivityLogResource_FieldPathSelectorDifference] = FullActivityLog_Resource_Difference_FieldMask()
					}
				} else if tp, ok := path.(*ActivityLogResource_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivityLogResource_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Resource_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Resource_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Resource_FieldMask) FilterInputFields() *ActivityLog_Resource_FieldMask {
	result := &ActivityLog_Resource_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Resource_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Resource_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogResource_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogResource_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Resource_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Resource_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Resource_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Resource_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Resource_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Resource_FieldMask) AppendPath(path ActivityLogResource_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Resource_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogResource_FieldPath))
}

func (fieldMask *ActivityLog_Resource_FieldMask) GetPaths() []ActivityLogResource_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Resource_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Resource_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogResource_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Resource_FieldMask) Set(target, source *ActivityLog_Resource) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Resource_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Resource), source.(*ActivityLog_Resource))
}

func (fieldMask *ActivityLog_Resource_FieldMask) Project(source *ActivityLog_Resource) *ActivityLog_Resource {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Resource{}
	differenceMask := &ActivityLog_Resource_Difference_FieldMask{}
	wholeDifferenceAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogResource_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogResource_FieldPathSelectorName:
				result.Name = source.Name
			case ActivityLogResource_FieldPathSelectorDifference:
				result.Difference = source.Difference
				wholeDifferenceAccepted = true
			}
		case *ActivityLogResource_FieldSubPath:
			switch tp.selector {
			case ActivityLogResource_FieldPathSelectorDifference:
				differenceMask.AppendPath(tp.subPath.(ActivityLogResourceDifference_FieldPath))
			}
		}
	}
	if wholeDifferenceAccepted == false && len(differenceMask.Paths) > 0 {
		result.Difference = differenceMask.Project(source.GetDifference())
	}
	return result
}

func (fieldMask *ActivityLog_Resource_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Resource))
}

func (fieldMask *ActivityLog_Resource_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Event_ClientMsgEvent_FieldMask struct {
	Paths []ActivityLogEventClientMsgEvent_FieldPath
}

func FullActivityLog_Event_ClientMsgEvent_FieldMask() *ActivityLog_Event_ClientMsgEvent_FieldMask {
	res := &ActivityLog_Event_ClientMsgEvent_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogEventClientMsgEvent_FieldTerminalPath{selector: ActivityLogEventClientMsgEvent_FieldPathSelectorData})
	res.Paths = append(res.Paths, &ActivityLogEventClientMsgEvent_FieldTerminalPath{selector: ActivityLogEventClientMsgEvent_FieldPathSelectorTime})
	return res
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogEventClientMsgEvent_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogEventClientMsgEvent_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogEventClientMsgEvent_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) Subtract(other *ActivityLog_Event_ClientMsgEvent_FieldMask) *ActivityLog_Event_ClientMsgEvent_FieldMask {
	result := &ActivityLog_Event_ClientMsgEvent_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogEventClientMsgEvent_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Event_ClientMsgEvent_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) FilterInputFields() *ActivityLog_Event_ClientMsgEvent_FieldMask {
	result := &ActivityLog_Event_ClientMsgEvent_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogEventClientMsgEvent_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogEventClientMsgEvent_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Event_ClientMsgEvent_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Event_ClientMsgEvent_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) AppendPath(path ActivityLogEventClientMsgEvent_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogEventClientMsgEvent_FieldPath))
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) GetPaths() []ActivityLogEventClientMsgEvent_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogEventClientMsgEvent_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) Set(target, source *ActivityLog_Event_ClientMsgEvent) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Event_ClientMsgEvent), source.(*ActivityLog_Event_ClientMsgEvent))
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) Project(source *ActivityLog_Event_ClientMsgEvent) *ActivityLog_Event_ClientMsgEvent {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Event_ClientMsgEvent{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogEventClientMsgEvent_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogEventClientMsgEvent_FieldPathSelectorData:
				result.Data = source.Data
			case ActivityLogEventClientMsgEvent_FieldPathSelectorTime:
				result.Time = source.Time
			}
		}
	}
	return result
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Event_ClientMsgEvent))
}

func (fieldMask *ActivityLog_Event_ClientMsgEvent_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Event_RegionalServerMsgEvent_FieldMask struct {
	Paths []ActivityLogEventRegionalServerMsgEvent_FieldPath
}

func FullActivityLog_Event_RegionalServerMsgEvent_FieldMask() *ActivityLog_Event_RegionalServerMsgEvent_FieldMask {
	res := &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogEventRegionalServerMsgEvent_FieldTerminalPath{selector: ActivityLogEventRegionalServerMsgEvent_FieldPathSelectorData})
	res.Paths = append(res.Paths, &ActivityLogEventRegionalServerMsgEvent_FieldTerminalPath{selector: ActivityLogEventRegionalServerMsgEvent_FieldPathSelectorTime})
	res.Paths = append(res.Paths, &ActivityLogEventRegionalServerMsgEvent_FieldTerminalPath{selector: ActivityLogEventRegionalServerMsgEvent_FieldPathSelectorRegionId})
	return res
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogEventRegionalServerMsgEvent_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogEventRegionalServerMsgEvent_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogEventRegionalServerMsgEvent_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) Subtract(other *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) *ActivityLog_Event_RegionalServerMsgEvent_FieldMask {
	result := &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogEventRegionalServerMsgEvent_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Event_RegionalServerMsgEvent_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) FilterInputFields() *ActivityLog_Event_RegionalServerMsgEvent_FieldMask {
	result := &ActivityLog_Event_RegionalServerMsgEvent_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogEventRegionalServerMsgEvent_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogEventRegionalServerMsgEvent_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Event_RegionalServerMsgEvent_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Event_RegionalServerMsgEvent_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) AppendPath(path ActivityLogEventRegionalServerMsgEvent_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogEventRegionalServerMsgEvent_FieldPath))
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) GetPaths() []ActivityLogEventRegionalServerMsgEvent_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogEventRegionalServerMsgEvent_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) Set(target, source *ActivityLog_Event_RegionalServerMsgEvent) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Event_RegionalServerMsgEvent), source.(*ActivityLog_Event_RegionalServerMsgEvent))
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) Project(source *ActivityLog_Event_RegionalServerMsgEvent) *ActivityLog_Event_RegionalServerMsgEvent {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Event_RegionalServerMsgEvent{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogEventRegionalServerMsgEvent_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogEventRegionalServerMsgEvent_FieldPathSelectorData:
				result.Data = source.Data
			case ActivityLogEventRegionalServerMsgEvent_FieldPathSelectorTime:
				result.Time = source.Time
			case ActivityLogEventRegionalServerMsgEvent_FieldPathSelectorRegionId:
				result.RegionId = source.RegionId
			}
		}
	}
	return result
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Event_RegionalServerMsgEvent))
}

func (fieldMask *ActivityLog_Event_RegionalServerMsgEvent_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Event_ServerMsgEvent_FieldMask struct {
	Paths []ActivityLogEventServerMsgEvent_FieldPath
}

func FullActivityLog_Event_ServerMsgEvent_FieldMask() *ActivityLog_Event_ServerMsgEvent_FieldMask {
	res := &ActivityLog_Event_ServerMsgEvent_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogEventServerMsgEvent_FieldTerminalPath{selector: ActivityLogEventServerMsgEvent_FieldPathSelectorData})
	res.Paths = append(res.Paths, &ActivityLogEventServerMsgEvent_FieldTerminalPath{selector: ActivityLogEventServerMsgEvent_FieldPathSelectorTime})
	return res
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogEventServerMsgEvent_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogEventServerMsgEvent_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogEventServerMsgEvent_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) Subtract(other *ActivityLog_Event_ServerMsgEvent_FieldMask) *ActivityLog_Event_ServerMsgEvent_FieldMask {
	result := &ActivityLog_Event_ServerMsgEvent_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogEventServerMsgEvent_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Event_ServerMsgEvent_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) FilterInputFields() *ActivityLog_Event_ServerMsgEvent_FieldMask {
	result := &ActivityLog_Event_ServerMsgEvent_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogEventServerMsgEvent_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogEventServerMsgEvent_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Event_ServerMsgEvent_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Event_ServerMsgEvent_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) AppendPath(path ActivityLogEventServerMsgEvent_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogEventServerMsgEvent_FieldPath))
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) GetPaths() []ActivityLogEventServerMsgEvent_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogEventServerMsgEvent_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) Set(target, source *ActivityLog_Event_ServerMsgEvent) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Event_ServerMsgEvent), source.(*ActivityLog_Event_ServerMsgEvent))
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) Project(source *ActivityLog_Event_ServerMsgEvent) *ActivityLog_Event_ServerMsgEvent {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Event_ServerMsgEvent{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogEventServerMsgEvent_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogEventServerMsgEvent_FieldPathSelectorData:
				result.Data = source.Data
			case ActivityLogEventServerMsgEvent_FieldPathSelectorTime:
				result.Time = source.Time
			}
		}
	}
	return result
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Event_ServerMsgEvent))
}

func (fieldMask *ActivityLog_Event_ServerMsgEvent_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Event_RegionalExitEvent_FieldMask struct {
	Paths []ActivityLogEventRegionalExitEvent_FieldPath
}

func FullActivityLog_Event_RegionalExitEvent_FieldMask() *ActivityLog_Event_RegionalExitEvent_FieldMask {
	res := &ActivityLog_Event_RegionalExitEvent_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogEventRegionalExitEvent_FieldTerminalPath{selector: ActivityLogEventRegionalExitEvent_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &ActivityLogEventRegionalExitEvent_FieldTerminalPath{selector: ActivityLogEventRegionalExitEvent_FieldPathSelectorTime})
	res.Paths = append(res.Paths, &ActivityLogEventRegionalExitEvent_FieldTerminalPath{selector: ActivityLogEventRegionalExitEvent_FieldPathSelectorRegionId})
	return res
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogEventRegionalExitEvent_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogEventRegionalExitEvent_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogEventRegionalExitEvent_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) Subtract(other *ActivityLog_Event_RegionalExitEvent_FieldMask) *ActivityLog_Event_RegionalExitEvent_FieldMask {
	result := &ActivityLog_Event_RegionalExitEvent_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ActivityLogEventRegionalExitEvent_FieldPathSelector]gotenobject.FieldMask{
		ActivityLogEventRegionalExitEvent_FieldPathSelectorStatus: &rpc.Status_FieldMask{},
	}
	mySubMasks := map[ActivityLogEventRegionalExitEvent_FieldPathSelector]gotenobject.FieldMask{
		ActivityLogEventRegionalExitEvent_FieldPathSelectorStatus: &rpc.Status_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogEventRegionalExitEvent_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivityLogEventRegionalExitEvent_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivityLogEventRegionalExitEvent_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivityLogEventRegionalExitEvent_FieldPathSelectorStatus:
						mySubMasks[ActivityLogEventRegionalExitEvent_FieldPathSelectorStatus] = rpc.FullStatus_FieldMask()
					}
				} else if tp, ok := path.(*ActivityLogEventRegionalExitEvent_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivityLogEventRegionalExitEvent_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Event_RegionalExitEvent_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) FilterInputFields() *ActivityLog_Event_RegionalExitEvent_FieldMask {
	result := &ActivityLog_Event_RegionalExitEvent_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogEventRegionalExitEvent_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogEventRegionalExitEvent_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Event_RegionalExitEvent_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Event_RegionalExitEvent_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) AppendPath(path ActivityLogEventRegionalExitEvent_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogEventRegionalExitEvent_FieldPath))
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) GetPaths() []ActivityLogEventRegionalExitEvent_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogEventRegionalExitEvent_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) Set(target, source *ActivityLog_Event_RegionalExitEvent) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Event_RegionalExitEvent), source.(*ActivityLog_Event_RegionalExitEvent))
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) Project(source *ActivityLog_Event_RegionalExitEvent) *ActivityLog_Event_RegionalExitEvent {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Event_RegionalExitEvent{}
	statusMask := &rpc.Status_FieldMask{}
	wholeStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogEventRegionalExitEvent_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogEventRegionalExitEvent_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			case ActivityLogEventRegionalExitEvent_FieldPathSelectorTime:
				result.Time = source.Time
			case ActivityLogEventRegionalExitEvent_FieldPathSelectorRegionId:
				result.RegionId = source.RegionId
			}
		case *ActivityLogEventRegionalExitEvent_FieldSubPath:
			switch tp.selector {
			case ActivityLogEventRegionalExitEvent_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(rpc.Status_FieldPath))
			}
		}
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	return result
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Event_RegionalExitEvent))
}

func (fieldMask *ActivityLog_Event_RegionalExitEvent_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Event_ExitEvent_FieldMask struct {
	Paths []ActivityLogEventExitEvent_FieldPath
}

func FullActivityLog_Event_ExitEvent_FieldMask() *ActivityLog_Event_ExitEvent_FieldMask {
	res := &ActivityLog_Event_ExitEvent_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogEventExitEvent_FieldTerminalPath{selector: ActivityLogEventExitEvent_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &ActivityLogEventExitEvent_FieldTerminalPath{selector: ActivityLogEventExitEvent_FieldPathSelectorTime})
	return res
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogEventExitEvent_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogEventExitEvent_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogEventExitEvent_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) Subtract(other *ActivityLog_Event_ExitEvent_FieldMask) *ActivityLog_Event_ExitEvent_FieldMask {
	result := &ActivityLog_Event_ExitEvent_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[ActivityLogEventExitEvent_FieldPathSelector]gotenobject.FieldMask{
		ActivityLogEventExitEvent_FieldPathSelectorStatus: &rpc.Status_FieldMask{},
	}
	mySubMasks := map[ActivityLogEventExitEvent_FieldPathSelector]gotenobject.FieldMask{
		ActivityLogEventExitEvent_FieldPathSelectorStatus: &rpc.Status_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogEventExitEvent_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ActivityLogEventExitEvent_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ActivityLogEventExitEvent_FieldTerminalPath); ok {
					switch tp.selector {
					case ActivityLogEventExitEvent_FieldPathSelectorStatus:
						mySubMasks[ActivityLogEventExitEvent_FieldPathSelectorStatus] = rpc.FullStatus_FieldMask()
					}
				} else if tp, ok := path.(*ActivityLogEventExitEvent_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ActivityLogEventExitEvent_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Event_ExitEvent_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) FilterInputFields() *ActivityLog_Event_ExitEvent_FieldMask {
	result := &ActivityLog_Event_ExitEvent_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogEventExitEvent_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogEventExitEvent_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Event_ExitEvent_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Event_ExitEvent_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) AppendPath(path ActivityLogEventExitEvent_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogEventExitEvent_FieldPath))
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) GetPaths() []ActivityLogEventExitEvent_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogEventExitEvent_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) Set(target, source *ActivityLog_Event_ExitEvent) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Event_ExitEvent), source.(*ActivityLog_Event_ExitEvent))
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) Project(source *ActivityLog_Event_ExitEvent) *ActivityLog_Event_ExitEvent {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Event_ExitEvent{}
	statusMask := &rpc.Status_FieldMask{}
	wholeStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogEventExitEvent_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogEventExitEvent_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			case ActivityLogEventExitEvent_FieldPathSelectorTime:
				result.Time = source.Time
			}
		case *ActivityLogEventExitEvent_FieldSubPath:
			switch tp.selector {
			case ActivityLogEventExitEvent_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(rpc.Status_FieldPath))
			}
		}
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	return result
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Event_ExitEvent))
}

func (fieldMask *ActivityLog_Event_ExitEvent_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ActivityLog_Resource_Difference_FieldMask struct {
	Paths []ActivityLogResourceDifference_FieldPath
}

func FullActivityLog_Resource_Difference_FieldMask() *ActivityLog_Resource_Difference_FieldMask {
	res := &ActivityLog_Resource_Difference_FieldMask{}
	res.Paths = append(res.Paths, &ActivityLogResourceDifference_FieldTerminalPath{selector: ActivityLogResourceDifference_FieldPathSelectorFields})
	res.Paths = append(res.Paths, &ActivityLogResourceDifference_FieldTerminalPath{selector: ActivityLogResourceDifference_FieldPathSelectorBefore})
	res.Paths = append(res.Paths, &ActivityLogResourceDifference_FieldTerminalPath{selector: ActivityLogResourceDifference_FieldPathSelectorAfter})
	return res
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ActivityLog_Resource_Difference_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseActivityLogResourceDifference_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ActivityLogResourceDifference_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseActivityLogResourceDifference_FieldPath(raw)
	})
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) ProtoMessage() {}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) Subtract(other *ActivityLog_Resource_Difference_FieldMask) *ActivityLog_Resource_Difference_FieldMask {
	result := &ActivityLog_Resource_Difference_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ActivityLogResourceDifference_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ActivityLog_Resource_Difference_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ActivityLog_Resource_Difference_FieldMask) FilterInputFields() *ActivityLog_Resource_Difference_FieldMask {
	result := &ActivityLog_Resource_Difference_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ActivityLog_Resource_Difference_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ActivityLogResourceDifference_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseActivityLogResourceDifference_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ActivityLog_Resource_Difference_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ActivityLog_Resource_Difference_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) AppendPath(path ActivityLogResourceDifference_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ActivityLogResourceDifference_FieldPath))
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) GetPaths() []ActivityLogResourceDifference_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseActivityLogResourceDifference_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) Set(target, source *ActivityLog_Resource_Difference) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ActivityLog_Resource_Difference), source.(*ActivityLog_Resource_Difference))
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) Project(source *ActivityLog_Resource_Difference) *ActivityLog_Resource_Difference {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ActivityLog_Resource_Difference{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ActivityLogResourceDifference_FieldTerminalPath:
			switch tp.selector {
			case ActivityLogResourceDifference_FieldPathSelectorFields:
				result.Fields = source.Fields
			case ActivityLogResourceDifference_FieldPathSelectorBefore:
				result.Before = source.Before
			case ActivityLogResourceDifference_FieldPathSelectorAfter:
				result.After = source.After
			}
		}
	}
	return result
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ActivityLog_Resource_Difference))
}

func (fieldMask *ActivityLog_Resource_Difference_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
