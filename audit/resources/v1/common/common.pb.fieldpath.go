// Code generated by protoc-gen-goten-object
// File: edgelq/audit/proto/v1/common.proto
// DO NOT EDIT!!!

package common

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	anypb "google.golang.org/protobuf/types/known/anypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &anypb.Any{}
	_ = &timestamppb.Timestamp{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Authentication_FieldPath interface {
	gotenobject.FieldPath
	Selector() Authentication_FieldPathSelector
	Get(source *Authentication) []interface{}
	GetSingle(source *Authentication) (interface{}, bool)
	ClearValue(item *Authentication)

	// Those methods build corresponding Authentication_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Authentication_FieldPathValue
	WithIArrayOfValues(values interface{}) Authentication_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Authentication_FieldPathArrayItemValue
}

type Authentication_FieldPathSelector int32

const (
	Authentication_FieldPathSelectorPrincipal     Authentication_FieldPathSelector = 0
	Authentication_FieldPathSelectorPrincipalType Authentication_FieldPathSelector = 1
)

func (s Authentication_FieldPathSelector) String() string {
	switch s {
	case Authentication_FieldPathSelectorPrincipal:
		return "principal"
	case Authentication_FieldPathSelectorPrincipalType:
		return "principal_type"
	default:
		panic(fmt.Sprintf("Invalid selector for Authentication: %d", s))
	}
}

func BuildAuthentication_FieldPath(fp gotenobject.RawFieldPath) (Authentication_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Authentication")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "principal":
			return &Authentication_FieldTerminalPath{selector: Authentication_FieldPathSelectorPrincipal}, nil
		case "principal_type", "principalType", "principal-type":
			return &Authentication_FieldTerminalPath{selector: Authentication_FieldPathSelectorPrincipalType}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Authentication", fp)
}

func ParseAuthentication_FieldPath(rawField string) (Authentication_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildAuthentication_FieldPath(fp)
}

func MustParseAuthentication_FieldPath(rawField string) Authentication_FieldPath {
	fp, err := ParseAuthentication_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Authentication_FieldTerminalPath struct {
	selector Authentication_FieldPathSelector
}

var _ Authentication_FieldPath = (*Authentication_FieldTerminalPath)(nil)

func (fp *Authentication_FieldTerminalPath) Selector() Authentication_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Authentication_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Authentication_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Authentication
func (fp *Authentication_FieldTerminalPath) Get(source *Authentication) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Authentication_FieldPathSelectorPrincipal:
			values = append(values, source.Principal)
		case Authentication_FieldPathSelectorPrincipalType:
			values = append(values, source.PrincipalType)
		default:
			panic(fmt.Sprintf("Invalid selector for Authentication: %d", fp.selector))
		}
	}
	return
}

func (fp *Authentication_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Authentication))
}

// GetSingle returns value pointed by specific field of from source Authentication
func (fp *Authentication_FieldTerminalPath) GetSingle(source *Authentication) (interface{}, bool) {
	switch fp.selector {
	case Authentication_FieldPathSelectorPrincipal:
		return source.GetPrincipal(), source != nil
	case Authentication_FieldPathSelectorPrincipalType:
		return source.GetPrincipalType(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Authentication: %d", fp.selector))
	}
}

func (fp *Authentication_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Authentication))
}

// GetDefault returns a default value of the field type
func (fp *Authentication_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Authentication_FieldPathSelectorPrincipal:
		return ""
	case Authentication_FieldPathSelectorPrincipalType:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for Authentication: %d", fp.selector))
	}
}

func (fp *Authentication_FieldTerminalPath) ClearValue(item *Authentication) {
	if item != nil {
		switch fp.selector {
		case Authentication_FieldPathSelectorPrincipal:
			item.Principal = ""
		case Authentication_FieldPathSelectorPrincipalType:
			item.PrincipalType = ""
		default:
			panic(fmt.Sprintf("Invalid selector for Authentication: %d", fp.selector))
		}
	}
}

func (fp *Authentication_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Authentication))
}

// IsLeaf - whether field path is holds simple value
func (fp *Authentication_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Authentication_FieldPathSelectorPrincipal ||
		fp.selector == Authentication_FieldPathSelectorPrincipalType
}

func (fp *Authentication_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Authentication_FieldTerminalPath) WithIValue(value interface{}) Authentication_FieldPathValue {
	switch fp.selector {
	case Authentication_FieldPathSelectorPrincipal:
		return &Authentication_FieldTerminalPathValue{Authentication_FieldTerminalPath: *fp, value: value.(string)}
	case Authentication_FieldPathSelectorPrincipalType:
		return &Authentication_FieldTerminalPathValue{Authentication_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Authentication: %d", fp.selector))
	}
}

func (fp *Authentication_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Authentication_FieldTerminalPath) WithIArrayOfValues(values interface{}) Authentication_FieldPathArrayOfValues {
	fpaov := &Authentication_FieldTerminalPathArrayOfValues{Authentication_FieldTerminalPath: *fp}
	switch fp.selector {
	case Authentication_FieldPathSelectorPrincipal:
		return &Authentication_FieldTerminalPathArrayOfValues{Authentication_FieldTerminalPath: *fp, values: values.([]string)}
	case Authentication_FieldPathSelectorPrincipalType:
		return &Authentication_FieldTerminalPathArrayOfValues{Authentication_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Authentication: %d", fp.selector))
	}
	return fpaov
}

func (fp *Authentication_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Authentication_FieldTerminalPath) WithIArrayItemValue(value interface{}) Authentication_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Authentication: %d", fp.selector))
	}
}

func (fp *Authentication_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Authentication_FieldPathValue allows storing values for Authentication fields according to their type
type Authentication_FieldPathValue interface {
	Authentication_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Authentication)
	CompareWith(*Authentication) (cmp int, comparable bool)
}

func ParseAuthentication_FieldPathValue(pathStr, valueStr string) (Authentication_FieldPathValue, error) {
	fp, err := ParseAuthentication_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Authentication field path value from %s: %v", valueStr, err)
	}
	return fpv.(Authentication_FieldPathValue), nil
}

func MustParseAuthentication_FieldPathValue(pathStr, valueStr string) Authentication_FieldPathValue {
	fpv, err := ParseAuthentication_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Authentication_FieldTerminalPathValue struct {
	Authentication_FieldTerminalPath
	value interface{}
}

var _ Authentication_FieldPathValue = (*Authentication_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Authentication' as interface{}
func (fpv *Authentication_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Authentication_FieldTerminalPathValue) AsPrincipalValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Authentication_FieldTerminalPathValue) AsPrincipalTypeValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object Authentication
func (fpv *Authentication_FieldTerminalPathValue) SetTo(target **Authentication) {
	if *target == nil {
		*target = new(Authentication)
	}
	switch fpv.selector {
	case Authentication_FieldPathSelectorPrincipal:
		(*target).Principal = fpv.value.(string)
	case Authentication_FieldPathSelectorPrincipalType:
		(*target).PrincipalType = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for Authentication: %d", fpv.selector))
	}
}

func (fpv *Authentication_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Authentication)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Authentication_FieldTerminalPathValue' with the value under path in 'Authentication'.
func (fpv *Authentication_FieldTerminalPathValue) CompareWith(source *Authentication) (int, bool) {
	switch fpv.selector {
	case Authentication_FieldPathSelectorPrincipal:
		leftValue := fpv.value.(string)
		rightValue := source.GetPrincipal()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Authentication_FieldPathSelectorPrincipalType:
		leftValue := fpv.value.(string)
		rightValue := source.GetPrincipalType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Authentication: %d", fpv.selector))
	}
}

func (fpv *Authentication_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Authentication))
}

// Authentication_FieldPathArrayItemValue allows storing single item in Path-specific values for Authentication according to their type
// Present only for array (repeated) types.
type Authentication_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Authentication_FieldPath
	ContainsValue(*Authentication) bool
}

// ParseAuthentication_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseAuthentication_FieldPathArrayItemValue(pathStr, valueStr string) (Authentication_FieldPathArrayItemValue, error) {
	fp, err := ParseAuthentication_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Authentication field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Authentication_FieldPathArrayItemValue), nil
}

func MustParseAuthentication_FieldPathArrayItemValue(pathStr, valueStr string) Authentication_FieldPathArrayItemValue {
	fpaiv, err := ParseAuthentication_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Authentication_FieldTerminalPathArrayItemValue struct {
	Authentication_FieldTerminalPath
	value interface{}
}

var _ Authentication_FieldPathArrayItemValue = (*Authentication_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Authentication as interface{}
func (fpaiv *Authentication_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Authentication_FieldTerminalPathArrayItemValue) GetSingle(source *Authentication) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Authentication_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Authentication))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Authentication'
func (fpaiv *Authentication_FieldTerminalPathArrayItemValue) ContainsValue(source *Authentication) bool {
	slice := fpaiv.Authentication_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Authentication_FieldPathArrayOfValues allows storing slice of values for Authentication fields according to their type
type Authentication_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Authentication_FieldPath
}

func ParseAuthentication_FieldPathArrayOfValues(pathStr, valuesStr string) (Authentication_FieldPathArrayOfValues, error) {
	fp, err := ParseAuthentication_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Authentication field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Authentication_FieldPathArrayOfValues), nil
}

func MustParseAuthentication_FieldPathArrayOfValues(pathStr, valuesStr string) Authentication_FieldPathArrayOfValues {
	fpaov, err := ParseAuthentication_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Authentication_FieldTerminalPathArrayOfValues struct {
	Authentication_FieldTerminalPath
	values interface{}
}

var _ Authentication_FieldPathArrayOfValues = (*Authentication_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Authentication_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Authentication_FieldPathSelectorPrincipal:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Authentication_FieldPathSelectorPrincipalType:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Authentication_FieldTerminalPathArrayOfValues) AsPrincipalArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Authentication_FieldTerminalPathArrayOfValues) AsPrincipalTypeArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Authorization_FieldPath interface {
	gotenobject.FieldPath
	Selector() Authorization_FieldPathSelector
	Get(source *Authorization) []interface{}
	GetSingle(source *Authorization) (interface{}, bool)
	ClearValue(item *Authorization)

	// Those methods build corresponding Authorization_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Authorization_FieldPathValue
	WithIArrayOfValues(values interface{}) Authorization_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Authorization_FieldPathArrayItemValue
}

type Authorization_FieldPathSelector int32

const (
	Authorization_FieldPathSelectorGrantedPermissions Authorization_FieldPathSelector = 0
	Authorization_FieldPathSelectorDeniedPermissions  Authorization_FieldPathSelector = 1
)

func (s Authorization_FieldPathSelector) String() string {
	switch s {
	case Authorization_FieldPathSelectorGrantedPermissions:
		return "granted_permissions"
	case Authorization_FieldPathSelectorDeniedPermissions:
		return "denied_permissions"
	default:
		panic(fmt.Sprintf("Invalid selector for Authorization: %d", s))
	}
}

func BuildAuthorization_FieldPath(fp gotenobject.RawFieldPath) (Authorization_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Authorization")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "granted_permissions", "grantedPermissions", "granted-permissions":
			return &Authorization_FieldTerminalPath{selector: Authorization_FieldPathSelectorGrantedPermissions}, nil
		case "denied_permissions", "deniedPermissions", "denied-permissions":
			return &Authorization_FieldTerminalPath{selector: Authorization_FieldPathSelectorDeniedPermissions}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Authorization", fp)
}

func ParseAuthorization_FieldPath(rawField string) (Authorization_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildAuthorization_FieldPath(fp)
}

func MustParseAuthorization_FieldPath(rawField string) Authorization_FieldPath {
	fp, err := ParseAuthorization_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Authorization_FieldTerminalPath struct {
	selector Authorization_FieldPathSelector
}

var _ Authorization_FieldPath = (*Authorization_FieldTerminalPath)(nil)

func (fp *Authorization_FieldTerminalPath) Selector() Authorization_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Authorization_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Authorization_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Authorization
func (fp *Authorization_FieldTerminalPath) Get(source *Authorization) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Authorization_FieldPathSelectorGrantedPermissions:
			for _, value := range source.GetGrantedPermissions() {
				values = append(values, value)
			}
		case Authorization_FieldPathSelectorDeniedPermissions:
			for _, value := range source.GetDeniedPermissions() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Authorization: %d", fp.selector))
		}
	}
	return
}

func (fp *Authorization_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Authorization))
}

// GetSingle returns value pointed by specific field of from source Authorization
func (fp *Authorization_FieldTerminalPath) GetSingle(source *Authorization) (interface{}, bool) {
	switch fp.selector {
	case Authorization_FieldPathSelectorGrantedPermissions:
		res := source.GetGrantedPermissions()
		return res, res != nil
	case Authorization_FieldPathSelectorDeniedPermissions:
		res := source.GetDeniedPermissions()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Authorization: %d", fp.selector))
	}
}

func (fp *Authorization_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Authorization))
}

// GetDefault returns a default value of the field type
func (fp *Authorization_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Authorization_FieldPathSelectorGrantedPermissions:
		return ([]string)(nil)
	case Authorization_FieldPathSelectorDeniedPermissions:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Authorization: %d", fp.selector))
	}
}

func (fp *Authorization_FieldTerminalPath) ClearValue(item *Authorization) {
	if item != nil {
		switch fp.selector {
		case Authorization_FieldPathSelectorGrantedPermissions:
			item.GrantedPermissions = nil
		case Authorization_FieldPathSelectorDeniedPermissions:
			item.DeniedPermissions = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Authorization: %d", fp.selector))
		}
	}
}

func (fp *Authorization_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Authorization))
}

// IsLeaf - whether field path is holds simple value
func (fp *Authorization_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Authorization_FieldPathSelectorGrantedPermissions ||
		fp.selector == Authorization_FieldPathSelectorDeniedPermissions
}

func (fp *Authorization_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Authorization_FieldTerminalPath) WithIValue(value interface{}) Authorization_FieldPathValue {
	switch fp.selector {
	case Authorization_FieldPathSelectorGrantedPermissions:
		return &Authorization_FieldTerminalPathValue{Authorization_FieldTerminalPath: *fp, value: value.([]string)}
	case Authorization_FieldPathSelectorDeniedPermissions:
		return &Authorization_FieldTerminalPathValue{Authorization_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Authorization: %d", fp.selector))
	}
}

func (fp *Authorization_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Authorization_FieldTerminalPath) WithIArrayOfValues(values interface{}) Authorization_FieldPathArrayOfValues {
	fpaov := &Authorization_FieldTerminalPathArrayOfValues{Authorization_FieldTerminalPath: *fp}
	switch fp.selector {
	case Authorization_FieldPathSelectorGrantedPermissions:
		return &Authorization_FieldTerminalPathArrayOfValues{Authorization_FieldTerminalPath: *fp, values: values.([][]string)}
	case Authorization_FieldPathSelectorDeniedPermissions:
		return &Authorization_FieldTerminalPathArrayOfValues{Authorization_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Authorization: %d", fp.selector))
	}
	return fpaov
}

func (fp *Authorization_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Authorization_FieldTerminalPath) WithIArrayItemValue(value interface{}) Authorization_FieldPathArrayItemValue {
	switch fp.selector {
	case Authorization_FieldPathSelectorGrantedPermissions:
		return &Authorization_FieldTerminalPathArrayItemValue{Authorization_FieldTerminalPath: *fp, value: value.(string)}
	case Authorization_FieldPathSelectorDeniedPermissions:
		return &Authorization_FieldTerminalPathArrayItemValue{Authorization_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for Authorization: %d", fp.selector))
	}
}

func (fp *Authorization_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Authorization_FieldPathValue allows storing values for Authorization fields according to their type
type Authorization_FieldPathValue interface {
	Authorization_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Authorization)
	CompareWith(*Authorization) (cmp int, comparable bool)
}

func ParseAuthorization_FieldPathValue(pathStr, valueStr string) (Authorization_FieldPathValue, error) {
	fp, err := ParseAuthorization_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Authorization field path value from %s: %v", valueStr, err)
	}
	return fpv.(Authorization_FieldPathValue), nil
}

func MustParseAuthorization_FieldPathValue(pathStr, valueStr string) Authorization_FieldPathValue {
	fpv, err := ParseAuthorization_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Authorization_FieldTerminalPathValue struct {
	Authorization_FieldTerminalPath
	value interface{}
}

var _ Authorization_FieldPathValue = (*Authorization_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Authorization' as interface{}
func (fpv *Authorization_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Authorization_FieldTerminalPathValue) AsGrantedPermissionsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *Authorization_FieldTerminalPathValue) AsDeniedPermissionsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object Authorization
func (fpv *Authorization_FieldTerminalPathValue) SetTo(target **Authorization) {
	if *target == nil {
		*target = new(Authorization)
	}
	switch fpv.selector {
	case Authorization_FieldPathSelectorGrantedPermissions:
		(*target).GrantedPermissions = fpv.value.([]string)
	case Authorization_FieldPathSelectorDeniedPermissions:
		(*target).DeniedPermissions = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for Authorization: %d", fpv.selector))
	}
}

func (fpv *Authorization_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Authorization)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Authorization_FieldTerminalPathValue' with the value under path in 'Authorization'.
func (fpv *Authorization_FieldTerminalPathValue) CompareWith(source *Authorization) (int, bool) {
	switch fpv.selector {
	case Authorization_FieldPathSelectorGrantedPermissions:
		return 0, false
	case Authorization_FieldPathSelectorDeniedPermissions:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Authorization: %d", fpv.selector))
	}
}

func (fpv *Authorization_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Authorization))
}

// Authorization_FieldPathArrayItemValue allows storing single item in Path-specific values for Authorization according to their type
// Present only for array (repeated) types.
type Authorization_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Authorization_FieldPath
	ContainsValue(*Authorization) bool
}

// ParseAuthorization_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseAuthorization_FieldPathArrayItemValue(pathStr, valueStr string) (Authorization_FieldPathArrayItemValue, error) {
	fp, err := ParseAuthorization_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Authorization field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Authorization_FieldPathArrayItemValue), nil
}

func MustParseAuthorization_FieldPathArrayItemValue(pathStr, valueStr string) Authorization_FieldPathArrayItemValue {
	fpaiv, err := ParseAuthorization_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Authorization_FieldTerminalPathArrayItemValue struct {
	Authorization_FieldTerminalPath
	value interface{}
}

var _ Authorization_FieldPathArrayItemValue = (*Authorization_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Authorization as interface{}
func (fpaiv *Authorization_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Authorization_FieldTerminalPathArrayItemValue) AsGrantedPermissionsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}
func (fpaiv *Authorization_FieldTerminalPathArrayItemValue) AsDeniedPermissionsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *Authorization_FieldTerminalPathArrayItemValue) GetSingle(source *Authorization) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Authorization_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Authorization))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Authorization'
func (fpaiv *Authorization_FieldTerminalPathArrayItemValue) ContainsValue(source *Authorization) bool {
	slice := fpaiv.Authorization_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Authorization_FieldPathArrayOfValues allows storing slice of values for Authorization fields according to their type
type Authorization_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Authorization_FieldPath
}

func ParseAuthorization_FieldPathArrayOfValues(pathStr, valuesStr string) (Authorization_FieldPathArrayOfValues, error) {
	fp, err := ParseAuthorization_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Authorization field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Authorization_FieldPathArrayOfValues), nil
}

func MustParseAuthorization_FieldPathArrayOfValues(pathStr, valuesStr string) Authorization_FieldPathArrayOfValues {
	fpaov, err := ParseAuthorization_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Authorization_FieldTerminalPathArrayOfValues struct {
	Authorization_FieldTerminalPath
	values interface{}
}

var _ Authorization_FieldPathArrayOfValues = (*Authorization_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Authorization_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Authorization_FieldPathSelectorGrantedPermissions:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case Authorization_FieldPathSelectorDeniedPermissions:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Authorization_FieldTerminalPathArrayOfValues) AsGrantedPermissionsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *Authorization_FieldTerminalPathArrayOfValues) AsDeniedPermissionsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ServiceData_FieldPath interface {
	gotenobject.FieldPath
	Selector() ServiceData_FieldPathSelector
	Get(source *ServiceData) []interface{}
	GetSingle(source *ServiceData) (interface{}, bool)
	ClearValue(item *ServiceData)

	// Those methods build corresponding ServiceData_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ServiceData_FieldPathValue
	WithIArrayOfValues(values interface{}) ServiceData_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ServiceData_FieldPathArrayItemValue
}

type ServiceData_FieldPathSelector int32

const (
	ServiceData_FieldPathSelectorName     ServiceData_FieldPathSelector = 0
	ServiceData_FieldPathSelectorRegionId ServiceData_FieldPathSelector = 1
)

func (s ServiceData_FieldPathSelector) String() string {
	switch s {
	case ServiceData_FieldPathSelectorName:
		return "name"
	case ServiceData_FieldPathSelectorRegionId:
		return "region_id"
	default:
		panic(fmt.Sprintf("Invalid selector for ServiceData: %d", s))
	}
}

func BuildServiceData_FieldPath(fp gotenobject.RawFieldPath) (ServiceData_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ServiceData")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &ServiceData_FieldTerminalPath{selector: ServiceData_FieldPathSelectorName}, nil
		case "region_id", "regionId", "region-id":
			return &ServiceData_FieldTerminalPath{selector: ServiceData_FieldPathSelectorRegionId}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ServiceData", fp)
}

func ParseServiceData_FieldPath(rawField string) (ServiceData_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildServiceData_FieldPath(fp)
}

func MustParseServiceData_FieldPath(rawField string) ServiceData_FieldPath {
	fp, err := ParseServiceData_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ServiceData_FieldTerminalPath struct {
	selector ServiceData_FieldPathSelector
}

var _ ServiceData_FieldPath = (*ServiceData_FieldTerminalPath)(nil)

func (fp *ServiceData_FieldTerminalPath) Selector() ServiceData_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ServiceData_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ServiceData_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ServiceData
func (fp *ServiceData_FieldTerminalPath) Get(source *ServiceData) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ServiceData_FieldPathSelectorName:
			values = append(values, source.Name)
		case ServiceData_FieldPathSelectorRegionId:
			values = append(values, source.RegionId)
		default:
			panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fp.selector))
		}
	}
	return
}

func (fp *ServiceData_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ServiceData))
}

// GetSingle returns value pointed by specific field of from source ServiceData
func (fp *ServiceData_FieldTerminalPath) GetSingle(source *ServiceData) (interface{}, bool) {
	switch fp.selector {
	case ServiceData_FieldPathSelectorName:
		return source.GetName(), source != nil
	case ServiceData_FieldPathSelectorRegionId:
		return source.GetRegionId(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fp.selector))
	}
}

func (fp *ServiceData_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ServiceData))
}

// GetDefault returns a default value of the field type
func (fp *ServiceData_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ServiceData_FieldPathSelectorName:
		return ""
	case ServiceData_FieldPathSelectorRegionId:
		return ""
	default:
		panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fp.selector))
	}
}

func (fp *ServiceData_FieldTerminalPath) ClearValue(item *ServiceData) {
	if item != nil {
		switch fp.selector {
		case ServiceData_FieldPathSelectorName:
			item.Name = ""
		case ServiceData_FieldPathSelectorRegionId:
			item.RegionId = ""
		default:
			panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fp.selector))
		}
	}
}

func (fp *ServiceData_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ServiceData))
}

// IsLeaf - whether field path is holds simple value
func (fp *ServiceData_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ServiceData_FieldPathSelectorName ||
		fp.selector == ServiceData_FieldPathSelectorRegionId
}

func (fp *ServiceData_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ServiceData_FieldTerminalPath) WithIValue(value interface{}) ServiceData_FieldPathValue {
	switch fp.selector {
	case ServiceData_FieldPathSelectorName:
		return &ServiceData_FieldTerminalPathValue{ServiceData_FieldTerminalPath: *fp, value: value.(string)}
	case ServiceData_FieldPathSelectorRegionId:
		return &ServiceData_FieldTerminalPathValue{ServiceData_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fp.selector))
	}
}

func (fp *ServiceData_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ServiceData_FieldTerminalPath) WithIArrayOfValues(values interface{}) ServiceData_FieldPathArrayOfValues {
	fpaov := &ServiceData_FieldTerminalPathArrayOfValues{ServiceData_FieldTerminalPath: *fp}
	switch fp.selector {
	case ServiceData_FieldPathSelectorName:
		return &ServiceData_FieldTerminalPathArrayOfValues{ServiceData_FieldTerminalPath: *fp, values: values.([]string)}
	case ServiceData_FieldPathSelectorRegionId:
		return &ServiceData_FieldTerminalPathArrayOfValues{ServiceData_FieldTerminalPath: *fp, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fp.selector))
	}
	return fpaov
}

func (fp *ServiceData_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ServiceData_FieldTerminalPath) WithIArrayItemValue(value interface{}) ServiceData_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fp.selector))
	}
}

func (fp *ServiceData_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ServiceData_FieldPathValue allows storing values for ServiceData fields according to their type
type ServiceData_FieldPathValue interface {
	ServiceData_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ServiceData)
	CompareWith(*ServiceData) (cmp int, comparable bool)
}

func ParseServiceData_FieldPathValue(pathStr, valueStr string) (ServiceData_FieldPathValue, error) {
	fp, err := ParseServiceData_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ServiceData field path value from %s: %v", valueStr, err)
	}
	return fpv.(ServiceData_FieldPathValue), nil
}

func MustParseServiceData_FieldPathValue(pathStr, valueStr string) ServiceData_FieldPathValue {
	fpv, err := ParseServiceData_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ServiceData_FieldTerminalPathValue struct {
	ServiceData_FieldTerminalPath
	value interface{}
}

var _ ServiceData_FieldPathValue = (*ServiceData_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ServiceData' as interface{}
func (fpv *ServiceData_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ServiceData_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *ServiceData_FieldTerminalPathValue) AsRegionIdValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}

// SetTo stores value for selected field for object ServiceData
func (fpv *ServiceData_FieldTerminalPathValue) SetTo(target **ServiceData) {
	if *target == nil {
		*target = new(ServiceData)
	}
	switch fpv.selector {
	case ServiceData_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case ServiceData_FieldPathSelectorRegionId:
		(*target).RegionId = fpv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fpv.selector))
	}
}

func (fpv *ServiceData_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ServiceData)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ServiceData_FieldTerminalPathValue' with the value under path in 'ServiceData'.
func (fpv *ServiceData_FieldTerminalPathValue) CompareWith(source *ServiceData) (int, bool) {
	switch fpv.selector {
	case ServiceData_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ServiceData_FieldPathSelectorRegionId:
		leftValue := fpv.value.(string)
		rightValue := source.GetRegionId()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ServiceData: %d", fpv.selector))
	}
}

func (fpv *ServiceData_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ServiceData))
}

// ServiceData_FieldPathArrayItemValue allows storing single item in Path-specific values for ServiceData according to their type
// Present only for array (repeated) types.
type ServiceData_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ServiceData_FieldPath
	ContainsValue(*ServiceData) bool
}

// ParseServiceData_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseServiceData_FieldPathArrayItemValue(pathStr, valueStr string) (ServiceData_FieldPathArrayItemValue, error) {
	fp, err := ParseServiceData_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ServiceData field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ServiceData_FieldPathArrayItemValue), nil
}

func MustParseServiceData_FieldPathArrayItemValue(pathStr, valueStr string) ServiceData_FieldPathArrayItemValue {
	fpaiv, err := ParseServiceData_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ServiceData_FieldTerminalPathArrayItemValue struct {
	ServiceData_FieldTerminalPath
	value interface{}
}

var _ ServiceData_FieldPathArrayItemValue = (*ServiceData_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ServiceData as interface{}
func (fpaiv *ServiceData_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ServiceData_FieldTerminalPathArrayItemValue) GetSingle(source *ServiceData) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ServiceData_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ServiceData))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ServiceData'
func (fpaiv *ServiceData_FieldTerminalPathArrayItemValue) ContainsValue(source *ServiceData) bool {
	slice := fpaiv.ServiceData_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ServiceData_FieldPathArrayOfValues allows storing slice of values for ServiceData fields according to their type
type ServiceData_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ServiceData_FieldPath
}

func ParseServiceData_FieldPathArrayOfValues(pathStr, valuesStr string) (ServiceData_FieldPathArrayOfValues, error) {
	fp, err := ParseServiceData_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ServiceData field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ServiceData_FieldPathArrayOfValues), nil
}

func MustParseServiceData_FieldPathArrayOfValues(pathStr, valuesStr string) ServiceData_FieldPathArrayOfValues {
	fpaov, err := ParseServiceData_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ServiceData_FieldTerminalPathArrayOfValues struct {
	ServiceData_FieldTerminalPath
	values interface{}
}

var _ ServiceData_FieldPathArrayOfValues = (*ServiceData_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ServiceData_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ServiceData_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case ServiceData_FieldPathSelectorRegionId:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ServiceData_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *ServiceData_FieldTerminalPathArrayOfValues) AsRegionIdArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ObjectState_FieldPath interface {
	gotenobject.FieldPath
	Selector() ObjectState_FieldPathSelector
	Get(source *ObjectState) []interface{}
	GetSingle(source *ObjectState) (interface{}, bool)
	ClearValue(item *ObjectState)

	// Those methods build corresponding ObjectState_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ObjectState_FieldPathValue
	WithIArrayOfValues(values interface{}) ObjectState_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ObjectState_FieldPathArrayItemValue
}

type ObjectState_FieldPathSelector int32

const (
	ObjectState_FieldPathSelectorData   ObjectState_FieldPathSelector = 0
	ObjectState_FieldPathSelectorLabels ObjectState_FieldPathSelector = 1
)

func (s ObjectState_FieldPathSelector) String() string {
	switch s {
	case ObjectState_FieldPathSelectorData:
		return "data"
	case ObjectState_FieldPathSelectorLabels:
		return "labels"
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", s))
	}
}

func BuildObjectState_FieldPath(fp gotenobject.RawFieldPath) (ObjectState_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ObjectState")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "data":
			return &ObjectState_FieldTerminalPath{selector: ObjectState_FieldPathSelectorData}, nil
		case "labels":
			return &ObjectState_FieldTerminalPath{selector: ObjectState_FieldPathSelectorLabels}, nil
		}
	} else {
		switch fp[0] {
		case "labels":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object ObjectState)", fp)
			}
			return &ObjectState_FieldPathMap{selector: ObjectState_FieldPathSelectorLabels, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ObjectState", fp)
}

func ParseObjectState_FieldPath(rawField string) (ObjectState_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildObjectState_FieldPath(fp)
}

func MustParseObjectState_FieldPath(rawField string) ObjectState_FieldPath {
	fp, err := ParseObjectState_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ObjectState_FieldTerminalPath struct {
	selector ObjectState_FieldPathSelector
}

var _ ObjectState_FieldPath = (*ObjectState_FieldTerminalPath)(nil)

func (fp *ObjectState_FieldTerminalPath) Selector() ObjectState_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ObjectState_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ObjectState_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ObjectState
func (fp *ObjectState_FieldTerminalPath) Get(source *ObjectState) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ObjectState_FieldPathSelectorData:
			if source.Data != nil {
				values = append(values, source.Data)
			}
		case ObjectState_FieldPathSelectorLabels:
			values = append(values, source.Labels)
		default:
			panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fp.selector))
		}
	}
	return
}

func (fp *ObjectState_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ObjectState))
}

// GetSingle returns value pointed by specific field of from source ObjectState
func (fp *ObjectState_FieldTerminalPath) GetSingle(source *ObjectState) (interface{}, bool) {
	switch fp.selector {
	case ObjectState_FieldPathSelectorData:
		res := source.GetData()
		return res, res != nil
	case ObjectState_FieldPathSelectorLabels:
		res := source.GetLabels()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fp.selector))
	}
}

func (fp *ObjectState_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ObjectState))
}

// GetDefault returns a default value of the field type
func (fp *ObjectState_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ObjectState_FieldPathSelectorData:
		return (*anypb.Any)(nil)
	case ObjectState_FieldPathSelectorLabels:
		return (map[string]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fp.selector))
	}
}

func (fp *ObjectState_FieldTerminalPath) ClearValue(item *ObjectState) {
	if item != nil {
		switch fp.selector {
		case ObjectState_FieldPathSelectorData:
			item.Data = nil
		case ObjectState_FieldPathSelectorLabels:
			item.Labels = nil
		default:
			panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fp.selector))
		}
	}
}

func (fp *ObjectState_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ObjectState))
}

// IsLeaf - whether field path is holds simple value
func (fp *ObjectState_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ObjectState_FieldPathSelectorData ||
		fp.selector == ObjectState_FieldPathSelectorLabels
}

func (fp *ObjectState_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ObjectState_FieldTerminalPath) WithIValue(value interface{}) ObjectState_FieldPathValue {
	switch fp.selector {
	case ObjectState_FieldPathSelectorData:
		return &ObjectState_FieldTerminalPathValue{ObjectState_FieldTerminalPath: *fp, value: value.(*anypb.Any)}
	case ObjectState_FieldPathSelectorLabels:
		return &ObjectState_FieldTerminalPathValue{ObjectState_FieldTerminalPath: *fp, value: value.(map[string]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fp.selector))
	}
}

func (fp *ObjectState_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ObjectState_FieldTerminalPath) WithIArrayOfValues(values interface{}) ObjectState_FieldPathArrayOfValues {
	fpaov := &ObjectState_FieldTerminalPathArrayOfValues{ObjectState_FieldTerminalPath: *fp}
	switch fp.selector {
	case ObjectState_FieldPathSelectorData:
		return &ObjectState_FieldTerminalPathArrayOfValues{ObjectState_FieldTerminalPath: *fp, values: values.([]*anypb.Any)}
	case ObjectState_FieldPathSelectorLabels:
		return &ObjectState_FieldTerminalPathArrayOfValues{ObjectState_FieldTerminalPath: *fp, values: values.([]map[string]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fp.selector))
	}
	return fpaov
}

func (fp *ObjectState_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ObjectState_FieldTerminalPath) WithIArrayItemValue(value interface{}) ObjectState_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fp.selector))
	}
}

func (fp *ObjectState_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type ObjectState_FieldPathMap struct {
	key      string
	selector ObjectState_FieldPathSelector
}

var _ ObjectState_FieldPath = (*ObjectState_FieldPathMap)(nil)

func (fpm *ObjectState_FieldPathMap) Selector() ObjectState_FieldPathSelector {
	return fpm.selector
}

func (fpm *ObjectState_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *ObjectState_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *ObjectState_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source ObjectState
func (fpm *ObjectState_FieldPathMap) Get(source *ObjectState) (values []interface{}) {
	switch fpm.selector {
	case ObjectState_FieldPathSelectorLabels:
		if value, ok := source.GetLabels()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpm.selector))
	}
	return
}

func (fpm *ObjectState_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*ObjectState))
}

// GetSingle returns value by selected field map key from source ObjectState
func (fpm *ObjectState_FieldPathMap) GetSingle(source *ObjectState) (interface{}, bool) {
	switch fpm.selector {
	case ObjectState_FieldPathSelectorLabels:
		res, ok := source.GetLabels()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpm.selector))
	}
}

func (fpm *ObjectState_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*ObjectState))
}

// GetDefault returns a default value of the field type
func (fpm *ObjectState_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case ObjectState_FieldPathSelectorLabels:
		var v string
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpm.selector))
	}
}

func (fpm *ObjectState_FieldPathMap) ClearValue(item *ObjectState) {
	if item != nil {
		switch fpm.selector {
		case ObjectState_FieldPathSelectorLabels:
			delete(item.Labels, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpm.selector))
		}
	}
}

func (fpm *ObjectState_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*ObjectState))
}

// IsLeaf - whether field path is holds simple value
func (fpm *ObjectState_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case ObjectState_FieldPathSelectorLabels:
		return true
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpm.selector))
	}
}

func (fpm *ObjectState_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *ObjectState_FieldPathMap) WithIValue(value interface{}) ObjectState_FieldPathValue {
	switch fpm.selector {
	case ObjectState_FieldPathSelectorLabels:
		return &ObjectState_FieldPathMapValue{ObjectState_FieldPathMap: *fpm, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpm.selector))
	}
}

func (fpm *ObjectState_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *ObjectState_FieldPathMap) WithIArrayOfValues(values interface{}) ObjectState_FieldPathArrayOfValues {
	switch fpm.selector {
	case ObjectState_FieldPathSelectorLabels:
		return &ObjectState_FieldPathMapArrayOfValues{ObjectState_FieldPathMap: *fpm, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpm.selector))
	}
}

func (fpm *ObjectState_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *ObjectState_FieldPathMap) WithIArrayItemValue(value interface{}) ObjectState_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *ObjectState_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

// ObjectState_FieldPathValue allows storing values for ObjectState fields according to their type
type ObjectState_FieldPathValue interface {
	ObjectState_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ObjectState)
	CompareWith(*ObjectState) (cmp int, comparable bool)
}

func ParseObjectState_FieldPathValue(pathStr, valueStr string) (ObjectState_FieldPathValue, error) {
	fp, err := ParseObjectState_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ObjectState field path value from %s: %v", valueStr, err)
	}
	return fpv.(ObjectState_FieldPathValue), nil
}

func MustParseObjectState_FieldPathValue(pathStr, valueStr string) ObjectState_FieldPathValue {
	fpv, err := ParseObjectState_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ObjectState_FieldTerminalPathValue struct {
	ObjectState_FieldTerminalPath
	value interface{}
}

var _ ObjectState_FieldPathValue = (*ObjectState_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ObjectState' as interface{}
func (fpv *ObjectState_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ObjectState_FieldTerminalPathValue) AsDataValue() (*anypb.Any, bool) {
	res, ok := fpv.value.(*anypb.Any)
	return res, ok
}
func (fpv *ObjectState_FieldTerminalPathValue) AsLabelsValue() (map[string]string, bool) {
	res, ok := fpv.value.(map[string]string)
	return res, ok
}

// SetTo stores value for selected field for object ObjectState
func (fpv *ObjectState_FieldTerminalPathValue) SetTo(target **ObjectState) {
	if *target == nil {
		*target = new(ObjectState)
	}
	switch fpv.selector {
	case ObjectState_FieldPathSelectorData:
		(*target).Data = fpv.value.(*anypb.Any)
	case ObjectState_FieldPathSelectorLabels:
		(*target).Labels = fpv.value.(map[string]string)
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpv.selector))
	}
}

func (fpv *ObjectState_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ObjectState)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ObjectState_FieldTerminalPathValue' with the value under path in 'ObjectState'.
func (fpv *ObjectState_FieldTerminalPathValue) CompareWith(source *ObjectState) (int, bool) {
	switch fpv.selector {
	case ObjectState_FieldPathSelectorData:
		return 0, false
	case ObjectState_FieldPathSelectorLabels:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpv.selector))
	}
}

func (fpv *ObjectState_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ObjectState))
}

type ObjectState_FieldPathMapValue struct {
	ObjectState_FieldPathMap
	value interface{}
}

var _ ObjectState_FieldPathValue = (*ObjectState_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in ObjectState as interface{}
func (fpmv *ObjectState_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *ObjectState_FieldPathMapValue) AsLabelsElementValue() (string, bool) {
	res, ok := fpmv.value.(string)
	return res, ok
}

// SetTo stores value for selected field in ObjectState
func (fpmv *ObjectState_FieldPathMapValue) SetTo(target **ObjectState) {
	if *target == nil {
		*target = new(ObjectState)
	}
	switch fpmv.selector {
	case ObjectState_FieldPathSelectorLabels:
		if (*target).Labels == nil {
			(*target).Labels = make(map[string]string)
		}
		(*target).Labels[fpmv.key] = fpmv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpmv.selector))
	}
}

func (fpmv *ObjectState_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ObjectState)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ObjectState_FieldPathMapValue' with the value under path in 'ObjectState'.
func (fpmv *ObjectState_FieldPathMapValue) CompareWith(source *ObjectState) (int, bool) {
	switch fpmv.selector {
	case ObjectState_FieldPathSelectorLabels:
		leftValue := fpmv.value.(string)
		rightValue := source.GetLabels()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ObjectState: %d", fpmv.selector))
	}
}

func (fpmv *ObjectState_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*ObjectState))
}

// ObjectState_FieldPathArrayItemValue allows storing single item in Path-specific values for ObjectState according to their type
// Present only for array (repeated) types.
type ObjectState_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ObjectState_FieldPath
	ContainsValue(*ObjectState) bool
}

// ParseObjectState_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseObjectState_FieldPathArrayItemValue(pathStr, valueStr string) (ObjectState_FieldPathArrayItemValue, error) {
	fp, err := ParseObjectState_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ObjectState field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ObjectState_FieldPathArrayItemValue), nil
}

func MustParseObjectState_FieldPathArrayItemValue(pathStr, valueStr string) ObjectState_FieldPathArrayItemValue {
	fpaiv, err := ParseObjectState_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ObjectState_FieldTerminalPathArrayItemValue struct {
	ObjectState_FieldTerminalPath
	value interface{}
}

var _ ObjectState_FieldPathArrayItemValue = (*ObjectState_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ObjectState as interface{}
func (fpaiv *ObjectState_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ObjectState_FieldTerminalPathArrayItemValue) GetSingle(source *ObjectState) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ObjectState_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ObjectState))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ObjectState'
func (fpaiv *ObjectState_FieldTerminalPathArrayItemValue) ContainsValue(source *ObjectState) bool {
	slice := fpaiv.ObjectState_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ObjectState_FieldPathArrayOfValues allows storing slice of values for ObjectState fields according to their type
type ObjectState_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ObjectState_FieldPath
}

func ParseObjectState_FieldPathArrayOfValues(pathStr, valuesStr string) (ObjectState_FieldPathArrayOfValues, error) {
	fp, err := ParseObjectState_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ObjectState field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ObjectState_FieldPathArrayOfValues), nil
}

func MustParseObjectState_FieldPathArrayOfValues(pathStr, valuesStr string) ObjectState_FieldPathArrayOfValues {
	fpaov, err := ParseObjectState_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ObjectState_FieldTerminalPathArrayOfValues struct {
	ObjectState_FieldTerminalPath
	values interface{}
}

var _ ObjectState_FieldPathArrayOfValues = (*ObjectState_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ObjectState_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ObjectState_FieldPathSelectorData:
		for _, v := range fpaov.values.([]*anypb.Any) {
			values = append(values, v)
		}
	case ObjectState_FieldPathSelectorLabels:
		for _, v := range fpaov.values.([]map[string]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ObjectState_FieldTerminalPathArrayOfValues) AsDataArrayOfValues() ([]*anypb.Any, bool) {
	res, ok := fpaov.values.([]*anypb.Any)
	return res, ok
}
func (fpaov *ObjectState_FieldTerminalPathArrayOfValues) AsLabelsArrayOfValues() ([]map[string]string, bool) {
	res, ok := fpaov.values.([]map[string]string)
	return res, ok
}

type ObjectState_FieldPathMapArrayOfValues struct {
	ObjectState_FieldPathMap
	values interface{}
}

var _ ObjectState_FieldPathArrayOfValues = (*ObjectState_FieldPathMapArrayOfValues)(nil)

func (fpmaov *ObjectState_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case ObjectState_FieldPathSelectorLabels:
		for _, v := range fpmaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *ObjectState_FieldPathMapArrayOfValues) AsLabelsArrayOfElementValues() ([]string, bool) {
	res, ok := fpmaov.values.([]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type LabelDescriptor_FieldPath interface {
	gotenobject.FieldPath
	Selector() LabelDescriptor_FieldPathSelector
	Get(source *LabelDescriptor) []interface{}
	GetSingle(source *LabelDescriptor) (interface{}, bool)
	ClearValue(item *LabelDescriptor)

	// Those methods build corresponding LabelDescriptor_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) LabelDescriptor_FieldPathValue
	WithIArrayOfValues(values interface{}) LabelDescriptor_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) LabelDescriptor_FieldPathArrayItemValue
}

type LabelDescriptor_FieldPathSelector int32

const (
	LabelDescriptor_FieldPathSelectorKey      LabelDescriptor_FieldPathSelector = 0
	LabelDescriptor_FieldPathSelectorVersions LabelDescriptor_FieldPathSelector = 1
)

func (s LabelDescriptor_FieldPathSelector) String() string {
	switch s {
	case LabelDescriptor_FieldPathSelectorKey:
		return "key"
	case LabelDescriptor_FieldPathSelectorVersions:
		return "versions"
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", s))
	}
}

func BuildLabelDescriptor_FieldPath(fp gotenobject.RawFieldPath) (LabelDescriptor_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object LabelDescriptor")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "key":
			return &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorKey}, nil
		case "versions":
			return &LabelDescriptor_FieldTerminalPath{selector: LabelDescriptor_FieldPathSelectorVersions}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object LabelDescriptor", fp)
}

func ParseLabelDescriptor_FieldPath(rawField string) (LabelDescriptor_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLabelDescriptor_FieldPath(fp)
}

func MustParseLabelDescriptor_FieldPath(rawField string) LabelDescriptor_FieldPath {
	fp, err := ParseLabelDescriptor_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type LabelDescriptor_FieldTerminalPath struct {
	selector LabelDescriptor_FieldPathSelector
}

var _ LabelDescriptor_FieldPath = (*LabelDescriptor_FieldTerminalPath)(nil)

func (fp *LabelDescriptor_FieldTerminalPath) Selector() LabelDescriptor_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *LabelDescriptor_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *LabelDescriptor_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source LabelDescriptor
func (fp *LabelDescriptor_FieldTerminalPath) Get(source *LabelDescriptor) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case LabelDescriptor_FieldPathSelectorKey:
			values = append(values, source.Key)
		case LabelDescriptor_FieldPathSelectorVersions:
			for _, value := range source.GetVersions() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
		}
	}
	return
}

func (fp *LabelDescriptor_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*LabelDescriptor))
}

// GetSingle returns value pointed by specific field of from source LabelDescriptor
func (fp *LabelDescriptor_FieldTerminalPath) GetSingle(source *LabelDescriptor) (interface{}, bool) {
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		return source.GetKey(), source != nil
	case LabelDescriptor_FieldPathSelectorVersions:
		res := source.GetVersions()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*LabelDescriptor))
}

// GetDefault returns a default value of the field type
func (fp *LabelDescriptor_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		return ""
	case LabelDescriptor_FieldPathSelectorVersions:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) ClearValue(item *LabelDescriptor) {
	if item != nil {
		switch fp.selector {
		case LabelDescriptor_FieldPathSelectorKey:
			item.Key = ""
		case LabelDescriptor_FieldPathSelectorVersions:
			item.Versions = nil
		default:
			panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
		}
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*LabelDescriptor))
}

// IsLeaf - whether field path is holds simple value
func (fp *LabelDescriptor_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == LabelDescriptor_FieldPathSelectorKey ||
		fp.selector == LabelDescriptor_FieldPathSelectorVersions
}

func (fp *LabelDescriptor_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *LabelDescriptor_FieldTerminalPath) WithIValue(value interface{}) LabelDescriptor_FieldPathValue {
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		return &LabelDescriptor_FieldTerminalPathValue{LabelDescriptor_FieldTerminalPath: *fp, value: value.(string)}
	case LabelDescriptor_FieldPathSelectorVersions:
		return &LabelDescriptor_FieldTerminalPathValue{LabelDescriptor_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *LabelDescriptor_FieldTerminalPath) WithIArrayOfValues(values interface{}) LabelDescriptor_FieldPathArrayOfValues {
	fpaov := &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp}
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		return &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp, values: values.([]string)}
	case LabelDescriptor_FieldPathSelectorVersions:
		return &LabelDescriptor_FieldTerminalPathArrayOfValues{LabelDescriptor_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
	return fpaov
}

func (fp *LabelDescriptor_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *LabelDescriptor_FieldTerminalPath) WithIArrayItemValue(value interface{}) LabelDescriptor_FieldPathArrayItemValue {
	switch fp.selector {
	case LabelDescriptor_FieldPathSelectorVersions:
		return &LabelDescriptor_FieldTerminalPathArrayItemValue{LabelDescriptor_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fp.selector))
	}
}

func (fp *LabelDescriptor_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// LabelDescriptor_FieldPathValue allows storing values for LabelDescriptor fields according to their type
type LabelDescriptor_FieldPathValue interface {
	LabelDescriptor_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **LabelDescriptor)
	CompareWith(*LabelDescriptor) (cmp int, comparable bool)
}

func ParseLabelDescriptor_FieldPathValue(pathStr, valueStr string) (LabelDescriptor_FieldPathValue, error) {
	fp, err := ParseLabelDescriptor_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelDescriptor field path value from %s: %v", valueStr, err)
	}
	return fpv.(LabelDescriptor_FieldPathValue), nil
}

func MustParseLabelDescriptor_FieldPathValue(pathStr, valueStr string) LabelDescriptor_FieldPathValue {
	fpv, err := ParseLabelDescriptor_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type LabelDescriptor_FieldTerminalPathValue struct {
	LabelDescriptor_FieldTerminalPath
	value interface{}
}

var _ LabelDescriptor_FieldPathValue = (*LabelDescriptor_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'LabelDescriptor' as interface{}
func (fpv *LabelDescriptor_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *LabelDescriptor_FieldTerminalPathValue) AsKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *LabelDescriptor_FieldTerminalPathValue) AsVersionsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object LabelDescriptor
func (fpv *LabelDescriptor_FieldTerminalPathValue) SetTo(target **LabelDescriptor) {
	if *target == nil {
		*target = new(LabelDescriptor)
	}
	switch fpv.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		(*target).Key = fpv.value.(string)
	case LabelDescriptor_FieldPathSelectorVersions:
		(*target).Versions = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fpv.selector))
	}
}

func (fpv *LabelDescriptor_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LabelDescriptor)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LabelDescriptor_FieldTerminalPathValue' with the value under path in 'LabelDescriptor'.
func (fpv *LabelDescriptor_FieldTerminalPathValue) CompareWith(source *LabelDescriptor) (int, bool) {
	switch fpv.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case LabelDescriptor_FieldPathSelectorVersions:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for LabelDescriptor: %d", fpv.selector))
	}
}

func (fpv *LabelDescriptor_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*LabelDescriptor))
}

// LabelDescriptor_FieldPathArrayItemValue allows storing single item in Path-specific values for LabelDescriptor according to their type
// Present only for array (repeated) types.
type LabelDescriptor_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	LabelDescriptor_FieldPath
	ContainsValue(*LabelDescriptor) bool
}

// ParseLabelDescriptor_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLabelDescriptor_FieldPathArrayItemValue(pathStr, valueStr string) (LabelDescriptor_FieldPathArrayItemValue, error) {
	fp, err := ParseLabelDescriptor_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelDescriptor field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(LabelDescriptor_FieldPathArrayItemValue), nil
}

func MustParseLabelDescriptor_FieldPathArrayItemValue(pathStr, valueStr string) LabelDescriptor_FieldPathArrayItemValue {
	fpaiv, err := ParseLabelDescriptor_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type LabelDescriptor_FieldTerminalPathArrayItemValue struct {
	LabelDescriptor_FieldTerminalPath
	value interface{}
}

var _ LabelDescriptor_FieldPathArrayItemValue = (*LabelDescriptor_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object LabelDescriptor as interface{}
func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) AsVersionsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) GetSingle(source *LabelDescriptor) (interface{}, bool) {
	return nil, false
}

func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*LabelDescriptor))
}

// Contains returns a boolean indicating if value that is being held is present in given 'LabelDescriptor'
func (fpaiv *LabelDescriptor_FieldTerminalPathArrayItemValue) ContainsValue(source *LabelDescriptor) bool {
	slice := fpaiv.LabelDescriptor_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// LabelDescriptor_FieldPathArrayOfValues allows storing slice of values for LabelDescriptor fields according to their type
type LabelDescriptor_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	LabelDescriptor_FieldPath
}

func ParseLabelDescriptor_FieldPathArrayOfValues(pathStr, valuesStr string) (LabelDescriptor_FieldPathArrayOfValues, error) {
	fp, err := ParseLabelDescriptor_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelDescriptor field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(LabelDescriptor_FieldPathArrayOfValues), nil
}

func MustParseLabelDescriptor_FieldPathArrayOfValues(pathStr, valuesStr string) LabelDescriptor_FieldPathArrayOfValues {
	fpaov, err := ParseLabelDescriptor_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type LabelDescriptor_FieldTerminalPathArrayOfValues struct {
	LabelDescriptor_FieldTerminalPath
	values interface{}
}

var _ LabelDescriptor_FieldPathArrayOfValues = (*LabelDescriptor_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case LabelDescriptor_FieldPathSelectorKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case LabelDescriptor_FieldPathSelectorVersions:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) AsKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *LabelDescriptor_FieldTerminalPathArrayOfValues) AsVersionsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type LabelKeySet_FieldPath interface {
	gotenobject.FieldPath
	Selector() LabelKeySet_FieldPathSelector
	Get(source *LabelKeySet) []interface{}
	GetSingle(source *LabelKeySet) (interface{}, bool)
	ClearValue(item *LabelKeySet)

	// Those methods build corresponding LabelKeySet_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) LabelKeySet_FieldPathValue
	WithIArrayOfValues(values interface{}) LabelKeySet_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) LabelKeySet_FieldPathArrayItemValue
}

type LabelKeySet_FieldPathSelector int32

const (
	LabelKeySet_FieldPathSelectorLabelKeys LabelKeySet_FieldPathSelector = 0
	LabelKeySet_FieldPathSelectorVersions  LabelKeySet_FieldPathSelector = 1
)

func (s LabelKeySet_FieldPathSelector) String() string {
	switch s {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return "label_keys"
	case LabelKeySet_FieldPathSelectorVersions:
		return "versions"
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", s))
	}
}

func BuildLabelKeySet_FieldPath(fp gotenobject.RawFieldPath) (LabelKeySet_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object LabelKeySet")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "label_keys", "labelKeys", "label-keys":
			return &LabelKeySet_FieldTerminalPath{selector: LabelKeySet_FieldPathSelectorLabelKeys}, nil
		case "versions":
			return &LabelKeySet_FieldTerminalPath{selector: LabelKeySet_FieldPathSelectorVersions}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object LabelKeySet", fp)
}

func ParseLabelKeySet_FieldPath(rawField string) (LabelKeySet_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLabelKeySet_FieldPath(fp)
}

func MustParseLabelKeySet_FieldPath(rawField string) LabelKeySet_FieldPath {
	fp, err := ParseLabelKeySet_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type LabelKeySet_FieldTerminalPath struct {
	selector LabelKeySet_FieldPathSelector
}

var _ LabelKeySet_FieldPath = (*LabelKeySet_FieldTerminalPath)(nil)

func (fp *LabelKeySet_FieldTerminalPath) Selector() LabelKeySet_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *LabelKeySet_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *LabelKeySet_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source LabelKeySet
func (fp *LabelKeySet_FieldTerminalPath) Get(source *LabelKeySet) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case LabelKeySet_FieldPathSelectorLabelKeys:
			for _, value := range source.GetLabelKeys() {
				values = append(values, value)
			}
		case LabelKeySet_FieldPathSelectorVersions:
			for _, value := range source.GetVersions() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
		}
	}
	return
}

func (fp *LabelKeySet_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*LabelKeySet))
}

// GetSingle returns value pointed by specific field of from source LabelKeySet
func (fp *LabelKeySet_FieldTerminalPath) GetSingle(source *LabelKeySet) (interface{}, bool) {
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		res := source.GetLabelKeys()
		return res, res != nil
	case LabelKeySet_FieldPathSelectorVersions:
		res := source.GetVersions()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
}

func (fp *LabelKeySet_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*LabelKeySet))
}

// GetDefault returns a default value of the field type
func (fp *LabelKeySet_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return ([]string)(nil)
	case LabelKeySet_FieldPathSelectorVersions:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
}

func (fp *LabelKeySet_FieldTerminalPath) ClearValue(item *LabelKeySet) {
	if item != nil {
		switch fp.selector {
		case LabelKeySet_FieldPathSelectorLabelKeys:
			item.LabelKeys = nil
		case LabelKeySet_FieldPathSelectorVersions:
			item.Versions = nil
		default:
			panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
		}
	}
}

func (fp *LabelKeySet_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*LabelKeySet))
}

// IsLeaf - whether field path is holds simple value
func (fp *LabelKeySet_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == LabelKeySet_FieldPathSelectorLabelKeys ||
		fp.selector == LabelKeySet_FieldPathSelectorVersions
}

func (fp *LabelKeySet_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *LabelKeySet_FieldTerminalPath) WithIValue(value interface{}) LabelKeySet_FieldPathValue {
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return &LabelKeySet_FieldTerminalPathValue{LabelKeySet_FieldTerminalPath: *fp, value: value.([]string)}
	case LabelKeySet_FieldPathSelectorVersions:
		return &LabelKeySet_FieldTerminalPathValue{LabelKeySet_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
}

func (fp *LabelKeySet_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *LabelKeySet_FieldTerminalPath) WithIArrayOfValues(values interface{}) LabelKeySet_FieldPathArrayOfValues {
	fpaov := &LabelKeySet_FieldTerminalPathArrayOfValues{LabelKeySet_FieldTerminalPath: *fp}
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return &LabelKeySet_FieldTerminalPathArrayOfValues{LabelKeySet_FieldTerminalPath: *fp, values: values.([][]string)}
	case LabelKeySet_FieldPathSelectorVersions:
		return &LabelKeySet_FieldTerminalPathArrayOfValues{LabelKeySet_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
	return fpaov
}

func (fp *LabelKeySet_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *LabelKeySet_FieldTerminalPath) WithIArrayItemValue(value interface{}) LabelKeySet_FieldPathArrayItemValue {
	switch fp.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return &LabelKeySet_FieldTerminalPathArrayItemValue{LabelKeySet_FieldTerminalPath: *fp, value: value.(string)}
	case LabelKeySet_FieldPathSelectorVersions:
		return &LabelKeySet_FieldTerminalPathArrayItemValue{LabelKeySet_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fp.selector))
	}
}

func (fp *LabelKeySet_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// LabelKeySet_FieldPathValue allows storing values for LabelKeySet fields according to their type
type LabelKeySet_FieldPathValue interface {
	LabelKeySet_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **LabelKeySet)
	CompareWith(*LabelKeySet) (cmp int, comparable bool)
}

func ParseLabelKeySet_FieldPathValue(pathStr, valueStr string) (LabelKeySet_FieldPathValue, error) {
	fp, err := ParseLabelKeySet_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelKeySet field path value from %s: %v", valueStr, err)
	}
	return fpv.(LabelKeySet_FieldPathValue), nil
}

func MustParseLabelKeySet_FieldPathValue(pathStr, valueStr string) LabelKeySet_FieldPathValue {
	fpv, err := ParseLabelKeySet_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type LabelKeySet_FieldTerminalPathValue struct {
	LabelKeySet_FieldTerminalPath
	value interface{}
}

var _ LabelKeySet_FieldPathValue = (*LabelKeySet_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'LabelKeySet' as interface{}
func (fpv *LabelKeySet_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *LabelKeySet_FieldTerminalPathValue) AsLabelKeysValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *LabelKeySet_FieldTerminalPathValue) AsVersionsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object LabelKeySet
func (fpv *LabelKeySet_FieldTerminalPathValue) SetTo(target **LabelKeySet) {
	if *target == nil {
		*target = new(LabelKeySet)
	}
	switch fpv.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		(*target).LabelKeys = fpv.value.([]string)
	case LabelKeySet_FieldPathSelectorVersions:
		(*target).Versions = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fpv.selector))
	}
}

func (fpv *LabelKeySet_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LabelKeySet)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LabelKeySet_FieldTerminalPathValue' with the value under path in 'LabelKeySet'.
func (fpv *LabelKeySet_FieldTerminalPathValue) CompareWith(source *LabelKeySet) (int, bool) {
	switch fpv.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		return 0, false
	case LabelKeySet_FieldPathSelectorVersions:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for LabelKeySet: %d", fpv.selector))
	}
}

func (fpv *LabelKeySet_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*LabelKeySet))
}

// LabelKeySet_FieldPathArrayItemValue allows storing single item in Path-specific values for LabelKeySet according to their type
// Present only for array (repeated) types.
type LabelKeySet_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	LabelKeySet_FieldPath
	ContainsValue(*LabelKeySet) bool
}

// ParseLabelKeySet_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLabelKeySet_FieldPathArrayItemValue(pathStr, valueStr string) (LabelKeySet_FieldPathArrayItemValue, error) {
	fp, err := ParseLabelKeySet_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelKeySet field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(LabelKeySet_FieldPathArrayItemValue), nil
}

func MustParseLabelKeySet_FieldPathArrayItemValue(pathStr, valueStr string) LabelKeySet_FieldPathArrayItemValue {
	fpaiv, err := ParseLabelKeySet_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type LabelKeySet_FieldTerminalPathArrayItemValue struct {
	LabelKeySet_FieldTerminalPath
	value interface{}
}

var _ LabelKeySet_FieldPathArrayItemValue = (*LabelKeySet_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object LabelKeySet as interface{}
func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) AsLabelKeysItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}
func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) AsVersionsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) GetSingle(source *LabelKeySet) (interface{}, bool) {
	return nil, false
}

func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*LabelKeySet))
}

// Contains returns a boolean indicating if value that is being held is present in given 'LabelKeySet'
func (fpaiv *LabelKeySet_FieldTerminalPathArrayItemValue) ContainsValue(source *LabelKeySet) bool {
	slice := fpaiv.LabelKeySet_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// LabelKeySet_FieldPathArrayOfValues allows storing slice of values for LabelKeySet fields according to their type
type LabelKeySet_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	LabelKeySet_FieldPath
}

func ParseLabelKeySet_FieldPathArrayOfValues(pathStr, valuesStr string) (LabelKeySet_FieldPathArrayOfValues, error) {
	fp, err := ParseLabelKeySet_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelKeySet field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(LabelKeySet_FieldPathArrayOfValues), nil
}

func MustParseLabelKeySet_FieldPathArrayOfValues(pathStr, valuesStr string) LabelKeySet_FieldPathArrayOfValues {
	fpaov, err := ParseLabelKeySet_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type LabelKeySet_FieldTerminalPathArrayOfValues struct {
	LabelKeySet_FieldTerminalPath
	values interface{}
}

var _ LabelKeySet_FieldPathArrayOfValues = (*LabelKeySet_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *LabelKeySet_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case LabelKeySet_FieldPathSelectorLabelKeys:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case LabelKeySet_FieldPathSelectorVersions:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *LabelKeySet_FieldTerminalPathArrayOfValues) AsLabelKeysArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *LabelKeySet_FieldTerminalPathArrayOfValues) AsVersionsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type TimeInterval_FieldPath interface {
	gotenobject.FieldPath
	Selector() TimeInterval_FieldPathSelector
	Get(source *TimeInterval) []interface{}
	GetSingle(source *TimeInterval) (interface{}, bool)
	ClearValue(item *TimeInterval)

	// Those methods build corresponding TimeInterval_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) TimeInterval_FieldPathValue
	WithIArrayOfValues(values interface{}) TimeInterval_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) TimeInterval_FieldPathArrayItemValue
}

type TimeInterval_FieldPathSelector int32

const (
	TimeInterval_FieldPathSelectorEndTime   TimeInterval_FieldPathSelector = 0
	TimeInterval_FieldPathSelectorStartTime TimeInterval_FieldPathSelector = 1
)

func (s TimeInterval_FieldPathSelector) String() string {
	switch s {
	case TimeInterval_FieldPathSelectorEndTime:
		return "end_time"
	case TimeInterval_FieldPathSelectorStartTime:
		return "start_time"
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", s))
	}
}

func BuildTimeInterval_FieldPath(fp gotenobject.RawFieldPath) (TimeInterval_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object TimeInterval")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "end_time", "endTime", "end-time":
			return &TimeInterval_FieldTerminalPath{selector: TimeInterval_FieldPathSelectorEndTime}, nil
		case "start_time", "startTime", "start-time":
			return &TimeInterval_FieldTerminalPath{selector: TimeInterval_FieldPathSelectorStartTime}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object TimeInterval", fp)
}

func ParseTimeInterval_FieldPath(rawField string) (TimeInterval_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildTimeInterval_FieldPath(fp)
}

func MustParseTimeInterval_FieldPath(rawField string) TimeInterval_FieldPath {
	fp, err := ParseTimeInterval_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type TimeInterval_FieldTerminalPath struct {
	selector TimeInterval_FieldPathSelector
}

var _ TimeInterval_FieldPath = (*TimeInterval_FieldTerminalPath)(nil)

func (fp *TimeInterval_FieldTerminalPath) Selector() TimeInterval_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *TimeInterval_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *TimeInterval_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source TimeInterval
func (fp *TimeInterval_FieldTerminalPath) Get(source *TimeInterval) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case TimeInterval_FieldPathSelectorEndTime:
			if source.EndTime != nil {
				values = append(values, source.EndTime)
			}
		case TimeInterval_FieldPathSelectorStartTime:
			if source.StartTime != nil {
				values = append(values, source.StartTime)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
		}
	}
	return
}

func (fp *TimeInterval_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*TimeInterval))
}

// GetSingle returns value pointed by specific field of from source TimeInterval
func (fp *TimeInterval_FieldTerminalPath) GetSingle(source *TimeInterval) (interface{}, bool) {
	switch fp.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		res := source.GetEndTime()
		return res, res != nil
	case TimeInterval_FieldPathSelectorStartTime:
		res := source.GetStartTime()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
}

func (fp *TimeInterval_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*TimeInterval))
}

// GetDefault returns a default value of the field type
func (fp *TimeInterval_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		return (*timestamppb.Timestamp)(nil)
	case TimeInterval_FieldPathSelectorStartTime:
		return (*timestamppb.Timestamp)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
}

func (fp *TimeInterval_FieldTerminalPath) ClearValue(item *TimeInterval) {
	if item != nil {
		switch fp.selector {
		case TimeInterval_FieldPathSelectorEndTime:
			item.EndTime = nil
		case TimeInterval_FieldPathSelectorStartTime:
			item.StartTime = nil
		default:
			panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
		}
	}
}

func (fp *TimeInterval_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*TimeInterval))
}

// IsLeaf - whether field path is holds simple value
func (fp *TimeInterval_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == TimeInterval_FieldPathSelectorEndTime ||
		fp.selector == TimeInterval_FieldPathSelectorStartTime
}

func (fp *TimeInterval_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *TimeInterval_FieldTerminalPath) WithIValue(value interface{}) TimeInterval_FieldPathValue {
	switch fp.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		return &TimeInterval_FieldTerminalPathValue{TimeInterval_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	case TimeInterval_FieldPathSelectorStartTime:
		return &TimeInterval_FieldTerminalPathValue{TimeInterval_FieldTerminalPath: *fp, value: value.(*timestamppb.Timestamp)}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
}

func (fp *TimeInterval_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *TimeInterval_FieldTerminalPath) WithIArrayOfValues(values interface{}) TimeInterval_FieldPathArrayOfValues {
	fpaov := &TimeInterval_FieldTerminalPathArrayOfValues{TimeInterval_FieldTerminalPath: *fp}
	switch fp.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		return &TimeInterval_FieldTerminalPathArrayOfValues{TimeInterval_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	case TimeInterval_FieldPathSelectorStartTime:
		return &TimeInterval_FieldTerminalPathArrayOfValues{TimeInterval_FieldTerminalPath: *fp, values: values.([]*timestamppb.Timestamp)}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
	return fpaov
}

func (fp *TimeInterval_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *TimeInterval_FieldTerminalPath) WithIArrayItemValue(value interface{}) TimeInterval_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fp.selector))
	}
}

func (fp *TimeInterval_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// TimeInterval_FieldPathValue allows storing values for TimeInterval fields according to their type
type TimeInterval_FieldPathValue interface {
	TimeInterval_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **TimeInterval)
	CompareWith(*TimeInterval) (cmp int, comparable bool)
}

func ParseTimeInterval_FieldPathValue(pathStr, valueStr string) (TimeInterval_FieldPathValue, error) {
	fp, err := ParseTimeInterval_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeInterval field path value from %s: %v", valueStr, err)
	}
	return fpv.(TimeInterval_FieldPathValue), nil
}

func MustParseTimeInterval_FieldPathValue(pathStr, valueStr string) TimeInterval_FieldPathValue {
	fpv, err := ParseTimeInterval_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type TimeInterval_FieldTerminalPathValue struct {
	TimeInterval_FieldTerminalPath
	value interface{}
}

var _ TimeInterval_FieldPathValue = (*TimeInterval_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'TimeInterval' as interface{}
func (fpv *TimeInterval_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *TimeInterval_FieldTerminalPathValue) AsEndTimeValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}
func (fpv *TimeInterval_FieldTerminalPathValue) AsStartTimeValue() (*timestamppb.Timestamp, bool) {
	res, ok := fpv.value.(*timestamppb.Timestamp)
	return res, ok
}

// SetTo stores value for selected field for object TimeInterval
func (fpv *TimeInterval_FieldTerminalPathValue) SetTo(target **TimeInterval) {
	if *target == nil {
		*target = new(TimeInterval)
	}
	switch fpv.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		(*target).EndTime = fpv.value.(*timestamppb.Timestamp)
	case TimeInterval_FieldPathSelectorStartTime:
		(*target).StartTime = fpv.value.(*timestamppb.Timestamp)
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fpv.selector))
	}
}

func (fpv *TimeInterval_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*TimeInterval)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'TimeInterval_FieldTerminalPathValue' with the value under path in 'TimeInterval'.
func (fpv *TimeInterval_FieldTerminalPathValue) CompareWith(source *TimeInterval) (int, bool) {
	switch fpv.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetEndTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case TimeInterval_FieldPathSelectorStartTime:
		leftValue := fpv.value.(*timestamppb.Timestamp)
		rightValue := source.GetStartTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for TimeInterval: %d", fpv.selector))
	}
}

func (fpv *TimeInterval_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*TimeInterval))
}

// TimeInterval_FieldPathArrayItemValue allows storing single item in Path-specific values for TimeInterval according to their type
// Present only for array (repeated) types.
type TimeInterval_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	TimeInterval_FieldPath
	ContainsValue(*TimeInterval) bool
}

// ParseTimeInterval_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseTimeInterval_FieldPathArrayItemValue(pathStr, valueStr string) (TimeInterval_FieldPathArrayItemValue, error) {
	fp, err := ParseTimeInterval_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeInterval field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(TimeInterval_FieldPathArrayItemValue), nil
}

func MustParseTimeInterval_FieldPathArrayItemValue(pathStr, valueStr string) TimeInterval_FieldPathArrayItemValue {
	fpaiv, err := ParseTimeInterval_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type TimeInterval_FieldTerminalPathArrayItemValue struct {
	TimeInterval_FieldTerminalPath
	value interface{}
}

var _ TimeInterval_FieldPathArrayItemValue = (*TimeInterval_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object TimeInterval as interface{}
func (fpaiv *TimeInterval_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *TimeInterval_FieldTerminalPathArrayItemValue) GetSingle(source *TimeInterval) (interface{}, bool) {
	return nil, false
}

func (fpaiv *TimeInterval_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*TimeInterval))
}

// Contains returns a boolean indicating if value that is being held is present in given 'TimeInterval'
func (fpaiv *TimeInterval_FieldTerminalPathArrayItemValue) ContainsValue(source *TimeInterval) bool {
	slice := fpaiv.TimeInterval_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// TimeInterval_FieldPathArrayOfValues allows storing slice of values for TimeInterval fields according to their type
type TimeInterval_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	TimeInterval_FieldPath
}

func ParseTimeInterval_FieldPathArrayOfValues(pathStr, valuesStr string) (TimeInterval_FieldPathArrayOfValues, error) {
	fp, err := ParseTimeInterval_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing TimeInterval field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(TimeInterval_FieldPathArrayOfValues), nil
}

func MustParseTimeInterval_FieldPathArrayOfValues(pathStr, valuesStr string) TimeInterval_FieldPathArrayOfValues {
	fpaov, err := ParseTimeInterval_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type TimeInterval_FieldTerminalPathArrayOfValues struct {
	TimeInterval_FieldTerminalPath
	values interface{}
}

var _ TimeInterval_FieldPathArrayOfValues = (*TimeInterval_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *TimeInterval_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case TimeInterval_FieldPathSelectorEndTime:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	case TimeInterval_FieldPathSelectorStartTime:
		for _, v := range fpaov.values.([]*timestamppb.Timestamp) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *TimeInterval_FieldTerminalPathArrayOfValues) AsEndTimeArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}
func (fpaov *TimeInterval_FieldTerminalPathArrayOfValues) AsStartTimeArrayOfValues() ([]*timestamppb.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamppb.Timestamp)
	return res, ok
}
