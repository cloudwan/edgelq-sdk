// Code generated by protoc-gen-goten-object
// File: edgelq/meta/proto/v1alpha2/deployment_service.proto
// DO NOT EDIT!!!

package deployment_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	deployment "github.com/cloudwan/edgelq-sdk/meta/resources/v1alpha2/deployment"
	service "github.com/cloudwan/edgelq-sdk/meta/resources/v1alpha2/service"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &deployment.Deployment{}
	_ = &service.Service{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetDeploymentRequest_FieldMask struct {
	Paths []GetDeploymentRequest_FieldPath
}

func FullGetDeploymentRequest_FieldMask() *GetDeploymentRequest_FieldMask {
	res := &GetDeploymentRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetDeploymentRequest_FieldTerminalPath{selector: GetDeploymentRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetDeploymentRequest_FieldTerminalPath{selector: GetDeploymentRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetDeploymentRequest_FieldTerminalPath{selector: GetDeploymentRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetDeploymentRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetDeploymentRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetDeploymentRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetDeploymentRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetDeploymentRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetDeploymentRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetDeploymentRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetDeploymentRequest_FieldPath(raw)
	})
}

func (fieldMask *GetDeploymentRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetDeploymentRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetDeploymentRequest_FieldMask) Subtract(other *GetDeploymentRequest_FieldMask) *GetDeploymentRequest_FieldMask {
	result := &GetDeploymentRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetDeploymentRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetDeploymentRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetDeploymentRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetDeploymentRequest_FieldMask) FilterInputFields() *GetDeploymentRequest_FieldMask {
	result := &GetDeploymentRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetDeploymentRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetDeploymentRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetDeploymentRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetDeploymentRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetDeploymentRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetDeploymentRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetDeploymentRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetDeploymentRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetDeploymentRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetDeploymentRequest_FieldMask) AppendPath(path GetDeploymentRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetDeploymentRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetDeploymentRequest_FieldPath))
}

func (fieldMask *GetDeploymentRequest_FieldMask) GetPaths() []GetDeploymentRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetDeploymentRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetDeploymentRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetDeploymentRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetDeploymentRequest_FieldMask) Set(target, source *GetDeploymentRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetDeploymentRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetDeploymentRequest), source.(*GetDeploymentRequest))
}

func (fieldMask *GetDeploymentRequest_FieldMask) Project(source *GetDeploymentRequest) *GetDeploymentRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetDeploymentRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetDeploymentRequest_FieldTerminalPath:
			switch tp.selector {
			case GetDeploymentRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetDeploymentRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetDeploymentRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetDeploymentRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetDeploymentRequest))
}

func (fieldMask *GetDeploymentRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetDeploymentsRequest_FieldMask struct {
	Paths []BatchGetDeploymentsRequest_FieldPath
}

func FullBatchGetDeploymentsRequest_FieldMask() *BatchGetDeploymentsRequest_FieldMask {
	res := &BatchGetDeploymentsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetDeploymentsRequest_FieldTerminalPath{selector: BatchGetDeploymentsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &BatchGetDeploymentsRequest_FieldTerminalPath{selector: BatchGetDeploymentsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetDeploymentsRequest_FieldTerminalPath{selector: BatchGetDeploymentsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetDeploymentsRequest_FieldTerminalPath{selector: BatchGetDeploymentsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetDeploymentsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetDeploymentsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetDeploymentsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetDeploymentsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) Subtract(other *BatchGetDeploymentsRequest_FieldMask) *BatchGetDeploymentsRequest_FieldMask {
	result := &BatchGetDeploymentsRequest_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetDeploymentsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetDeploymentsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetDeploymentsRequest_FieldMask) FilterInputFields() *BatchGetDeploymentsRequest_FieldMask {
	result := &BatchGetDeploymentsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetDeploymentsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetDeploymentsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetDeploymentsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetDeploymentsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetDeploymentsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) AppendPath(path BatchGetDeploymentsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetDeploymentsRequest_FieldPath))
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) GetPaths() []BatchGetDeploymentsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetDeploymentsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) Set(target, source *BatchGetDeploymentsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetDeploymentsRequest), source.(*BatchGetDeploymentsRequest))
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) Project(source *BatchGetDeploymentsRequest) *BatchGetDeploymentsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetDeploymentsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetDeploymentsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetDeploymentsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case BatchGetDeploymentsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetDeploymentsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetDeploymentsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetDeploymentsRequest))
}

func (fieldMask *BatchGetDeploymentsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetDeploymentsResponse_FieldMask struct {
	Paths []BatchGetDeploymentsResponse_FieldPath
}

func FullBatchGetDeploymentsResponse_FieldMask() *BatchGetDeploymentsResponse_FieldMask {
	res := &BatchGetDeploymentsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetDeploymentsResponse_FieldTerminalPath{selector: BatchGetDeploymentsResponse_FieldPathSelectorDeployments})
	res.Paths = append(res.Paths, &BatchGetDeploymentsResponse_FieldTerminalPath{selector: BatchGetDeploymentsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetDeploymentsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetDeploymentsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetDeploymentsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetDeploymentsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) Subtract(other *BatchGetDeploymentsResponse_FieldMask) *BatchGetDeploymentsResponse_FieldMask {
	result := &BatchGetDeploymentsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetDeploymentsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetDeploymentsResponse_FieldPathSelectorDeployments: &deployment.Deployment_FieldMask{},
	}
	mySubMasks := map[BatchGetDeploymentsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetDeploymentsResponse_FieldPathSelectorDeployments: &deployment.Deployment_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetDeploymentsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetDeploymentsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetDeploymentsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetDeploymentsResponse_FieldPathSelectorDeployments:
						mySubMasks[BatchGetDeploymentsResponse_FieldPathSelectorDeployments] = deployment.FullDeployment_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetDeploymentsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetDeploymentsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetDeploymentsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetDeploymentsResponse_FieldMask) FilterInputFields() *BatchGetDeploymentsResponse_FieldMask {
	result := &BatchGetDeploymentsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetDeploymentsResponse_FieldPathSelectorDeployments:
			if _, ok := path.(*BatchGetDeploymentsResponse_FieldTerminalPath); ok {
				for _, subpath := range deployment.FullDeployment_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetDeploymentsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetDeploymentsResponse_FieldSubPath); ok {
				selectedMask := &deployment.Deployment_FieldMask{
					Paths: []deployment.Deployment_FieldPath{sub.subPath.(deployment.Deployment_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetDeploymentsResponse_FieldSubPath{selector: BatchGetDeploymentsResponse_FieldPathSelectorDeployments, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetDeploymentsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetDeploymentsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetDeploymentsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetDeploymentsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetDeploymentsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) AppendPath(path BatchGetDeploymentsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetDeploymentsResponse_FieldPath))
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) GetPaths() []BatchGetDeploymentsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetDeploymentsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) Set(target, source *BatchGetDeploymentsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetDeploymentsResponse), source.(*BatchGetDeploymentsResponse))
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) Project(source *BatchGetDeploymentsResponse) *BatchGetDeploymentsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetDeploymentsResponse{}
	deploymentsMask := &deployment.Deployment_FieldMask{}
	wholeDeploymentsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetDeploymentsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetDeploymentsResponse_FieldPathSelectorDeployments:
				result.Deployments = source.Deployments
				wholeDeploymentsAccepted = true
			case BatchGetDeploymentsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetDeploymentsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetDeploymentsResponse_FieldPathSelectorDeployments:
				deploymentsMask.AppendPath(tp.subPath.(deployment.Deployment_FieldPath))
			}
		}
	}
	if wholeDeploymentsAccepted == false && len(deploymentsMask.Paths) > 0 {
		for _, sourceItem := range source.GetDeployments() {
			result.Deployments = append(result.Deployments, deploymentsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetDeploymentsResponse))
}

func (fieldMask *BatchGetDeploymentsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListDeploymentsRequest_FieldMask struct {
	Paths []ListDeploymentsRequest_FieldPath
}

func FullListDeploymentsRequest_FieldMask() *ListDeploymentsRequest_FieldMask {
	res := &ListDeploymentsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListDeploymentsRequest_FieldTerminalPath{selector: ListDeploymentsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListDeploymentsRequest_FieldTerminalPath{selector: ListDeploymentsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListDeploymentsRequest_FieldTerminalPath{selector: ListDeploymentsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListDeploymentsRequest_FieldTerminalPath{selector: ListDeploymentsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListDeploymentsRequest_FieldTerminalPath{selector: ListDeploymentsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListDeploymentsRequest_FieldTerminalPath{selector: ListDeploymentsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListDeploymentsRequest_FieldTerminalPath{selector: ListDeploymentsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListDeploymentsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListDeploymentsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListDeploymentsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListDeploymentsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListDeploymentsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListDeploymentsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListDeploymentsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListDeploymentsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListDeploymentsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListDeploymentsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListDeploymentsRequest_FieldMask) Subtract(other *ListDeploymentsRequest_FieldMask) *ListDeploymentsRequest_FieldMask {
	result := &ListDeploymentsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListDeploymentsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListDeploymentsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListDeploymentsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListDeploymentsRequest_FieldMask) FilterInputFields() *ListDeploymentsRequest_FieldMask {
	result := &ListDeploymentsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListDeploymentsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListDeploymentsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListDeploymentsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListDeploymentsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListDeploymentsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListDeploymentsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListDeploymentsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListDeploymentsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListDeploymentsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListDeploymentsRequest_FieldMask) AppendPath(path ListDeploymentsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListDeploymentsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListDeploymentsRequest_FieldPath))
}

func (fieldMask *ListDeploymentsRequest_FieldMask) GetPaths() []ListDeploymentsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListDeploymentsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListDeploymentsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListDeploymentsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListDeploymentsRequest_FieldMask) Set(target, source *ListDeploymentsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListDeploymentsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListDeploymentsRequest), source.(*ListDeploymentsRequest))
}

func (fieldMask *ListDeploymentsRequest_FieldMask) Project(source *ListDeploymentsRequest) *ListDeploymentsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListDeploymentsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListDeploymentsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListDeploymentsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListDeploymentsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListDeploymentsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListDeploymentsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListDeploymentsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListDeploymentsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListDeploymentsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListDeploymentsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListDeploymentsRequest))
}

func (fieldMask *ListDeploymentsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListDeploymentsResponse_FieldMask struct {
	Paths []ListDeploymentsResponse_FieldPath
}

func FullListDeploymentsResponse_FieldMask() *ListDeploymentsResponse_FieldMask {
	res := &ListDeploymentsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListDeploymentsResponse_FieldTerminalPath{selector: ListDeploymentsResponse_FieldPathSelectorDeployments})
	res.Paths = append(res.Paths, &ListDeploymentsResponse_FieldTerminalPath{selector: ListDeploymentsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListDeploymentsResponse_FieldTerminalPath{selector: ListDeploymentsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListDeploymentsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListDeploymentsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListDeploymentsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListDeploymentsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListDeploymentsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListDeploymentsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListDeploymentsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListDeploymentsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListDeploymentsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListDeploymentsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListDeploymentsResponse_FieldMask) Subtract(other *ListDeploymentsResponse_FieldMask) *ListDeploymentsResponse_FieldMask {
	result := &ListDeploymentsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListDeploymentsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListDeploymentsResponse_FieldPathSelectorDeployments: &deployment.Deployment_FieldMask{},
	}
	mySubMasks := map[ListDeploymentsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListDeploymentsResponse_FieldPathSelectorDeployments: &deployment.Deployment_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListDeploymentsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListDeploymentsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListDeploymentsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListDeploymentsResponse_FieldPathSelectorDeployments:
						mySubMasks[ListDeploymentsResponse_FieldPathSelectorDeployments] = deployment.FullDeployment_FieldMask()
					}
				} else if tp, ok := path.(*ListDeploymentsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListDeploymentsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListDeploymentsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListDeploymentsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListDeploymentsResponse_FieldMask) FilterInputFields() *ListDeploymentsResponse_FieldMask {
	result := &ListDeploymentsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListDeploymentsResponse_FieldPathSelectorDeployments:
			if _, ok := path.(*ListDeploymentsResponse_FieldTerminalPath); ok {
				for _, subpath := range deployment.FullDeployment_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListDeploymentsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListDeploymentsResponse_FieldSubPath); ok {
				selectedMask := &deployment.Deployment_FieldMask{
					Paths: []deployment.Deployment_FieldPath{sub.subPath.(deployment.Deployment_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListDeploymentsResponse_FieldSubPath{selector: ListDeploymentsResponse_FieldPathSelectorDeployments, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListDeploymentsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListDeploymentsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListDeploymentsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListDeploymentsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListDeploymentsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListDeploymentsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListDeploymentsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListDeploymentsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListDeploymentsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListDeploymentsResponse_FieldMask) AppendPath(path ListDeploymentsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListDeploymentsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListDeploymentsResponse_FieldPath))
}

func (fieldMask *ListDeploymentsResponse_FieldMask) GetPaths() []ListDeploymentsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListDeploymentsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListDeploymentsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListDeploymentsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListDeploymentsResponse_FieldMask) Set(target, source *ListDeploymentsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListDeploymentsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListDeploymentsResponse), source.(*ListDeploymentsResponse))
}

func (fieldMask *ListDeploymentsResponse_FieldMask) Project(source *ListDeploymentsResponse) *ListDeploymentsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListDeploymentsResponse{}
	deploymentsMask := &deployment.Deployment_FieldMask{}
	wholeDeploymentsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListDeploymentsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListDeploymentsResponse_FieldPathSelectorDeployments:
				result.Deployments = source.Deployments
				wholeDeploymentsAccepted = true
			case ListDeploymentsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListDeploymentsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListDeploymentsResponse_FieldSubPath:
			switch tp.selector {
			case ListDeploymentsResponse_FieldPathSelectorDeployments:
				deploymentsMask.AppendPath(tp.subPath.(deployment.Deployment_FieldPath))
			}
		}
	}
	if wholeDeploymentsAccepted == false && len(deploymentsMask.Paths) > 0 {
		for _, sourceItem := range source.GetDeployments() {
			result.Deployments = append(result.Deployments, deploymentsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListDeploymentsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListDeploymentsResponse))
}

func (fieldMask *ListDeploymentsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeploymentRequest_FieldMask struct {
	Paths []WatchDeploymentRequest_FieldPath
}

func FullWatchDeploymentRequest_FieldMask() *WatchDeploymentRequest_FieldMask {
	res := &WatchDeploymentRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeploymentRequest_FieldTerminalPath{selector: WatchDeploymentRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchDeploymentRequest_FieldTerminalPath{selector: WatchDeploymentRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchDeploymentRequest_FieldTerminalPath{selector: WatchDeploymentRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchDeploymentRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeploymentRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeploymentRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeploymentRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeploymentRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeploymentRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeploymentRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeploymentRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchDeploymentRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeploymentRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeploymentRequest_FieldMask) Subtract(other *WatchDeploymentRequest_FieldMask) *WatchDeploymentRequest_FieldMask {
	result := &WatchDeploymentRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeploymentRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeploymentRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeploymentRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeploymentRequest_FieldMask) FilterInputFields() *WatchDeploymentRequest_FieldMask {
	result := &WatchDeploymentRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeploymentRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeploymentRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeploymentRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeploymentRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeploymentRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeploymentRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeploymentRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeploymentRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentRequest_FieldMask) AppendPath(path WatchDeploymentRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeploymentRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeploymentRequest_FieldPath))
}

func (fieldMask *WatchDeploymentRequest_FieldMask) GetPaths() []WatchDeploymentRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeploymentRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeploymentRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeploymentRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeploymentRequest_FieldMask) Set(target, source *WatchDeploymentRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeploymentRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeploymentRequest), source.(*WatchDeploymentRequest))
}

func (fieldMask *WatchDeploymentRequest_FieldMask) Project(source *WatchDeploymentRequest) *WatchDeploymentRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeploymentRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeploymentRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchDeploymentRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchDeploymentRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchDeploymentRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchDeploymentRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeploymentRequest))
}

func (fieldMask *WatchDeploymentRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeploymentResponse_FieldMask struct {
	Paths []WatchDeploymentResponse_FieldPath
}

func FullWatchDeploymentResponse_FieldMask() *WatchDeploymentResponse_FieldMask {
	res := &WatchDeploymentResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeploymentResponse_FieldTerminalPath{selector: WatchDeploymentResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchDeploymentResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeploymentResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeploymentResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeploymentResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeploymentResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeploymentResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeploymentResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeploymentResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchDeploymentResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeploymentResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeploymentResponse_FieldMask) Subtract(other *WatchDeploymentResponse_FieldMask) *WatchDeploymentResponse_FieldMask {
	result := &WatchDeploymentResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeploymentResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeploymentResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeploymentResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeploymentResponse_FieldMask) FilterInputFields() *WatchDeploymentResponse_FieldMask {
	result := &WatchDeploymentResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeploymentResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeploymentResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeploymentResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeploymentResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeploymentResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeploymentResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeploymentResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeploymentResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentResponse_FieldMask) AppendPath(path WatchDeploymentResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeploymentResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeploymentResponse_FieldPath))
}

func (fieldMask *WatchDeploymentResponse_FieldMask) GetPaths() []WatchDeploymentResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeploymentResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeploymentResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeploymentResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeploymentResponse_FieldMask) Set(target, source *WatchDeploymentResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeploymentResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeploymentResponse), source.(*WatchDeploymentResponse))
}

func (fieldMask *WatchDeploymentResponse_FieldMask) Project(source *WatchDeploymentResponse) *WatchDeploymentResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeploymentResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeploymentResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchDeploymentResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchDeploymentResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeploymentResponse))
}

func (fieldMask *WatchDeploymentResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeploymentsRequest_FieldMask struct {
	Paths []WatchDeploymentsRequest_FieldPath
}

func FullWatchDeploymentsRequest_FieldMask() *WatchDeploymentsRequest_FieldMask {
	res := &WatchDeploymentsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchDeploymentsRequest_FieldTerminalPath{selector: WatchDeploymentsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeploymentsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeploymentsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeploymentsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeploymentsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeploymentsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) Subtract(other *WatchDeploymentsRequest_FieldMask) *WatchDeploymentsRequest_FieldMask {
	result := &WatchDeploymentsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeploymentsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeploymentsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeploymentsRequest_FieldMask) FilterInputFields() *WatchDeploymentsRequest_FieldMask {
	result := &WatchDeploymentsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeploymentsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeploymentsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeploymentsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeploymentsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeploymentsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) AppendPath(path WatchDeploymentsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeploymentsRequest_FieldPath))
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) GetPaths() []WatchDeploymentsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeploymentsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) Set(target, source *WatchDeploymentsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeploymentsRequest), source.(*WatchDeploymentsRequest))
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) Project(source *WatchDeploymentsRequest) *WatchDeploymentsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeploymentsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeploymentsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchDeploymentsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchDeploymentsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchDeploymentsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchDeploymentsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchDeploymentsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchDeploymentsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchDeploymentsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchDeploymentsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchDeploymentsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchDeploymentsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeploymentsRequest))
}

func (fieldMask *WatchDeploymentsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeploymentsResponse_FieldMask struct {
	Paths []WatchDeploymentsResponse_FieldPath
}

func FullWatchDeploymentsResponse_FieldMask() *WatchDeploymentsResponse_FieldMask {
	res := &WatchDeploymentsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeploymentsResponse_FieldTerminalPath{selector: WatchDeploymentsResponse_FieldPathSelectorDeploymentChanges})
	res.Paths = append(res.Paths, &WatchDeploymentsResponse_FieldTerminalPath{selector: WatchDeploymentsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchDeploymentsResponse_FieldTerminalPath{selector: WatchDeploymentsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchDeploymentsResponse_FieldTerminalPath{selector: WatchDeploymentsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchDeploymentsResponse_FieldTerminalPath{selector: WatchDeploymentsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchDeploymentsResponse_FieldTerminalPath{selector: WatchDeploymentsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchDeploymentsResponse_FieldTerminalPath{selector: WatchDeploymentsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeploymentsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeploymentsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeploymentsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeploymentsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeploymentsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) Subtract(other *WatchDeploymentsResponse_FieldMask) *WatchDeploymentsResponse_FieldMask {
	result := &WatchDeploymentsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchDeploymentsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchDeploymentsResponse_FieldPathSelectorPageTokenChange: &WatchDeploymentsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchDeploymentsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchDeploymentsResponse_FieldPathSelectorPageTokenChange: &WatchDeploymentsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeploymentsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchDeploymentsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchDeploymentsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchDeploymentsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchDeploymentsResponse_FieldPathSelectorPageTokenChange] = FullWatchDeploymentsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchDeploymentsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchDeploymentsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeploymentsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeploymentsResponse_FieldMask) FilterInputFields() *WatchDeploymentsResponse_FieldMask {
	result := &WatchDeploymentsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeploymentsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeploymentsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeploymentsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeploymentsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeploymentsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) AppendPath(path WatchDeploymentsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeploymentsResponse_FieldPath))
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) GetPaths() []WatchDeploymentsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeploymentsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) Set(target, source *WatchDeploymentsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeploymentsResponse), source.(*WatchDeploymentsResponse))
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) Project(source *WatchDeploymentsResponse) *WatchDeploymentsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeploymentsResponse{}
	pageTokenChangeMask := &WatchDeploymentsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeploymentsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchDeploymentsResponse_FieldPathSelectorDeploymentChanges:
				result.DeploymentChanges = source.DeploymentChanges
			case WatchDeploymentsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchDeploymentsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchDeploymentsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchDeploymentsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchDeploymentsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchDeploymentsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchDeploymentsResponse_FieldSubPath:
			switch tp.selector {
			case WatchDeploymentsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchDeploymentsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeploymentsResponse))
}

func (fieldMask *WatchDeploymentsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchDeploymentsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchDeploymentsResponsePageTokenChange_FieldPath
}

func FullWatchDeploymentsResponse_PageTokenChange_FieldMask() *WatchDeploymentsResponse_PageTokenChange_FieldMask {
	res := &WatchDeploymentsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchDeploymentsResponsePageTokenChange_FieldTerminalPath{selector: WatchDeploymentsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchDeploymentsResponsePageTokenChange_FieldTerminalPath{selector: WatchDeploymentsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchDeploymentsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchDeploymentsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchDeploymentsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) Subtract(other *WatchDeploymentsResponse_PageTokenChange_FieldMask) *WatchDeploymentsResponse_PageTokenChange_FieldMask {
	result := &WatchDeploymentsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchDeploymentsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchDeploymentsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchDeploymentsResponse_PageTokenChange_FieldMask {
	result := &WatchDeploymentsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchDeploymentsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchDeploymentsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchDeploymentsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchDeploymentsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) AppendPath(path WatchDeploymentsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchDeploymentsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) GetPaths() []WatchDeploymentsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchDeploymentsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) Set(target, source *WatchDeploymentsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchDeploymentsResponse_PageTokenChange), source.(*WatchDeploymentsResponse_PageTokenChange))
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) Project(source *WatchDeploymentsResponse_PageTokenChange) *WatchDeploymentsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchDeploymentsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchDeploymentsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchDeploymentsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchDeploymentsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchDeploymentsResponse_PageTokenChange))
}

func (fieldMask *WatchDeploymentsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateDeploymentRequest_FieldMask struct {
	Paths []CreateDeploymentRequest_FieldPath
}

func FullCreateDeploymentRequest_FieldMask() *CreateDeploymentRequest_FieldMask {
	res := &CreateDeploymentRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateDeploymentRequest_FieldTerminalPath{selector: CreateDeploymentRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateDeploymentRequest_FieldTerminalPath{selector: CreateDeploymentRequest_FieldPathSelectorDeployment})
	return res
}

func (fieldMask *CreateDeploymentRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateDeploymentRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateDeploymentRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateDeploymentRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateDeploymentRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateDeploymentRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateDeploymentRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateDeploymentRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateDeploymentRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateDeploymentRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateDeploymentRequest_FieldMask) Subtract(other *CreateDeploymentRequest_FieldMask) *CreateDeploymentRequest_FieldMask {
	result := &CreateDeploymentRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateDeploymentRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateDeploymentRequest_FieldPathSelectorDeployment: &deployment.Deployment_FieldMask{},
	}
	mySubMasks := map[CreateDeploymentRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateDeploymentRequest_FieldPathSelectorDeployment: &deployment.Deployment_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateDeploymentRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateDeploymentRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateDeploymentRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateDeploymentRequest_FieldPathSelectorDeployment:
						mySubMasks[CreateDeploymentRequest_FieldPathSelectorDeployment] = deployment.FullDeployment_FieldMask()
					}
				} else if tp, ok := path.(*CreateDeploymentRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateDeploymentRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateDeploymentRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateDeploymentRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateDeploymentRequest_FieldMask) FilterInputFields() *CreateDeploymentRequest_FieldMask {
	result := &CreateDeploymentRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateDeploymentRequest_FieldPathSelectorDeployment:
			if _, ok := path.(*CreateDeploymentRequest_FieldTerminalPath); ok {
				for _, subpath := range deployment.FullDeployment_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateDeploymentRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateDeploymentRequest_FieldSubPath); ok {
				selectedMask := &deployment.Deployment_FieldMask{
					Paths: []deployment.Deployment_FieldPath{sub.subPath.(deployment.Deployment_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateDeploymentRequest_FieldSubPath{selector: CreateDeploymentRequest_FieldPathSelectorDeployment, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateDeploymentRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateDeploymentRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateDeploymentRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateDeploymentRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateDeploymentRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateDeploymentRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateDeploymentRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateDeploymentRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateDeploymentRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateDeploymentRequest_FieldMask) AppendPath(path CreateDeploymentRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateDeploymentRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateDeploymentRequest_FieldPath))
}

func (fieldMask *CreateDeploymentRequest_FieldMask) GetPaths() []CreateDeploymentRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateDeploymentRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateDeploymentRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateDeploymentRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateDeploymentRequest_FieldMask) Set(target, source *CreateDeploymentRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateDeploymentRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateDeploymentRequest), source.(*CreateDeploymentRequest))
}

func (fieldMask *CreateDeploymentRequest_FieldMask) Project(source *CreateDeploymentRequest) *CreateDeploymentRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateDeploymentRequest{}
	deploymentMask := &deployment.Deployment_FieldMask{}
	wholeDeploymentAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateDeploymentRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateDeploymentRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateDeploymentRequest_FieldPathSelectorDeployment:
				result.Deployment = source.Deployment
				wholeDeploymentAccepted = true
			}
		case *CreateDeploymentRequest_FieldSubPath:
			switch tp.selector {
			case CreateDeploymentRequest_FieldPathSelectorDeployment:
				deploymentMask.AppendPath(tp.subPath.(deployment.Deployment_FieldPath))
			}
		}
	}
	if wholeDeploymentAccepted == false && len(deploymentMask.Paths) > 0 {
		result.Deployment = deploymentMask.Project(source.GetDeployment())
	}
	return result
}

func (fieldMask *CreateDeploymentRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateDeploymentRequest))
}

func (fieldMask *CreateDeploymentRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateDeploymentRequest_FieldMask struct {
	Paths []UpdateDeploymentRequest_FieldPath
}

func FullUpdateDeploymentRequest_FieldMask() *UpdateDeploymentRequest_FieldMask {
	res := &UpdateDeploymentRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateDeploymentRequest_FieldTerminalPath{selector: UpdateDeploymentRequest_FieldPathSelectorDeployment})
	res.Paths = append(res.Paths, &UpdateDeploymentRequest_FieldTerminalPath{selector: UpdateDeploymentRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateDeploymentRequest_FieldTerminalPath{selector: UpdateDeploymentRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateDeploymentRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateDeploymentRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateDeploymentRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateDeploymentRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateDeploymentRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) Subtract(other *UpdateDeploymentRequest_FieldMask) *UpdateDeploymentRequest_FieldMask {
	result := &UpdateDeploymentRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateDeploymentRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateDeploymentRequest_FieldPathSelectorDeployment: &deployment.Deployment_FieldMask{},
		UpdateDeploymentRequest_FieldPathSelectorCas:        &UpdateDeploymentRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateDeploymentRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateDeploymentRequest_FieldPathSelectorDeployment: &deployment.Deployment_FieldMask{},
		UpdateDeploymentRequest_FieldPathSelectorCas:        &UpdateDeploymentRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateDeploymentRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateDeploymentRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateDeploymentRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateDeploymentRequest_FieldPathSelectorDeployment:
						mySubMasks[UpdateDeploymentRequest_FieldPathSelectorDeployment] = deployment.FullDeployment_FieldMask()
					case UpdateDeploymentRequest_FieldPathSelectorCas:
						mySubMasks[UpdateDeploymentRequest_FieldPathSelectorCas] = FullUpdateDeploymentRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateDeploymentRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateDeploymentRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateDeploymentRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateDeploymentRequest_FieldMask) FilterInputFields() *UpdateDeploymentRequest_FieldMask {
	result := &UpdateDeploymentRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateDeploymentRequest_FieldPathSelectorDeployment:
			if _, ok := path.(*UpdateDeploymentRequest_FieldTerminalPath); ok {
				for _, subpath := range deployment.FullDeployment_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeploymentRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateDeploymentRequest_FieldSubPath); ok {
				selectedMask := &deployment.Deployment_FieldMask{
					Paths: []deployment.Deployment_FieldPath{sub.subPath.(deployment.Deployment_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeploymentRequest_FieldSubPath{selector: UpdateDeploymentRequest_FieldPathSelectorDeployment, subPath: allowedPath})
				}
			}
		case UpdateDeploymentRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateDeploymentRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateDeploymentRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeploymentRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateDeploymentRequest_FieldSubPath); ok {
				selectedMask := &UpdateDeploymentRequest_CAS_FieldMask{
					Paths: []UpdateDeploymentRequestCAS_FieldPath{sub.subPath.(UpdateDeploymentRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeploymentRequest_FieldSubPath{selector: UpdateDeploymentRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateDeploymentRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateDeploymentRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateDeploymentRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateDeploymentRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateDeploymentRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) AppendPath(path UpdateDeploymentRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateDeploymentRequest_FieldPath))
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) GetPaths() []UpdateDeploymentRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateDeploymentRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) Set(target, source *UpdateDeploymentRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateDeploymentRequest), source.(*UpdateDeploymentRequest))
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) Project(source *UpdateDeploymentRequest) *UpdateDeploymentRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateDeploymentRequest{}
	deploymentMask := &deployment.Deployment_FieldMask{}
	wholeDeploymentAccepted := false
	casMask := &UpdateDeploymentRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateDeploymentRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateDeploymentRequest_FieldPathSelectorDeployment:
				result.Deployment = source.Deployment
				wholeDeploymentAccepted = true
			case UpdateDeploymentRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateDeploymentRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateDeploymentRequest_FieldSubPath:
			switch tp.selector {
			case UpdateDeploymentRequest_FieldPathSelectorDeployment:
				deploymentMask.AppendPath(tp.subPath.(deployment.Deployment_FieldPath))
			case UpdateDeploymentRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateDeploymentRequestCAS_FieldPath))
			}
		}
	}
	if wholeDeploymentAccepted == false && len(deploymentMask.Paths) > 0 {
		result.Deployment = deploymentMask.Project(source.GetDeployment())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateDeploymentRequest))
}

func (fieldMask *UpdateDeploymentRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateDeploymentRequest_CAS_FieldMask struct {
	Paths []UpdateDeploymentRequestCAS_FieldPath
}

func FullUpdateDeploymentRequest_CAS_FieldMask() *UpdateDeploymentRequest_CAS_FieldMask {
	res := &UpdateDeploymentRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateDeploymentRequestCAS_FieldTerminalPath{selector: UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateDeploymentRequestCAS_FieldTerminalPath{selector: UpdateDeploymentRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateDeploymentRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateDeploymentRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateDeploymentRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) Subtract(other *UpdateDeploymentRequest_CAS_FieldMask) *UpdateDeploymentRequest_CAS_FieldMask {
	result := &UpdateDeploymentRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateDeploymentRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState: &deployment.Deployment_FieldMask{},
	}
	mySubMasks := map[UpdateDeploymentRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState: &deployment.Deployment_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateDeploymentRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateDeploymentRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateDeploymentRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState] = deployment.FullDeployment_FieldMask()
					}
				} else if tp, ok := path.(*UpdateDeploymentRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateDeploymentRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateDeploymentRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) FilterInputFields() *UpdateDeploymentRequest_CAS_FieldMask {
	result := &UpdateDeploymentRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateDeploymentRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range deployment.FullDeployment_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeploymentRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateDeploymentRequestCAS_FieldSubPath); ok {
				selectedMask := &deployment.Deployment_FieldMask{
					Paths: []deployment.Deployment_FieldPath{sub.subPath.(deployment.Deployment_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateDeploymentRequestCAS_FieldSubPath{selector: UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateDeploymentRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateDeploymentRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateDeploymentRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateDeploymentRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) AppendPath(path UpdateDeploymentRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateDeploymentRequestCAS_FieldPath))
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) GetPaths() []UpdateDeploymentRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateDeploymentRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) Set(target, source *UpdateDeploymentRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateDeploymentRequest_CAS), source.(*UpdateDeploymentRequest_CAS))
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) Project(source *UpdateDeploymentRequest_CAS) *UpdateDeploymentRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateDeploymentRequest_CAS{}
	conditionalStateMask := &deployment.Deployment_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateDeploymentRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateDeploymentRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateDeploymentRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateDeploymentRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(deployment.Deployment_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateDeploymentRequest_CAS))
}

func (fieldMask *UpdateDeploymentRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteDeploymentRequest_FieldMask struct {
	Paths []DeleteDeploymentRequest_FieldPath
}

func FullDeleteDeploymentRequest_FieldMask() *DeleteDeploymentRequest_FieldMask {
	res := &DeleteDeploymentRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteDeploymentRequest_FieldTerminalPath{selector: DeleteDeploymentRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteDeploymentRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteDeploymentRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteDeploymentRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteDeploymentRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteDeploymentRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) Subtract(other *DeleteDeploymentRequest_FieldMask) *DeleteDeploymentRequest_FieldMask {
	result := &DeleteDeploymentRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteDeploymentRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteDeploymentRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteDeploymentRequest_FieldMask) FilterInputFields() *DeleteDeploymentRequest_FieldMask {
	result := &DeleteDeploymentRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteDeploymentRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteDeploymentRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteDeploymentRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteDeploymentRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteDeploymentRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) AppendPath(path DeleteDeploymentRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteDeploymentRequest_FieldPath))
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) GetPaths() []DeleteDeploymentRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteDeploymentRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) Set(target, source *DeleteDeploymentRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteDeploymentRequest), source.(*DeleteDeploymentRequest))
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) Project(source *DeleteDeploymentRequest) *DeleteDeploymentRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteDeploymentRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteDeploymentRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteDeploymentRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteDeploymentRequest))
}

func (fieldMask *DeleteDeploymentRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
