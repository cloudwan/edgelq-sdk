// Code generated by protoc-gen-goten-object
// File: edgelq/proxies/proto/v1alpha/broker_custom.proto
// DO NOT EDIT!!!

package broker_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	project "github.com/cloudwan/edgelq-sdk/proxies/resources/v1alpha/project"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &project.Project{}
)

type ListenRequest_FieldMask struct {
	Paths []ListenRequest_FieldPath
}

func FullListenRequest_FieldMask() *ListenRequest_FieldMask {
	res := &ListenRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListenRequest_FieldTerminalPath{selector: ListenRequest_FieldPathSelectorOpenRequest})
	res.Paths = append(res.Paths, &ListenRequest_FieldTerminalPath{selector: ListenRequest_FieldPathSelectorResumeRequest})
	res.Paths = append(res.Paths, &ListenRequest_FieldTerminalPath{selector: ListenRequest_FieldPathSelectorChannelOpenError})
	res.Paths = append(res.Paths, &ListenRequest_FieldTerminalPath{selector: ListenRequest_FieldPathSelectorPing})
	return res
}

func (fieldMask *ListenRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenRequest_FieldPath(raw)
	})
}

func (fieldMask *ListenRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListenRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenRequest_FieldMask) Subtract(other *ListenRequest_FieldMask) *ListenRequest_FieldMask {
	result := &ListenRequest_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[ListenRequest_FieldPathSelector]gotenobject.FieldMask{
		ListenRequest_FieldPathSelectorOpenRequest:      &ListenRequest_OpenRequest_FieldMask{},
		ListenRequest_FieldPathSelectorResumeRequest:    &ListenRequest_ResumeRequest_FieldMask{},
		ListenRequest_FieldPathSelectorChannelOpenError: &ListenRequest_ChannelOpenError_FieldMask{},
		ListenRequest_FieldPathSelectorPing:             &Ping_FieldMask{},
	}
	mySubMasks := map[ListenRequest_FieldPathSelector]gotenobject.FieldMask{
		ListenRequest_FieldPathSelectorOpenRequest:      &ListenRequest_OpenRequest_FieldMask{},
		ListenRequest_FieldPathSelectorResumeRequest:    &ListenRequest_ResumeRequest_FieldMask{},
		ListenRequest_FieldPathSelectorChannelOpenError: &ListenRequest_ChannelOpenError_FieldMask{},
		ListenRequest_FieldPathSelectorPing:             &Ping_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListenRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListenRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case ListenRequest_FieldPathSelectorOpenRequest:
						mySubMasks[ListenRequest_FieldPathSelectorOpenRequest] = FullListenRequest_OpenRequest_FieldMask()
					case ListenRequest_FieldPathSelectorResumeRequest:
						mySubMasks[ListenRequest_FieldPathSelectorResumeRequest] = FullListenRequest_ResumeRequest_FieldMask()
					case ListenRequest_FieldPathSelectorChannelOpenError:
						mySubMasks[ListenRequest_FieldPathSelectorChannelOpenError] = FullListenRequest_ChannelOpenError_FieldMask()
					case ListenRequest_FieldPathSelectorPing:
						mySubMasks[ListenRequest_FieldPathSelectorPing] = FullPing_FieldMask()
					}
				} else if tp, ok := path.(*ListenRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListenRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenRequest_FieldMask) FilterInputFields() *ListenRequest_FieldMask {
	result := &ListenRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenRequest_FieldMask) AppendPath(path ListenRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenRequest_FieldPath))
}

func (fieldMask *ListenRequest_FieldMask) GetPaths() []ListenRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenRequest_FieldMask) Set(target, source *ListenRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenRequest), source.(*ListenRequest))
}

func (fieldMask *ListenRequest_FieldMask) Project(source *ListenRequest) *ListenRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenRequest{}
	openRequestMask := &ListenRequest_OpenRequest_FieldMask{}
	wholeOpenRequestAccepted := false
	resumeRequestMask := &ListenRequest_ResumeRequest_FieldMask{}
	wholeResumeRequestAccepted := false
	channelOpenErrorMask := &ListenRequest_ChannelOpenError_FieldMask{}
	wholeChannelOpenErrorAccepted := false
	pingMask := &Ping_FieldMask{}
	wholePingAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenRequest_FieldTerminalPath:
			switch tp.selector {
			case ListenRequest_FieldPathSelectorOpenRequest:
				if source, ok := source.Message.(*ListenRequest_OpenRequest_); ok {
					result.Message = &ListenRequest_OpenRequest_{
						OpenRequest: source.OpenRequest,
					}
				}
				wholeOpenRequestAccepted = true
			case ListenRequest_FieldPathSelectorResumeRequest:
				if source, ok := source.Message.(*ListenRequest_ResumeRequest_); ok {
					result.Message = &ListenRequest_ResumeRequest_{
						ResumeRequest: source.ResumeRequest,
					}
				}
				wholeResumeRequestAccepted = true
			case ListenRequest_FieldPathSelectorChannelOpenError:
				if source, ok := source.Message.(*ListenRequest_ChannelOpenError_); ok {
					result.Message = &ListenRequest_ChannelOpenError_{
						ChannelOpenError: source.ChannelOpenError,
					}
				}
				wholeChannelOpenErrorAccepted = true
			case ListenRequest_FieldPathSelectorPing:
				if source, ok := source.Message.(*ListenRequest_Ping); ok {
					result.Message = &ListenRequest_Ping{
						Ping: source.Ping,
					}
				}
				wholePingAccepted = true
			}
		case *ListenRequest_FieldSubPath:
			switch tp.selector {
			case ListenRequest_FieldPathSelectorOpenRequest:
				openRequestMask.AppendPath(tp.subPath.(ListenRequestOpenRequest_FieldPath))
			case ListenRequest_FieldPathSelectorResumeRequest:
				resumeRequestMask.AppendPath(tp.subPath.(ListenRequestResumeRequest_FieldPath))
			case ListenRequest_FieldPathSelectorChannelOpenError:
				channelOpenErrorMask.AppendPath(tp.subPath.(ListenRequestChannelOpenError_FieldPath))
			case ListenRequest_FieldPathSelectorPing:
				pingMask.AppendPath(tp.subPath.(Ping_FieldPath))
			}
		}
	}
	if wholeOpenRequestAccepted == false && len(openRequestMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ListenRequest_OpenRequest_); ok {
			result.Message = (*ListenRequest_OpenRequest_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenRequest_OpenRequest_{}
				oneOfRes.OpenRequest = openRequestMask.Project(asOneOf.OpenRequest)
				result.Message = oneOfRes
			}
		}
	}
	if wholeResumeRequestAccepted == false && len(resumeRequestMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ListenRequest_ResumeRequest_); ok {
			result.Message = (*ListenRequest_ResumeRequest_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenRequest_ResumeRequest_{}
				oneOfRes.ResumeRequest = resumeRequestMask.Project(asOneOf.ResumeRequest)
				result.Message = oneOfRes
			}
		}
	}
	if wholeChannelOpenErrorAccepted == false && len(channelOpenErrorMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ListenRequest_ChannelOpenError_); ok {
			result.Message = (*ListenRequest_ChannelOpenError_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenRequest_ChannelOpenError_{}
				oneOfRes.ChannelOpenError = channelOpenErrorMask.Project(asOneOf.ChannelOpenError)
				result.Message = oneOfRes
			}
		}
	}
	if wholePingAccepted == false && len(pingMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ListenRequest_Ping); ok {
			result.Message = (*ListenRequest_Ping)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenRequest_Ping{}
				oneOfRes.Ping = pingMask.Project(asOneOf.Ping)
				result.Message = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ListenRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenRequest))
}

func (fieldMask *ListenRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenRequest_OpenRequest_FieldMask struct {
	Paths []ListenRequestOpenRequest_FieldPath
}

func FullListenRequest_OpenRequest_FieldMask() *ListenRequest_OpenRequest_FieldMask {
	res := &ListenRequest_OpenRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListenRequestOpenRequest_FieldTerminalPath{selector: ListenRequestOpenRequest_FieldPathSelectorProject})
	res.Paths = append(res.Paths, &ListenRequestOpenRequest_FieldTerminalPath{selector: ListenRequestOpenRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenRequest_OpenRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenRequestOpenRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenRequestOpenRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenRequestOpenRequest_FieldPath(raw)
	})
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) Subtract(other *ListenRequest_OpenRequest_FieldMask) *ListenRequest_OpenRequest_FieldMask {
	result := &ListenRequest_OpenRequest_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenRequestOpenRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenRequest_OpenRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenRequest_OpenRequest_FieldMask) FilterInputFields() *ListenRequest_OpenRequest_FieldMask {
	result := &ListenRequest_OpenRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenRequest_OpenRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenRequestOpenRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenRequestOpenRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenRequest_OpenRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenRequest_OpenRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) AppendPath(path ListenRequestOpenRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenRequestOpenRequest_FieldPath))
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) GetPaths() []ListenRequestOpenRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenRequestOpenRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) Set(target, source *ListenRequest_OpenRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenRequest_OpenRequest), source.(*ListenRequest_OpenRequest))
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) Project(source *ListenRequest_OpenRequest) *ListenRequest_OpenRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenRequest_OpenRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenRequestOpenRequest_FieldTerminalPath:
			switch tp.selector {
			case ListenRequestOpenRequest_FieldPathSelectorProject:
				result.Project = source.Project
			case ListenRequestOpenRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenRequest_OpenRequest))
}

func (fieldMask *ListenRequest_OpenRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenRequest_ResumeRequest_FieldMask struct {
	Paths []ListenRequestResumeRequest_FieldPath
}

func FullListenRequest_ResumeRequest_FieldMask() *ListenRequest_ResumeRequest_FieldMask {
	res := &ListenRequest_ResumeRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListenRequestResumeRequest_FieldTerminalPath{selector: ListenRequestResumeRequest_FieldPathSelectorProject})
	res.Paths = append(res.Paths, &ListenRequestResumeRequest_FieldTerminalPath{selector: ListenRequestResumeRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ListenRequestResumeRequest_FieldTerminalPath{selector: ListenRequestResumeRequest_FieldPathSelectorSessionId})
	return res
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenRequest_ResumeRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenRequestResumeRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenRequestResumeRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenRequestResumeRequest_FieldPath(raw)
	})
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) Subtract(other *ListenRequest_ResumeRequest_FieldMask) *ListenRequest_ResumeRequest_FieldMask {
	result := &ListenRequest_ResumeRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenRequestResumeRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenRequest_ResumeRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenRequest_ResumeRequest_FieldMask) FilterInputFields() *ListenRequest_ResumeRequest_FieldMask {
	result := &ListenRequest_ResumeRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenRequest_ResumeRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenRequestResumeRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenRequestResumeRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenRequest_ResumeRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenRequest_ResumeRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) AppendPath(path ListenRequestResumeRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenRequestResumeRequest_FieldPath))
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) GetPaths() []ListenRequestResumeRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenRequestResumeRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) Set(target, source *ListenRequest_ResumeRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenRequest_ResumeRequest), source.(*ListenRequest_ResumeRequest))
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) Project(source *ListenRequest_ResumeRequest) *ListenRequest_ResumeRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenRequest_ResumeRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenRequestResumeRequest_FieldTerminalPath:
			switch tp.selector {
			case ListenRequestResumeRequest_FieldPathSelectorProject:
				result.Project = source.Project
			case ListenRequestResumeRequest_FieldPathSelectorName:
				result.Name = source.Name
			case ListenRequestResumeRequest_FieldPathSelectorSessionId:
				result.SessionId = source.SessionId
			}
		}
	}
	return result
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenRequest_ResumeRequest))
}

func (fieldMask *ListenRequest_ResumeRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenRequest_ChannelOpenError_FieldMask struct {
	Paths []ListenRequestChannelOpenError_FieldPath
}

func FullListenRequest_ChannelOpenError_FieldMask() *ListenRequest_ChannelOpenError_FieldMask {
	res := &ListenRequest_ChannelOpenError_FieldMask{}
	res.Paths = append(res.Paths, &ListenRequestChannelOpenError_FieldTerminalPath{selector: ListenRequestChannelOpenError_FieldPathSelectorChannelId})
	res.Paths = append(res.Paths, &ListenRequestChannelOpenError_FieldTerminalPath{selector: ListenRequestChannelOpenError_FieldPathSelectorMessage})
	return res
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenRequestChannelOpenError_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenRequestChannelOpenError_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenRequestChannelOpenError_FieldPath(raw)
	})
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) ProtoMessage() {}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) Subtract(other *ListenRequest_ChannelOpenError_FieldMask) *ListenRequest_ChannelOpenError_FieldMask {
	result := &ListenRequest_ChannelOpenError_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenRequestChannelOpenError_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenRequest_ChannelOpenError_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) FilterInputFields() *ListenRequest_ChannelOpenError_FieldMask {
	result := &ListenRequest_ChannelOpenError_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenRequestChannelOpenError_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenRequestChannelOpenError_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenRequest_ChannelOpenError_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenRequest_ChannelOpenError_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) AppendPath(path ListenRequestChannelOpenError_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenRequestChannelOpenError_FieldPath))
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) GetPaths() []ListenRequestChannelOpenError_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenRequestChannelOpenError_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) Set(target, source *ListenRequest_ChannelOpenError) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenRequest_ChannelOpenError), source.(*ListenRequest_ChannelOpenError))
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) Project(source *ListenRequest_ChannelOpenError) *ListenRequest_ChannelOpenError {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenRequest_ChannelOpenError{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenRequestChannelOpenError_FieldTerminalPath:
			switch tp.selector {
			case ListenRequestChannelOpenError_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			case ListenRequestChannelOpenError_FieldPathSelectorMessage:
				result.Message = source.Message
			}
		}
	}
	return result
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenRequest_ChannelOpenError))
}

func (fieldMask *ListenRequest_ChannelOpenError_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenResponse_FieldMask struct {
	Paths []ListenResponse_FieldPath
}

func FullListenResponse_FieldMask() *ListenResponse_FieldMask {
	res := &ListenResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListenResponse_FieldTerminalPath{selector: ListenResponse_FieldPathSelectorListening})
	res.Paths = append(res.Paths, &ListenResponse_FieldTerminalPath{selector: ListenResponse_FieldPathSelectorOpenChannelResponse})
	res.Paths = append(res.Paths, &ListenResponse_FieldTerminalPath{selector: ListenResponse_FieldPathSelectorResumeChannelResponse})
	return res
}

func (fieldMask *ListenResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenResponse_FieldPath(raw)
	})
}

func (fieldMask *ListenResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListenResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenResponse_FieldMask) Subtract(other *ListenResponse_FieldMask) *ListenResponse_FieldMask {
	result := &ListenResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListenResponse_FieldPathSelector]gotenobject.FieldMask{
		ListenResponse_FieldPathSelectorListening:             &ListenResponse_Listening_FieldMask{},
		ListenResponse_FieldPathSelectorOpenChannelResponse:   &ListenResponse_OpenChannelResponse_FieldMask{},
		ListenResponse_FieldPathSelectorResumeChannelResponse: &ListenResponse_ResumeChannelResponse_FieldMask{},
	}
	mySubMasks := map[ListenResponse_FieldPathSelector]gotenobject.FieldMask{
		ListenResponse_FieldPathSelectorListening:             &ListenResponse_Listening_FieldMask{},
		ListenResponse_FieldPathSelectorOpenChannelResponse:   &ListenResponse_OpenChannelResponse_FieldMask{},
		ListenResponse_FieldPathSelectorResumeChannelResponse: &ListenResponse_ResumeChannelResponse_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListenResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListenResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListenResponse_FieldPathSelectorListening:
						mySubMasks[ListenResponse_FieldPathSelectorListening] = FullListenResponse_Listening_FieldMask()
					case ListenResponse_FieldPathSelectorOpenChannelResponse:
						mySubMasks[ListenResponse_FieldPathSelectorOpenChannelResponse] = FullListenResponse_OpenChannelResponse_FieldMask()
					case ListenResponse_FieldPathSelectorResumeChannelResponse:
						mySubMasks[ListenResponse_FieldPathSelectorResumeChannelResponse] = FullListenResponse_ResumeChannelResponse_FieldMask()
					}
				} else if tp, ok := path.(*ListenResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListenResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenResponse_FieldMask) FilterInputFields() *ListenResponse_FieldMask {
	result := &ListenResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenResponse_FieldMask) AppendPath(path ListenResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenResponse_FieldPath))
}

func (fieldMask *ListenResponse_FieldMask) GetPaths() []ListenResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenResponse_FieldMask) Set(target, source *ListenResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenResponse), source.(*ListenResponse))
}

func (fieldMask *ListenResponse_FieldMask) Project(source *ListenResponse) *ListenResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenResponse{}
	listeningMask := &ListenResponse_Listening_FieldMask{}
	wholeListeningAccepted := false
	openChannelResponseMask := &ListenResponse_OpenChannelResponse_FieldMask{}
	wholeOpenChannelResponseAccepted := false
	resumeChannelResponseMask := &ListenResponse_ResumeChannelResponse_FieldMask{}
	wholeResumeChannelResponseAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenResponse_FieldTerminalPath:
			switch tp.selector {
			case ListenResponse_FieldPathSelectorListening:
				if source, ok := source.Message.(*ListenResponse_Listening_); ok {
					result.Message = &ListenResponse_Listening_{
						Listening: source.Listening,
					}
				}
				wholeListeningAccepted = true
			case ListenResponse_FieldPathSelectorOpenChannelResponse:
				if source, ok := source.Message.(*ListenResponse_OpenChannelResponse_); ok {
					result.Message = &ListenResponse_OpenChannelResponse_{
						OpenChannelResponse: source.OpenChannelResponse,
					}
				}
				wholeOpenChannelResponseAccepted = true
			case ListenResponse_FieldPathSelectorResumeChannelResponse:
				if source, ok := source.Message.(*ListenResponse_ResumeChannelResponse_); ok {
					result.Message = &ListenResponse_ResumeChannelResponse_{
						ResumeChannelResponse: source.ResumeChannelResponse,
					}
				}
				wholeResumeChannelResponseAccepted = true
			}
		case *ListenResponse_FieldSubPath:
			switch tp.selector {
			case ListenResponse_FieldPathSelectorListening:
				listeningMask.AppendPath(tp.subPath.(ListenResponseListening_FieldPath))
			case ListenResponse_FieldPathSelectorOpenChannelResponse:
				openChannelResponseMask.AppendPath(tp.subPath.(ListenResponseOpenChannelResponse_FieldPath))
			case ListenResponse_FieldPathSelectorResumeChannelResponse:
				resumeChannelResponseMask.AppendPath(tp.subPath.(ListenResponseResumeChannelResponse_FieldPath))
			}
		}
	}
	if wholeListeningAccepted == false && len(listeningMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ListenResponse_Listening_); ok {
			result.Message = (*ListenResponse_Listening_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenResponse_Listening_{}
				oneOfRes.Listening = listeningMask.Project(asOneOf.Listening)
				result.Message = oneOfRes
			}
		}
	}
	if wholeOpenChannelResponseAccepted == false && len(openChannelResponseMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ListenResponse_OpenChannelResponse_); ok {
			result.Message = (*ListenResponse_OpenChannelResponse_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenResponse_OpenChannelResponse_{}
				oneOfRes.OpenChannelResponse = openChannelResponseMask.Project(asOneOf.OpenChannelResponse)
				result.Message = oneOfRes
			}
		}
	}
	if wholeResumeChannelResponseAccepted == false && len(resumeChannelResponseMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ListenResponse_ResumeChannelResponse_); ok {
			result.Message = (*ListenResponse_ResumeChannelResponse_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenResponse_ResumeChannelResponse_{}
				oneOfRes.ResumeChannelResponse = resumeChannelResponseMask.Project(asOneOf.ResumeChannelResponse)
				result.Message = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ListenResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenResponse))
}

func (fieldMask *ListenResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenResponse_Listening_FieldMask struct {
	Paths []ListenResponseListening_FieldPath
}

func FullListenResponse_Listening_FieldMask() *ListenResponse_Listening_FieldMask {
	res := &ListenResponse_Listening_FieldMask{}
	res.Paths = append(res.Paths, &ListenResponseListening_FieldTerminalPath{selector: ListenResponseListening_FieldPathSelectorSessionId})
	return res
}

func (fieldMask *ListenResponse_Listening_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenResponse_Listening_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenResponse_Listening_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenResponseListening_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenResponse_Listening_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenResponseListening_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenResponse_Listening_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenResponseListening_FieldPath(raw)
	})
}

func (fieldMask *ListenResponse_Listening_FieldMask) ProtoMessage() {}

func (fieldMask *ListenResponse_Listening_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenResponse_Listening_FieldMask) Subtract(other *ListenResponse_Listening_FieldMask) *ListenResponse_Listening_FieldMask {
	result := &ListenResponse_Listening_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenResponseListening_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenResponse_Listening_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenResponse_Listening_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenResponse_Listening_FieldMask) FilterInputFields() *ListenResponse_Listening_FieldMask {
	result := &ListenResponse_Listening_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenResponse_Listening_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenResponse_Listening_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenResponseListening_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenResponseListening_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenResponse_Listening_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenResponse_Listening_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenResponse_Listening_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenResponse_Listening_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenResponse_Listening_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenResponse_Listening_FieldMask) AppendPath(path ListenResponseListening_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenResponse_Listening_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenResponseListening_FieldPath))
}

func (fieldMask *ListenResponse_Listening_FieldMask) GetPaths() []ListenResponseListening_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenResponse_Listening_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenResponse_Listening_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenResponseListening_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenResponse_Listening_FieldMask) Set(target, source *ListenResponse_Listening) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenResponse_Listening_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenResponse_Listening), source.(*ListenResponse_Listening))
}

func (fieldMask *ListenResponse_Listening_FieldMask) Project(source *ListenResponse_Listening) *ListenResponse_Listening {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenResponse_Listening{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenResponseListening_FieldTerminalPath:
			switch tp.selector {
			case ListenResponseListening_FieldPathSelectorSessionId:
				result.SessionId = source.SessionId
			}
		}
	}
	return result
}

func (fieldMask *ListenResponse_Listening_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenResponse_Listening))
}

func (fieldMask *ListenResponse_Listening_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenResponse_OpenChannelResponse_FieldMask struct {
	Paths []ListenResponseOpenChannelResponse_FieldPath
}

func FullListenResponse_OpenChannelResponse_FieldMask() *ListenResponse_OpenChannelResponse_FieldMask {
	res := &ListenResponse_OpenChannelResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListenResponseOpenChannelResponse_FieldTerminalPath{selector: ListenResponseOpenChannelResponse_FieldPathSelectorChannelId})
	res.Paths = append(res.Paths, &ListenResponseOpenChannelResponse_FieldTerminalPath{selector: ListenResponseOpenChannelResponse_FieldPathSelectorService})
	res.Paths = append(res.Paths, &ListenResponseOpenChannelResponse_FieldTerminalPath{selector: ListenResponseOpenChannelResponse_FieldPathSelectorArg})
	return res
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenResponseOpenChannelResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenResponseOpenChannelResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenResponseOpenChannelResponse_FieldPath(raw)
	})
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) Subtract(other *ListenResponse_OpenChannelResponse_FieldMask) *ListenResponse_OpenChannelResponse_FieldMask {
	result := &ListenResponse_OpenChannelResponse_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenResponseOpenChannelResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenResponse_OpenChannelResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) FilterInputFields() *ListenResponse_OpenChannelResponse_FieldMask {
	result := &ListenResponse_OpenChannelResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenResponseOpenChannelResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenResponseOpenChannelResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenResponse_OpenChannelResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenResponse_OpenChannelResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) AppendPath(path ListenResponseOpenChannelResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenResponseOpenChannelResponse_FieldPath))
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) GetPaths() []ListenResponseOpenChannelResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenResponseOpenChannelResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) Set(target, source *ListenResponse_OpenChannelResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenResponse_OpenChannelResponse), source.(*ListenResponse_OpenChannelResponse))
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) Project(source *ListenResponse_OpenChannelResponse) *ListenResponse_OpenChannelResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenResponse_OpenChannelResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenResponseOpenChannelResponse_FieldTerminalPath:
			switch tp.selector {
			case ListenResponseOpenChannelResponse_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			case ListenResponseOpenChannelResponse_FieldPathSelectorService:
				result.Service = source.Service
			case ListenResponseOpenChannelResponse_FieldPathSelectorArg:
				result.Arg = source.Arg
			}
		}
	}
	return result
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenResponse_OpenChannelResponse))
}

func (fieldMask *ListenResponse_OpenChannelResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenResponse_ResumeChannelResponse_FieldMask struct {
	Paths []ListenResponseResumeChannelResponse_FieldPath
}

func FullListenResponse_ResumeChannelResponse_FieldMask() *ListenResponse_ResumeChannelResponse_FieldMask {
	res := &ListenResponse_ResumeChannelResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListenResponseResumeChannelResponse_FieldTerminalPath{selector: ListenResponseResumeChannelResponse_FieldPathSelectorChannelId})
	res.Paths = append(res.Paths, &ListenResponseResumeChannelResponse_FieldTerminalPath{selector: ListenResponseResumeChannelResponse_FieldPathSelectorService})
	res.Paths = append(res.Paths, &ListenResponseResumeChannelResponse_FieldTerminalPath{selector: ListenResponseResumeChannelResponse_FieldPathSelectorArg})
	res.Paths = append(res.Paths, &ListenResponseResumeChannelResponse_FieldTerminalPath{selector: ListenResponseResumeChannelResponse_FieldPathSelectorLastMessageId})
	return res
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenResponseResumeChannelResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenResponseResumeChannelResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenResponseResumeChannelResponse_FieldPath(raw)
	})
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) Subtract(other *ListenResponse_ResumeChannelResponse_FieldMask) *ListenResponse_ResumeChannelResponse_FieldMask {
	result := &ListenResponse_ResumeChannelResponse_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenResponseResumeChannelResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenResponse_ResumeChannelResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) FilterInputFields() *ListenResponse_ResumeChannelResponse_FieldMask {
	result := &ListenResponse_ResumeChannelResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenResponseResumeChannelResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenResponseResumeChannelResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenResponse_ResumeChannelResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenResponse_ResumeChannelResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) AppendPath(path ListenResponseResumeChannelResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenResponseResumeChannelResponse_FieldPath))
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) GetPaths() []ListenResponseResumeChannelResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenResponseResumeChannelResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) Set(target, source *ListenResponse_ResumeChannelResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenResponse_ResumeChannelResponse), source.(*ListenResponse_ResumeChannelResponse))
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) Project(source *ListenResponse_ResumeChannelResponse) *ListenResponse_ResumeChannelResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenResponse_ResumeChannelResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenResponseResumeChannelResponse_FieldTerminalPath:
			switch tp.selector {
			case ListenResponseResumeChannelResponse_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			case ListenResponseResumeChannelResponse_FieldPathSelectorService:
				result.Service = source.Service
			case ListenResponseResumeChannelResponse_FieldPathSelectorArg:
				result.Arg = source.Arg
			case ListenResponseResumeChannelResponse_FieldPathSelectorLastMessageId:
				result.LastMessageId = source.LastMessageId
			}
		}
	}
	return result
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenResponse_ResumeChannelResponse))
}

func (fieldMask *ListenResponse_ResumeChannelResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type AcceptRequest_FieldMask struct {
	Paths []AcceptRequest_FieldPath
}

func FullAcceptRequest_FieldMask() *AcceptRequest_FieldMask {
	res := &AcceptRequest_FieldMask{}
	res.Paths = append(res.Paths, &AcceptRequest_FieldTerminalPath{selector: AcceptRequest_FieldPathSelectorOpenRequest})
	res.Paths = append(res.Paths, &AcceptRequest_FieldTerminalPath{selector: AcceptRequest_FieldPathSelectorResumeRequest})
	res.Paths = append(res.Paths, &AcceptRequest_FieldTerminalPath{selector: AcceptRequest_FieldPathSelectorData})
	res.Paths = append(res.Paths, &AcceptRequest_FieldTerminalPath{selector: AcceptRequest_FieldPathSelectorAck})
	res.Paths = append(res.Paths, &AcceptRequest_FieldTerminalPath{selector: AcceptRequest_FieldPathSelectorClose})
	res.Paths = append(res.Paths, &AcceptRequest_FieldTerminalPath{selector: AcceptRequest_FieldPathSelectorError})
	res.Paths = append(res.Paths, &AcceptRequest_FieldTerminalPath{selector: AcceptRequest_FieldPathSelectorPing})
	return res
}

func (fieldMask *AcceptRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *AcceptRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *AcceptRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseAcceptRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *AcceptRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*AcceptRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *AcceptRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAcceptRequest_FieldPath(raw)
	})
}

func (fieldMask *AcceptRequest_FieldMask) ProtoMessage() {}

func (fieldMask *AcceptRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *AcceptRequest_FieldMask) Subtract(other *AcceptRequest_FieldMask) *AcceptRequest_FieldMask {
	result := &AcceptRequest_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[AcceptRequest_FieldPathSelector]gotenobject.FieldMask{
		AcceptRequest_FieldPathSelectorOpenRequest:   &AcceptRequest_OpenRequest_FieldMask{},
		AcceptRequest_FieldPathSelectorResumeRequest: &AcceptRequest_ResumeRequest_FieldMask{},
		AcceptRequest_FieldPathSelectorData:          &Data_FieldMask{},
		AcceptRequest_FieldPathSelectorAck:           &Ack_FieldMask{},
		AcceptRequest_FieldPathSelectorClose:         &Close_FieldMask{},
		AcceptRequest_FieldPathSelectorError:         &Error_FieldMask{},
		AcceptRequest_FieldPathSelectorPing:          &Ping_FieldMask{},
	}
	mySubMasks := map[AcceptRequest_FieldPathSelector]gotenobject.FieldMask{
		AcceptRequest_FieldPathSelectorOpenRequest:   &AcceptRequest_OpenRequest_FieldMask{},
		AcceptRequest_FieldPathSelectorResumeRequest: &AcceptRequest_ResumeRequest_FieldMask{},
		AcceptRequest_FieldPathSelectorData:          &Data_FieldMask{},
		AcceptRequest_FieldPathSelectorAck:           &Ack_FieldMask{},
		AcceptRequest_FieldPathSelectorClose:         &Close_FieldMask{},
		AcceptRequest_FieldPathSelectorError:         &Error_FieldMask{},
		AcceptRequest_FieldPathSelectorPing:          &Ping_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *AcceptRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *AcceptRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*AcceptRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case AcceptRequest_FieldPathSelectorOpenRequest:
						mySubMasks[AcceptRequest_FieldPathSelectorOpenRequest] = FullAcceptRequest_OpenRequest_FieldMask()
					case AcceptRequest_FieldPathSelectorResumeRequest:
						mySubMasks[AcceptRequest_FieldPathSelectorResumeRequest] = FullAcceptRequest_ResumeRequest_FieldMask()
					case AcceptRequest_FieldPathSelectorData:
						mySubMasks[AcceptRequest_FieldPathSelectorData] = FullData_FieldMask()
					case AcceptRequest_FieldPathSelectorAck:
						mySubMasks[AcceptRequest_FieldPathSelectorAck] = FullAck_FieldMask()
					case AcceptRequest_FieldPathSelectorClose:
						mySubMasks[AcceptRequest_FieldPathSelectorClose] = FullClose_FieldMask()
					case AcceptRequest_FieldPathSelectorError:
						mySubMasks[AcceptRequest_FieldPathSelectorError] = FullError_FieldMask()
					case AcceptRequest_FieldPathSelectorPing:
						mySubMasks[AcceptRequest_FieldPathSelectorPing] = FullPing_FieldMask()
					}
				} else if tp, ok := path.(*AcceptRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &AcceptRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *AcceptRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*AcceptRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *AcceptRequest_FieldMask) FilterInputFields() *AcceptRequest_FieldMask {
	result := &AcceptRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *AcceptRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *AcceptRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]AcceptRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAcceptRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask AcceptRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *AcceptRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AcceptRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask AcceptRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *AcceptRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AcceptRequest_FieldMask) AppendPath(path AcceptRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *AcceptRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(AcceptRequest_FieldPath))
}

func (fieldMask *AcceptRequest_FieldMask) GetPaths() []AcceptRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *AcceptRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *AcceptRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAcceptRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *AcceptRequest_FieldMask) Set(target, source *AcceptRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *AcceptRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*AcceptRequest), source.(*AcceptRequest))
}

func (fieldMask *AcceptRequest_FieldMask) Project(source *AcceptRequest) *AcceptRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &AcceptRequest{}
	openRequestMask := &AcceptRequest_OpenRequest_FieldMask{}
	wholeOpenRequestAccepted := false
	resumeRequestMask := &AcceptRequest_ResumeRequest_FieldMask{}
	wholeResumeRequestAccepted := false
	dataMask := &Data_FieldMask{}
	wholeDataAccepted := false
	ackMask := &Ack_FieldMask{}
	wholeAckAccepted := false
	closeMask := &Close_FieldMask{}
	wholeCloseAccepted := false
	errorMask := &Error_FieldMask{}
	wholeErrorAccepted := false
	pingMask := &Ping_FieldMask{}
	wholePingAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *AcceptRequest_FieldTerminalPath:
			switch tp.selector {
			case AcceptRequest_FieldPathSelectorOpenRequest:
				if source, ok := source.Message.(*AcceptRequest_OpenRequest_); ok {
					result.Message = &AcceptRequest_OpenRequest_{
						OpenRequest: source.OpenRequest,
					}
				}
				wholeOpenRequestAccepted = true
			case AcceptRequest_FieldPathSelectorResumeRequest:
				if source, ok := source.Message.(*AcceptRequest_ResumeRequest_); ok {
					result.Message = &AcceptRequest_ResumeRequest_{
						ResumeRequest: source.ResumeRequest,
					}
				}
				wholeResumeRequestAccepted = true
			case AcceptRequest_FieldPathSelectorData:
				if source, ok := source.Message.(*AcceptRequest_Data); ok {
					result.Message = &AcceptRequest_Data{
						Data: source.Data,
					}
				}
				wholeDataAccepted = true
			case AcceptRequest_FieldPathSelectorAck:
				if source, ok := source.Message.(*AcceptRequest_Ack); ok {
					result.Message = &AcceptRequest_Ack{
						Ack: source.Ack,
					}
				}
				wholeAckAccepted = true
			case AcceptRequest_FieldPathSelectorClose:
				if source, ok := source.Message.(*AcceptRequest_Close); ok {
					result.Message = &AcceptRequest_Close{
						Close: source.Close,
					}
				}
				wholeCloseAccepted = true
			case AcceptRequest_FieldPathSelectorError:
				if source, ok := source.Message.(*AcceptRequest_Error); ok {
					result.Message = &AcceptRequest_Error{
						Error: source.Error,
					}
				}
				wholeErrorAccepted = true
			case AcceptRequest_FieldPathSelectorPing:
				if source, ok := source.Message.(*AcceptRequest_Ping); ok {
					result.Message = &AcceptRequest_Ping{
						Ping: source.Ping,
					}
				}
				wholePingAccepted = true
			}
		case *AcceptRequest_FieldSubPath:
			switch tp.selector {
			case AcceptRequest_FieldPathSelectorOpenRequest:
				openRequestMask.AppendPath(tp.subPath.(AcceptRequestOpenRequest_FieldPath))
			case AcceptRequest_FieldPathSelectorResumeRequest:
				resumeRequestMask.AppendPath(tp.subPath.(AcceptRequestResumeRequest_FieldPath))
			case AcceptRequest_FieldPathSelectorData:
				dataMask.AppendPath(tp.subPath.(Data_FieldPath))
			case AcceptRequest_FieldPathSelectorAck:
				ackMask.AppendPath(tp.subPath.(Ack_FieldPath))
			case AcceptRequest_FieldPathSelectorClose:
				closeMask.AppendPath(tp.subPath.(Close_FieldPath))
			case AcceptRequest_FieldPathSelectorError:
				errorMask.AppendPath(tp.subPath.(Error_FieldPath))
			case AcceptRequest_FieldPathSelectorPing:
				pingMask.AppendPath(tp.subPath.(Ping_FieldPath))
			}
		}
	}
	if wholeOpenRequestAccepted == false && len(openRequestMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptRequest_OpenRequest_); ok {
			result.Message = (*AcceptRequest_OpenRequest_)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptRequest_OpenRequest_{}
				oneOfRes.OpenRequest = openRequestMask.Project(asOneOf.OpenRequest)
				result.Message = oneOfRes
			}
		}
	}
	if wholeResumeRequestAccepted == false && len(resumeRequestMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptRequest_ResumeRequest_); ok {
			result.Message = (*AcceptRequest_ResumeRequest_)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptRequest_ResumeRequest_{}
				oneOfRes.ResumeRequest = resumeRequestMask.Project(asOneOf.ResumeRequest)
				result.Message = oneOfRes
			}
		}
	}
	if wholeDataAccepted == false && len(dataMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptRequest_Data); ok {
			result.Message = (*AcceptRequest_Data)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptRequest_Data{}
				oneOfRes.Data = dataMask.Project(asOneOf.Data)
				result.Message = oneOfRes
			}
		}
	}
	if wholeAckAccepted == false && len(ackMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptRequest_Ack); ok {
			result.Message = (*AcceptRequest_Ack)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptRequest_Ack{}
				oneOfRes.Ack = ackMask.Project(asOneOf.Ack)
				result.Message = oneOfRes
			}
		}
	}
	if wholeCloseAccepted == false && len(closeMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptRequest_Close); ok {
			result.Message = (*AcceptRequest_Close)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptRequest_Close{}
				oneOfRes.Close = closeMask.Project(asOneOf.Close)
				result.Message = oneOfRes
			}
		}
	}
	if wholeErrorAccepted == false && len(errorMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptRequest_Error); ok {
			result.Message = (*AcceptRequest_Error)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptRequest_Error{}
				oneOfRes.Error = errorMask.Project(asOneOf.Error)
				result.Message = oneOfRes
			}
		}
	}
	if wholePingAccepted == false && len(pingMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptRequest_Ping); ok {
			result.Message = (*AcceptRequest_Ping)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptRequest_Ping{}
				oneOfRes.Ping = pingMask.Project(asOneOf.Ping)
				result.Message = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *AcceptRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*AcceptRequest))
}

func (fieldMask *AcceptRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type AcceptRequest_OpenRequest_FieldMask struct {
	Paths []AcceptRequestOpenRequest_FieldPath
}

func FullAcceptRequest_OpenRequest_FieldMask() *AcceptRequest_OpenRequest_FieldMask {
	res := &AcceptRequest_OpenRequest_FieldMask{}
	res.Paths = append(res.Paths, &AcceptRequestOpenRequest_FieldTerminalPath{selector: AcceptRequestOpenRequest_FieldPathSelectorProject})
	res.Paths = append(res.Paths, &AcceptRequestOpenRequest_FieldTerminalPath{selector: AcceptRequestOpenRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &AcceptRequestOpenRequest_FieldTerminalPath{selector: AcceptRequestOpenRequest_FieldPathSelectorSessionId})
	res.Paths = append(res.Paths, &AcceptRequestOpenRequest_FieldTerminalPath{selector: AcceptRequestOpenRequest_FieldPathSelectorChannelId})
	return res
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *AcceptRequest_OpenRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseAcceptRequestOpenRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*AcceptRequestOpenRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAcceptRequestOpenRequest_FieldPath(raw)
	})
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) ProtoMessage() {}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) Subtract(other *AcceptRequest_OpenRequest_FieldMask) *AcceptRequest_OpenRequest_FieldMask {
	result := &AcceptRequest_OpenRequest_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *AcceptRequestOpenRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*AcceptRequest_OpenRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *AcceptRequest_OpenRequest_FieldMask) FilterInputFields() *AcceptRequest_OpenRequest_FieldMask {
	result := &AcceptRequest_OpenRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *AcceptRequest_OpenRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]AcceptRequestOpenRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAcceptRequestOpenRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask AcceptRequest_OpenRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask AcceptRequest_OpenRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) AppendPath(path AcceptRequestOpenRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(AcceptRequestOpenRequest_FieldPath))
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) GetPaths() []AcceptRequestOpenRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAcceptRequestOpenRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) Set(target, source *AcceptRequest_OpenRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*AcceptRequest_OpenRequest), source.(*AcceptRequest_OpenRequest))
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) Project(source *AcceptRequest_OpenRequest) *AcceptRequest_OpenRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &AcceptRequest_OpenRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *AcceptRequestOpenRequest_FieldTerminalPath:
			switch tp.selector {
			case AcceptRequestOpenRequest_FieldPathSelectorProject:
				result.Project = source.Project
			case AcceptRequestOpenRequest_FieldPathSelectorName:
				result.Name = source.Name
			case AcceptRequestOpenRequest_FieldPathSelectorSessionId:
				result.SessionId = source.SessionId
			case AcceptRequestOpenRequest_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			}
		}
	}
	return result
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*AcceptRequest_OpenRequest))
}

func (fieldMask *AcceptRequest_OpenRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type AcceptRequest_ResumeRequest_FieldMask struct {
	Paths []AcceptRequestResumeRequest_FieldPath
}

func FullAcceptRequest_ResumeRequest_FieldMask() *AcceptRequest_ResumeRequest_FieldMask {
	res := &AcceptRequest_ResumeRequest_FieldMask{}
	res.Paths = append(res.Paths, &AcceptRequestResumeRequest_FieldTerminalPath{selector: AcceptRequestResumeRequest_FieldPathSelectorProject})
	res.Paths = append(res.Paths, &AcceptRequestResumeRequest_FieldTerminalPath{selector: AcceptRequestResumeRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &AcceptRequestResumeRequest_FieldTerminalPath{selector: AcceptRequestResumeRequest_FieldPathSelectorSessionId})
	res.Paths = append(res.Paths, &AcceptRequestResumeRequest_FieldTerminalPath{selector: AcceptRequestResumeRequest_FieldPathSelectorChannelId})
	res.Paths = append(res.Paths, &AcceptRequestResumeRequest_FieldTerminalPath{selector: AcceptRequestResumeRequest_FieldPathSelectorLastMessageId})
	return res
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseAcceptRequestResumeRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*AcceptRequestResumeRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAcceptRequestResumeRequest_FieldPath(raw)
	})
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) ProtoMessage() {}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) Subtract(other *AcceptRequest_ResumeRequest_FieldMask) *AcceptRequest_ResumeRequest_FieldMask {
	result := &AcceptRequest_ResumeRequest_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *AcceptRequestResumeRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*AcceptRequest_ResumeRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) FilterInputFields() *AcceptRequest_ResumeRequest_FieldMask {
	result := &AcceptRequest_ResumeRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]AcceptRequestResumeRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAcceptRequestResumeRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask AcceptRequest_ResumeRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask AcceptRequest_ResumeRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) AppendPath(path AcceptRequestResumeRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(AcceptRequestResumeRequest_FieldPath))
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) GetPaths() []AcceptRequestResumeRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAcceptRequestResumeRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) Set(target, source *AcceptRequest_ResumeRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*AcceptRequest_ResumeRequest), source.(*AcceptRequest_ResumeRequest))
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) Project(source *AcceptRequest_ResumeRequest) *AcceptRequest_ResumeRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &AcceptRequest_ResumeRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *AcceptRequestResumeRequest_FieldTerminalPath:
			switch tp.selector {
			case AcceptRequestResumeRequest_FieldPathSelectorProject:
				result.Project = source.Project
			case AcceptRequestResumeRequest_FieldPathSelectorName:
				result.Name = source.Name
			case AcceptRequestResumeRequest_FieldPathSelectorSessionId:
				result.SessionId = source.SessionId
			case AcceptRequestResumeRequest_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			case AcceptRequestResumeRequest_FieldPathSelectorLastMessageId:
				result.LastMessageId = source.LastMessageId
			}
		}
	}
	return result
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*AcceptRequest_ResumeRequest))
}

func (fieldMask *AcceptRequest_ResumeRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Ping_FieldMask struct {
	Paths []Ping_FieldPath
}

func FullPing_FieldMask() *Ping_FieldMask {
	res := &Ping_FieldMask{}
	return res
}

func (fieldMask *Ping_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Ping_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Ping_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePing_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Ping_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Ping_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Ping_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePing_FieldPath(raw)
	})
}

func (fieldMask *Ping_FieldMask) ProtoMessage() {}

func (fieldMask *Ping_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Ping_FieldMask) Subtract(other *Ping_FieldMask) *Ping_FieldMask {
	result := &Ping_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Ping_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Ping_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Ping_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Ping_FieldMask) FilterInputFields() *Ping_FieldMask {
	result := &Ping_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Ping_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Ping_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Ping_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePing_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Ping_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Ping_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Ping_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Ping_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Ping_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Ping_FieldMask) AppendPath(path Ping_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Ping_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Ping_FieldPath))
}

func (fieldMask *Ping_FieldMask) GetPaths() []Ping_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Ping_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Ping_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePing_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Ping_FieldMask) Set(target, source *Ping) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Ping_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Ping), source.(*Ping))
}

func (fieldMask *Ping_FieldMask) Project(source *Ping) *Ping {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Ping{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Ping_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *Ping_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Ping))
}

func (fieldMask *Ping_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type AcceptResponse_FieldMask struct {
	Paths []AcceptResponse_FieldPath
}

func FullAcceptResponse_FieldMask() *AcceptResponse_FieldMask {
	res := &AcceptResponse_FieldMask{}
	res.Paths = append(res.Paths, &AcceptResponse_FieldTerminalPath{selector: AcceptResponse_FieldPathSelectorData})
	res.Paths = append(res.Paths, &AcceptResponse_FieldTerminalPath{selector: AcceptResponse_FieldPathSelectorAck})
	res.Paths = append(res.Paths, &AcceptResponse_FieldTerminalPath{selector: AcceptResponse_FieldPathSelectorClose})
	res.Paths = append(res.Paths, &AcceptResponse_FieldTerminalPath{selector: AcceptResponse_FieldPathSelectorError})
	return res
}

func (fieldMask *AcceptResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *AcceptResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *AcceptResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseAcceptResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *AcceptResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*AcceptResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *AcceptResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAcceptResponse_FieldPath(raw)
	})
}

func (fieldMask *AcceptResponse_FieldMask) ProtoMessage() {}

func (fieldMask *AcceptResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *AcceptResponse_FieldMask) Subtract(other *AcceptResponse_FieldMask) *AcceptResponse_FieldMask {
	result := &AcceptResponse_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[AcceptResponse_FieldPathSelector]gotenobject.FieldMask{
		AcceptResponse_FieldPathSelectorData:  &Data_FieldMask{},
		AcceptResponse_FieldPathSelectorAck:   &Ack_FieldMask{},
		AcceptResponse_FieldPathSelectorClose: &Close_FieldMask{},
		AcceptResponse_FieldPathSelectorError: &Error_FieldMask{},
	}
	mySubMasks := map[AcceptResponse_FieldPathSelector]gotenobject.FieldMask{
		AcceptResponse_FieldPathSelectorData:  &Data_FieldMask{},
		AcceptResponse_FieldPathSelectorAck:   &Ack_FieldMask{},
		AcceptResponse_FieldPathSelectorClose: &Close_FieldMask{},
		AcceptResponse_FieldPathSelectorError: &Error_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *AcceptResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *AcceptResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*AcceptResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case AcceptResponse_FieldPathSelectorData:
						mySubMasks[AcceptResponse_FieldPathSelectorData] = FullData_FieldMask()
					case AcceptResponse_FieldPathSelectorAck:
						mySubMasks[AcceptResponse_FieldPathSelectorAck] = FullAck_FieldMask()
					case AcceptResponse_FieldPathSelectorClose:
						mySubMasks[AcceptResponse_FieldPathSelectorClose] = FullClose_FieldMask()
					case AcceptResponse_FieldPathSelectorError:
						mySubMasks[AcceptResponse_FieldPathSelectorError] = FullError_FieldMask()
					}
				} else if tp, ok := path.(*AcceptResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &AcceptResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *AcceptResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*AcceptResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *AcceptResponse_FieldMask) FilterInputFields() *AcceptResponse_FieldMask {
	result := &AcceptResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *AcceptResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *AcceptResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]AcceptResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAcceptResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask AcceptResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *AcceptResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AcceptResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask AcceptResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *AcceptResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AcceptResponse_FieldMask) AppendPath(path AcceptResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *AcceptResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(AcceptResponse_FieldPath))
}

func (fieldMask *AcceptResponse_FieldMask) GetPaths() []AcceptResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *AcceptResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *AcceptResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAcceptResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *AcceptResponse_FieldMask) Set(target, source *AcceptResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *AcceptResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*AcceptResponse), source.(*AcceptResponse))
}

func (fieldMask *AcceptResponse_FieldMask) Project(source *AcceptResponse) *AcceptResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &AcceptResponse{}
	dataMask := &Data_FieldMask{}
	wholeDataAccepted := false
	ackMask := &Ack_FieldMask{}
	wholeAckAccepted := false
	closeMask := &Close_FieldMask{}
	wholeCloseAccepted := false
	errorMask := &Error_FieldMask{}
	wholeErrorAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *AcceptResponse_FieldTerminalPath:
			switch tp.selector {
			case AcceptResponse_FieldPathSelectorData:
				if source, ok := source.Message.(*AcceptResponse_Data); ok {
					result.Message = &AcceptResponse_Data{
						Data: source.Data,
					}
				}
				wholeDataAccepted = true
			case AcceptResponse_FieldPathSelectorAck:
				if source, ok := source.Message.(*AcceptResponse_Ack); ok {
					result.Message = &AcceptResponse_Ack{
						Ack: source.Ack,
					}
				}
				wholeAckAccepted = true
			case AcceptResponse_FieldPathSelectorClose:
				if source, ok := source.Message.(*AcceptResponse_Close); ok {
					result.Message = &AcceptResponse_Close{
						Close: source.Close,
					}
				}
				wholeCloseAccepted = true
			case AcceptResponse_FieldPathSelectorError:
				if source, ok := source.Message.(*AcceptResponse_Error); ok {
					result.Message = &AcceptResponse_Error{
						Error: source.Error,
					}
				}
				wholeErrorAccepted = true
			}
		case *AcceptResponse_FieldSubPath:
			switch tp.selector {
			case AcceptResponse_FieldPathSelectorData:
				dataMask.AppendPath(tp.subPath.(Data_FieldPath))
			case AcceptResponse_FieldPathSelectorAck:
				ackMask.AppendPath(tp.subPath.(Ack_FieldPath))
			case AcceptResponse_FieldPathSelectorClose:
				closeMask.AppendPath(tp.subPath.(Close_FieldPath))
			case AcceptResponse_FieldPathSelectorError:
				errorMask.AppendPath(tp.subPath.(Error_FieldPath))
			}
		}
	}
	if wholeDataAccepted == false && len(dataMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptResponse_Data); ok {
			result.Message = (*AcceptResponse_Data)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptResponse_Data{}
				oneOfRes.Data = dataMask.Project(asOneOf.Data)
				result.Message = oneOfRes
			}
		}
	}
	if wholeAckAccepted == false && len(ackMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptResponse_Ack); ok {
			result.Message = (*AcceptResponse_Ack)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptResponse_Ack{}
				oneOfRes.Ack = ackMask.Project(asOneOf.Ack)
				result.Message = oneOfRes
			}
		}
	}
	if wholeCloseAccepted == false && len(closeMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptResponse_Close); ok {
			result.Message = (*AcceptResponse_Close)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptResponse_Close{}
				oneOfRes.Close = closeMask.Project(asOneOf.Close)
				result.Message = oneOfRes
			}
		}
	}
	if wholeErrorAccepted == false && len(errorMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*AcceptResponse_Error); ok {
			result.Message = (*AcceptResponse_Error)(nil)
			if asOneOf != nil {
				oneOfRes := &AcceptResponse_Error{}
				oneOfRes.Error = errorMask.Project(asOneOf.Error)
				result.Message = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *AcceptResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*AcceptResponse))
}

func (fieldMask *AcceptResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Data_FieldMask struct {
	Paths []Data_FieldPath
}

func FullData_FieldMask() *Data_FieldMask {
	res := &Data_FieldMask{}
	res.Paths = append(res.Paths, &Data_FieldTerminalPath{selector: Data_FieldPathSelectorId})
	res.Paths = append(res.Paths, &Data_FieldTerminalPath{selector: Data_FieldPathSelectorBytes})
	res.Paths = append(res.Paths, &Data_FieldTerminalPath{selector: Data_FieldPathSelectorAckRequired})
	return res
}

func (fieldMask *Data_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Data_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Data_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseData_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Data_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Data_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Data_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseData_FieldPath(raw)
	})
}

func (fieldMask *Data_FieldMask) ProtoMessage() {}

func (fieldMask *Data_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Data_FieldMask) Subtract(other *Data_FieldMask) *Data_FieldMask {
	result := &Data_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Data_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Data_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Data_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Data_FieldMask) FilterInputFields() *Data_FieldMask {
	result := &Data_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Data_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Data_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Data_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseData_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Data_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Data_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Data_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Data_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Data_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Data_FieldMask) AppendPath(path Data_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Data_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Data_FieldPath))
}

func (fieldMask *Data_FieldMask) GetPaths() []Data_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Data_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Data_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseData_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Data_FieldMask) Set(target, source *Data) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Data_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Data), source.(*Data))
}

func (fieldMask *Data_FieldMask) Project(source *Data) *Data {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Data{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Data_FieldTerminalPath:
			switch tp.selector {
			case Data_FieldPathSelectorId:
				result.Id = source.Id
			case Data_FieldPathSelectorBytes:
				result.Bytes = source.Bytes
			case Data_FieldPathSelectorAckRequired:
				result.AckRequired = source.AckRequired
			}
		}
	}
	return result
}

func (fieldMask *Data_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Data))
}

func (fieldMask *Data_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Ack_FieldMask struct {
	Paths []Ack_FieldPath
}

func FullAck_FieldMask() *Ack_FieldMask {
	res := &Ack_FieldMask{}
	res.Paths = append(res.Paths, &Ack_FieldTerminalPath{selector: Ack_FieldPathSelectorId})
	return res
}

func (fieldMask *Ack_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Ack_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Ack_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseAck_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Ack_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Ack_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Ack_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAck_FieldPath(raw)
	})
}

func (fieldMask *Ack_FieldMask) ProtoMessage() {}

func (fieldMask *Ack_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Ack_FieldMask) Subtract(other *Ack_FieldMask) *Ack_FieldMask {
	result := &Ack_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Ack_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Ack_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Ack_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Ack_FieldMask) FilterInputFields() *Ack_FieldMask {
	result := &Ack_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Ack_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Ack_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Ack_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAck_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Ack_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Ack_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Ack_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Ack_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Ack_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Ack_FieldMask) AppendPath(path Ack_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Ack_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Ack_FieldPath))
}

func (fieldMask *Ack_FieldMask) GetPaths() []Ack_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Ack_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Ack_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAck_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Ack_FieldMask) Set(target, source *Ack) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Ack_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Ack), source.(*Ack))
}

func (fieldMask *Ack_FieldMask) Project(source *Ack) *Ack {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Ack{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Ack_FieldTerminalPath:
			switch tp.selector {
			case Ack_FieldPathSelectorId:
				result.Id = source.Id
			}
		}
	}
	return result
}

func (fieldMask *Ack_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Ack))
}

func (fieldMask *Ack_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Close_FieldMask struct {
	Paths []Close_FieldPath
}

func FullClose_FieldMask() *Close_FieldMask {
	res := &Close_FieldMask{}
	res.Paths = append(res.Paths, &Close_FieldTerminalPath{selector: Close_FieldPathSelectorId})
	return res
}

func (fieldMask *Close_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Close_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Close_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseClose_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Close_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Close_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Close_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseClose_FieldPath(raw)
	})
}

func (fieldMask *Close_FieldMask) ProtoMessage() {}

func (fieldMask *Close_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Close_FieldMask) Subtract(other *Close_FieldMask) *Close_FieldMask {
	result := &Close_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Close_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Close_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Close_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Close_FieldMask) FilterInputFields() *Close_FieldMask {
	result := &Close_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Close_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Close_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Close_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseClose_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Close_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Close_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Close_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Close_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Close_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Close_FieldMask) AppendPath(path Close_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Close_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Close_FieldPath))
}

func (fieldMask *Close_FieldMask) GetPaths() []Close_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Close_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Close_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseClose_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Close_FieldMask) Set(target, source *Close) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Close_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Close), source.(*Close))
}

func (fieldMask *Close_FieldMask) Project(source *Close) *Close {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Close{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Close_FieldTerminalPath:
			switch tp.selector {
			case Close_FieldPathSelectorId:
				result.Id = source.Id
			}
		}
	}
	return result
}

func (fieldMask *Close_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Close))
}

func (fieldMask *Close_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Error_FieldMask struct {
	Paths []Error_FieldPath
}

func FullError_FieldMask() *Error_FieldMask {
	res := &Error_FieldMask{}
	res.Paths = append(res.Paths, &Error_FieldTerminalPath{selector: Error_FieldPathSelectorId})
	res.Paths = append(res.Paths, &Error_FieldTerminalPath{selector: Error_FieldPathSelectorMessage})
	return res
}

func (fieldMask *Error_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Error_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Error_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseError_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Error_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Error_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Error_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseError_FieldPath(raw)
	})
}

func (fieldMask *Error_FieldMask) ProtoMessage() {}

func (fieldMask *Error_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Error_FieldMask) Subtract(other *Error_FieldMask) *Error_FieldMask {
	result := &Error_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Error_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Error_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Error_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Error_FieldMask) FilterInputFields() *Error_FieldMask {
	result := &Error_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Error_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Error_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Error_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseError_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Error_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Error_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Error_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Error_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Error_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Error_FieldMask) AppendPath(path Error_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Error_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Error_FieldPath))
}

func (fieldMask *Error_FieldMask) GetPaths() []Error_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Error_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Error_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseError_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Error_FieldMask) Set(target, source *Error) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Error_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Error), source.(*Error))
}

func (fieldMask *Error_FieldMask) Project(source *Error) *Error {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Error{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Error_FieldTerminalPath:
			switch tp.selector {
			case Error_FieldPathSelectorId:
				result.Id = source.Id
			case Error_FieldPathSelectorMessage:
				result.Message = source.Message
			}
		}
	}
	return result
}

func (fieldMask *Error_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Error))
}

func (fieldMask *Error_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectRequest_FieldMask struct {
	Paths []ConnectRequest_FieldPath
}

func FullConnectRequest_FieldMask() *ConnectRequest_FieldMask {
	res := &ConnectRequest_FieldMask{}
	res.Paths = append(res.Paths, &ConnectRequest_FieldTerminalPath{selector: ConnectRequest_FieldPathSelectorOpenRequest})
	res.Paths = append(res.Paths, &ConnectRequest_FieldTerminalPath{selector: ConnectRequest_FieldPathSelectorResumeRequest})
	res.Paths = append(res.Paths, &ConnectRequest_FieldTerminalPath{selector: ConnectRequest_FieldPathSelectorAck})
	res.Paths = append(res.Paths, &ConnectRequest_FieldTerminalPath{selector: ConnectRequest_FieldPathSelectorData})
	res.Paths = append(res.Paths, &ConnectRequest_FieldTerminalPath{selector: ConnectRequest_FieldPathSelectorClose})
	res.Paths = append(res.Paths, &ConnectRequest_FieldTerminalPath{selector: ConnectRequest_FieldPathSelectorError})
	res.Paths = append(res.Paths, &ConnectRequest_FieldTerminalPath{selector: ConnectRequest_FieldPathSelectorPing})
	return res
}

func (fieldMask *ConnectRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectRequest_FieldPath(raw)
	})
}

func (fieldMask *ConnectRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectRequest_FieldMask) Subtract(other *ConnectRequest_FieldMask) *ConnectRequest_FieldMask {
	result := &ConnectRequest_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[ConnectRequest_FieldPathSelector]gotenobject.FieldMask{
		ConnectRequest_FieldPathSelectorOpenRequest:   &ConnectRequest_OpenRequest_FieldMask{},
		ConnectRequest_FieldPathSelectorResumeRequest: &ConnectRequest_ResumeRequest_FieldMask{},
		ConnectRequest_FieldPathSelectorAck:           &Ack_FieldMask{},
		ConnectRequest_FieldPathSelectorData:          &Data_FieldMask{},
		ConnectRequest_FieldPathSelectorClose:         &Close_FieldMask{},
		ConnectRequest_FieldPathSelectorError:         &Error_FieldMask{},
		ConnectRequest_FieldPathSelectorPing:          &Ping_FieldMask{},
	}
	mySubMasks := map[ConnectRequest_FieldPathSelector]gotenobject.FieldMask{
		ConnectRequest_FieldPathSelectorOpenRequest:   &ConnectRequest_OpenRequest_FieldMask{},
		ConnectRequest_FieldPathSelectorResumeRequest: &ConnectRequest_ResumeRequest_FieldMask{},
		ConnectRequest_FieldPathSelectorAck:           &Ack_FieldMask{},
		ConnectRequest_FieldPathSelectorData:          &Data_FieldMask{},
		ConnectRequest_FieldPathSelectorClose:         &Close_FieldMask{},
		ConnectRequest_FieldPathSelectorError:         &Error_FieldMask{},
		ConnectRequest_FieldPathSelectorPing:          &Ping_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConnectRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConnectRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case ConnectRequest_FieldPathSelectorOpenRequest:
						mySubMasks[ConnectRequest_FieldPathSelectorOpenRequest] = FullConnectRequest_OpenRequest_FieldMask()
					case ConnectRequest_FieldPathSelectorResumeRequest:
						mySubMasks[ConnectRequest_FieldPathSelectorResumeRequest] = FullConnectRequest_ResumeRequest_FieldMask()
					case ConnectRequest_FieldPathSelectorAck:
						mySubMasks[ConnectRequest_FieldPathSelectorAck] = FullAck_FieldMask()
					case ConnectRequest_FieldPathSelectorData:
						mySubMasks[ConnectRequest_FieldPathSelectorData] = FullData_FieldMask()
					case ConnectRequest_FieldPathSelectorClose:
						mySubMasks[ConnectRequest_FieldPathSelectorClose] = FullClose_FieldMask()
					case ConnectRequest_FieldPathSelectorError:
						mySubMasks[ConnectRequest_FieldPathSelectorError] = FullError_FieldMask()
					case ConnectRequest_FieldPathSelectorPing:
						mySubMasks[ConnectRequest_FieldPathSelectorPing] = FullPing_FieldMask()
					}
				} else if tp, ok := path.(*ConnectRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConnectRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectRequest_FieldMask) FilterInputFields() *ConnectRequest_FieldMask {
	result := &ConnectRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectRequest_FieldMask) AppendPath(path ConnectRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectRequest_FieldPath))
}

func (fieldMask *ConnectRequest_FieldMask) GetPaths() []ConnectRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectRequest_FieldMask) Set(target, source *ConnectRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectRequest), source.(*ConnectRequest))
}

func (fieldMask *ConnectRequest_FieldMask) Project(source *ConnectRequest) *ConnectRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectRequest{}
	openRequestMask := &ConnectRequest_OpenRequest_FieldMask{}
	wholeOpenRequestAccepted := false
	resumeRequestMask := &ConnectRequest_ResumeRequest_FieldMask{}
	wholeResumeRequestAccepted := false
	ackMask := &Ack_FieldMask{}
	wholeAckAccepted := false
	dataMask := &Data_FieldMask{}
	wholeDataAccepted := false
	closeMask := &Close_FieldMask{}
	wholeCloseAccepted := false
	errorMask := &Error_FieldMask{}
	wholeErrorAccepted := false
	pingMask := &Ping_FieldMask{}
	wholePingAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectRequest_FieldTerminalPath:
			switch tp.selector {
			case ConnectRequest_FieldPathSelectorOpenRequest:
				if source, ok := source.Message.(*ConnectRequest_OpenRequest_); ok {
					result.Message = &ConnectRequest_OpenRequest_{
						OpenRequest: source.OpenRequest,
					}
				}
				wholeOpenRequestAccepted = true
			case ConnectRequest_FieldPathSelectorResumeRequest:
				if source, ok := source.Message.(*ConnectRequest_ResumeRequest_); ok {
					result.Message = &ConnectRequest_ResumeRequest_{
						ResumeRequest: source.ResumeRequest,
					}
				}
				wholeResumeRequestAccepted = true
			case ConnectRequest_FieldPathSelectorAck:
				if source, ok := source.Message.(*ConnectRequest_Ack); ok {
					result.Message = &ConnectRequest_Ack{
						Ack: source.Ack,
					}
				}
				wholeAckAccepted = true
			case ConnectRequest_FieldPathSelectorData:
				if source, ok := source.Message.(*ConnectRequest_Data); ok {
					result.Message = &ConnectRequest_Data{
						Data: source.Data,
					}
				}
				wholeDataAccepted = true
			case ConnectRequest_FieldPathSelectorClose:
				if source, ok := source.Message.(*ConnectRequest_Close); ok {
					result.Message = &ConnectRequest_Close{
						Close: source.Close,
					}
				}
				wholeCloseAccepted = true
			case ConnectRequest_FieldPathSelectorError:
				if source, ok := source.Message.(*ConnectRequest_Error); ok {
					result.Message = &ConnectRequest_Error{
						Error: source.Error,
					}
				}
				wholeErrorAccepted = true
			case ConnectRequest_FieldPathSelectorPing:
				if source, ok := source.Message.(*ConnectRequest_Ping); ok {
					result.Message = &ConnectRequest_Ping{
						Ping: source.Ping,
					}
				}
				wholePingAccepted = true
			}
		case *ConnectRequest_FieldSubPath:
			switch tp.selector {
			case ConnectRequest_FieldPathSelectorOpenRequest:
				openRequestMask.AppendPath(tp.subPath.(ConnectRequestOpenRequest_FieldPath))
			case ConnectRequest_FieldPathSelectorResumeRequest:
				resumeRequestMask.AppendPath(tp.subPath.(ConnectRequestResumeRequest_FieldPath))
			case ConnectRequest_FieldPathSelectorAck:
				ackMask.AppendPath(tp.subPath.(Ack_FieldPath))
			case ConnectRequest_FieldPathSelectorData:
				dataMask.AppendPath(tp.subPath.(Data_FieldPath))
			case ConnectRequest_FieldPathSelectorClose:
				closeMask.AppendPath(tp.subPath.(Close_FieldPath))
			case ConnectRequest_FieldPathSelectorError:
				errorMask.AppendPath(tp.subPath.(Error_FieldPath))
			case ConnectRequest_FieldPathSelectorPing:
				pingMask.AppendPath(tp.subPath.(Ping_FieldPath))
			}
		}
	}
	if wholeOpenRequestAccepted == false && len(openRequestMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectRequest_OpenRequest_); ok {
			result.Message = (*ConnectRequest_OpenRequest_)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectRequest_OpenRequest_{}
				oneOfRes.OpenRequest = openRequestMask.Project(asOneOf.OpenRequest)
				result.Message = oneOfRes
			}
		}
	}
	if wholeResumeRequestAccepted == false && len(resumeRequestMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectRequest_ResumeRequest_); ok {
			result.Message = (*ConnectRequest_ResumeRequest_)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectRequest_ResumeRequest_{}
				oneOfRes.ResumeRequest = resumeRequestMask.Project(asOneOf.ResumeRequest)
				result.Message = oneOfRes
			}
		}
	}
	if wholeAckAccepted == false && len(ackMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectRequest_Ack); ok {
			result.Message = (*ConnectRequest_Ack)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectRequest_Ack{}
				oneOfRes.Ack = ackMask.Project(asOneOf.Ack)
				result.Message = oneOfRes
			}
		}
	}
	if wholeDataAccepted == false && len(dataMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectRequest_Data); ok {
			result.Message = (*ConnectRequest_Data)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectRequest_Data{}
				oneOfRes.Data = dataMask.Project(asOneOf.Data)
				result.Message = oneOfRes
			}
		}
	}
	if wholeCloseAccepted == false && len(closeMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectRequest_Close); ok {
			result.Message = (*ConnectRequest_Close)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectRequest_Close{}
				oneOfRes.Close = closeMask.Project(asOneOf.Close)
				result.Message = oneOfRes
			}
		}
	}
	if wholeErrorAccepted == false && len(errorMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectRequest_Error); ok {
			result.Message = (*ConnectRequest_Error)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectRequest_Error{}
				oneOfRes.Error = errorMask.Project(asOneOf.Error)
				result.Message = oneOfRes
			}
		}
	}
	if wholePingAccepted == false && len(pingMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectRequest_Ping); ok {
			result.Message = (*ConnectRequest_Ping)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectRequest_Ping{}
				oneOfRes.Ping = pingMask.Project(asOneOf.Ping)
				result.Message = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ConnectRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectRequest))
}

func (fieldMask *ConnectRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectRequest_OpenRequest_FieldMask struct {
	Paths []ConnectRequestOpenRequest_FieldPath
}

func FullConnectRequest_OpenRequest_FieldMask() *ConnectRequest_OpenRequest_FieldMask {
	res := &ConnectRequest_OpenRequest_FieldMask{}
	res.Paths = append(res.Paths, &ConnectRequestOpenRequest_FieldTerminalPath{selector: ConnectRequestOpenRequest_FieldPathSelectorProject})
	res.Paths = append(res.Paths, &ConnectRequestOpenRequest_FieldTerminalPath{selector: ConnectRequestOpenRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ConnectRequestOpenRequest_FieldTerminalPath{selector: ConnectRequestOpenRequest_FieldPathSelectorProviderName})
	res.Paths = append(res.Paths, &ConnectRequestOpenRequest_FieldTerminalPath{selector: ConnectRequestOpenRequest_FieldPathSelectorService})
	res.Paths = append(res.Paths, &ConnectRequestOpenRequest_FieldTerminalPath{selector: ConnectRequestOpenRequest_FieldPathSelectorArg})
	return res
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectRequest_OpenRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectRequestOpenRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectRequestOpenRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectRequestOpenRequest_FieldPath(raw)
	})
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) Subtract(other *ConnectRequest_OpenRequest_FieldMask) *ConnectRequest_OpenRequest_FieldMask {
	result := &ConnectRequest_OpenRequest_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectRequestOpenRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectRequest_OpenRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectRequest_OpenRequest_FieldMask) FilterInputFields() *ConnectRequest_OpenRequest_FieldMask {
	result := &ConnectRequest_OpenRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectRequest_OpenRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectRequestOpenRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectRequestOpenRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectRequest_OpenRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectRequest_OpenRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) AppendPath(path ConnectRequestOpenRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectRequestOpenRequest_FieldPath))
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) GetPaths() []ConnectRequestOpenRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectRequestOpenRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) Set(target, source *ConnectRequest_OpenRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectRequest_OpenRequest), source.(*ConnectRequest_OpenRequest))
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) Project(source *ConnectRequest_OpenRequest) *ConnectRequest_OpenRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectRequest_OpenRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectRequestOpenRequest_FieldTerminalPath:
			switch tp.selector {
			case ConnectRequestOpenRequest_FieldPathSelectorProject:
				result.Project = source.Project
			case ConnectRequestOpenRequest_FieldPathSelectorName:
				result.Name = source.Name
			case ConnectRequestOpenRequest_FieldPathSelectorProviderName:
				result.ProviderName = source.ProviderName
			case ConnectRequestOpenRequest_FieldPathSelectorService:
				result.Service = source.Service
			case ConnectRequestOpenRequest_FieldPathSelectorArg:
				result.Arg = source.Arg
			}
		}
	}
	return result
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectRequest_OpenRequest))
}

func (fieldMask *ConnectRequest_OpenRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectRequest_ResumeRequest_FieldMask struct {
	Paths []ConnectRequestResumeRequest_FieldPath
}

func FullConnectRequest_ResumeRequest_FieldMask() *ConnectRequest_ResumeRequest_FieldMask {
	res := &ConnectRequest_ResumeRequest_FieldMask{}
	res.Paths = append(res.Paths, &ConnectRequestResumeRequest_FieldTerminalPath{selector: ConnectRequestResumeRequest_FieldPathSelectorProject})
	res.Paths = append(res.Paths, &ConnectRequestResumeRequest_FieldTerminalPath{selector: ConnectRequestResumeRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &ConnectRequestResumeRequest_FieldTerminalPath{selector: ConnectRequestResumeRequest_FieldPathSelectorProviderName})
	res.Paths = append(res.Paths, &ConnectRequestResumeRequest_FieldTerminalPath{selector: ConnectRequestResumeRequest_FieldPathSelectorSessionId})
	res.Paths = append(res.Paths, &ConnectRequestResumeRequest_FieldTerminalPath{selector: ConnectRequestResumeRequest_FieldPathSelectorChannelId})
	res.Paths = append(res.Paths, &ConnectRequestResumeRequest_FieldTerminalPath{selector: ConnectRequestResumeRequest_FieldPathSelectorLastMessageId})
	return res
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectRequestResumeRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectRequestResumeRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectRequestResumeRequest_FieldPath(raw)
	})
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) Subtract(other *ConnectRequest_ResumeRequest_FieldMask) *ConnectRequest_ResumeRequest_FieldMask {
	result := &ConnectRequest_ResumeRequest_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectRequestResumeRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectRequest_ResumeRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) FilterInputFields() *ConnectRequest_ResumeRequest_FieldMask {
	result := &ConnectRequest_ResumeRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectRequestResumeRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectRequestResumeRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectRequest_ResumeRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectRequest_ResumeRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) AppendPath(path ConnectRequestResumeRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectRequestResumeRequest_FieldPath))
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) GetPaths() []ConnectRequestResumeRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectRequestResumeRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) Set(target, source *ConnectRequest_ResumeRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectRequest_ResumeRequest), source.(*ConnectRequest_ResumeRequest))
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) Project(source *ConnectRequest_ResumeRequest) *ConnectRequest_ResumeRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectRequest_ResumeRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectRequestResumeRequest_FieldTerminalPath:
			switch tp.selector {
			case ConnectRequestResumeRequest_FieldPathSelectorProject:
				result.Project = source.Project
			case ConnectRequestResumeRequest_FieldPathSelectorName:
				result.Name = source.Name
			case ConnectRequestResumeRequest_FieldPathSelectorProviderName:
				result.ProviderName = source.ProviderName
			case ConnectRequestResumeRequest_FieldPathSelectorSessionId:
				result.SessionId = source.SessionId
			case ConnectRequestResumeRequest_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			case ConnectRequestResumeRequest_FieldPathSelectorLastMessageId:
				result.LastMessageId = source.LastMessageId
			}
		}
	}
	return result
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectRequest_ResumeRequest))
}

func (fieldMask *ConnectRequest_ResumeRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectResponse_FieldMask struct {
	Paths []ConnectResponse_FieldPath
}

func FullConnectResponse_FieldMask() *ConnectResponse_FieldMask {
	res := &ConnectResponse_FieldMask{}
	res.Paths = append(res.Paths, &ConnectResponse_FieldTerminalPath{selector: ConnectResponse_FieldPathSelectorOpenResponse})
	res.Paths = append(res.Paths, &ConnectResponse_FieldTerminalPath{selector: ConnectResponse_FieldPathSelectorResumeResponse})
	res.Paths = append(res.Paths, &ConnectResponse_FieldTerminalPath{selector: ConnectResponse_FieldPathSelectorChannelOpenError})
	res.Paths = append(res.Paths, &ConnectResponse_FieldTerminalPath{selector: ConnectResponse_FieldPathSelectorAck})
	res.Paths = append(res.Paths, &ConnectResponse_FieldTerminalPath{selector: ConnectResponse_FieldPathSelectorData})
	res.Paths = append(res.Paths, &ConnectResponse_FieldTerminalPath{selector: ConnectResponse_FieldPathSelectorClose})
	res.Paths = append(res.Paths, &ConnectResponse_FieldTerminalPath{selector: ConnectResponse_FieldPathSelectorError})
	return res
}

func (fieldMask *ConnectResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectResponse_FieldPath(raw)
	})
}

func (fieldMask *ConnectResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectResponse_FieldMask) Subtract(other *ConnectResponse_FieldMask) *ConnectResponse_FieldMask {
	result := &ConnectResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[ConnectResponse_FieldPathSelector]gotenobject.FieldMask{
		ConnectResponse_FieldPathSelectorOpenResponse:     &ConnectResponse_OpenResponse_FieldMask{},
		ConnectResponse_FieldPathSelectorResumeResponse:   &ConnectResponse_ResumeResponse_FieldMask{},
		ConnectResponse_FieldPathSelectorChannelOpenError: &ConnectResponse_ChannelOpenError_FieldMask{},
		ConnectResponse_FieldPathSelectorAck:              &Ack_FieldMask{},
		ConnectResponse_FieldPathSelectorData:             &Data_FieldMask{},
		ConnectResponse_FieldPathSelectorClose:            &Close_FieldMask{},
		ConnectResponse_FieldPathSelectorError:            &Error_FieldMask{},
	}
	mySubMasks := map[ConnectResponse_FieldPathSelector]gotenobject.FieldMask{
		ConnectResponse_FieldPathSelectorOpenResponse:     &ConnectResponse_OpenResponse_FieldMask{},
		ConnectResponse_FieldPathSelectorResumeResponse:   &ConnectResponse_ResumeResponse_FieldMask{},
		ConnectResponse_FieldPathSelectorChannelOpenError: &ConnectResponse_ChannelOpenError_FieldMask{},
		ConnectResponse_FieldPathSelectorAck:              &Ack_FieldMask{},
		ConnectResponse_FieldPathSelectorData:             &Data_FieldMask{},
		ConnectResponse_FieldPathSelectorClose:            &Close_FieldMask{},
		ConnectResponse_FieldPathSelectorError:            &Error_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConnectResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConnectResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ConnectResponse_FieldPathSelectorOpenResponse:
						mySubMasks[ConnectResponse_FieldPathSelectorOpenResponse] = FullConnectResponse_OpenResponse_FieldMask()
					case ConnectResponse_FieldPathSelectorResumeResponse:
						mySubMasks[ConnectResponse_FieldPathSelectorResumeResponse] = FullConnectResponse_ResumeResponse_FieldMask()
					case ConnectResponse_FieldPathSelectorChannelOpenError:
						mySubMasks[ConnectResponse_FieldPathSelectorChannelOpenError] = FullConnectResponse_ChannelOpenError_FieldMask()
					case ConnectResponse_FieldPathSelectorAck:
						mySubMasks[ConnectResponse_FieldPathSelectorAck] = FullAck_FieldMask()
					case ConnectResponse_FieldPathSelectorData:
						mySubMasks[ConnectResponse_FieldPathSelectorData] = FullData_FieldMask()
					case ConnectResponse_FieldPathSelectorClose:
						mySubMasks[ConnectResponse_FieldPathSelectorClose] = FullClose_FieldMask()
					case ConnectResponse_FieldPathSelectorError:
						mySubMasks[ConnectResponse_FieldPathSelectorError] = FullError_FieldMask()
					}
				} else if tp, ok := path.(*ConnectResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConnectResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectResponse_FieldMask) FilterInputFields() *ConnectResponse_FieldMask {
	result := &ConnectResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectResponse_FieldMask) AppendPath(path ConnectResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectResponse_FieldPath))
}

func (fieldMask *ConnectResponse_FieldMask) GetPaths() []ConnectResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectResponse_FieldMask) Set(target, source *ConnectResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectResponse), source.(*ConnectResponse))
}

func (fieldMask *ConnectResponse_FieldMask) Project(source *ConnectResponse) *ConnectResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectResponse{}
	openResponseMask := &ConnectResponse_OpenResponse_FieldMask{}
	wholeOpenResponseAccepted := false
	resumeResponseMask := &ConnectResponse_ResumeResponse_FieldMask{}
	wholeResumeResponseAccepted := false
	channelOpenErrorMask := &ConnectResponse_ChannelOpenError_FieldMask{}
	wholeChannelOpenErrorAccepted := false
	ackMask := &Ack_FieldMask{}
	wholeAckAccepted := false
	dataMask := &Data_FieldMask{}
	wholeDataAccepted := false
	closeMask := &Close_FieldMask{}
	wholeCloseAccepted := false
	errorMask := &Error_FieldMask{}
	wholeErrorAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectResponse_FieldTerminalPath:
			switch tp.selector {
			case ConnectResponse_FieldPathSelectorOpenResponse:
				if source, ok := source.Message.(*ConnectResponse_OpenResponse_); ok {
					result.Message = &ConnectResponse_OpenResponse_{
						OpenResponse: source.OpenResponse,
					}
				}
				wholeOpenResponseAccepted = true
			case ConnectResponse_FieldPathSelectorResumeResponse:
				if source, ok := source.Message.(*ConnectResponse_ResumeResponse_); ok {
					result.Message = &ConnectResponse_ResumeResponse_{
						ResumeResponse: source.ResumeResponse,
					}
				}
				wholeResumeResponseAccepted = true
			case ConnectResponse_FieldPathSelectorChannelOpenError:
				if source, ok := source.Message.(*ConnectResponse_ChannelOpenError_); ok {
					result.Message = &ConnectResponse_ChannelOpenError_{
						ChannelOpenError: source.ChannelOpenError,
					}
				}
				wholeChannelOpenErrorAccepted = true
			case ConnectResponse_FieldPathSelectorAck:
				if source, ok := source.Message.(*ConnectResponse_Ack); ok {
					result.Message = &ConnectResponse_Ack{
						Ack: source.Ack,
					}
				}
				wholeAckAccepted = true
			case ConnectResponse_FieldPathSelectorData:
				if source, ok := source.Message.(*ConnectResponse_Data); ok {
					result.Message = &ConnectResponse_Data{
						Data: source.Data,
					}
				}
				wholeDataAccepted = true
			case ConnectResponse_FieldPathSelectorClose:
				if source, ok := source.Message.(*ConnectResponse_Close); ok {
					result.Message = &ConnectResponse_Close{
						Close: source.Close,
					}
				}
				wholeCloseAccepted = true
			case ConnectResponse_FieldPathSelectorError:
				if source, ok := source.Message.(*ConnectResponse_Error); ok {
					result.Message = &ConnectResponse_Error{
						Error: source.Error,
					}
				}
				wholeErrorAccepted = true
			}
		case *ConnectResponse_FieldSubPath:
			switch tp.selector {
			case ConnectResponse_FieldPathSelectorOpenResponse:
				openResponseMask.AppendPath(tp.subPath.(ConnectResponseOpenResponse_FieldPath))
			case ConnectResponse_FieldPathSelectorResumeResponse:
				resumeResponseMask.AppendPath(tp.subPath.(ConnectResponseResumeResponse_FieldPath))
			case ConnectResponse_FieldPathSelectorChannelOpenError:
				channelOpenErrorMask.AppendPath(tp.subPath.(ConnectResponseChannelOpenError_FieldPath))
			case ConnectResponse_FieldPathSelectorAck:
				ackMask.AppendPath(tp.subPath.(Ack_FieldPath))
			case ConnectResponse_FieldPathSelectorData:
				dataMask.AppendPath(tp.subPath.(Data_FieldPath))
			case ConnectResponse_FieldPathSelectorClose:
				closeMask.AppendPath(tp.subPath.(Close_FieldPath))
			case ConnectResponse_FieldPathSelectorError:
				errorMask.AppendPath(tp.subPath.(Error_FieldPath))
			}
		}
	}
	if wholeOpenResponseAccepted == false && len(openResponseMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectResponse_OpenResponse_); ok {
			result.Message = (*ConnectResponse_OpenResponse_)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectResponse_OpenResponse_{}
				oneOfRes.OpenResponse = openResponseMask.Project(asOneOf.OpenResponse)
				result.Message = oneOfRes
			}
		}
	}
	if wholeResumeResponseAccepted == false && len(resumeResponseMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectResponse_ResumeResponse_); ok {
			result.Message = (*ConnectResponse_ResumeResponse_)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectResponse_ResumeResponse_{}
				oneOfRes.ResumeResponse = resumeResponseMask.Project(asOneOf.ResumeResponse)
				result.Message = oneOfRes
			}
		}
	}
	if wholeChannelOpenErrorAccepted == false && len(channelOpenErrorMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectResponse_ChannelOpenError_); ok {
			result.Message = (*ConnectResponse_ChannelOpenError_)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectResponse_ChannelOpenError_{}
				oneOfRes.ChannelOpenError = channelOpenErrorMask.Project(asOneOf.ChannelOpenError)
				result.Message = oneOfRes
			}
		}
	}
	if wholeAckAccepted == false && len(ackMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectResponse_Ack); ok {
			result.Message = (*ConnectResponse_Ack)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectResponse_Ack{}
				oneOfRes.Ack = ackMask.Project(asOneOf.Ack)
				result.Message = oneOfRes
			}
		}
	}
	if wholeDataAccepted == false && len(dataMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectResponse_Data); ok {
			result.Message = (*ConnectResponse_Data)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectResponse_Data{}
				oneOfRes.Data = dataMask.Project(asOneOf.Data)
				result.Message = oneOfRes
			}
		}
	}
	if wholeCloseAccepted == false && len(closeMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectResponse_Close); ok {
			result.Message = (*ConnectResponse_Close)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectResponse_Close{}
				oneOfRes.Close = closeMask.Project(asOneOf.Close)
				result.Message = oneOfRes
			}
		}
	}
	if wholeErrorAccepted == false && len(errorMask.Paths) > 0 {
		if asOneOf, ok := source.Message.(*ConnectResponse_Error); ok {
			result.Message = (*ConnectResponse_Error)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectResponse_Error{}
				oneOfRes.Error = errorMask.Project(asOneOf.Error)
				result.Message = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ConnectResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectResponse))
}

func (fieldMask *ConnectResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectResponse_OpenResponse_FieldMask struct {
	Paths []ConnectResponseOpenResponse_FieldPath
}

func FullConnectResponse_OpenResponse_FieldMask() *ConnectResponse_OpenResponse_FieldMask {
	res := &ConnectResponse_OpenResponse_FieldMask{}
	res.Paths = append(res.Paths, &ConnectResponseOpenResponse_FieldTerminalPath{selector: ConnectResponseOpenResponse_FieldPathSelectorSessionId})
	res.Paths = append(res.Paths, &ConnectResponseOpenResponse_FieldTerminalPath{selector: ConnectResponseOpenResponse_FieldPathSelectorChannelId})
	return res
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectResponse_OpenResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectResponseOpenResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectResponseOpenResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectResponseOpenResponse_FieldPath(raw)
	})
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) Subtract(other *ConnectResponse_OpenResponse_FieldMask) *ConnectResponse_OpenResponse_FieldMask {
	result := &ConnectResponse_OpenResponse_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectResponseOpenResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectResponse_OpenResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectResponse_OpenResponse_FieldMask) FilterInputFields() *ConnectResponse_OpenResponse_FieldMask {
	result := &ConnectResponse_OpenResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectResponse_OpenResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectResponseOpenResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectResponseOpenResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectResponse_OpenResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectResponse_OpenResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) AppendPath(path ConnectResponseOpenResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectResponseOpenResponse_FieldPath))
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) GetPaths() []ConnectResponseOpenResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectResponseOpenResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) Set(target, source *ConnectResponse_OpenResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectResponse_OpenResponse), source.(*ConnectResponse_OpenResponse))
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) Project(source *ConnectResponse_OpenResponse) *ConnectResponse_OpenResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectResponse_OpenResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectResponseOpenResponse_FieldTerminalPath:
			switch tp.selector {
			case ConnectResponseOpenResponse_FieldPathSelectorSessionId:
				result.SessionId = source.SessionId
			case ConnectResponseOpenResponse_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			}
		}
	}
	return result
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectResponse_OpenResponse))
}

func (fieldMask *ConnectResponse_OpenResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectResponse_ResumeResponse_FieldMask struct {
	Paths []ConnectResponseResumeResponse_FieldPath
}

func FullConnectResponse_ResumeResponse_FieldMask() *ConnectResponse_ResumeResponse_FieldMask {
	res := &ConnectResponse_ResumeResponse_FieldMask{}
	res.Paths = append(res.Paths, &ConnectResponseResumeResponse_FieldTerminalPath{selector: ConnectResponseResumeResponse_FieldPathSelectorSessionId})
	res.Paths = append(res.Paths, &ConnectResponseResumeResponse_FieldTerminalPath{selector: ConnectResponseResumeResponse_FieldPathSelectorChannelId})
	res.Paths = append(res.Paths, &ConnectResponseResumeResponse_FieldTerminalPath{selector: ConnectResponseResumeResponse_FieldPathSelectorLastMessageId})
	return res
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectResponseResumeResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectResponseResumeResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectResponseResumeResponse_FieldPath(raw)
	})
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) Subtract(other *ConnectResponse_ResumeResponse_FieldMask) *ConnectResponse_ResumeResponse_FieldMask {
	result := &ConnectResponse_ResumeResponse_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectResponseResumeResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectResponse_ResumeResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) FilterInputFields() *ConnectResponse_ResumeResponse_FieldMask {
	result := &ConnectResponse_ResumeResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectResponseResumeResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectResponseResumeResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectResponse_ResumeResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectResponse_ResumeResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) AppendPath(path ConnectResponseResumeResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectResponseResumeResponse_FieldPath))
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) GetPaths() []ConnectResponseResumeResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectResponseResumeResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) Set(target, source *ConnectResponse_ResumeResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectResponse_ResumeResponse), source.(*ConnectResponse_ResumeResponse))
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) Project(source *ConnectResponse_ResumeResponse) *ConnectResponse_ResumeResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectResponse_ResumeResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectResponseResumeResponse_FieldTerminalPath:
			switch tp.selector {
			case ConnectResponseResumeResponse_FieldPathSelectorSessionId:
				result.SessionId = source.SessionId
			case ConnectResponseResumeResponse_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			case ConnectResponseResumeResponse_FieldPathSelectorLastMessageId:
				result.LastMessageId = source.LastMessageId
			}
		}
	}
	return result
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectResponse_ResumeResponse))
}

func (fieldMask *ConnectResponse_ResumeResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectResponse_ChannelOpenError_FieldMask struct {
	Paths []ConnectResponseChannelOpenError_FieldPath
}

func FullConnectResponse_ChannelOpenError_FieldMask() *ConnectResponse_ChannelOpenError_FieldMask {
	res := &ConnectResponse_ChannelOpenError_FieldMask{}
	res.Paths = append(res.Paths, &ConnectResponseChannelOpenError_FieldTerminalPath{selector: ConnectResponseChannelOpenError_FieldPathSelectorChannelId})
	res.Paths = append(res.Paths, &ConnectResponseChannelOpenError_FieldTerminalPath{selector: ConnectResponseChannelOpenError_FieldPathSelectorMessage})
	return res
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectResponseChannelOpenError_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectResponseChannelOpenError_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectResponseChannelOpenError_FieldPath(raw)
	})
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) Subtract(other *ConnectResponse_ChannelOpenError_FieldMask) *ConnectResponse_ChannelOpenError_FieldMask {
	result := &ConnectResponse_ChannelOpenError_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectResponseChannelOpenError_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectResponse_ChannelOpenError_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) FilterInputFields() *ConnectResponse_ChannelOpenError_FieldMask {
	result := &ConnectResponse_ChannelOpenError_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectResponseChannelOpenError_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectResponseChannelOpenError_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectResponse_ChannelOpenError_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectResponse_ChannelOpenError_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) AppendPath(path ConnectResponseChannelOpenError_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectResponseChannelOpenError_FieldPath))
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) GetPaths() []ConnectResponseChannelOpenError_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectResponseChannelOpenError_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) Set(target, source *ConnectResponse_ChannelOpenError) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectResponse_ChannelOpenError), source.(*ConnectResponse_ChannelOpenError))
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) Project(source *ConnectResponse_ChannelOpenError) *ConnectResponse_ChannelOpenError {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectResponse_ChannelOpenError{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectResponseChannelOpenError_FieldTerminalPath:
			switch tp.selector {
			case ConnectResponseChannelOpenError_FieldPathSelectorChannelId:
				result.ChannelId = source.ChannelId
			case ConnectResponseChannelOpenError_FieldPathSelectorMessage:
				result.Message = source.Message
			}
		}
	}
	return result
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectResponse_ChannelOpenError))
}

func (fieldMask *ConnectResponse_ChannelOpenError_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
