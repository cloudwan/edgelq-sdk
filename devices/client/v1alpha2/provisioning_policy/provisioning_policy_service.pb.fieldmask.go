// Code generated by protoc-gen-goten-object
// File: edgelq/devices/proto/v1alpha2/provisioning_policy_service.proto
// DO NOT EDIT!!!

package provisioning_policy_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	project "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha2/project"
	provisioning_policy "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha2/provisioning_policy"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &project.Project{}
	_ = &provisioning_policy.ProvisioningPolicy{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetProvisioningPolicyRequest_FieldMask struct {
	Paths []GetProvisioningPolicyRequest_FieldPath
}

func FullGetProvisioningPolicyRequest_FieldMask() *GetProvisioningPolicyRequest_FieldMask {
	res := &GetProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetProvisioningPolicyRequest_FieldTerminalPath{selector: GetProvisioningPolicyRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetProvisioningPolicyRequest_FieldTerminalPath{selector: GetProvisioningPolicyRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetProvisioningPolicyRequest_FieldTerminalPath{selector: GetProvisioningPolicyRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Subtract(other *GetProvisioningPolicyRequest_FieldMask) *GetProvisioningPolicyRequest_FieldMask {
	result := &GetProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetProvisioningPolicyRequest_FieldMask) FilterInputFields() *GetProvisioningPolicyRequest_FieldMask {
	result := &GetProvisioningPolicyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) AppendPath(path GetProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) GetPaths() []GetProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Set(target, source *GetProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetProvisioningPolicyRequest), source.(*GetProvisioningPolicyRequest))
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Project(source *GetProvisioningPolicyRequest) *GetProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetProvisioningPolicyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case GetProvisioningPolicyRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetProvisioningPolicyRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetProvisioningPolicyRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetProvisioningPolicyRequest))
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProvisioningPoliciesRequest_FieldMask struct {
	Paths []BatchGetProvisioningPoliciesRequest_FieldPath
}

func FullBatchGetProvisioningPoliciesRequest_FieldMask() *BatchGetProvisioningPoliciesRequest_FieldMask {
	res := &BatchGetProvisioningPoliciesRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProvisioningPoliciesRequest_FieldTerminalPath{selector: BatchGetProvisioningPoliciesRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetProvisioningPoliciesRequest_FieldTerminalPath{selector: BatchGetProvisioningPoliciesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetProvisioningPoliciesRequest_FieldTerminalPath{selector: BatchGetProvisioningPoliciesRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProvisioningPoliciesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProvisioningPoliciesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProvisioningPoliciesRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) Subtract(other *BatchGetProvisioningPoliciesRequest_FieldMask) *BatchGetProvisioningPoliciesRequest_FieldMask {
	result := &BatchGetProvisioningPoliciesRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProvisioningPoliciesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProvisioningPoliciesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) FilterInputFields() *BatchGetProvisioningPoliciesRequest_FieldMask {
	result := &BatchGetProvisioningPoliciesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProvisioningPoliciesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProvisioningPoliciesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProvisioningPoliciesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProvisioningPoliciesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) AppendPath(path BatchGetProvisioningPoliciesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProvisioningPoliciesRequest_FieldPath))
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) GetPaths() []BatchGetProvisioningPoliciesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProvisioningPoliciesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) Set(target, source *BatchGetProvisioningPoliciesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProvisioningPoliciesRequest), source.(*BatchGetProvisioningPoliciesRequest))
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) Project(source *BatchGetProvisioningPoliciesRequest) *BatchGetProvisioningPoliciesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProvisioningPoliciesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProvisioningPoliciesRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProvisioningPoliciesRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetProvisioningPoliciesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetProvisioningPoliciesRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProvisioningPoliciesRequest))
}

func (fieldMask *BatchGetProvisioningPoliciesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProvisioningPoliciesResponse_FieldMask struct {
	Paths []BatchGetProvisioningPoliciesResponse_FieldPath
}

func FullBatchGetProvisioningPoliciesResponse_FieldMask() *BatchGetProvisioningPoliciesResponse_FieldMask {
	res := &BatchGetProvisioningPoliciesResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProvisioningPoliciesResponse_FieldTerminalPath{selector: BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies})
	res.Paths = append(res.Paths, &BatchGetProvisioningPoliciesResponse_FieldTerminalPath{selector: BatchGetProvisioningPoliciesResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProvisioningPoliciesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProvisioningPoliciesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProvisioningPoliciesResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) Subtract(other *BatchGetProvisioningPoliciesResponse_FieldMask) *BatchGetProvisioningPoliciesResponse_FieldMask {
	result := &BatchGetProvisioningPoliciesResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetProvisioningPoliciesResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}
	mySubMasks := map[BatchGetProvisioningPoliciesResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProvisioningPoliciesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetProvisioningPoliciesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetProvisioningPoliciesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies:
						mySubMasks[BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetProvisioningPoliciesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetProvisioningPoliciesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProvisioningPoliciesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) FilterInputFields() *BatchGetProvisioningPoliciesResponse_FieldMask {
	result := &BatchGetProvisioningPoliciesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies:
			if _, ok := path.(*BatchGetProvisioningPoliciesResponse_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProvisioningPoliciesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetProvisioningPoliciesResponse_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProvisioningPoliciesResponse_FieldSubPath{selector: BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProvisioningPoliciesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProvisioningPoliciesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProvisioningPoliciesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProvisioningPoliciesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) AppendPath(path BatchGetProvisioningPoliciesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProvisioningPoliciesResponse_FieldPath))
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) GetPaths() []BatchGetProvisioningPoliciesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProvisioningPoliciesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) Set(target, source *BatchGetProvisioningPoliciesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProvisioningPoliciesResponse), source.(*BatchGetProvisioningPoliciesResponse))
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) Project(source *BatchGetProvisioningPoliciesResponse) *BatchGetProvisioningPoliciesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProvisioningPoliciesResponse{}
	provisioningPoliciesMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeProvisioningPoliciesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProvisioningPoliciesResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies:
				result.ProvisioningPolicies = source.ProvisioningPolicies
				wholeProvisioningPoliciesAccepted = true
			case BatchGetProvisioningPoliciesResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetProvisioningPoliciesResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies:
				provisioningPoliciesMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			}
		}
	}
	if wholeProvisioningPoliciesAccepted == false && len(provisioningPoliciesMask.Paths) > 0 {
		for _, sourceItem := range source.GetProvisioningPolicies() {
			result.ProvisioningPolicies = append(result.ProvisioningPolicies, provisioningPoliciesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProvisioningPoliciesResponse))
}

func (fieldMask *BatchGetProvisioningPoliciesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProvisioningPoliciesRequest_FieldMask struct {
	Paths []ListProvisioningPoliciesRequest_FieldPath
}

func FullListProvisioningPoliciesRequest_FieldMask() *ListProvisioningPoliciesRequest_FieldMask {
	res := &ListProvisioningPoliciesRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListProvisioningPoliciesRequest_FieldTerminalPath{selector: ListProvisioningPoliciesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListProvisioningPoliciesRequest_FieldTerminalPath{selector: ListProvisioningPoliciesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListProvisioningPoliciesRequest_FieldTerminalPath{selector: ListProvisioningPoliciesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListProvisioningPoliciesRequest_FieldTerminalPath{selector: ListProvisioningPoliciesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListProvisioningPoliciesRequest_FieldTerminalPath{selector: ListProvisioningPoliciesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListProvisioningPoliciesRequest_FieldTerminalPath{selector: ListProvisioningPoliciesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListProvisioningPoliciesRequest_FieldTerminalPath{selector: ListProvisioningPoliciesRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProvisioningPoliciesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProvisioningPoliciesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProvisioningPoliciesRequest_FieldPath(raw)
	})
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) Subtract(other *ListProvisioningPoliciesRequest_FieldMask) *ListProvisioningPoliciesRequest_FieldMask {
	result := &ListProvisioningPoliciesRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProvisioningPoliciesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProvisioningPoliciesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) FilterInputFields() *ListProvisioningPoliciesRequest_FieldMask {
	result := &ListProvisioningPoliciesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProvisioningPoliciesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProvisioningPoliciesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProvisioningPoliciesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProvisioningPoliciesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) AppendPath(path ListProvisioningPoliciesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProvisioningPoliciesRequest_FieldPath))
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) GetPaths() []ListProvisioningPoliciesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProvisioningPoliciesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) Set(target, source *ListProvisioningPoliciesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProvisioningPoliciesRequest), source.(*ListProvisioningPoliciesRequest))
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) Project(source *ListProvisioningPoliciesRequest) *ListProvisioningPoliciesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProvisioningPoliciesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProvisioningPoliciesRequest_FieldTerminalPath:
			switch tp.selector {
			case ListProvisioningPoliciesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListProvisioningPoliciesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListProvisioningPoliciesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListProvisioningPoliciesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListProvisioningPoliciesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListProvisioningPoliciesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListProvisioningPoliciesRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProvisioningPoliciesRequest))
}

func (fieldMask *ListProvisioningPoliciesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProvisioningPoliciesResponse_FieldMask struct {
	Paths []ListProvisioningPoliciesResponse_FieldPath
}

func FullListProvisioningPoliciesResponse_FieldMask() *ListProvisioningPoliciesResponse_FieldMask {
	res := &ListProvisioningPoliciesResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListProvisioningPoliciesResponse_FieldTerminalPath{selector: ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies})
	res.Paths = append(res.Paths, &ListProvisioningPoliciesResponse_FieldTerminalPath{selector: ListProvisioningPoliciesResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListProvisioningPoliciesResponse_FieldTerminalPath{selector: ListProvisioningPoliciesResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProvisioningPoliciesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProvisioningPoliciesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProvisioningPoliciesResponse_FieldPath(raw)
	})
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) Subtract(other *ListProvisioningPoliciesResponse_FieldMask) *ListProvisioningPoliciesResponse_FieldMask {
	result := &ListProvisioningPoliciesResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListProvisioningPoliciesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}
	mySubMasks := map[ListProvisioningPoliciesResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProvisioningPoliciesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListProvisioningPoliciesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListProvisioningPoliciesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies:
						mySubMasks[ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					}
				} else if tp, ok := path.(*ListProvisioningPoliciesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListProvisioningPoliciesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProvisioningPoliciesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) FilterInputFields() *ListProvisioningPoliciesResponse_FieldMask {
	result := &ListProvisioningPoliciesResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies:
			if _, ok := path.(*ListProvisioningPoliciesResponse_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProvisioningPoliciesResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListProvisioningPoliciesResponse_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProvisioningPoliciesResponse_FieldSubPath{selector: ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProvisioningPoliciesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProvisioningPoliciesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProvisioningPoliciesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProvisioningPoliciesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) AppendPath(path ListProvisioningPoliciesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProvisioningPoliciesResponse_FieldPath))
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) GetPaths() []ListProvisioningPoliciesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProvisioningPoliciesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) Set(target, source *ListProvisioningPoliciesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProvisioningPoliciesResponse), source.(*ListProvisioningPoliciesResponse))
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) Project(source *ListProvisioningPoliciesResponse) *ListProvisioningPoliciesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProvisioningPoliciesResponse{}
	provisioningPoliciesMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeProvisioningPoliciesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProvisioningPoliciesResponse_FieldTerminalPath:
			switch tp.selector {
			case ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies:
				result.ProvisioningPolicies = source.ProvisioningPolicies
				wholeProvisioningPoliciesAccepted = true
			case ListProvisioningPoliciesResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListProvisioningPoliciesResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListProvisioningPoliciesResponse_FieldSubPath:
			switch tp.selector {
			case ListProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicies:
				provisioningPoliciesMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			}
		}
	}
	if wholeProvisioningPoliciesAccepted == false && len(provisioningPoliciesMask.Paths) > 0 {
		for _, sourceItem := range source.GetProvisioningPolicies() {
			result.ProvisioningPolicies = append(result.ProvisioningPolicies, provisioningPoliciesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProvisioningPoliciesResponse))
}

func (fieldMask *ListProvisioningPoliciesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPolicyRequest_FieldMask struct {
	Paths []WatchProvisioningPolicyRequest_FieldPath
}

func FullWatchProvisioningPolicyRequest_FieldMask() *WatchProvisioningPolicyRequest_FieldMask {
	res := &WatchProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPolicyRequest_FieldTerminalPath{selector: WatchProvisioningPolicyRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchProvisioningPolicyRequest_FieldTerminalPath{selector: WatchProvisioningPolicyRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProvisioningPolicyRequest_FieldTerminalPath{selector: WatchProvisioningPolicyRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Subtract(other *WatchProvisioningPolicyRequest_FieldMask) *WatchProvisioningPolicyRequest_FieldMask {
	result := &WatchProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) FilterInputFields() *WatchProvisioningPolicyRequest_FieldMask {
	result := &WatchProvisioningPolicyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) AppendPath(path WatchProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) GetPaths() []WatchProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Set(target, source *WatchProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPolicyRequest), source.(*WatchProvisioningPolicyRequest))
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Project(source *WatchProvisioningPolicyRequest) *WatchProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPolicyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPolicyRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchProvisioningPolicyRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProvisioningPolicyRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPolicyRequest))
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPolicyResponse_FieldMask struct {
	Paths []WatchProvisioningPolicyResponse_FieldPath
}

func FullWatchProvisioningPolicyResponse_FieldMask() *WatchProvisioningPolicyResponse_FieldMask {
	res := &WatchProvisioningPolicyResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPolicyResponse_FieldTerminalPath{selector: WatchProvisioningPolicyResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPolicyResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPolicyResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPolicyResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Subtract(other *WatchProvisioningPolicyResponse_FieldMask) *WatchProvisioningPolicyResponse_FieldMask {
	result := &WatchProvisioningPolicyResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPolicyResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPolicyResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) FilterInputFields() *WatchProvisioningPolicyResponse_FieldMask {
	result := &WatchProvisioningPolicyResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPolicyResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPolicyResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPolicyResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPolicyResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) AppendPath(path WatchProvisioningPolicyResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPolicyResponse_FieldPath))
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) GetPaths() []WatchProvisioningPolicyResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPolicyResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Set(target, source *WatchProvisioningPolicyResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPolicyResponse), source.(*WatchProvisioningPolicyResponse))
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Project(source *WatchProvisioningPolicyResponse) *WatchProvisioningPolicyResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPolicyResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPolicyResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPolicyResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPolicyResponse))
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPoliciesRequest_FieldMask struct {
	Paths []WatchProvisioningPoliciesRequest_FieldPath
}

func FullWatchProvisioningPoliciesRequest_FieldMask() *WatchProvisioningPoliciesRequest_FieldMask {
	res := &WatchProvisioningPoliciesRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesRequest_FieldTerminalPath{selector: WatchProvisioningPoliciesRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPoliciesRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPoliciesRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPoliciesRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) Subtract(other *WatchProvisioningPoliciesRequest_FieldMask) *WatchProvisioningPoliciesRequest_FieldMask {
	result := &WatchProvisioningPoliciesRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPoliciesRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPoliciesRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) FilterInputFields() *WatchProvisioningPoliciesRequest_FieldMask {
	result := &WatchProvisioningPoliciesRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPoliciesRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPoliciesRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPoliciesRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPoliciesRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) AppendPath(path WatchProvisioningPoliciesRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPoliciesRequest_FieldPath))
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) GetPaths() []WatchProvisioningPoliciesRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPoliciesRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) Set(target, source *WatchProvisioningPoliciesRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPoliciesRequest), source.(*WatchProvisioningPoliciesRequest))
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) Project(source *WatchProvisioningPoliciesRequest) *WatchProvisioningPoliciesRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPoliciesRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPoliciesRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPoliciesRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchProvisioningPoliciesRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchProvisioningPoliciesRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchProvisioningPoliciesRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchProvisioningPoliciesRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchProvisioningPoliciesRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProvisioningPoliciesRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchProvisioningPoliciesRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchProvisioningPoliciesRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProvisioningPoliciesRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchProvisioningPoliciesRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPoliciesRequest))
}

func (fieldMask *WatchProvisioningPoliciesRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPoliciesResponse_FieldMask struct {
	Paths []WatchProvisioningPoliciesResponse_FieldPath
}

func FullWatchProvisioningPoliciesResponse_FieldMask() *WatchProvisioningPoliciesResponse_FieldMask {
	res := &WatchProvisioningPoliciesResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponse_FieldTerminalPath{selector: WatchProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicyChanges})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponse_FieldTerminalPath{selector: WatchProvisioningPoliciesResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponse_FieldTerminalPath{selector: WatchProvisioningPoliciesResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponse_FieldTerminalPath{selector: WatchProvisioningPoliciesResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponse_FieldTerminalPath{selector: WatchProvisioningPoliciesResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponse_FieldTerminalPath{selector: WatchProvisioningPoliciesResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponse_FieldTerminalPath{selector: WatchProvisioningPoliciesResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPoliciesResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPoliciesResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPoliciesResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) Subtract(other *WatchProvisioningPoliciesResponse_FieldMask) *WatchProvisioningPoliciesResponse_FieldMask {
	result := &WatchProvisioningPoliciesResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchProvisioningPoliciesResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProvisioningPoliciesResponse_FieldPathSelectorPageTokenChange: &WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchProvisioningPoliciesResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProvisioningPoliciesResponse_FieldPathSelectorPageTokenChange: &WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPoliciesResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchProvisioningPoliciesResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchProvisioningPoliciesResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchProvisioningPoliciesResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchProvisioningPoliciesResponse_FieldPathSelectorPageTokenChange] = FullWatchProvisioningPoliciesResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchProvisioningPoliciesResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchProvisioningPoliciesResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPoliciesResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) FilterInputFields() *WatchProvisioningPoliciesResponse_FieldMask {
	result := &WatchProvisioningPoliciesResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPoliciesResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPoliciesResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPoliciesResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPoliciesResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) AppendPath(path WatchProvisioningPoliciesResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPoliciesResponse_FieldPath))
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) GetPaths() []WatchProvisioningPoliciesResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPoliciesResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) Set(target, source *WatchProvisioningPoliciesResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPoliciesResponse), source.(*WatchProvisioningPoliciesResponse))
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) Project(source *WatchProvisioningPoliciesResponse) *WatchProvisioningPoliciesResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPoliciesResponse{}
	pageTokenChangeMask := &WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPoliciesResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPoliciesResponse_FieldPathSelectorProvisioningPolicyChanges:
				result.ProvisioningPolicyChanges = source.ProvisioningPolicyChanges
			case WatchProvisioningPoliciesResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchProvisioningPoliciesResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchProvisioningPoliciesResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProvisioningPoliciesResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchProvisioningPoliciesResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchProvisioningPoliciesResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchProvisioningPoliciesResponse_FieldSubPath:
			switch tp.selector {
			case WatchProvisioningPoliciesResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchProvisioningPoliciesResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPoliciesResponse))
}

func (fieldMask *WatchProvisioningPoliciesResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask struct {
	Paths []WatchProvisioningPoliciesResponsePageTokenChange_FieldPath
}

func FullWatchProvisioningPoliciesResponse_PageTokenChange_FieldMask() *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask {
	res := &WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponsePageTokenChange_FieldTerminalPath{selector: WatchProvisioningPoliciesResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchProvisioningPoliciesResponsePageTokenChange_FieldTerminalPath{selector: WatchProvisioningPoliciesResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPoliciesResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPoliciesResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPoliciesResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) Subtract(other *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask {
	result := &WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPoliciesResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask {
	result := &WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPoliciesResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPoliciesResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) AppendPath(path WatchProvisioningPoliciesResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPoliciesResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) GetPaths() []WatchProvisioningPoliciesResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPoliciesResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) Set(target, source *WatchProvisioningPoliciesResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPoliciesResponse_PageTokenChange), source.(*WatchProvisioningPoliciesResponse_PageTokenChange))
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) Project(source *WatchProvisioningPoliciesResponse_PageTokenChange) *WatchProvisioningPoliciesResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPoliciesResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPoliciesResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPoliciesResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchProvisioningPoliciesResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPoliciesResponse_PageTokenChange))
}

func (fieldMask *WatchProvisioningPoliciesResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateProvisioningPolicyRequest_FieldMask struct {
	Paths []CreateProvisioningPolicyRequest_FieldPath
}

func FullCreateProvisioningPolicyRequest_FieldMask() *CreateProvisioningPolicyRequest_FieldMask {
	res := &CreateProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateProvisioningPolicyRequest_FieldTerminalPath{selector: CreateProvisioningPolicyRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateProvisioningPolicyRequest_FieldTerminalPath{selector: CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy})
	return res
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Subtract(other *CreateProvisioningPolicyRequest_FieldMask) *CreateProvisioningPolicyRequest_FieldMask {
	result := &CreateProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateProvisioningPolicyRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}
	mySubMasks := map[CreateProvisioningPolicyRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateProvisioningPolicyRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateProvisioningPolicyRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
						mySubMasks[CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					}
				} else if tp, ok := path.(*CreateProvisioningPolicyRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateProvisioningPolicyRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) FilterInputFields() *CreateProvisioningPolicyRequest_FieldMask {
	result := &CreateProvisioningPolicyRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
			if _, ok := path.(*CreateProvisioningPolicyRequest_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProvisioningPolicyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateProvisioningPolicyRequest_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProvisioningPolicyRequest_FieldSubPath{selector: CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) AppendPath(path CreateProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) GetPaths() []CreateProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Set(target, source *CreateProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateProvisioningPolicyRequest), source.(*CreateProvisioningPolicyRequest))
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Project(source *CreateProvisioningPolicyRequest) *CreateProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateProvisioningPolicyRequest{}
	provisioningPolicyMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeProvisioningPolicyAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateProvisioningPolicyRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
				result.ProvisioningPolicy = source.ProvisioningPolicy
				wholeProvisioningPolicyAccepted = true
			}
		case *CreateProvisioningPolicyRequest_FieldSubPath:
			switch tp.selector {
			case CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
				provisioningPolicyMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			}
		}
	}
	if wholeProvisioningPolicyAccepted == false && len(provisioningPolicyMask.Paths) > 0 {
		result.ProvisioningPolicy = provisioningPolicyMask.Project(source.GetProvisioningPolicy())
	}
	return result
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateProvisioningPolicyRequest))
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProvisioningPolicyRequest_FieldMask struct {
	Paths []UpdateProvisioningPolicyRequest_FieldPath
}

func FullUpdateProvisioningPolicyRequest_FieldMask() *UpdateProvisioningPolicyRequest_FieldMask {
	res := &UpdateProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequest_FieldTerminalPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy})
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequest_FieldTerminalPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequest_FieldTerminalPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Subtract(other *UpdateProvisioningPolicyRequest_FieldMask) *UpdateProvisioningPolicyRequest_FieldMask {
	result := &UpdateProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateProvisioningPolicyRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy: &provisioning_policy.ProvisioningPolicy_FieldMask{},
		UpdateProvisioningPolicyRequest_FieldPathSelectorCas:                &UpdateProvisioningPolicyRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateProvisioningPolicyRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy: &provisioning_policy.ProvisioningPolicy_FieldMask{},
		UpdateProvisioningPolicyRequest_FieldPathSelectorCas:                &UpdateProvisioningPolicyRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProvisioningPolicyRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProvisioningPolicyRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
						mySubMasks[UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					case UpdateProvisioningPolicyRequest_FieldPathSelectorCas:
						mySubMasks[UpdateProvisioningPolicyRequest_FieldPathSelectorCas] = FullUpdateProvisioningPolicyRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProvisioningPolicyRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) FilterInputFields() *UpdateProvisioningPolicyRequest_FieldMask {
	result := &UpdateProvisioningPolicyRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
			if _, ok := path.(*UpdateProvisioningPolicyRequest_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProvisioningPolicyRequest_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy, subPath: allowedPath})
				}
			}
		case UpdateProvisioningPolicyRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateProvisioningPolicyRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateProvisioningPolicyRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProvisioningPolicyRequest_FieldSubPath); ok {
				selectedMask := &UpdateProvisioningPolicyRequest_CAS_FieldMask{
					Paths: []UpdateProvisioningPolicyRequestCAS_FieldPath{sub.subPath.(UpdateProvisioningPolicyRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) AppendPath(path UpdateProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) GetPaths() []UpdateProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Set(target, source *UpdateProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProvisioningPolicyRequest), source.(*UpdateProvisioningPolicyRequest))
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Project(source *UpdateProvisioningPolicyRequest) *UpdateProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProvisioningPolicyRequest{}
	provisioningPolicyMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeProvisioningPolicyAccepted := false
	casMask := &UpdateProvisioningPolicyRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
				result.ProvisioningPolicy = source.ProvisioningPolicy
				wholeProvisioningPolicyAccepted = true
			case UpdateProvisioningPolicyRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateProvisioningPolicyRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateProvisioningPolicyRequest_FieldSubPath:
			switch tp.selector {
			case UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
				provisioningPolicyMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			case UpdateProvisioningPolicyRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateProvisioningPolicyRequestCAS_FieldPath))
			}
		}
	}
	if wholeProvisioningPolicyAccepted == false && len(provisioningPolicyMask.Paths) > 0 {
		result.ProvisioningPolicy = provisioningPolicyMask.Project(source.GetProvisioningPolicy())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProvisioningPolicyRequest))
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProvisioningPolicyRequest_CAS_FieldMask struct {
	Paths []UpdateProvisioningPolicyRequestCAS_FieldPath
}

func FullUpdateProvisioningPolicyRequest_CAS_FieldMask() *UpdateProvisioningPolicyRequest_CAS_FieldMask {
	res := &UpdateProvisioningPolicyRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequestCAS_FieldTerminalPath{selector: UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequestCAS_FieldTerminalPath{selector: UpdateProvisioningPolicyRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProvisioningPolicyRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProvisioningPolicyRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Subtract(other *UpdateProvisioningPolicyRequest_CAS_FieldMask) *UpdateProvisioningPolicyRequest_CAS_FieldMask {
	result := &UpdateProvisioningPolicyRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateProvisioningPolicyRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}
	mySubMasks := map[UpdateProvisioningPolicyRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProvisioningPolicyRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProvisioningPolicyRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProvisioningPolicyRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) FilterInputFields() *UpdateProvisioningPolicyRequest_CAS_FieldMask {
	result := &UpdateProvisioningPolicyRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequestCAS_FieldSubPath{selector: UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProvisioningPolicyRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProvisioningPolicyRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProvisioningPolicyRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProvisioningPolicyRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) AppendPath(path UpdateProvisioningPolicyRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProvisioningPolicyRequestCAS_FieldPath))
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) GetPaths() []UpdateProvisioningPolicyRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProvisioningPolicyRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Set(target, source *UpdateProvisioningPolicyRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProvisioningPolicyRequest_CAS), source.(*UpdateProvisioningPolicyRequest_CAS))
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Project(source *UpdateProvisioningPolicyRequest_CAS) *UpdateProvisioningPolicyRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProvisioningPolicyRequest_CAS{}
	conditionalStateMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProvisioningPolicyRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateProvisioningPolicyRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProvisioningPolicyRequest_CAS))
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteProvisioningPolicyRequest_FieldMask struct {
	Paths []DeleteProvisioningPolicyRequest_FieldPath
}

func FullDeleteProvisioningPolicyRequest_FieldMask() *DeleteProvisioningPolicyRequest_FieldMask {
	res := &DeleteProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteProvisioningPolicyRequest_FieldTerminalPath{selector: DeleteProvisioningPolicyRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Subtract(other *DeleteProvisioningPolicyRequest_FieldMask) *DeleteProvisioningPolicyRequest_FieldMask {
	result := &DeleteProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) FilterInputFields() *DeleteProvisioningPolicyRequest_FieldMask {
	result := &DeleteProvisioningPolicyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) AppendPath(path DeleteProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) GetPaths() []DeleteProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Set(target, source *DeleteProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteProvisioningPolicyRequest), source.(*DeleteProvisioningPolicyRequest))
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Project(source *DeleteProvisioningPolicyRequest) *DeleteProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteProvisioningPolicyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteProvisioningPolicyRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteProvisioningPolicyRequest))
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
