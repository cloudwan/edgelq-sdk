// Code generated by protoc-gen-goten-object
// File: edgelq/devices/proto/v1alpha2/os_version_service.proto
// DO NOT EDIT!!!

package os_version_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	os_version "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha2/os_version"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &os_version.OsVersion{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetOsVersionRequest_FieldMask struct {
	Paths []GetOsVersionRequest_FieldPath
}

func FullGetOsVersionRequest_FieldMask() *GetOsVersionRequest_FieldMask {
	res := &GetOsVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetOsVersionRequest_FieldTerminalPath{selector: GetOsVersionRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetOsVersionRequest_FieldTerminalPath{selector: GetOsVersionRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetOsVersionRequest_FieldTerminalPath{selector: GetOsVersionRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetOsVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetOsVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetOsVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetOsVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetOsVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetOsVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetOsVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetOsVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *GetOsVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetOsVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetOsVersionRequest_FieldMask) Subtract(other *GetOsVersionRequest_FieldMask) *GetOsVersionRequest_FieldMask {
	result := &GetOsVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetOsVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetOsVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetOsVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetOsVersionRequest_FieldMask) FilterInputFields() *GetOsVersionRequest_FieldMask {
	result := &GetOsVersionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetOsVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetOsVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetOsVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetOsVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetOsVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetOsVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetOsVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetOsVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetOsVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetOsVersionRequest_FieldMask) AppendPath(path GetOsVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetOsVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetOsVersionRequest_FieldPath))
}

func (fieldMask *GetOsVersionRequest_FieldMask) GetPaths() []GetOsVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetOsVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetOsVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetOsVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetOsVersionRequest_FieldMask) Set(target, source *GetOsVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetOsVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetOsVersionRequest), source.(*GetOsVersionRequest))
}

func (fieldMask *GetOsVersionRequest_FieldMask) Project(source *GetOsVersionRequest) *GetOsVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetOsVersionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetOsVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case GetOsVersionRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetOsVersionRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetOsVersionRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetOsVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetOsVersionRequest))
}

func (fieldMask *GetOsVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetOsVersionsRequest_FieldMask struct {
	Paths []BatchGetOsVersionsRequest_FieldPath
}

func FullBatchGetOsVersionsRequest_FieldMask() *BatchGetOsVersionsRequest_FieldMask {
	res := &BatchGetOsVersionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetOsVersionsRequest_FieldTerminalPath{selector: BatchGetOsVersionsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetOsVersionsRequest_FieldTerminalPath{selector: BatchGetOsVersionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetOsVersionsRequest_FieldTerminalPath{selector: BatchGetOsVersionsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetOsVersionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetOsVersionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetOsVersionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetOsVersionsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) Subtract(other *BatchGetOsVersionsRequest_FieldMask) *BatchGetOsVersionsRequest_FieldMask {
	result := &BatchGetOsVersionsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetOsVersionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetOsVersionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetOsVersionsRequest_FieldMask) FilterInputFields() *BatchGetOsVersionsRequest_FieldMask {
	result := &BatchGetOsVersionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetOsVersionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetOsVersionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetOsVersionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetOsVersionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetOsVersionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) AppendPath(path BatchGetOsVersionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetOsVersionsRequest_FieldPath))
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) GetPaths() []BatchGetOsVersionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetOsVersionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) Set(target, source *BatchGetOsVersionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetOsVersionsRequest), source.(*BatchGetOsVersionsRequest))
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) Project(source *BatchGetOsVersionsRequest) *BatchGetOsVersionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetOsVersionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetOsVersionsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetOsVersionsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetOsVersionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetOsVersionsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetOsVersionsRequest))
}

func (fieldMask *BatchGetOsVersionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetOsVersionsResponse_FieldMask struct {
	Paths []BatchGetOsVersionsResponse_FieldPath
}

func FullBatchGetOsVersionsResponse_FieldMask() *BatchGetOsVersionsResponse_FieldMask {
	res := &BatchGetOsVersionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetOsVersionsResponse_FieldTerminalPath{selector: BatchGetOsVersionsResponse_FieldPathSelectorOsVersions})
	res.Paths = append(res.Paths, &BatchGetOsVersionsResponse_FieldTerminalPath{selector: BatchGetOsVersionsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetOsVersionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetOsVersionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetOsVersionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetOsVersionsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) Subtract(other *BatchGetOsVersionsResponse_FieldMask) *BatchGetOsVersionsResponse_FieldMask {
	result := &BatchGetOsVersionsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetOsVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetOsVersionsResponse_FieldPathSelectorOsVersions: &os_version.OsVersion_FieldMask{},
	}
	mySubMasks := map[BatchGetOsVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetOsVersionsResponse_FieldPathSelectorOsVersions: &os_version.OsVersion_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetOsVersionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetOsVersionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetOsVersionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetOsVersionsResponse_FieldPathSelectorOsVersions:
						mySubMasks[BatchGetOsVersionsResponse_FieldPathSelectorOsVersions] = os_version.FullOsVersion_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetOsVersionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetOsVersionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetOsVersionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetOsVersionsResponse_FieldMask) FilterInputFields() *BatchGetOsVersionsResponse_FieldMask {
	result := &BatchGetOsVersionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetOsVersionsResponse_FieldPathSelectorOsVersions:
			if _, ok := path.(*BatchGetOsVersionsResponse_FieldTerminalPath); ok {
				for _, subpath := range os_version.FullOsVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetOsVersionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetOsVersionsResponse_FieldSubPath); ok {
				selectedMask := &os_version.OsVersion_FieldMask{
					Paths: []os_version.OsVersion_FieldPath{sub.subPath.(os_version.OsVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetOsVersionsResponse_FieldSubPath{selector: BatchGetOsVersionsResponse_FieldPathSelectorOsVersions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetOsVersionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetOsVersionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetOsVersionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetOsVersionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetOsVersionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) AppendPath(path BatchGetOsVersionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetOsVersionsResponse_FieldPath))
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) GetPaths() []BatchGetOsVersionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetOsVersionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) Set(target, source *BatchGetOsVersionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetOsVersionsResponse), source.(*BatchGetOsVersionsResponse))
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) Project(source *BatchGetOsVersionsResponse) *BatchGetOsVersionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetOsVersionsResponse{}
	osVersionsMask := &os_version.OsVersion_FieldMask{}
	wholeOsVersionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetOsVersionsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetOsVersionsResponse_FieldPathSelectorOsVersions:
				result.OsVersions = source.OsVersions
				wholeOsVersionsAccepted = true
			case BatchGetOsVersionsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetOsVersionsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetOsVersionsResponse_FieldPathSelectorOsVersions:
				osVersionsMask.AppendPath(tp.subPath.(os_version.OsVersion_FieldPath))
			}
		}
	}
	if wholeOsVersionsAccepted == false && len(osVersionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetOsVersions() {
			result.OsVersions = append(result.OsVersions, osVersionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetOsVersionsResponse))
}

func (fieldMask *BatchGetOsVersionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListOsVersionsRequest_FieldMask struct {
	Paths []ListOsVersionsRequest_FieldPath
}

func FullListOsVersionsRequest_FieldMask() *ListOsVersionsRequest_FieldMask {
	res := &ListOsVersionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListOsVersionsRequest_FieldTerminalPath{selector: ListOsVersionsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListOsVersionsRequest_FieldTerminalPath{selector: ListOsVersionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListOsVersionsRequest_FieldTerminalPath{selector: ListOsVersionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListOsVersionsRequest_FieldTerminalPath{selector: ListOsVersionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListOsVersionsRequest_FieldTerminalPath{selector: ListOsVersionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListOsVersionsRequest_FieldTerminalPath{selector: ListOsVersionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListOsVersionsRequest_FieldTerminalPath{selector: ListOsVersionsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListOsVersionsRequest_FieldTerminalPath{selector: ListOsVersionsRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListOsVersionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListOsVersionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListOsVersionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListOsVersionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListOsVersionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListOsVersionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListOsVersionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListOsVersionsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListOsVersionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListOsVersionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListOsVersionsRequest_FieldMask) Subtract(other *ListOsVersionsRequest_FieldMask) *ListOsVersionsRequest_FieldMask {
	result := &ListOsVersionsRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListOsVersionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListOsVersionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListOsVersionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListOsVersionsRequest_FieldMask) FilterInputFields() *ListOsVersionsRequest_FieldMask {
	result := &ListOsVersionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListOsVersionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListOsVersionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListOsVersionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListOsVersionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListOsVersionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListOsVersionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListOsVersionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListOsVersionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListOsVersionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListOsVersionsRequest_FieldMask) AppendPath(path ListOsVersionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListOsVersionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListOsVersionsRequest_FieldPath))
}

func (fieldMask *ListOsVersionsRequest_FieldMask) GetPaths() []ListOsVersionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListOsVersionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListOsVersionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListOsVersionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListOsVersionsRequest_FieldMask) Set(target, source *ListOsVersionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListOsVersionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListOsVersionsRequest), source.(*ListOsVersionsRequest))
}

func (fieldMask *ListOsVersionsRequest_FieldMask) Project(source *ListOsVersionsRequest) *ListOsVersionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListOsVersionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListOsVersionsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListOsVersionsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListOsVersionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListOsVersionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListOsVersionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListOsVersionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListOsVersionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListOsVersionsRequest_FieldPathSelectorView:
				result.View = source.View
			case ListOsVersionsRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListOsVersionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListOsVersionsRequest))
}

func (fieldMask *ListOsVersionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListOsVersionsResponse_FieldMask struct {
	Paths []ListOsVersionsResponse_FieldPath
}

func FullListOsVersionsResponse_FieldMask() *ListOsVersionsResponse_FieldMask {
	res := &ListOsVersionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListOsVersionsResponse_FieldTerminalPath{selector: ListOsVersionsResponse_FieldPathSelectorOsVersions})
	res.Paths = append(res.Paths, &ListOsVersionsResponse_FieldTerminalPath{selector: ListOsVersionsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListOsVersionsResponse_FieldTerminalPath{selector: ListOsVersionsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListOsVersionsResponse_FieldTerminalPath{selector: ListOsVersionsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListOsVersionsResponse_FieldTerminalPath{selector: ListOsVersionsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListOsVersionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListOsVersionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListOsVersionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListOsVersionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListOsVersionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListOsVersionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListOsVersionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListOsVersionsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListOsVersionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListOsVersionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListOsVersionsResponse_FieldMask) Subtract(other *ListOsVersionsResponse_FieldMask) *ListOsVersionsResponse_FieldMask {
	result := &ListOsVersionsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListOsVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListOsVersionsResponse_FieldPathSelectorOsVersions: &os_version.OsVersion_FieldMask{},
	}
	mySubMasks := map[ListOsVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListOsVersionsResponse_FieldPathSelectorOsVersions: &os_version.OsVersion_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListOsVersionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListOsVersionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListOsVersionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListOsVersionsResponse_FieldPathSelectorOsVersions:
						mySubMasks[ListOsVersionsResponse_FieldPathSelectorOsVersions] = os_version.FullOsVersion_FieldMask()
					}
				} else if tp, ok := path.(*ListOsVersionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListOsVersionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListOsVersionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListOsVersionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListOsVersionsResponse_FieldMask) FilterInputFields() *ListOsVersionsResponse_FieldMask {
	result := &ListOsVersionsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListOsVersionsResponse_FieldPathSelectorOsVersions:
			if _, ok := path.(*ListOsVersionsResponse_FieldTerminalPath); ok {
				for _, subpath := range os_version.FullOsVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListOsVersionsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListOsVersionsResponse_FieldSubPath); ok {
				selectedMask := &os_version.OsVersion_FieldMask{
					Paths: []os_version.OsVersion_FieldPath{sub.subPath.(os_version.OsVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListOsVersionsResponse_FieldSubPath{selector: ListOsVersionsResponse_FieldPathSelectorOsVersions, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListOsVersionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListOsVersionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListOsVersionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListOsVersionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListOsVersionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListOsVersionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListOsVersionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListOsVersionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListOsVersionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListOsVersionsResponse_FieldMask) AppendPath(path ListOsVersionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListOsVersionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListOsVersionsResponse_FieldPath))
}

func (fieldMask *ListOsVersionsResponse_FieldMask) GetPaths() []ListOsVersionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListOsVersionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListOsVersionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListOsVersionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListOsVersionsResponse_FieldMask) Set(target, source *ListOsVersionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListOsVersionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListOsVersionsResponse), source.(*ListOsVersionsResponse))
}

func (fieldMask *ListOsVersionsResponse_FieldMask) Project(source *ListOsVersionsResponse) *ListOsVersionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListOsVersionsResponse{}
	osVersionsMask := &os_version.OsVersion_FieldMask{}
	wholeOsVersionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListOsVersionsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListOsVersionsResponse_FieldPathSelectorOsVersions:
				result.OsVersions = source.OsVersions
				wholeOsVersionsAccepted = true
			case ListOsVersionsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListOsVersionsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListOsVersionsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListOsVersionsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListOsVersionsResponse_FieldSubPath:
			switch tp.selector {
			case ListOsVersionsResponse_FieldPathSelectorOsVersions:
				osVersionsMask.AppendPath(tp.subPath.(os_version.OsVersion_FieldPath))
			}
		}
	}
	if wholeOsVersionsAccepted == false && len(osVersionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetOsVersions() {
			result.OsVersions = append(result.OsVersions, osVersionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListOsVersionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListOsVersionsResponse))
}

func (fieldMask *ListOsVersionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchOsVersionRequest_FieldMask struct {
	Paths []WatchOsVersionRequest_FieldPath
}

func FullWatchOsVersionRequest_FieldMask() *WatchOsVersionRequest_FieldMask {
	res := &WatchOsVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchOsVersionRequest_FieldTerminalPath{selector: WatchOsVersionRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchOsVersionRequest_FieldTerminalPath{selector: WatchOsVersionRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchOsVersionRequest_FieldTerminalPath{selector: WatchOsVersionRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchOsVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchOsVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchOsVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchOsVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchOsVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchOsVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchOsVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchOsVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchOsVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchOsVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchOsVersionRequest_FieldMask) Subtract(other *WatchOsVersionRequest_FieldMask) *WatchOsVersionRequest_FieldMask {
	result := &WatchOsVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchOsVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchOsVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchOsVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchOsVersionRequest_FieldMask) FilterInputFields() *WatchOsVersionRequest_FieldMask {
	result := &WatchOsVersionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchOsVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchOsVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchOsVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchOsVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchOsVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchOsVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchOsVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchOsVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionRequest_FieldMask) AppendPath(path WatchOsVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchOsVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchOsVersionRequest_FieldPath))
}

func (fieldMask *WatchOsVersionRequest_FieldMask) GetPaths() []WatchOsVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchOsVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchOsVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchOsVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchOsVersionRequest_FieldMask) Set(target, source *WatchOsVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchOsVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchOsVersionRequest), source.(*WatchOsVersionRequest))
}

func (fieldMask *WatchOsVersionRequest_FieldMask) Project(source *WatchOsVersionRequest) *WatchOsVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchOsVersionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchOsVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchOsVersionRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchOsVersionRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchOsVersionRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchOsVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchOsVersionRequest))
}

func (fieldMask *WatchOsVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchOsVersionResponse_FieldMask struct {
	Paths []WatchOsVersionResponse_FieldPath
}

func FullWatchOsVersionResponse_FieldMask() *WatchOsVersionResponse_FieldMask {
	res := &WatchOsVersionResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchOsVersionResponse_FieldTerminalPath{selector: WatchOsVersionResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchOsVersionResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchOsVersionResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchOsVersionResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchOsVersionResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchOsVersionResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchOsVersionResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchOsVersionResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchOsVersionResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchOsVersionResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchOsVersionResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchOsVersionResponse_FieldMask) Subtract(other *WatchOsVersionResponse_FieldMask) *WatchOsVersionResponse_FieldMask {
	result := &WatchOsVersionResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchOsVersionResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchOsVersionResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchOsVersionResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchOsVersionResponse_FieldMask) FilterInputFields() *WatchOsVersionResponse_FieldMask {
	result := &WatchOsVersionResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchOsVersionResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchOsVersionResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchOsVersionResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchOsVersionResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchOsVersionResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchOsVersionResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchOsVersionResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchOsVersionResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionResponse_FieldMask) AppendPath(path WatchOsVersionResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchOsVersionResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchOsVersionResponse_FieldPath))
}

func (fieldMask *WatchOsVersionResponse_FieldMask) GetPaths() []WatchOsVersionResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchOsVersionResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchOsVersionResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchOsVersionResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchOsVersionResponse_FieldMask) Set(target, source *WatchOsVersionResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchOsVersionResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchOsVersionResponse), source.(*WatchOsVersionResponse))
}

func (fieldMask *WatchOsVersionResponse_FieldMask) Project(source *WatchOsVersionResponse) *WatchOsVersionResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchOsVersionResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchOsVersionResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchOsVersionResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchOsVersionResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchOsVersionResponse))
}

func (fieldMask *WatchOsVersionResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchOsVersionsRequest_FieldMask struct {
	Paths []WatchOsVersionsRequest_FieldPath
}

func FullWatchOsVersionsRequest_FieldMask() *WatchOsVersionsRequest_FieldMask {
	res := &WatchOsVersionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchOsVersionsRequest_FieldTerminalPath{selector: WatchOsVersionsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchOsVersionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchOsVersionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchOsVersionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchOsVersionsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchOsVersionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) Subtract(other *WatchOsVersionsRequest_FieldMask) *WatchOsVersionsRequest_FieldMask {
	result := &WatchOsVersionsRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchOsVersionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchOsVersionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchOsVersionsRequest_FieldMask) FilterInputFields() *WatchOsVersionsRequest_FieldMask {
	result := &WatchOsVersionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchOsVersionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchOsVersionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchOsVersionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchOsVersionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchOsVersionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) AppendPath(path WatchOsVersionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchOsVersionsRequest_FieldPath))
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) GetPaths() []WatchOsVersionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchOsVersionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) Set(target, source *WatchOsVersionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchOsVersionsRequest), source.(*WatchOsVersionsRequest))
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) Project(source *WatchOsVersionsRequest) *WatchOsVersionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchOsVersionsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchOsVersionsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchOsVersionsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchOsVersionsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchOsVersionsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchOsVersionsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchOsVersionsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchOsVersionsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchOsVersionsRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchOsVersionsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchOsVersionsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchOsVersionsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchOsVersionsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchOsVersionsRequest))
}

func (fieldMask *WatchOsVersionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchOsVersionsResponse_FieldMask struct {
	Paths []WatchOsVersionsResponse_FieldPath
}

func FullWatchOsVersionsResponse_FieldMask() *WatchOsVersionsResponse_FieldMask {
	res := &WatchOsVersionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchOsVersionsResponse_FieldTerminalPath{selector: WatchOsVersionsResponse_FieldPathSelectorOsVersionChanges})
	res.Paths = append(res.Paths, &WatchOsVersionsResponse_FieldTerminalPath{selector: WatchOsVersionsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchOsVersionsResponse_FieldTerminalPath{selector: WatchOsVersionsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchOsVersionsResponse_FieldTerminalPath{selector: WatchOsVersionsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchOsVersionsResponse_FieldTerminalPath{selector: WatchOsVersionsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchOsVersionsResponse_FieldTerminalPath{selector: WatchOsVersionsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchOsVersionsResponse_FieldTerminalPath{selector: WatchOsVersionsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchOsVersionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchOsVersionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchOsVersionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchOsVersionsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchOsVersionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) Subtract(other *WatchOsVersionsResponse_FieldMask) *WatchOsVersionsResponse_FieldMask {
	result := &WatchOsVersionsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchOsVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchOsVersionsResponse_FieldPathSelectorPageTokenChange: &WatchOsVersionsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchOsVersionsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchOsVersionsResponse_FieldPathSelectorPageTokenChange: &WatchOsVersionsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchOsVersionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchOsVersionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchOsVersionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchOsVersionsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchOsVersionsResponse_FieldPathSelectorPageTokenChange] = FullWatchOsVersionsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchOsVersionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchOsVersionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchOsVersionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchOsVersionsResponse_FieldMask) FilterInputFields() *WatchOsVersionsResponse_FieldMask {
	result := &WatchOsVersionsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchOsVersionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchOsVersionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchOsVersionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchOsVersionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchOsVersionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) AppendPath(path WatchOsVersionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchOsVersionsResponse_FieldPath))
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) GetPaths() []WatchOsVersionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchOsVersionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) Set(target, source *WatchOsVersionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchOsVersionsResponse), source.(*WatchOsVersionsResponse))
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) Project(source *WatchOsVersionsResponse) *WatchOsVersionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchOsVersionsResponse{}
	pageTokenChangeMask := &WatchOsVersionsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchOsVersionsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchOsVersionsResponse_FieldPathSelectorOsVersionChanges:
				result.OsVersionChanges = source.OsVersionChanges
			case WatchOsVersionsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchOsVersionsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchOsVersionsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchOsVersionsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchOsVersionsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchOsVersionsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchOsVersionsResponse_FieldSubPath:
			switch tp.selector {
			case WatchOsVersionsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchOsVersionsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchOsVersionsResponse))
}

func (fieldMask *WatchOsVersionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchOsVersionsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchOsVersionsResponsePageTokenChange_FieldPath
}

func FullWatchOsVersionsResponse_PageTokenChange_FieldMask() *WatchOsVersionsResponse_PageTokenChange_FieldMask {
	res := &WatchOsVersionsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchOsVersionsResponsePageTokenChange_FieldTerminalPath{selector: WatchOsVersionsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchOsVersionsResponsePageTokenChange_FieldTerminalPath{selector: WatchOsVersionsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchOsVersionsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchOsVersionsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchOsVersionsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) Subtract(other *WatchOsVersionsResponse_PageTokenChange_FieldMask) *WatchOsVersionsResponse_PageTokenChange_FieldMask {
	result := &WatchOsVersionsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchOsVersionsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchOsVersionsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchOsVersionsResponse_PageTokenChange_FieldMask {
	result := &WatchOsVersionsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchOsVersionsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchOsVersionsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchOsVersionsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchOsVersionsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) AppendPath(path WatchOsVersionsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchOsVersionsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) GetPaths() []WatchOsVersionsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchOsVersionsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) Set(target, source *WatchOsVersionsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchOsVersionsResponse_PageTokenChange), source.(*WatchOsVersionsResponse_PageTokenChange))
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) Project(source *WatchOsVersionsResponse_PageTokenChange) *WatchOsVersionsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchOsVersionsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchOsVersionsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchOsVersionsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchOsVersionsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchOsVersionsResponse_PageTokenChange))
}

func (fieldMask *WatchOsVersionsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateOsVersionRequest_FieldMask struct {
	Paths []CreateOsVersionRequest_FieldPath
}

func FullCreateOsVersionRequest_FieldMask() *CreateOsVersionRequest_FieldMask {
	res := &CreateOsVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateOsVersionRequest_FieldTerminalPath{selector: CreateOsVersionRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateOsVersionRequest_FieldTerminalPath{selector: CreateOsVersionRequest_FieldPathSelectorOsVersion})
	return res
}

func (fieldMask *CreateOsVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateOsVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateOsVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateOsVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateOsVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateOsVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateOsVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateOsVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateOsVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateOsVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateOsVersionRequest_FieldMask) Subtract(other *CreateOsVersionRequest_FieldMask) *CreateOsVersionRequest_FieldMask {
	result := &CreateOsVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateOsVersionRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateOsVersionRequest_FieldPathSelectorOsVersion: &os_version.OsVersion_FieldMask{},
	}
	mySubMasks := map[CreateOsVersionRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateOsVersionRequest_FieldPathSelectorOsVersion: &os_version.OsVersion_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateOsVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateOsVersionRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateOsVersionRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateOsVersionRequest_FieldPathSelectorOsVersion:
						mySubMasks[CreateOsVersionRequest_FieldPathSelectorOsVersion] = os_version.FullOsVersion_FieldMask()
					}
				} else if tp, ok := path.(*CreateOsVersionRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateOsVersionRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateOsVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateOsVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateOsVersionRequest_FieldMask) FilterInputFields() *CreateOsVersionRequest_FieldMask {
	result := &CreateOsVersionRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateOsVersionRequest_FieldPathSelectorOsVersion:
			if _, ok := path.(*CreateOsVersionRequest_FieldTerminalPath); ok {
				for _, subpath := range os_version.FullOsVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateOsVersionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateOsVersionRequest_FieldSubPath); ok {
				selectedMask := &os_version.OsVersion_FieldMask{
					Paths: []os_version.OsVersion_FieldPath{sub.subPath.(os_version.OsVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateOsVersionRequest_FieldSubPath{selector: CreateOsVersionRequest_FieldPathSelectorOsVersion, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateOsVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateOsVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateOsVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateOsVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateOsVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateOsVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateOsVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateOsVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateOsVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateOsVersionRequest_FieldMask) AppendPath(path CreateOsVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateOsVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateOsVersionRequest_FieldPath))
}

func (fieldMask *CreateOsVersionRequest_FieldMask) GetPaths() []CreateOsVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateOsVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateOsVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateOsVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateOsVersionRequest_FieldMask) Set(target, source *CreateOsVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateOsVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateOsVersionRequest), source.(*CreateOsVersionRequest))
}

func (fieldMask *CreateOsVersionRequest_FieldMask) Project(source *CreateOsVersionRequest) *CreateOsVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateOsVersionRequest{}
	osVersionMask := &os_version.OsVersion_FieldMask{}
	wholeOsVersionAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateOsVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateOsVersionRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateOsVersionRequest_FieldPathSelectorOsVersion:
				result.OsVersion = source.OsVersion
				wholeOsVersionAccepted = true
			}
		case *CreateOsVersionRequest_FieldSubPath:
			switch tp.selector {
			case CreateOsVersionRequest_FieldPathSelectorOsVersion:
				osVersionMask.AppendPath(tp.subPath.(os_version.OsVersion_FieldPath))
			}
		}
	}
	if wholeOsVersionAccepted == false && len(osVersionMask.Paths) > 0 {
		result.OsVersion = osVersionMask.Project(source.GetOsVersion())
	}
	return result
}

func (fieldMask *CreateOsVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateOsVersionRequest))
}

func (fieldMask *CreateOsVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateOsVersionRequest_FieldMask struct {
	Paths []UpdateOsVersionRequest_FieldPath
}

func FullUpdateOsVersionRequest_FieldMask() *UpdateOsVersionRequest_FieldMask {
	res := &UpdateOsVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateOsVersionRequest_FieldTerminalPath{selector: UpdateOsVersionRequest_FieldPathSelectorOsVersion})
	res.Paths = append(res.Paths, &UpdateOsVersionRequest_FieldTerminalPath{selector: UpdateOsVersionRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateOsVersionRequest_FieldTerminalPath{selector: UpdateOsVersionRequest_FieldPathSelectorCas})
	res.Paths = append(res.Paths, &UpdateOsVersionRequest_FieldTerminalPath{selector: UpdateOsVersionRequest_FieldPathSelectorAllowMissing})
	return res
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateOsVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateOsVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateOsVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateOsVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateOsVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) Subtract(other *UpdateOsVersionRequest_FieldMask) *UpdateOsVersionRequest_FieldMask {
	result := &UpdateOsVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[UpdateOsVersionRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateOsVersionRequest_FieldPathSelectorOsVersion: &os_version.OsVersion_FieldMask{},
		UpdateOsVersionRequest_FieldPathSelectorCas:       &UpdateOsVersionRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateOsVersionRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateOsVersionRequest_FieldPathSelectorOsVersion: &os_version.OsVersion_FieldMask{},
		UpdateOsVersionRequest_FieldPathSelectorCas:       &UpdateOsVersionRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateOsVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateOsVersionRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateOsVersionRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateOsVersionRequest_FieldPathSelectorOsVersion:
						mySubMasks[UpdateOsVersionRequest_FieldPathSelectorOsVersion] = os_version.FullOsVersion_FieldMask()
					case UpdateOsVersionRequest_FieldPathSelectorCas:
						mySubMasks[UpdateOsVersionRequest_FieldPathSelectorCas] = FullUpdateOsVersionRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateOsVersionRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateOsVersionRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateOsVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateOsVersionRequest_FieldMask) FilterInputFields() *UpdateOsVersionRequest_FieldMask {
	result := &UpdateOsVersionRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateOsVersionRequest_FieldPathSelectorOsVersion:
			if _, ok := path.(*UpdateOsVersionRequest_FieldTerminalPath); ok {
				for _, subpath := range os_version.FullOsVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateOsVersionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateOsVersionRequest_FieldSubPath); ok {
				selectedMask := &os_version.OsVersion_FieldMask{
					Paths: []os_version.OsVersion_FieldPath{sub.subPath.(os_version.OsVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateOsVersionRequest_FieldSubPath{selector: UpdateOsVersionRequest_FieldPathSelectorOsVersion, subPath: allowedPath})
				}
			}
		case UpdateOsVersionRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateOsVersionRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateOsVersionRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateOsVersionRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateOsVersionRequest_FieldSubPath); ok {
				selectedMask := &UpdateOsVersionRequest_CAS_FieldMask{
					Paths: []UpdateOsVersionRequestCAS_FieldPath{sub.subPath.(UpdateOsVersionRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateOsVersionRequest_FieldSubPath{selector: UpdateOsVersionRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateOsVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateOsVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateOsVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateOsVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateOsVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) AppendPath(path UpdateOsVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateOsVersionRequest_FieldPath))
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) GetPaths() []UpdateOsVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateOsVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) Set(target, source *UpdateOsVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateOsVersionRequest), source.(*UpdateOsVersionRequest))
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) Project(source *UpdateOsVersionRequest) *UpdateOsVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateOsVersionRequest{}
	osVersionMask := &os_version.OsVersion_FieldMask{}
	wholeOsVersionAccepted := false
	casMask := &UpdateOsVersionRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateOsVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateOsVersionRequest_FieldPathSelectorOsVersion:
				result.OsVersion = source.OsVersion
				wholeOsVersionAccepted = true
			case UpdateOsVersionRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateOsVersionRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			case UpdateOsVersionRequest_FieldPathSelectorAllowMissing:
				result.AllowMissing = source.AllowMissing
			}
		case *UpdateOsVersionRequest_FieldSubPath:
			switch tp.selector {
			case UpdateOsVersionRequest_FieldPathSelectorOsVersion:
				osVersionMask.AppendPath(tp.subPath.(os_version.OsVersion_FieldPath))
			case UpdateOsVersionRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateOsVersionRequestCAS_FieldPath))
			}
		}
	}
	if wholeOsVersionAccepted == false && len(osVersionMask.Paths) > 0 {
		result.OsVersion = osVersionMask.Project(source.GetOsVersion())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateOsVersionRequest))
}

func (fieldMask *UpdateOsVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateOsVersionRequest_CAS_FieldMask struct {
	Paths []UpdateOsVersionRequestCAS_FieldPath
}

func FullUpdateOsVersionRequest_CAS_FieldMask() *UpdateOsVersionRequest_CAS_FieldMask {
	res := &UpdateOsVersionRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateOsVersionRequestCAS_FieldTerminalPath{selector: UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateOsVersionRequestCAS_FieldTerminalPath{selector: UpdateOsVersionRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateOsVersionRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateOsVersionRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateOsVersionRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) Subtract(other *UpdateOsVersionRequest_CAS_FieldMask) *UpdateOsVersionRequest_CAS_FieldMask {
	result := &UpdateOsVersionRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateOsVersionRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState: &os_version.OsVersion_FieldMask{},
	}
	mySubMasks := map[UpdateOsVersionRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState: &os_version.OsVersion_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateOsVersionRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateOsVersionRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateOsVersionRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState] = os_version.FullOsVersion_FieldMask()
					}
				} else if tp, ok := path.(*UpdateOsVersionRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateOsVersionRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateOsVersionRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) FilterInputFields() *UpdateOsVersionRequest_CAS_FieldMask {
	result := &UpdateOsVersionRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateOsVersionRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range os_version.FullOsVersion_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateOsVersionRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateOsVersionRequestCAS_FieldSubPath); ok {
				selectedMask := &os_version.OsVersion_FieldMask{
					Paths: []os_version.OsVersion_FieldPath{sub.subPath.(os_version.OsVersion_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateOsVersionRequestCAS_FieldSubPath{selector: UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateOsVersionRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateOsVersionRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateOsVersionRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateOsVersionRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) AppendPath(path UpdateOsVersionRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateOsVersionRequestCAS_FieldPath))
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) GetPaths() []UpdateOsVersionRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateOsVersionRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) Set(target, source *UpdateOsVersionRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateOsVersionRequest_CAS), source.(*UpdateOsVersionRequest_CAS))
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) Project(source *UpdateOsVersionRequest_CAS) *UpdateOsVersionRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateOsVersionRequest_CAS{}
	conditionalStateMask := &os_version.OsVersion_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateOsVersionRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateOsVersionRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateOsVersionRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateOsVersionRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(os_version.OsVersion_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateOsVersionRequest_CAS))
}

func (fieldMask *UpdateOsVersionRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteOsVersionRequest_FieldMask struct {
	Paths []DeleteOsVersionRequest_FieldPath
}

func FullDeleteOsVersionRequest_FieldMask() *DeleteOsVersionRequest_FieldMask {
	res := &DeleteOsVersionRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteOsVersionRequest_FieldTerminalPath{selector: DeleteOsVersionRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteOsVersionRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteOsVersionRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteOsVersionRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteOsVersionRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteOsVersionRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) Subtract(other *DeleteOsVersionRequest_FieldMask) *DeleteOsVersionRequest_FieldMask {
	result := &DeleteOsVersionRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteOsVersionRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteOsVersionRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteOsVersionRequest_FieldMask) FilterInputFields() *DeleteOsVersionRequest_FieldMask {
	result := &DeleteOsVersionRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteOsVersionRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteOsVersionRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteOsVersionRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteOsVersionRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteOsVersionRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) AppendPath(path DeleteOsVersionRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteOsVersionRequest_FieldPath))
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) GetPaths() []DeleteOsVersionRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteOsVersionRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) Set(target, source *DeleteOsVersionRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteOsVersionRequest), source.(*DeleteOsVersionRequest))
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) Project(source *DeleteOsVersionRequest) *DeleteOsVersionRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteOsVersionRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteOsVersionRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteOsVersionRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteOsVersionRequest))
}

func (fieldMask *DeleteOsVersionRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
