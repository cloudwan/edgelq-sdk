// Code generated by protoc-gen-goten-object
// File: edgelq/devices/proto/v1alpha/broker_custom.proto
// DO NOT EDIT!!!

package broker_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	device "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha/device"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &device.Device{}
)

type ListenForConnectionsRequest_FieldMask struct {
	Paths []ListenForConnectionsRequest_FieldPath
}

func FullListenForConnectionsRequest_FieldMask() *ListenForConnectionsRequest_FieldMask {
	res := &ListenForConnectionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListenForConnectionsRequest_FieldTerminalPath{selector: ListenForConnectionsRequest_FieldPathSelectorRegisterListener})
	res.Paths = append(res.Paths, &ListenForConnectionsRequest_FieldTerminalPath{selector: ListenForConnectionsRequest_FieldPathSelectorChannelOpenError})
	res.Paths = append(res.Paths, &ListenForConnectionsRequest_FieldTerminalPath{selector: ListenForConnectionsRequest_FieldPathSelectorKeepAlive})
	return res
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenForConnectionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenForConnectionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenForConnectionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenForConnectionsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListenForConnectionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) Subtract(other *ListenForConnectionsRequest_FieldMask) *ListenForConnectionsRequest_FieldMask {
	result := &ListenForConnectionsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListenForConnectionsRequest_FieldPathSelector]gotenobject.FieldMask{
		ListenForConnectionsRequest_FieldPathSelectorRegisterListener: &ListenForConnectionsRequest_RegisterListener_FieldMask{},
		ListenForConnectionsRequest_FieldPathSelectorChannelOpenError: &ListenForConnectionsRequest_ChannelOpenError_FieldMask{},
		ListenForConnectionsRequest_FieldPathSelectorKeepAlive:        &ListenForConnectionsRequest_KeepAlive_FieldMask{},
	}
	mySubMasks := map[ListenForConnectionsRequest_FieldPathSelector]gotenobject.FieldMask{
		ListenForConnectionsRequest_FieldPathSelectorRegisterListener: &ListenForConnectionsRequest_RegisterListener_FieldMask{},
		ListenForConnectionsRequest_FieldPathSelectorChannelOpenError: &ListenForConnectionsRequest_ChannelOpenError_FieldMask{},
		ListenForConnectionsRequest_FieldPathSelectorKeepAlive:        &ListenForConnectionsRequest_KeepAlive_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenForConnectionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListenForConnectionsRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListenForConnectionsRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case ListenForConnectionsRequest_FieldPathSelectorRegisterListener:
						mySubMasks[ListenForConnectionsRequest_FieldPathSelectorRegisterListener] = FullListenForConnectionsRequest_RegisterListener_FieldMask()
					case ListenForConnectionsRequest_FieldPathSelectorChannelOpenError:
						mySubMasks[ListenForConnectionsRequest_FieldPathSelectorChannelOpenError] = FullListenForConnectionsRequest_ChannelOpenError_FieldMask()
					case ListenForConnectionsRequest_FieldPathSelectorKeepAlive:
						mySubMasks[ListenForConnectionsRequest_FieldPathSelectorKeepAlive] = FullListenForConnectionsRequest_KeepAlive_FieldMask()
					}
				} else if tp, ok := path.(*ListenForConnectionsRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListenForConnectionsRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenForConnectionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenForConnectionsRequest_FieldMask) FilterInputFields() *ListenForConnectionsRequest_FieldMask {
	result := &ListenForConnectionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenForConnectionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenForConnectionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenForConnectionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenForConnectionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenForConnectionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) AppendPath(path ListenForConnectionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenForConnectionsRequest_FieldPath))
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) GetPaths() []ListenForConnectionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenForConnectionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) Set(target, source *ListenForConnectionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenForConnectionsRequest), source.(*ListenForConnectionsRequest))
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) Project(source *ListenForConnectionsRequest) *ListenForConnectionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenForConnectionsRequest{}
	registerListenerMask := &ListenForConnectionsRequest_RegisterListener_FieldMask{}
	wholeRegisterListenerAccepted := false
	channelOpenErrorMask := &ListenForConnectionsRequest_ChannelOpenError_FieldMask{}
	wholeChannelOpenErrorAccepted := false
	keepAliveMask := &ListenForConnectionsRequest_KeepAlive_FieldMask{}
	wholeKeepAliveAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenForConnectionsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListenForConnectionsRequest_FieldPathSelectorRegisterListener:
				if source, ok := source.Msg.(*ListenForConnectionsRequest_RegisterListener_); ok {
					result.Msg = &ListenForConnectionsRequest_RegisterListener_{
						RegisterListener: source.RegisterListener,
					}
				}
				wholeRegisterListenerAccepted = true
			case ListenForConnectionsRequest_FieldPathSelectorChannelOpenError:
				if source, ok := source.Msg.(*ListenForConnectionsRequest_ChannelOpenError_); ok {
					result.Msg = &ListenForConnectionsRequest_ChannelOpenError_{
						ChannelOpenError: source.ChannelOpenError,
					}
				}
				wholeChannelOpenErrorAccepted = true
			case ListenForConnectionsRequest_FieldPathSelectorKeepAlive:
				if source, ok := source.Msg.(*ListenForConnectionsRequest_KeepAlive_); ok {
					result.Msg = &ListenForConnectionsRequest_KeepAlive_{
						KeepAlive: source.KeepAlive,
					}
				}
				wholeKeepAliveAccepted = true
			}
		case *ListenForConnectionsRequest_FieldSubPath:
			switch tp.selector {
			case ListenForConnectionsRequest_FieldPathSelectorRegisterListener:
				registerListenerMask.AppendPath(tp.subPath.(ListenForConnectionsRequestRegisterListener_FieldPath))
			case ListenForConnectionsRequest_FieldPathSelectorChannelOpenError:
				channelOpenErrorMask.AppendPath(tp.subPath.(ListenForConnectionsRequestChannelOpenError_FieldPath))
			case ListenForConnectionsRequest_FieldPathSelectorKeepAlive:
				keepAliveMask.AppendPath(tp.subPath.(ListenForConnectionsRequestKeepAlive_FieldPath))
			}
		}
	}
	if wholeRegisterListenerAccepted == false && len(registerListenerMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ListenForConnectionsRequest_RegisterListener_); ok {
			result.Msg = (*ListenForConnectionsRequest_RegisterListener_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenForConnectionsRequest_RegisterListener_{}
				oneOfRes.RegisterListener = registerListenerMask.Project(asOneOf.RegisterListener)
				result.Msg = oneOfRes
			}
		}
	}
	if wholeChannelOpenErrorAccepted == false && len(channelOpenErrorMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ListenForConnectionsRequest_ChannelOpenError_); ok {
			result.Msg = (*ListenForConnectionsRequest_ChannelOpenError_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenForConnectionsRequest_ChannelOpenError_{}
				oneOfRes.ChannelOpenError = channelOpenErrorMask.Project(asOneOf.ChannelOpenError)
				result.Msg = oneOfRes
			}
		}
	}
	if wholeKeepAliveAccepted == false && len(keepAliveMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ListenForConnectionsRequest_KeepAlive_); ok {
			result.Msg = (*ListenForConnectionsRequest_KeepAlive_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenForConnectionsRequest_KeepAlive_{}
				oneOfRes.KeepAlive = keepAliveMask.Project(asOneOf.KeepAlive)
				result.Msg = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenForConnectionsRequest))
}

func (fieldMask *ListenForConnectionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenForConnectionsRequest_RegisterListener_FieldMask struct {
	Paths []ListenForConnectionsRequestRegisterListener_FieldPath
}

func FullListenForConnectionsRequest_RegisterListener_FieldMask() *ListenForConnectionsRequest_RegisterListener_FieldMask {
	res := &ListenForConnectionsRequest_RegisterListener_FieldMask{}
	res.Paths = append(res.Paths, &ListenForConnectionsRequestRegisterListener_FieldTerminalPath{selector: ListenForConnectionsRequestRegisterListener_FieldPathSelectorDevice})
	return res
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenForConnectionsRequestRegisterListener_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenForConnectionsRequestRegisterListener_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenForConnectionsRequestRegisterListener_FieldPath(raw)
	})
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) ProtoMessage() {}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) Subtract(other *ListenForConnectionsRequest_RegisterListener_FieldMask) *ListenForConnectionsRequest_RegisterListener_FieldMask {
	result := &ListenForConnectionsRequest_RegisterListener_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenForConnectionsRequestRegisterListener_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenForConnectionsRequest_RegisterListener_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) FilterInputFields() *ListenForConnectionsRequest_RegisterListener_FieldMask {
	result := &ListenForConnectionsRequest_RegisterListener_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenForConnectionsRequestRegisterListener_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenForConnectionsRequestRegisterListener_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenForConnectionsRequest_RegisterListener_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenForConnectionsRequest_RegisterListener_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) AppendPath(path ListenForConnectionsRequestRegisterListener_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenForConnectionsRequestRegisterListener_FieldPath))
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) GetPaths() []ListenForConnectionsRequestRegisterListener_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenForConnectionsRequestRegisterListener_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) Set(target, source *ListenForConnectionsRequest_RegisterListener) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenForConnectionsRequest_RegisterListener), source.(*ListenForConnectionsRequest_RegisterListener))
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) Project(source *ListenForConnectionsRequest_RegisterListener) *ListenForConnectionsRequest_RegisterListener {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenForConnectionsRequest_RegisterListener{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenForConnectionsRequestRegisterListener_FieldTerminalPath:
			switch tp.selector {
			case ListenForConnectionsRequestRegisterListener_FieldPathSelectorDevice:
				result.Device = source.Device
			}
		}
	}
	return result
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenForConnectionsRequest_RegisterListener))
}

func (fieldMask *ListenForConnectionsRequest_RegisterListener_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenForConnectionsRequest_ChannelOpenError_FieldMask struct {
	Paths []ListenForConnectionsRequestChannelOpenError_FieldPath
}

func FullListenForConnectionsRequest_ChannelOpenError_FieldMask() *ListenForConnectionsRequest_ChannelOpenError_FieldMask {
	res := &ListenForConnectionsRequest_ChannelOpenError_FieldMask{}
	res.Paths = append(res.Paths, &ListenForConnectionsRequestChannelOpenError_FieldTerminalPath{selector: ListenForConnectionsRequestChannelOpenError_FieldPathSelectorChannel})
	res.Paths = append(res.Paths, &ListenForConnectionsRequestChannelOpenError_FieldTerminalPath{selector: ListenForConnectionsRequestChannelOpenError_FieldPathSelectorMessage})
	return res
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenForConnectionsRequestChannelOpenError_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenForConnectionsRequestChannelOpenError_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenForConnectionsRequestChannelOpenError_FieldPath(raw)
	})
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) ProtoMessage() {}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) Subtract(other *ListenForConnectionsRequest_ChannelOpenError_FieldMask) *ListenForConnectionsRequest_ChannelOpenError_FieldMask {
	result := &ListenForConnectionsRequest_ChannelOpenError_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenForConnectionsRequestChannelOpenError_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenForConnectionsRequest_ChannelOpenError_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) FilterInputFields() *ListenForConnectionsRequest_ChannelOpenError_FieldMask {
	result := &ListenForConnectionsRequest_ChannelOpenError_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenForConnectionsRequestChannelOpenError_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenForConnectionsRequestChannelOpenError_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenForConnectionsRequest_ChannelOpenError_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenForConnectionsRequest_ChannelOpenError_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) AppendPath(path ListenForConnectionsRequestChannelOpenError_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenForConnectionsRequestChannelOpenError_FieldPath))
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) GetPaths() []ListenForConnectionsRequestChannelOpenError_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenForConnectionsRequestChannelOpenError_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) Set(target, source *ListenForConnectionsRequest_ChannelOpenError) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenForConnectionsRequest_ChannelOpenError), source.(*ListenForConnectionsRequest_ChannelOpenError))
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) Project(source *ListenForConnectionsRequest_ChannelOpenError) *ListenForConnectionsRequest_ChannelOpenError {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenForConnectionsRequest_ChannelOpenError{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenForConnectionsRequestChannelOpenError_FieldTerminalPath:
			switch tp.selector {
			case ListenForConnectionsRequestChannelOpenError_FieldPathSelectorChannel:
				result.Channel = source.Channel
			case ListenForConnectionsRequestChannelOpenError_FieldPathSelectorMessage:
				result.Message = source.Message
			}
		}
	}
	return result
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenForConnectionsRequest_ChannelOpenError))
}

func (fieldMask *ListenForConnectionsRequest_ChannelOpenError_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenForConnectionsRequest_KeepAlive_FieldMask struct {
	Paths []ListenForConnectionsRequestKeepAlive_FieldPath
}

func FullListenForConnectionsRequest_KeepAlive_FieldMask() *ListenForConnectionsRequest_KeepAlive_FieldMask {
	res := &ListenForConnectionsRequest_KeepAlive_FieldMask{}
	return res
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenForConnectionsRequestKeepAlive_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenForConnectionsRequestKeepAlive_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenForConnectionsRequestKeepAlive_FieldPath(raw)
	})
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) ProtoMessage() {}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) Subtract(other *ListenForConnectionsRequest_KeepAlive_FieldMask) *ListenForConnectionsRequest_KeepAlive_FieldMask {
	result := &ListenForConnectionsRequest_KeepAlive_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenForConnectionsRequestKeepAlive_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenForConnectionsRequest_KeepAlive_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) FilterInputFields() *ListenForConnectionsRequest_KeepAlive_FieldMask {
	result := &ListenForConnectionsRequest_KeepAlive_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenForConnectionsRequestKeepAlive_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenForConnectionsRequestKeepAlive_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenForConnectionsRequest_KeepAlive_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenForConnectionsRequest_KeepAlive_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) AppendPath(path ListenForConnectionsRequestKeepAlive_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenForConnectionsRequestKeepAlive_FieldPath))
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) GetPaths() []ListenForConnectionsRequestKeepAlive_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenForConnectionsRequestKeepAlive_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) Set(target, source *ListenForConnectionsRequest_KeepAlive) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenForConnectionsRequest_KeepAlive), source.(*ListenForConnectionsRequest_KeepAlive))
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) Project(source *ListenForConnectionsRequest_KeepAlive) *ListenForConnectionsRequest_KeepAlive {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenForConnectionsRequest_KeepAlive{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenForConnectionsRequestKeepAlive_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenForConnectionsRequest_KeepAlive))
}

func (fieldMask *ListenForConnectionsRequest_KeepAlive_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenForConnectionsResponse_FieldMask struct {
	Paths []ListenForConnectionsResponse_FieldPath
}

func FullListenForConnectionsResponse_FieldMask() *ListenForConnectionsResponse_FieldMask {
	res := &ListenForConnectionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListenForConnectionsResponse_FieldTerminalPath{selector: ListenForConnectionsResponse_FieldPathSelectorChannelRequested})
	return res
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenForConnectionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenForConnectionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenForConnectionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenForConnectionsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListenForConnectionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) Subtract(other *ListenForConnectionsResponse_FieldMask) *ListenForConnectionsResponse_FieldMask {
	result := &ListenForConnectionsResponse_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[ListenForConnectionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListenForConnectionsResponse_FieldPathSelectorChannelRequested: &ListenForConnectionsResponse_ChannelRequested_FieldMask{},
	}
	mySubMasks := map[ListenForConnectionsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListenForConnectionsResponse_FieldPathSelectorChannelRequested: &ListenForConnectionsResponse_ChannelRequested_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenForConnectionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListenForConnectionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListenForConnectionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListenForConnectionsResponse_FieldPathSelectorChannelRequested:
						mySubMasks[ListenForConnectionsResponse_FieldPathSelectorChannelRequested] = FullListenForConnectionsResponse_ChannelRequested_FieldMask()
					}
				} else if tp, ok := path.(*ListenForConnectionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListenForConnectionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenForConnectionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenForConnectionsResponse_FieldMask) FilterInputFields() *ListenForConnectionsResponse_FieldMask {
	result := &ListenForConnectionsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenForConnectionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenForConnectionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenForConnectionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenForConnectionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenForConnectionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) AppendPath(path ListenForConnectionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenForConnectionsResponse_FieldPath))
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) GetPaths() []ListenForConnectionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenForConnectionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) Set(target, source *ListenForConnectionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenForConnectionsResponse), source.(*ListenForConnectionsResponse))
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) Project(source *ListenForConnectionsResponse) *ListenForConnectionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenForConnectionsResponse{}
	channelRequestedMask := &ListenForConnectionsResponse_ChannelRequested_FieldMask{}
	wholeChannelRequestedAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenForConnectionsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListenForConnectionsResponse_FieldPathSelectorChannelRequested:
				if source, ok := source.Msg.(*ListenForConnectionsResponse_ChannelRequested_); ok {
					result.Msg = &ListenForConnectionsResponse_ChannelRequested_{
						ChannelRequested: source.ChannelRequested,
					}
				}
				wholeChannelRequestedAccepted = true
			}
		case *ListenForConnectionsResponse_FieldSubPath:
			switch tp.selector {
			case ListenForConnectionsResponse_FieldPathSelectorChannelRequested:
				channelRequestedMask.AppendPath(tp.subPath.(ListenForConnectionsResponseChannelRequested_FieldPath))
			}
		}
	}
	if wholeChannelRequestedAccepted == false && len(channelRequestedMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ListenForConnectionsResponse_ChannelRequested_); ok {
			result.Msg = (*ListenForConnectionsResponse_ChannelRequested_)(nil)
			if asOneOf != nil {
				oneOfRes := &ListenForConnectionsResponse_ChannelRequested_{}
				oneOfRes.ChannelRequested = channelRequestedMask.Project(asOneOf.ChannelRequested)
				result.Msg = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenForConnectionsResponse))
}

func (fieldMask *ListenForConnectionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListenForConnectionsResponse_ChannelRequested_FieldMask struct {
	Paths []ListenForConnectionsResponseChannelRequested_FieldPath
}

func FullListenForConnectionsResponse_ChannelRequested_FieldMask() *ListenForConnectionsResponse_ChannelRequested_FieldMask {
	res := &ListenForConnectionsResponse_ChannelRequested_FieldMask{}
	res.Paths = append(res.Paths, &ListenForConnectionsResponseChannelRequested_FieldTerminalPath{selector: ListenForConnectionsResponseChannelRequested_FieldPathSelectorChannel})
	res.Paths = append(res.Paths, &ListenForConnectionsResponseChannelRequested_FieldTerminalPath{selector: ListenForConnectionsResponseChannelRequested_FieldPathSelectorService})
	res.Paths = append(res.Paths, &ListenForConnectionsResponseChannelRequested_FieldTerminalPath{selector: ListenForConnectionsResponseChannelRequested_FieldPathSelectorArg})
	return res
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListenForConnectionsResponseChannelRequested_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListenForConnectionsResponseChannelRequested_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListenForConnectionsResponseChannelRequested_FieldPath(raw)
	})
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) ProtoMessage() {}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) Subtract(other *ListenForConnectionsResponse_ChannelRequested_FieldMask) *ListenForConnectionsResponse_ChannelRequested_FieldMask {
	result := &ListenForConnectionsResponse_ChannelRequested_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListenForConnectionsResponseChannelRequested_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListenForConnectionsResponse_ChannelRequested_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) FilterInputFields() *ListenForConnectionsResponse_ChannelRequested_FieldMask {
	result := &ListenForConnectionsResponse_ChannelRequested_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListenForConnectionsResponseChannelRequested_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListenForConnectionsResponseChannelRequested_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListenForConnectionsResponse_ChannelRequested_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListenForConnectionsResponse_ChannelRequested_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) AppendPath(path ListenForConnectionsResponseChannelRequested_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListenForConnectionsResponseChannelRequested_FieldPath))
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) GetPaths() []ListenForConnectionsResponseChannelRequested_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListenForConnectionsResponseChannelRequested_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) Set(target, source *ListenForConnectionsResponse_ChannelRequested) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListenForConnectionsResponse_ChannelRequested), source.(*ListenForConnectionsResponse_ChannelRequested))
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) Project(source *ListenForConnectionsResponse_ChannelRequested) *ListenForConnectionsResponse_ChannelRequested {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListenForConnectionsResponse_ChannelRequested{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListenForConnectionsResponseChannelRequested_FieldTerminalPath:
			switch tp.selector {
			case ListenForConnectionsResponseChannelRequested_FieldPathSelectorChannel:
				result.Channel = source.Channel
			case ListenForConnectionsResponseChannelRequested_FieldPathSelectorService:
				result.Service = source.Service
			case ListenForConnectionsResponseChannelRequested_FieldPathSelectorArg:
				result.Arg = source.Arg
			}
		}
	}
	return result
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListenForConnectionsResponse_ChannelRequested))
}

func (fieldMask *ListenForConnectionsResponse_ChannelRequested_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type OpenConnectionChannelSocketRequest_FieldMask struct {
	Paths []OpenConnectionChannelSocketRequest_FieldPath
}

func FullOpenConnectionChannelSocketRequest_FieldMask() *OpenConnectionChannelSocketRequest_FieldMask {
	res := &OpenConnectionChannelSocketRequest_FieldMask{}
	res.Paths = append(res.Paths, &OpenConnectionChannelSocketRequest_FieldTerminalPath{selector: OpenConnectionChannelSocketRequest_FieldPathSelectorRegisterSocket})
	res.Paths = append(res.Paths, &OpenConnectionChannelSocketRequest_FieldTerminalPath{selector: OpenConnectionChannelSocketRequest_FieldPathSelectorData})
	res.Paths = append(res.Paths, &OpenConnectionChannelSocketRequest_FieldTerminalPath{selector: OpenConnectionChannelSocketRequest_FieldPathSelectorError})
	res.Paths = append(res.Paths, &OpenConnectionChannelSocketRequest_FieldTerminalPath{selector: OpenConnectionChannelSocketRequest_FieldPathSelectorAck})
	return res
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseOpenConnectionChannelSocketRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*OpenConnectionChannelSocketRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseOpenConnectionChannelSocketRequest_FieldPath(raw)
	})
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) ProtoMessage() {}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) Subtract(other *OpenConnectionChannelSocketRequest_FieldMask) *OpenConnectionChannelSocketRequest_FieldMask {
	result := &OpenConnectionChannelSocketRequest_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[OpenConnectionChannelSocketRequest_FieldPathSelector]gotenobject.FieldMask{
		OpenConnectionChannelSocketRequest_FieldPathSelectorRegisterSocket: &OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask{},
		OpenConnectionChannelSocketRequest_FieldPathSelectorAck:            &Ack_FieldMask{},
	}
	mySubMasks := map[OpenConnectionChannelSocketRequest_FieldPathSelector]gotenobject.FieldMask{
		OpenConnectionChannelSocketRequest_FieldPathSelectorRegisterSocket: &OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask{},
		OpenConnectionChannelSocketRequest_FieldPathSelectorAck:            &Ack_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *OpenConnectionChannelSocketRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *OpenConnectionChannelSocketRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*OpenConnectionChannelSocketRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case OpenConnectionChannelSocketRequest_FieldPathSelectorRegisterSocket:
						mySubMasks[OpenConnectionChannelSocketRequest_FieldPathSelectorRegisterSocket] = FullOpenConnectionChannelSocketRequest_RegisterSocket_FieldMask()
					case OpenConnectionChannelSocketRequest_FieldPathSelectorAck:
						mySubMasks[OpenConnectionChannelSocketRequest_FieldPathSelectorAck] = FullAck_FieldMask()
					}
				} else if tp, ok := path.(*OpenConnectionChannelSocketRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &OpenConnectionChannelSocketRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*OpenConnectionChannelSocketRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) FilterInputFields() *OpenConnectionChannelSocketRequest_FieldMask {
	result := &OpenConnectionChannelSocketRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]OpenConnectionChannelSocketRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseOpenConnectionChannelSocketRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask OpenConnectionChannelSocketRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask OpenConnectionChannelSocketRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) AppendPath(path OpenConnectionChannelSocketRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(OpenConnectionChannelSocketRequest_FieldPath))
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) GetPaths() []OpenConnectionChannelSocketRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseOpenConnectionChannelSocketRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) Set(target, source *OpenConnectionChannelSocketRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*OpenConnectionChannelSocketRequest), source.(*OpenConnectionChannelSocketRequest))
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) Project(source *OpenConnectionChannelSocketRequest) *OpenConnectionChannelSocketRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &OpenConnectionChannelSocketRequest{}
	registerSocketMask := &OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask{}
	wholeRegisterSocketAccepted := false
	ackMask := &Ack_FieldMask{}
	wholeAckAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *OpenConnectionChannelSocketRequest_FieldTerminalPath:
			switch tp.selector {
			case OpenConnectionChannelSocketRequest_FieldPathSelectorRegisterSocket:
				if source, ok := source.Msg.(*OpenConnectionChannelSocketRequest_RegisterSocket_); ok {
					result.Msg = &OpenConnectionChannelSocketRequest_RegisterSocket_{
						RegisterSocket: source.RegisterSocket,
					}
				}
				wholeRegisterSocketAccepted = true
			case OpenConnectionChannelSocketRequest_FieldPathSelectorData:
				if source, ok := source.Msg.(*OpenConnectionChannelSocketRequest_Data); ok {
					result.Msg = &OpenConnectionChannelSocketRequest_Data{
						Data: source.Data,
					}
				}
			case OpenConnectionChannelSocketRequest_FieldPathSelectorError:
				if source, ok := source.Msg.(*OpenConnectionChannelSocketRequest_Error); ok {
					result.Msg = &OpenConnectionChannelSocketRequest_Error{
						Error: source.Error,
					}
				}
			case OpenConnectionChannelSocketRequest_FieldPathSelectorAck:
				if source, ok := source.Msg.(*OpenConnectionChannelSocketRequest_Ack); ok {
					result.Msg = &OpenConnectionChannelSocketRequest_Ack{
						Ack: source.Ack,
					}
				}
				wholeAckAccepted = true
			}
		case *OpenConnectionChannelSocketRequest_FieldSubPath:
			switch tp.selector {
			case OpenConnectionChannelSocketRequest_FieldPathSelectorRegisterSocket:
				registerSocketMask.AppendPath(tp.subPath.(OpenConnectionChannelSocketRequestRegisterSocket_FieldPath))
			case OpenConnectionChannelSocketRequest_FieldPathSelectorAck:
				ackMask.AppendPath(tp.subPath.(Ack_FieldPath))
			}
		}
	}
	if wholeRegisterSocketAccepted == false && len(registerSocketMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*OpenConnectionChannelSocketRequest_RegisterSocket_); ok {
			result.Msg = (*OpenConnectionChannelSocketRequest_RegisterSocket_)(nil)
			if asOneOf != nil {
				oneOfRes := &OpenConnectionChannelSocketRequest_RegisterSocket_{}
				oneOfRes.RegisterSocket = registerSocketMask.Project(asOneOf.RegisterSocket)
				result.Msg = oneOfRes
			}
		}
	}
	if wholeAckAccepted == false && len(ackMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*OpenConnectionChannelSocketRequest_Ack); ok {
			result.Msg = (*OpenConnectionChannelSocketRequest_Ack)(nil)
			if asOneOf != nil {
				oneOfRes := &OpenConnectionChannelSocketRequest_Ack{}
				oneOfRes.Ack = ackMask.Project(asOneOf.Ack)
				result.Msg = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*OpenConnectionChannelSocketRequest))
}

func (fieldMask *OpenConnectionChannelSocketRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask struct {
	Paths []OpenConnectionChannelSocketRequestRegisterSocket_FieldPath
}

func FullOpenConnectionChannelSocketRequest_RegisterSocket_FieldMask() *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask {
	res := &OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask{}
	res.Paths = append(res.Paths, &OpenConnectionChannelSocketRequestRegisterSocket_FieldTerminalPath{selector: OpenConnectionChannelSocketRequestRegisterSocket_FieldPathSelectorDevice})
	res.Paths = append(res.Paths, &OpenConnectionChannelSocketRequestRegisterSocket_FieldTerminalPath{selector: OpenConnectionChannelSocketRequestRegisterSocket_FieldPathSelectorChannel})
	return res
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseOpenConnectionChannelSocketRequestRegisterSocket_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*OpenConnectionChannelSocketRequestRegisterSocket_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseOpenConnectionChannelSocketRequestRegisterSocket_FieldPath(raw)
	})
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) ProtoMessage() {}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) Subtract(other *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask {
	result := &OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *OpenConnectionChannelSocketRequestRegisterSocket_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) FilterInputFields() *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask {
	result := &OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]OpenConnectionChannelSocketRequestRegisterSocket_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseOpenConnectionChannelSocketRequestRegisterSocket_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) AppendPath(path OpenConnectionChannelSocketRequestRegisterSocket_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(OpenConnectionChannelSocketRequestRegisterSocket_FieldPath))
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) GetPaths() []OpenConnectionChannelSocketRequestRegisterSocket_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseOpenConnectionChannelSocketRequestRegisterSocket_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) Set(target, source *OpenConnectionChannelSocketRequest_RegisterSocket) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*OpenConnectionChannelSocketRequest_RegisterSocket), source.(*OpenConnectionChannelSocketRequest_RegisterSocket))
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) Project(source *OpenConnectionChannelSocketRequest_RegisterSocket) *OpenConnectionChannelSocketRequest_RegisterSocket {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &OpenConnectionChannelSocketRequest_RegisterSocket{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *OpenConnectionChannelSocketRequestRegisterSocket_FieldTerminalPath:
			switch tp.selector {
			case OpenConnectionChannelSocketRequestRegisterSocket_FieldPathSelectorDevice:
				result.Device = source.Device
			case OpenConnectionChannelSocketRequestRegisterSocket_FieldPathSelectorChannel:
				result.Channel = source.Channel
			}
		}
	}
	return result
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*OpenConnectionChannelSocketRequest_RegisterSocket))
}

func (fieldMask *OpenConnectionChannelSocketRequest_RegisterSocket_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type OpenConnectionChannelSocketResponse_FieldMask struct {
	Paths []OpenConnectionChannelSocketResponse_FieldPath
}

func FullOpenConnectionChannelSocketResponse_FieldMask() *OpenConnectionChannelSocketResponse_FieldMask {
	res := &OpenConnectionChannelSocketResponse_FieldMask{}
	res.Paths = append(res.Paths, &OpenConnectionChannelSocketResponse_FieldTerminalPath{selector: OpenConnectionChannelSocketResponse_FieldPathSelectorData})
	res.Paths = append(res.Paths, &OpenConnectionChannelSocketResponse_FieldTerminalPath{selector: OpenConnectionChannelSocketResponse_FieldPathSelectorAck})
	return res
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseOpenConnectionChannelSocketResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*OpenConnectionChannelSocketResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseOpenConnectionChannelSocketResponse_FieldPath(raw)
	})
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) ProtoMessage() {}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) Subtract(other *OpenConnectionChannelSocketResponse_FieldMask) *OpenConnectionChannelSocketResponse_FieldMask {
	result := &OpenConnectionChannelSocketResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[OpenConnectionChannelSocketResponse_FieldPathSelector]gotenobject.FieldMask{
		OpenConnectionChannelSocketResponse_FieldPathSelectorAck: &Ack_FieldMask{},
	}
	mySubMasks := map[OpenConnectionChannelSocketResponse_FieldPathSelector]gotenobject.FieldMask{
		OpenConnectionChannelSocketResponse_FieldPathSelectorAck: &Ack_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *OpenConnectionChannelSocketResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *OpenConnectionChannelSocketResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*OpenConnectionChannelSocketResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case OpenConnectionChannelSocketResponse_FieldPathSelectorAck:
						mySubMasks[OpenConnectionChannelSocketResponse_FieldPathSelectorAck] = FullAck_FieldMask()
					}
				} else if tp, ok := path.(*OpenConnectionChannelSocketResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &OpenConnectionChannelSocketResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*OpenConnectionChannelSocketResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) FilterInputFields() *OpenConnectionChannelSocketResponse_FieldMask {
	result := &OpenConnectionChannelSocketResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]OpenConnectionChannelSocketResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseOpenConnectionChannelSocketResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask OpenConnectionChannelSocketResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask OpenConnectionChannelSocketResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) AppendPath(path OpenConnectionChannelSocketResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(OpenConnectionChannelSocketResponse_FieldPath))
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) GetPaths() []OpenConnectionChannelSocketResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseOpenConnectionChannelSocketResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) Set(target, source *OpenConnectionChannelSocketResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*OpenConnectionChannelSocketResponse), source.(*OpenConnectionChannelSocketResponse))
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) Project(source *OpenConnectionChannelSocketResponse) *OpenConnectionChannelSocketResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &OpenConnectionChannelSocketResponse{}
	ackMask := &Ack_FieldMask{}
	wholeAckAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *OpenConnectionChannelSocketResponse_FieldTerminalPath:
			switch tp.selector {
			case OpenConnectionChannelSocketResponse_FieldPathSelectorData:
				if source, ok := source.Msg.(*OpenConnectionChannelSocketResponse_Data); ok {
					result.Msg = &OpenConnectionChannelSocketResponse_Data{
						Data: source.Data,
					}
				}
			case OpenConnectionChannelSocketResponse_FieldPathSelectorAck:
				if source, ok := source.Msg.(*OpenConnectionChannelSocketResponse_Ack); ok {
					result.Msg = &OpenConnectionChannelSocketResponse_Ack{
						Ack: source.Ack,
					}
				}
				wholeAckAccepted = true
			}
		case *OpenConnectionChannelSocketResponse_FieldSubPath:
			switch tp.selector {
			case OpenConnectionChannelSocketResponse_FieldPathSelectorAck:
				ackMask.AppendPath(tp.subPath.(Ack_FieldPath))
			}
		}
	}
	if wholeAckAccepted == false && len(ackMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*OpenConnectionChannelSocketResponse_Ack); ok {
			result.Msg = (*OpenConnectionChannelSocketResponse_Ack)(nil)
			if asOneOf != nil {
				oneOfRes := &OpenConnectionChannelSocketResponse_Ack{}
				oneOfRes.Ack = ackMask.Project(asOneOf.Ack)
				result.Msg = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*OpenConnectionChannelSocketResponse))
}

func (fieldMask *OpenConnectionChannelSocketResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectToDeviceRequest_FieldMask struct {
	Paths []ConnectToDeviceRequest_FieldPath
}

func FullConnectToDeviceRequest_FieldMask() *ConnectToDeviceRequest_FieldMask {
	res := &ConnectToDeviceRequest_FieldMask{}
	res.Paths = append(res.Paths, &ConnectToDeviceRequest_FieldTerminalPath{selector: ConnectToDeviceRequest_FieldPathSelectorOpenRequest})
	res.Paths = append(res.Paths, &ConnectToDeviceRequest_FieldTerminalPath{selector: ConnectToDeviceRequest_FieldPathSelectorData})
	res.Paths = append(res.Paths, &ConnectToDeviceRequest_FieldTerminalPath{selector: ConnectToDeviceRequest_FieldPathSelectorAck})
	res.Paths = append(res.Paths, &ConnectToDeviceRequest_FieldTerminalPath{selector: ConnectToDeviceRequest_FieldPathSelectorKeepAlive})
	return res
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectToDeviceRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectToDeviceRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectToDeviceRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectToDeviceRequest_FieldPath(raw)
	})
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectToDeviceRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) Subtract(other *ConnectToDeviceRequest_FieldMask) *ConnectToDeviceRequest_FieldMask {
	result := &ConnectToDeviceRequest_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[ConnectToDeviceRequest_FieldPathSelector]gotenobject.FieldMask{
		ConnectToDeviceRequest_FieldPathSelectorOpenRequest: &ConnectToDeviceRequest_OpenRequest_FieldMask{},
		ConnectToDeviceRequest_FieldPathSelectorAck:         &Ack_FieldMask{},
		ConnectToDeviceRequest_FieldPathSelectorKeepAlive:   &ConnectToDeviceRequest_KeepAlive_FieldMask{},
	}
	mySubMasks := map[ConnectToDeviceRequest_FieldPathSelector]gotenobject.FieldMask{
		ConnectToDeviceRequest_FieldPathSelectorOpenRequest: &ConnectToDeviceRequest_OpenRequest_FieldMask{},
		ConnectToDeviceRequest_FieldPathSelectorAck:         &Ack_FieldMask{},
		ConnectToDeviceRequest_FieldPathSelectorKeepAlive:   &ConnectToDeviceRequest_KeepAlive_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectToDeviceRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConnectToDeviceRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConnectToDeviceRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case ConnectToDeviceRequest_FieldPathSelectorOpenRequest:
						mySubMasks[ConnectToDeviceRequest_FieldPathSelectorOpenRequest] = FullConnectToDeviceRequest_OpenRequest_FieldMask()
					case ConnectToDeviceRequest_FieldPathSelectorAck:
						mySubMasks[ConnectToDeviceRequest_FieldPathSelectorAck] = FullAck_FieldMask()
					case ConnectToDeviceRequest_FieldPathSelectorKeepAlive:
						mySubMasks[ConnectToDeviceRequest_FieldPathSelectorKeepAlive] = FullConnectToDeviceRequest_KeepAlive_FieldMask()
					}
				} else if tp, ok := path.(*ConnectToDeviceRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConnectToDeviceRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectToDeviceRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectToDeviceRequest_FieldMask) FilterInputFields() *ConnectToDeviceRequest_FieldMask {
	result := &ConnectToDeviceRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectToDeviceRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectToDeviceRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectToDeviceRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectToDeviceRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectToDeviceRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) AppendPath(path ConnectToDeviceRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectToDeviceRequest_FieldPath))
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) GetPaths() []ConnectToDeviceRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectToDeviceRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) Set(target, source *ConnectToDeviceRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectToDeviceRequest), source.(*ConnectToDeviceRequest))
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) Project(source *ConnectToDeviceRequest) *ConnectToDeviceRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectToDeviceRequest{}
	openRequestMask := &ConnectToDeviceRequest_OpenRequest_FieldMask{}
	wholeOpenRequestAccepted := false
	ackMask := &Ack_FieldMask{}
	wholeAckAccepted := false
	keepAliveMask := &ConnectToDeviceRequest_KeepAlive_FieldMask{}
	wholeKeepAliveAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectToDeviceRequest_FieldTerminalPath:
			switch tp.selector {
			case ConnectToDeviceRequest_FieldPathSelectorOpenRequest:
				if source, ok := source.Msg.(*ConnectToDeviceRequest_OpenRequest_); ok {
					result.Msg = &ConnectToDeviceRequest_OpenRequest_{
						OpenRequest: source.OpenRequest,
					}
				}
				wholeOpenRequestAccepted = true
			case ConnectToDeviceRequest_FieldPathSelectorData:
				if source, ok := source.Msg.(*ConnectToDeviceRequest_Data); ok {
					result.Msg = &ConnectToDeviceRequest_Data{
						Data: source.Data,
					}
				}
			case ConnectToDeviceRequest_FieldPathSelectorAck:
				if source, ok := source.Msg.(*ConnectToDeviceRequest_Ack); ok {
					result.Msg = &ConnectToDeviceRequest_Ack{
						Ack: source.Ack,
					}
				}
				wholeAckAccepted = true
			case ConnectToDeviceRequest_FieldPathSelectorKeepAlive:
				if source, ok := source.Msg.(*ConnectToDeviceRequest_KeepAlive_); ok {
					result.Msg = &ConnectToDeviceRequest_KeepAlive_{
						KeepAlive: source.KeepAlive,
					}
				}
				wholeKeepAliveAccepted = true
			}
		case *ConnectToDeviceRequest_FieldSubPath:
			switch tp.selector {
			case ConnectToDeviceRequest_FieldPathSelectorOpenRequest:
				openRequestMask.AppendPath(tp.subPath.(ConnectToDeviceRequestOpenRequest_FieldPath))
			case ConnectToDeviceRequest_FieldPathSelectorAck:
				ackMask.AppendPath(tp.subPath.(Ack_FieldPath))
			case ConnectToDeviceRequest_FieldPathSelectorKeepAlive:
				keepAliveMask.AppendPath(tp.subPath.(ConnectToDeviceRequestKeepAlive_FieldPath))
			}
		}
	}
	if wholeOpenRequestAccepted == false && len(openRequestMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ConnectToDeviceRequest_OpenRequest_); ok {
			result.Msg = (*ConnectToDeviceRequest_OpenRequest_)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectToDeviceRequest_OpenRequest_{}
				oneOfRes.OpenRequest = openRequestMask.Project(asOneOf.OpenRequest)
				result.Msg = oneOfRes
			}
		}
	}
	if wholeAckAccepted == false && len(ackMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ConnectToDeviceRequest_Ack); ok {
			result.Msg = (*ConnectToDeviceRequest_Ack)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectToDeviceRequest_Ack{}
				oneOfRes.Ack = ackMask.Project(asOneOf.Ack)
				result.Msg = oneOfRes
			}
		}
	}
	if wholeKeepAliveAccepted == false && len(keepAliveMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ConnectToDeviceRequest_KeepAlive_); ok {
			result.Msg = (*ConnectToDeviceRequest_KeepAlive_)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectToDeviceRequest_KeepAlive_{}
				oneOfRes.KeepAlive = keepAliveMask.Project(asOneOf.KeepAlive)
				result.Msg = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectToDeviceRequest))
}

func (fieldMask *ConnectToDeviceRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectToDeviceRequest_OpenRequest_FieldMask struct {
	Paths []ConnectToDeviceRequestOpenRequest_FieldPath
}

func FullConnectToDeviceRequest_OpenRequest_FieldMask() *ConnectToDeviceRequest_OpenRequest_FieldMask {
	res := &ConnectToDeviceRequest_OpenRequest_FieldMask{}
	res.Paths = append(res.Paths, &ConnectToDeviceRequestOpenRequest_FieldTerminalPath{selector: ConnectToDeviceRequestOpenRequest_FieldPathSelectorDevice})
	res.Paths = append(res.Paths, &ConnectToDeviceRequestOpenRequest_FieldTerminalPath{selector: ConnectToDeviceRequestOpenRequest_FieldPathSelectorService})
	res.Paths = append(res.Paths, &ConnectToDeviceRequestOpenRequest_FieldTerminalPath{selector: ConnectToDeviceRequestOpenRequest_FieldPathSelectorArg})
	return res
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectToDeviceRequestOpenRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectToDeviceRequestOpenRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectToDeviceRequestOpenRequest_FieldPath(raw)
	})
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) Subtract(other *ConnectToDeviceRequest_OpenRequest_FieldMask) *ConnectToDeviceRequest_OpenRequest_FieldMask {
	result := &ConnectToDeviceRequest_OpenRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectToDeviceRequestOpenRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectToDeviceRequest_OpenRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) FilterInputFields() *ConnectToDeviceRequest_OpenRequest_FieldMask {
	result := &ConnectToDeviceRequest_OpenRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectToDeviceRequestOpenRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectToDeviceRequestOpenRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectToDeviceRequest_OpenRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectToDeviceRequest_OpenRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) AppendPath(path ConnectToDeviceRequestOpenRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectToDeviceRequestOpenRequest_FieldPath))
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) GetPaths() []ConnectToDeviceRequestOpenRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectToDeviceRequestOpenRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) Set(target, source *ConnectToDeviceRequest_OpenRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectToDeviceRequest_OpenRequest), source.(*ConnectToDeviceRequest_OpenRequest))
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) Project(source *ConnectToDeviceRequest_OpenRequest) *ConnectToDeviceRequest_OpenRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectToDeviceRequest_OpenRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectToDeviceRequestOpenRequest_FieldTerminalPath:
			switch tp.selector {
			case ConnectToDeviceRequestOpenRequest_FieldPathSelectorDevice:
				result.Device = source.Device
			case ConnectToDeviceRequestOpenRequest_FieldPathSelectorService:
				result.Service = source.Service
			case ConnectToDeviceRequestOpenRequest_FieldPathSelectorArg:
				result.Arg = source.Arg
			}
		}
	}
	return result
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectToDeviceRequest_OpenRequest))
}

func (fieldMask *ConnectToDeviceRequest_OpenRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectToDeviceRequest_KeepAlive_FieldMask struct {
	Paths []ConnectToDeviceRequestKeepAlive_FieldPath
}

func FullConnectToDeviceRequest_KeepAlive_FieldMask() *ConnectToDeviceRequest_KeepAlive_FieldMask {
	res := &ConnectToDeviceRequest_KeepAlive_FieldMask{}
	return res
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectToDeviceRequestKeepAlive_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectToDeviceRequestKeepAlive_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectToDeviceRequestKeepAlive_FieldPath(raw)
	})
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) Subtract(other *ConnectToDeviceRequest_KeepAlive_FieldMask) *ConnectToDeviceRequest_KeepAlive_FieldMask {
	result := &ConnectToDeviceRequest_KeepAlive_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectToDeviceRequestKeepAlive_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectToDeviceRequest_KeepAlive_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) FilterInputFields() *ConnectToDeviceRequest_KeepAlive_FieldMask {
	result := &ConnectToDeviceRequest_KeepAlive_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectToDeviceRequestKeepAlive_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectToDeviceRequestKeepAlive_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectToDeviceRequest_KeepAlive_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectToDeviceRequest_KeepAlive_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) AppendPath(path ConnectToDeviceRequestKeepAlive_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectToDeviceRequestKeepAlive_FieldPath))
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) GetPaths() []ConnectToDeviceRequestKeepAlive_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectToDeviceRequestKeepAlive_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) Set(target, source *ConnectToDeviceRequest_KeepAlive) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectToDeviceRequest_KeepAlive), source.(*ConnectToDeviceRequest_KeepAlive))
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) Project(source *ConnectToDeviceRequest_KeepAlive) *ConnectToDeviceRequest_KeepAlive {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectToDeviceRequest_KeepAlive{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectToDeviceRequestKeepAlive_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectToDeviceRequest_KeepAlive))
}

func (fieldMask *ConnectToDeviceRequest_KeepAlive_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectToDeviceResponse_FieldMask struct {
	Paths []ConnectToDeviceResponse_FieldPath
}

func FullConnectToDeviceResponse_FieldMask() *ConnectToDeviceResponse_FieldMask {
	res := &ConnectToDeviceResponse_FieldMask{}
	res.Paths = append(res.Paths, &ConnectToDeviceResponse_FieldTerminalPath{selector: ConnectToDeviceResponse_FieldPathSelectorOpenResponse})
	res.Paths = append(res.Paths, &ConnectToDeviceResponse_FieldTerminalPath{selector: ConnectToDeviceResponse_FieldPathSelectorData})
	res.Paths = append(res.Paths, &ConnectToDeviceResponse_FieldTerminalPath{selector: ConnectToDeviceResponse_FieldPathSelectorError})
	res.Paths = append(res.Paths, &ConnectToDeviceResponse_FieldTerminalPath{selector: ConnectToDeviceResponse_FieldPathSelectorAck})
	return res
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectToDeviceResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectToDeviceResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectToDeviceResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectToDeviceResponse_FieldPath(raw)
	})
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectToDeviceResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) Subtract(other *ConnectToDeviceResponse_FieldMask) *ConnectToDeviceResponse_FieldMask {
	result := &ConnectToDeviceResponse_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[ConnectToDeviceResponse_FieldPathSelector]gotenobject.FieldMask{
		ConnectToDeviceResponse_FieldPathSelectorOpenResponse: &ConnectToDeviceResponse_OpenResponse_FieldMask{},
		ConnectToDeviceResponse_FieldPathSelectorAck:          &Ack_FieldMask{},
	}
	mySubMasks := map[ConnectToDeviceResponse_FieldPathSelector]gotenobject.FieldMask{
		ConnectToDeviceResponse_FieldPathSelectorOpenResponse: &ConnectToDeviceResponse_OpenResponse_FieldMask{},
		ConnectToDeviceResponse_FieldPathSelectorAck:          &Ack_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectToDeviceResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConnectToDeviceResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConnectToDeviceResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ConnectToDeviceResponse_FieldPathSelectorOpenResponse:
						mySubMasks[ConnectToDeviceResponse_FieldPathSelectorOpenResponse] = FullConnectToDeviceResponse_OpenResponse_FieldMask()
					case ConnectToDeviceResponse_FieldPathSelectorAck:
						mySubMasks[ConnectToDeviceResponse_FieldPathSelectorAck] = FullAck_FieldMask()
					}
				} else if tp, ok := path.(*ConnectToDeviceResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConnectToDeviceResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectToDeviceResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectToDeviceResponse_FieldMask) FilterInputFields() *ConnectToDeviceResponse_FieldMask {
	result := &ConnectToDeviceResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectToDeviceResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectToDeviceResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectToDeviceResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectToDeviceResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectToDeviceResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) AppendPath(path ConnectToDeviceResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectToDeviceResponse_FieldPath))
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) GetPaths() []ConnectToDeviceResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectToDeviceResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) Set(target, source *ConnectToDeviceResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectToDeviceResponse), source.(*ConnectToDeviceResponse))
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) Project(source *ConnectToDeviceResponse) *ConnectToDeviceResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectToDeviceResponse{}
	openResponseMask := &ConnectToDeviceResponse_OpenResponse_FieldMask{}
	wholeOpenResponseAccepted := false
	ackMask := &Ack_FieldMask{}
	wholeAckAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectToDeviceResponse_FieldTerminalPath:
			switch tp.selector {
			case ConnectToDeviceResponse_FieldPathSelectorOpenResponse:
				if source, ok := source.Msg.(*ConnectToDeviceResponse_OpenResponse_); ok {
					result.Msg = &ConnectToDeviceResponse_OpenResponse_{
						OpenResponse: source.OpenResponse,
					}
				}
				wholeOpenResponseAccepted = true
			case ConnectToDeviceResponse_FieldPathSelectorData:
				if source, ok := source.Msg.(*ConnectToDeviceResponse_Data); ok {
					result.Msg = &ConnectToDeviceResponse_Data{
						Data: source.Data,
					}
				}
			case ConnectToDeviceResponse_FieldPathSelectorError:
				if source, ok := source.Msg.(*ConnectToDeviceResponse_Error); ok {
					result.Msg = &ConnectToDeviceResponse_Error{
						Error: source.Error,
					}
				}
			case ConnectToDeviceResponse_FieldPathSelectorAck:
				if source, ok := source.Msg.(*ConnectToDeviceResponse_Ack); ok {
					result.Msg = &ConnectToDeviceResponse_Ack{
						Ack: source.Ack,
					}
				}
				wholeAckAccepted = true
			}
		case *ConnectToDeviceResponse_FieldSubPath:
			switch tp.selector {
			case ConnectToDeviceResponse_FieldPathSelectorOpenResponse:
				openResponseMask.AppendPath(tp.subPath.(ConnectToDeviceResponseOpenResponse_FieldPath))
			case ConnectToDeviceResponse_FieldPathSelectorAck:
				ackMask.AppendPath(tp.subPath.(Ack_FieldPath))
			}
		}
	}
	if wholeOpenResponseAccepted == false && len(openResponseMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ConnectToDeviceResponse_OpenResponse_); ok {
			result.Msg = (*ConnectToDeviceResponse_OpenResponse_)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectToDeviceResponse_OpenResponse_{}
				oneOfRes.OpenResponse = openResponseMask.Project(asOneOf.OpenResponse)
				result.Msg = oneOfRes
			}
		}
	}
	if wholeAckAccepted == false && len(ackMask.Paths) > 0 {
		if asOneOf, ok := source.Msg.(*ConnectToDeviceResponse_Ack); ok {
			result.Msg = (*ConnectToDeviceResponse_Ack)(nil)
			if asOneOf != nil {
				oneOfRes := &ConnectToDeviceResponse_Ack{}
				oneOfRes.Ack = ackMask.Project(asOneOf.Ack)
				result.Msg = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectToDeviceResponse))
}

func (fieldMask *ConnectToDeviceResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConnectToDeviceResponse_OpenResponse_FieldMask struct {
	Paths []ConnectToDeviceResponseOpenResponse_FieldPath
}

func FullConnectToDeviceResponse_OpenResponse_FieldMask() *ConnectToDeviceResponse_OpenResponse_FieldMask {
	res := &ConnectToDeviceResponse_OpenResponse_FieldMask{}
	return res
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConnectToDeviceResponseOpenResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConnectToDeviceResponseOpenResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConnectToDeviceResponseOpenResponse_FieldPath(raw)
	})
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) Subtract(other *ConnectToDeviceResponse_OpenResponse_FieldMask) *ConnectToDeviceResponse_OpenResponse_FieldMask {
	result := &ConnectToDeviceResponse_OpenResponse_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConnectToDeviceResponseOpenResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConnectToDeviceResponse_OpenResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) FilterInputFields() *ConnectToDeviceResponse_OpenResponse_FieldMask {
	result := &ConnectToDeviceResponse_OpenResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConnectToDeviceResponseOpenResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConnectToDeviceResponseOpenResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConnectToDeviceResponse_OpenResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConnectToDeviceResponse_OpenResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) AppendPath(path ConnectToDeviceResponseOpenResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConnectToDeviceResponseOpenResponse_FieldPath))
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) GetPaths() []ConnectToDeviceResponseOpenResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConnectToDeviceResponseOpenResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) Set(target, source *ConnectToDeviceResponse_OpenResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConnectToDeviceResponse_OpenResponse), source.(*ConnectToDeviceResponse_OpenResponse))
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) Project(source *ConnectToDeviceResponse_OpenResponse) *ConnectToDeviceResponse_OpenResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConnectToDeviceResponse_OpenResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConnectToDeviceResponseOpenResponse_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConnectToDeviceResponse_OpenResponse))
}

func (fieldMask *ConnectToDeviceResponse_OpenResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Ack_FieldMask struct {
	Paths []Ack_FieldPath
}

func FullAck_FieldMask() *Ack_FieldMask {
	res := &Ack_FieldMask{}
	res.Paths = append(res.Paths, &Ack_FieldTerminalPath{selector: Ack_FieldPathSelectorProcessed})
	return res
}

func (fieldMask *Ack_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Ack_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Ack_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseAck_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Ack_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Ack_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Ack_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAck_FieldPath(raw)
	})
}

func (fieldMask *Ack_FieldMask) ProtoMessage() {}

func (fieldMask *Ack_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Ack_FieldMask) Subtract(other *Ack_FieldMask) *Ack_FieldMask {
	result := &Ack_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Ack_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Ack_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Ack_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Ack_FieldMask) FilterInputFields() *Ack_FieldMask {
	result := &Ack_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Ack_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Ack_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Ack_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAck_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Ack_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Ack_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Ack_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Ack_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Ack_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Ack_FieldMask) AppendPath(path Ack_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Ack_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Ack_FieldPath))
}

func (fieldMask *Ack_FieldMask) GetPaths() []Ack_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Ack_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Ack_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAck_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Ack_FieldMask) Set(target, source *Ack) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Ack_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Ack), source.(*Ack))
}

func (fieldMask *Ack_FieldMask) Project(source *Ack) *Ack {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Ack{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Ack_FieldTerminalPath:
			switch tp.selector {
			case Ack_FieldPathSelectorProcessed:
				result.Processed = source.Processed
			}
		}
	}
	return result
}

func (fieldMask *Ack_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Ack))
}

func (fieldMask *Ack_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
