// Code generated by protoc-gen-goten-object
// File: edgelq/devices/proto/v1alpha/provisioning_policy_service.proto
// DO NOT EDIT!!!

package provisioning_policy_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	project "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha/project"
	provisioning_policy "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha/provisioning_policy"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &project.Project{}
	_ = &provisioning_policy.ProvisioningPolicy{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetProvisioningPolicyRequest_FieldMask struct {
	Paths []GetProvisioningPolicyRequest_FieldPath
}

func FullGetProvisioningPolicyRequest_FieldMask() *GetProvisioningPolicyRequest_FieldMask {
	res := &GetProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetProvisioningPolicyRequest_FieldTerminalPath{selector: GetProvisioningPolicyRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetProvisioningPolicyRequest_FieldTerminalPath{selector: GetProvisioningPolicyRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetProvisioningPolicyRequest_FieldTerminalPath{selector: GetProvisioningPolicyRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Subtract(other *GetProvisioningPolicyRequest_FieldMask) *GetProvisioningPolicyRequest_FieldMask {
	result := &GetProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetProvisioningPolicyRequest_FieldMask) FilterInputFields() *GetProvisioningPolicyRequest_FieldMask {
	result := &GetProvisioningPolicyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) AppendPath(path GetProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) GetPaths() []GetProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Set(target, source *GetProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetProvisioningPolicyRequest), source.(*GetProvisioningPolicyRequest))
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) Project(source *GetProvisioningPolicyRequest) *GetProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetProvisioningPolicyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case GetProvisioningPolicyRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetProvisioningPolicyRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetProvisioningPolicyRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetProvisioningPolicyRequest))
}

func (fieldMask *GetProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProvisioningPolicysRequest_FieldMask struct {
	Paths []BatchGetProvisioningPolicysRequest_FieldPath
}

func FullBatchGetProvisioningPolicysRequest_FieldMask() *BatchGetProvisioningPolicysRequest_FieldMask {
	res := &BatchGetProvisioningPolicysRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProvisioningPolicysRequest_FieldTerminalPath{selector: BatchGetProvisioningPolicysRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetProvisioningPolicysRequest_FieldTerminalPath{selector: BatchGetProvisioningPolicysRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetProvisioningPolicysRequest_FieldTerminalPath{selector: BatchGetProvisioningPolicysRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProvisioningPolicysRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProvisioningPolicysRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProvisioningPolicysRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) Subtract(other *BatchGetProvisioningPolicysRequest_FieldMask) *BatchGetProvisioningPolicysRequest_FieldMask {
	result := &BatchGetProvisioningPolicysRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProvisioningPolicysRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProvisioningPolicysRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) FilterInputFields() *BatchGetProvisioningPolicysRequest_FieldMask {
	result := &BatchGetProvisioningPolicysRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProvisioningPolicysRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProvisioningPolicysRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProvisioningPolicysRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProvisioningPolicysRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) AppendPath(path BatchGetProvisioningPolicysRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProvisioningPolicysRequest_FieldPath))
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) GetPaths() []BatchGetProvisioningPolicysRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProvisioningPolicysRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) Set(target, source *BatchGetProvisioningPolicysRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProvisioningPolicysRequest), source.(*BatchGetProvisioningPolicysRequest))
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) Project(source *BatchGetProvisioningPolicysRequest) *BatchGetProvisioningPolicysRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProvisioningPolicysRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProvisioningPolicysRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProvisioningPolicysRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetProvisioningPolicysRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetProvisioningPolicysRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProvisioningPolicysRequest))
}

func (fieldMask *BatchGetProvisioningPolicysRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProvisioningPolicysResponse_FieldMask struct {
	Paths []BatchGetProvisioningPolicysResponse_FieldPath
}

func FullBatchGetProvisioningPolicysResponse_FieldMask() *BatchGetProvisioningPolicysResponse_FieldMask {
	res := &BatchGetProvisioningPolicysResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProvisioningPolicysResponse_FieldTerminalPath{selector: BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys})
	res.Paths = append(res.Paths, &BatchGetProvisioningPolicysResponse_FieldTerminalPath{selector: BatchGetProvisioningPolicysResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProvisioningPolicysResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProvisioningPolicysResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProvisioningPolicysResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) Subtract(other *BatchGetProvisioningPolicysResponse_FieldMask) *BatchGetProvisioningPolicysResponse_FieldMask {
	result := &BatchGetProvisioningPolicysResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetProvisioningPolicysResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}
	mySubMasks := map[BatchGetProvisioningPolicysResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProvisioningPolicysResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetProvisioningPolicysResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetProvisioningPolicysResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys:
						mySubMasks[BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetProvisioningPolicysResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetProvisioningPolicysResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProvisioningPolicysResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) FilterInputFields() *BatchGetProvisioningPolicysResponse_FieldMask {
	result := &BatchGetProvisioningPolicysResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys:
			if _, ok := path.(*BatchGetProvisioningPolicysResponse_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProvisioningPolicysResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetProvisioningPolicysResponse_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProvisioningPolicysResponse_FieldSubPath{selector: BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProvisioningPolicysResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProvisioningPolicysResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProvisioningPolicysResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProvisioningPolicysResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) AppendPath(path BatchGetProvisioningPolicysResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProvisioningPolicysResponse_FieldPath))
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) GetPaths() []BatchGetProvisioningPolicysResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProvisioningPolicysResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) Set(target, source *BatchGetProvisioningPolicysResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProvisioningPolicysResponse), source.(*BatchGetProvisioningPolicysResponse))
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) Project(source *BatchGetProvisioningPolicysResponse) *BatchGetProvisioningPolicysResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProvisioningPolicysResponse{}
	provisioningPolicysMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeProvisioningPolicysAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProvisioningPolicysResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys:
				result.ProvisioningPolicys = source.ProvisioningPolicys
				wholeProvisioningPolicysAccepted = true
			case BatchGetProvisioningPolicysResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetProvisioningPolicysResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys:
				provisioningPolicysMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			}
		}
	}
	if wholeProvisioningPolicysAccepted == false && len(provisioningPolicysMask.Paths) > 0 {
		for _, sourceItem := range source.GetProvisioningPolicys() {
			result.ProvisioningPolicys = append(result.ProvisioningPolicys, provisioningPolicysMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProvisioningPolicysResponse))
}

func (fieldMask *BatchGetProvisioningPolicysResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProvisioningPolicysRequest_FieldMask struct {
	Paths []ListProvisioningPolicysRequest_FieldPath
}

func FullListProvisioningPolicysRequest_FieldMask() *ListProvisioningPolicysRequest_FieldMask {
	res := &ListProvisioningPolicysRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListProvisioningPolicysRequest_FieldTerminalPath{selector: ListProvisioningPolicysRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListProvisioningPolicysRequest_FieldTerminalPath{selector: ListProvisioningPolicysRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListProvisioningPolicysRequest_FieldTerminalPath{selector: ListProvisioningPolicysRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListProvisioningPolicysRequest_FieldTerminalPath{selector: ListProvisioningPolicysRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListProvisioningPolicysRequest_FieldTerminalPath{selector: ListProvisioningPolicysRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListProvisioningPolicysRequest_FieldTerminalPath{selector: ListProvisioningPolicysRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListProvisioningPolicysRequest_FieldTerminalPath{selector: ListProvisioningPolicysRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProvisioningPolicysRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProvisioningPolicysRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProvisioningPolicysRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProvisioningPolicysRequest_FieldPath(raw)
	})
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) Subtract(other *ListProvisioningPolicysRequest_FieldMask) *ListProvisioningPolicysRequest_FieldMask {
	result := &ListProvisioningPolicysRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProvisioningPolicysRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProvisioningPolicysRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProvisioningPolicysRequest_FieldMask) FilterInputFields() *ListProvisioningPolicysRequest_FieldMask {
	result := &ListProvisioningPolicysRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProvisioningPolicysRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProvisioningPolicysRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProvisioningPolicysRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProvisioningPolicysRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProvisioningPolicysRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) AppendPath(path ListProvisioningPolicysRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProvisioningPolicysRequest_FieldPath))
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) GetPaths() []ListProvisioningPolicysRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProvisioningPolicysRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) Set(target, source *ListProvisioningPolicysRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProvisioningPolicysRequest), source.(*ListProvisioningPolicysRequest))
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) Project(source *ListProvisioningPolicysRequest) *ListProvisioningPolicysRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProvisioningPolicysRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProvisioningPolicysRequest_FieldTerminalPath:
			switch tp.selector {
			case ListProvisioningPolicysRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListProvisioningPolicysRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListProvisioningPolicysRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListProvisioningPolicysRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListProvisioningPolicysRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListProvisioningPolicysRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListProvisioningPolicysRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProvisioningPolicysRequest))
}

func (fieldMask *ListProvisioningPolicysRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProvisioningPolicysResponse_FieldMask struct {
	Paths []ListProvisioningPolicysResponse_FieldPath
}

func FullListProvisioningPolicysResponse_FieldMask() *ListProvisioningPolicysResponse_FieldMask {
	res := &ListProvisioningPolicysResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListProvisioningPolicysResponse_FieldTerminalPath{selector: ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys})
	res.Paths = append(res.Paths, &ListProvisioningPolicysResponse_FieldTerminalPath{selector: ListProvisioningPolicysResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListProvisioningPolicysResponse_FieldTerminalPath{selector: ListProvisioningPolicysResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProvisioningPolicysResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProvisioningPolicysResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProvisioningPolicysResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProvisioningPolicysResponse_FieldPath(raw)
	})
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) Subtract(other *ListProvisioningPolicysResponse_FieldMask) *ListProvisioningPolicysResponse_FieldMask {
	result := &ListProvisioningPolicysResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListProvisioningPolicysResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}
	mySubMasks := map[ListProvisioningPolicysResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProvisioningPolicysResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListProvisioningPolicysResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListProvisioningPolicysResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys:
						mySubMasks[ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					}
				} else if tp, ok := path.(*ListProvisioningPolicysResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListProvisioningPolicysResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProvisioningPolicysResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProvisioningPolicysResponse_FieldMask) FilterInputFields() *ListProvisioningPolicysResponse_FieldMask {
	result := &ListProvisioningPolicysResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys:
			if _, ok := path.(*ListProvisioningPolicysResponse_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProvisioningPolicysResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListProvisioningPolicysResponse_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProvisioningPolicysResponse_FieldSubPath{selector: ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProvisioningPolicysResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProvisioningPolicysResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProvisioningPolicysResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProvisioningPolicysResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProvisioningPolicysResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) AppendPath(path ListProvisioningPolicysResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProvisioningPolicysResponse_FieldPath))
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) GetPaths() []ListProvisioningPolicysResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProvisioningPolicysResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) Set(target, source *ListProvisioningPolicysResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProvisioningPolicysResponse), source.(*ListProvisioningPolicysResponse))
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) Project(source *ListProvisioningPolicysResponse) *ListProvisioningPolicysResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProvisioningPolicysResponse{}
	provisioningPolicysMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeProvisioningPolicysAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProvisioningPolicysResponse_FieldTerminalPath:
			switch tp.selector {
			case ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys:
				result.ProvisioningPolicys = source.ProvisioningPolicys
				wholeProvisioningPolicysAccepted = true
			case ListProvisioningPolicysResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListProvisioningPolicysResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListProvisioningPolicysResponse_FieldSubPath:
			switch tp.selector {
			case ListProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicys:
				provisioningPolicysMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			}
		}
	}
	if wholeProvisioningPolicysAccepted == false && len(provisioningPolicysMask.Paths) > 0 {
		for _, sourceItem := range source.GetProvisioningPolicys() {
			result.ProvisioningPolicys = append(result.ProvisioningPolicys, provisioningPolicysMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProvisioningPolicysResponse))
}

func (fieldMask *ListProvisioningPolicysResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPolicyRequest_FieldMask struct {
	Paths []WatchProvisioningPolicyRequest_FieldPath
}

func FullWatchProvisioningPolicyRequest_FieldMask() *WatchProvisioningPolicyRequest_FieldMask {
	res := &WatchProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPolicyRequest_FieldTerminalPath{selector: WatchProvisioningPolicyRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchProvisioningPolicyRequest_FieldTerminalPath{selector: WatchProvisioningPolicyRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProvisioningPolicyRequest_FieldTerminalPath{selector: WatchProvisioningPolicyRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Subtract(other *WatchProvisioningPolicyRequest_FieldMask) *WatchProvisioningPolicyRequest_FieldMask {
	result := &WatchProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) FilterInputFields() *WatchProvisioningPolicyRequest_FieldMask {
	result := &WatchProvisioningPolicyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) AppendPath(path WatchProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) GetPaths() []WatchProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Set(target, source *WatchProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPolicyRequest), source.(*WatchProvisioningPolicyRequest))
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) Project(source *WatchProvisioningPolicyRequest) *WatchProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPolicyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPolicyRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchProvisioningPolicyRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProvisioningPolicyRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPolicyRequest))
}

func (fieldMask *WatchProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPolicyResponse_FieldMask struct {
	Paths []WatchProvisioningPolicyResponse_FieldPath
}

func FullWatchProvisioningPolicyResponse_FieldMask() *WatchProvisioningPolicyResponse_FieldMask {
	res := &WatchProvisioningPolicyResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPolicyResponse_FieldTerminalPath{selector: WatchProvisioningPolicyResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPolicyResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPolicyResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPolicyResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Subtract(other *WatchProvisioningPolicyResponse_FieldMask) *WatchProvisioningPolicyResponse_FieldMask {
	result := &WatchProvisioningPolicyResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPolicyResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPolicyResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) FilterInputFields() *WatchProvisioningPolicyResponse_FieldMask {
	result := &WatchProvisioningPolicyResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPolicyResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPolicyResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPolicyResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPolicyResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) AppendPath(path WatchProvisioningPolicyResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPolicyResponse_FieldPath))
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) GetPaths() []WatchProvisioningPolicyResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPolicyResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Set(target, source *WatchProvisioningPolicyResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPolicyResponse), source.(*WatchProvisioningPolicyResponse))
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) Project(source *WatchProvisioningPolicyResponse) *WatchProvisioningPolicyResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPolicyResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPolicyResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPolicyResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPolicyResponse))
}

func (fieldMask *WatchProvisioningPolicyResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPolicysRequest_FieldMask struct {
	Paths []WatchProvisioningPolicysRequest_FieldPath
}

func FullWatchProvisioningPolicysRequest_FieldMask() *WatchProvisioningPolicysRequest_FieldMask {
	res := &WatchProvisioningPolicysRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysRequest_FieldTerminalPath{selector: WatchProvisioningPolicysRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPolicysRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPolicysRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPolicysRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) Subtract(other *WatchProvisioningPolicysRequest_FieldMask) *WatchProvisioningPolicysRequest_FieldMask {
	result := &WatchProvisioningPolicysRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPolicysRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPolicysRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) FilterInputFields() *WatchProvisioningPolicysRequest_FieldMask {
	result := &WatchProvisioningPolicysRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPolicysRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPolicysRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPolicysRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPolicysRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) AppendPath(path WatchProvisioningPolicysRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPolicysRequest_FieldPath))
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) GetPaths() []WatchProvisioningPolicysRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPolicysRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) Set(target, source *WatchProvisioningPolicysRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPolicysRequest), source.(*WatchProvisioningPolicysRequest))
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) Project(source *WatchProvisioningPolicysRequest) *WatchProvisioningPolicysRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPolicysRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPolicysRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPolicysRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchProvisioningPolicysRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchProvisioningPolicysRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchProvisioningPolicysRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchProvisioningPolicysRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchProvisioningPolicysRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProvisioningPolicysRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchProvisioningPolicysRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchProvisioningPolicysRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProvisioningPolicysRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchProvisioningPolicysRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPolicysRequest))
}

func (fieldMask *WatchProvisioningPolicysRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPolicysResponse_FieldMask struct {
	Paths []WatchProvisioningPolicysResponse_FieldPath
}

func FullWatchProvisioningPolicysResponse_FieldMask() *WatchProvisioningPolicysResponse_FieldMask {
	res := &WatchProvisioningPolicysResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponse_FieldTerminalPath{selector: WatchProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicyChanges})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponse_FieldTerminalPath{selector: WatchProvisioningPolicysResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponse_FieldTerminalPath{selector: WatchProvisioningPolicysResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponse_FieldTerminalPath{selector: WatchProvisioningPolicysResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponse_FieldTerminalPath{selector: WatchProvisioningPolicysResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponse_FieldTerminalPath{selector: WatchProvisioningPolicysResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponse_FieldTerminalPath{selector: WatchProvisioningPolicysResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPolicysResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPolicysResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPolicysResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) Subtract(other *WatchProvisioningPolicysResponse_FieldMask) *WatchProvisioningPolicysResponse_FieldMask {
	result := &WatchProvisioningPolicysResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchProvisioningPolicysResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProvisioningPolicysResponse_FieldPathSelectorPageTokenChange: &WatchProvisioningPolicysResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchProvisioningPolicysResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProvisioningPolicysResponse_FieldPathSelectorPageTokenChange: &WatchProvisioningPolicysResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPolicysResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchProvisioningPolicysResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchProvisioningPolicysResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchProvisioningPolicysResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchProvisioningPolicysResponse_FieldPathSelectorPageTokenChange] = FullWatchProvisioningPolicysResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchProvisioningPolicysResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchProvisioningPolicysResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPolicysResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) FilterInputFields() *WatchProvisioningPolicysResponse_FieldMask {
	result := &WatchProvisioningPolicysResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPolicysResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPolicysResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPolicysResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPolicysResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) AppendPath(path WatchProvisioningPolicysResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPolicysResponse_FieldPath))
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) GetPaths() []WatchProvisioningPolicysResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPolicysResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) Set(target, source *WatchProvisioningPolicysResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPolicysResponse), source.(*WatchProvisioningPolicysResponse))
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) Project(source *WatchProvisioningPolicysResponse) *WatchProvisioningPolicysResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPolicysResponse{}
	pageTokenChangeMask := &WatchProvisioningPolicysResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPolicysResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPolicysResponse_FieldPathSelectorProvisioningPolicyChanges:
				result.ProvisioningPolicyChanges = source.ProvisioningPolicyChanges
			case WatchProvisioningPolicysResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchProvisioningPolicysResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchProvisioningPolicysResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProvisioningPolicysResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchProvisioningPolicysResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchProvisioningPolicysResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchProvisioningPolicysResponse_FieldSubPath:
			switch tp.selector {
			case WatchProvisioningPolicysResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchProvisioningPolicysResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPolicysResponse))
}

func (fieldMask *WatchProvisioningPolicysResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProvisioningPolicysResponse_PageTokenChange_FieldMask struct {
	Paths []WatchProvisioningPolicysResponsePageTokenChange_FieldPath
}

func FullWatchProvisioningPolicysResponse_PageTokenChange_FieldMask() *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask {
	res := &WatchProvisioningPolicysResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponsePageTokenChange_FieldTerminalPath{selector: WatchProvisioningPolicysResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchProvisioningPolicysResponsePageTokenChange_FieldTerminalPath{selector: WatchProvisioningPolicysResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProvisioningPolicysResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProvisioningPolicysResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProvisioningPolicysResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) Subtract(other *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask {
	result := &WatchProvisioningPolicysResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProvisioningPolicysResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProvisioningPolicysResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask {
	result := &WatchProvisioningPolicysResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProvisioningPolicysResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProvisioningPolicysResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) AppendPath(path WatchProvisioningPolicysResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProvisioningPolicysResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) GetPaths() []WatchProvisioningPolicysResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProvisioningPolicysResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) Set(target, source *WatchProvisioningPolicysResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProvisioningPolicysResponse_PageTokenChange), source.(*WatchProvisioningPolicysResponse_PageTokenChange))
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) Project(source *WatchProvisioningPolicysResponse_PageTokenChange) *WatchProvisioningPolicysResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProvisioningPolicysResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProvisioningPolicysResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchProvisioningPolicysResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchProvisioningPolicysResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProvisioningPolicysResponse_PageTokenChange))
}

func (fieldMask *WatchProvisioningPolicysResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateProvisioningPolicyRequest_FieldMask struct {
	Paths []CreateProvisioningPolicyRequest_FieldPath
}

func FullCreateProvisioningPolicyRequest_FieldMask() *CreateProvisioningPolicyRequest_FieldMask {
	res := &CreateProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateProvisioningPolicyRequest_FieldTerminalPath{selector: CreateProvisioningPolicyRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateProvisioningPolicyRequest_FieldTerminalPath{selector: CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy})
	return res
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Subtract(other *CreateProvisioningPolicyRequest_FieldMask) *CreateProvisioningPolicyRequest_FieldMask {
	result := &CreateProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateProvisioningPolicyRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}
	mySubMasks := map[CreateProvisioningPolicyRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateProvisioningPolicyRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateProvisioningPolicyRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
						mySubMasks[CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					}
				} else if tp, ok := path.(*CreateProvisioningPolicyRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateProvisioningPolicyRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) FilterInputFields() *CreateProvisioningPolicyRequest_FieldMask {
	result := &CreateProvisioningPolicyRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
			if _, ok := path.(*CreateProvisioningPolicyRequest_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProvisioningPolicyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateProvisioningPolicyRequest_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProvisioningPolicyRequest_FieldSubPath{selector: CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) AppendPath(path CreateProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) GetPaths() []CreateProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Set(target, source *CreateProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateProvisioningPolicyRequest), source.(*CreateProvisioningPolicyRequest))
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) Project(source *CreateProvisioningPolicyRequest) *CreateProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateProvisioningPolicyRequest{}
	provisioningPolicyMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeProvisioningPolicyAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateProvisioningPolicyRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
				result.ProvisioningPolicy = source.ProvisioningPolicy
				wholeProvisioningPolicyAccepted = true
			}
		case *CreateProvisioningPolicyRequest_FieldSubPath:
			switch tp.selector {
			case CreateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
				provisioningPolicyMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			}
		}
	}
	if wholeProvisioningPolicyAccepted == false && len(provisioningPolicyMask.Paths) > 0 {
		result.ProvisioningPolicy = provisioningPolicyMask.Project(source.GetProvisioningPolicy())
	}
	return result
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateProvisioningPolicyRequest))
}

func (fieldMask *CreateProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProvisioningPolicyRequest_FieldMask struct {
	Paths []UpdateProvisioningPolicyRequest_FieldPath
}

func FullUpdateProvisioningPolicyRequest_FieldMask() *UpdateProvisioningPolicyRequest_FieldMask {
	res := &UpdateProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequest_FieldTerminalPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy})
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequest_FieldTerminalPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequest_FieldTerminalPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Subtract(other *UpdateProvisioningPolicyRequest_FieldMask) *UpdateProvisioningPolicyRequest_FieldMask {
	result := &UpdateProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateProvisioningPolicyRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy: &provisioning_policy.ProvisioningPolicy_FieldMask{},
		UpdateProvisioningPolicyRequest_FieldPathSelectorCas:                &UpdateProvisioningPolicyRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateProvisioningPolicyRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy: &provisioning_policy.ProvisioningPolicy_FieldMask{},
		UpdateProvisioningPolicyRequest_FieldPathSelectorCas:                &UpdateProvisioningPolicyRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProvisioningPolicyRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProvisioningPolicyRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
						mySubMasks[UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					case UpdateProvisioningPolicyRequest_FieldPathSelectorCas:
						mySubMasks[UpdateProvisioningPolicyRequest_FieldPathSelectorCas] = FullUpdateProvisioningPolicyRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProvisioningPolicyRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) FilterInputFields() *UpdateProvisioningPolicyRequest_FieldMask {
	result := &UpdateProvisioningPolicyRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
			if _, ok := path.(*UpdateProvisioningPolicyRequest_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProvisioningPolicyRequest_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy, subPath: allowedPath})
				}
			}
		case UpdateProvisioningPolicyRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateProvisioningPolicyRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateProvisioningPolicyRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProvisioningPolicyRequest_FieldSubPath); ok {
				selectedMask := &UpdateProvisioningPolicyRequest_CAS_FieldMask{
					Paths: []UpdateProvisioningPolicyRequestCAS_FieldPath{sub.subPath.(UpdateProvisioningPolicyRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequest_FieldSubPath{selector: UpdateProvisioningPolicyRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) AppendPath(path UpdateProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) GetPaths() []UpdateProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Set(target, source *UpdateProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProvisioningPolicyRequest), source.(*UpdateProvisioningPolicyRequest))
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) Project(source *UpdateProvisioningPolicyRequest) *UpdateProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProvisioningPolicyRequest{}
	provisioningPolicyMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeProvisioningPolicyAccepted := false
	casMask := &UpdateProvisioningPolicyRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
				result.ProvisioningPolicy = source.ProvisioningPolicy
				wholeProvisioningPolicyAccepted = true
			case UpdateProvisioningPolicyRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateProvisioningPolicyRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateProvisioningPolicyRequest_FieldSubPath:
			switch tp.selector {
			case UpdateProvisioningPolicyRequest_FieldPathSelectorProvisioningPolicy:
				provisioningPolicyMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			case UpdateProvisioningPolicyRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateProvisioningPolicyRequestCAS_FieldPath))
			}
		}
	}
	if wholeProvisioningPolicyAccepted == false && len(provisioningPolicyMask.Paths) > 0 {
		result.ProvisioningPolicy = provisioningPolicyMask.Project(source.GetProvisioningPolicy())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProvisioningPolicyRequest))
}

func (fieldMask *UpdateProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProvisioningPolicyRequest_CAS_FieldMask struct {
	Paths []UpdateProvisioningPolicyRequestCAS_FieldPath
}

func FullUpdateProvisioningPolicyRequest_CAS_FieldMask() *UpdateProvisioningPolicyRequest_CAS_FieldMask {
	res := &UpdateProvisioningPolicyRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequestCAS_FieldTerminalPath{selector: UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateProvisioningPolicyRequestCAS_FieldTerminalPath{selector: UpdateProvisioningPolicyRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProvisioningPolicyRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProvisioningPolicyRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Subtract(other *UpdateProvisioningPolicyRequest_CAS_FieldMask) *UpdateProvisioningPolicyRequest_CAS_FieldMask {
	result := &UpdateProvisioningPolicyRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateProvisioningPolicyRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}
	mySubMasks := map[UpdateProvisioningPolicyRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState: &provisioning_policy.ProvisioningPolicy_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProvisioningPolicyRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProvisioningPolicyRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState] = provisioning_policy.FullProvisioningPolicy_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProvisioningPolicyRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) FilterInputFields() *UpdateProvisioningPolicyRequest_CAS_FieldMask {
	result := &UpdateProvisioningPolicyRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range provisioning_policy.FullProvisioningPolicy_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProvisioningPolicyRequestCAS_FieldSubPath); ok {
				selectedMask := &provisioning_policy.ProvisioningPolicy_FieldMask{
					Paths: []provisioning_policy.ProvisioningPolicy_FieldPath{sub.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProvisioningPolicyRequestCAS_FieldSubPath{selector: UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProvisioningPolicyRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProvisioningPolicyRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProvisioningPolicyRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProvisioningPolicyRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) AppendPath(path UpdateProvisioningPolicyRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProvisioningPolicyRequestCAS_FieldPath))
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) GetPaths() []UpdateProvisioningPolicyRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProvisioningPolicyRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Set(target, source *UpdateProvisioningPolicyRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProvisioningPolicyRequest_CAS), source.(*UpdateProvisioningPolicyRequest_CAS))
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) Project(source *UpdateProvisioningPolicyRequest_CAS) *UpdateProvisioningPolicyRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProvisioningPolicyRequest_CAS{}
	conditionalStateMask := &provisioning_policy.ProvisioningPolicy_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProvisioningPolicyRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateProvisioningPolicyRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateProvisioningPolicyRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(provisioning_policy.ProvisioningPolicy_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProvisioningPolicyRequest_CAS))
}

func (fieldMask *UpdateProvisioningPolicyRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteProvisioningPolicyRequest_FieldMask struct {
	Paths []DeleteProvisioningPolicyRequest_FieldPath
}

func FullDeleteProvisioningPolicyRequest_FieldMask() *DeleteProvisioningPolicyRequest_FieldMask {
	res := &DeleteProvisioningPolicyRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteProvisioningPolicyRequest_FieldTerminalPath{selector: DeleteProvisioningPolicyRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteProvisioningPolicyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteProvisioningPolicyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteProvisioningPolicyRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Subtract(other *DeleteProvisioningPolicyRequest_FieldMask) *DeleteProvisioningPolicyRequest_FieldMask {
	result := &DeleteProvisioningPolicyRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteProvisioningPolicyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteProvisioningPolicyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) FilterInputFields() *DeleteProvisioningPolicyRequest_FieldMask {
	result := &DeleteProvisioningPolicyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteProvisioningPolicyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteProvisioningPolicyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteProvisioningPolicyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteProvisioningPolicyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) AppendPath(path DeleteProvisioningPolicyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteProvisioningPolicyRequest_FieldPath))
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) GetPaths() []DeleteProvisioningPolicyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteProvisioningPolicyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Set(target, source *DeleteProvisioningPolicyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteProvisioningPolicyRequest), source.(*DeleteProvisioningPolicyRequest))
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) Project(source *DeleteProvisioningPolicyRequest) *DeleteProvisioningPolicyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteProvisioningPolicyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteProvisioningPolicyRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteProvisioningPolicyRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteProvisioningPolicyRequest))
}

func (fieldMask *DeleteProvisioningPolicyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
