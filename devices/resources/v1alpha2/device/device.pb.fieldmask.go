// Code generated by protoc-gen-goten-object
// File: edgelq/devices/proto/v1alpha2/device.proto
// DO NOT EDIT!!!

package device

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	ntt_meta "github.com/cloudwan/edgelq-sdk/common/types/meta"
	project "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha2/project"
	iam_attestation_domain "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/attestation_domain"
	iam_iam_common "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/common"
	iam_service_account "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/service_account"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &ntt_meta.Meta{}
	_ = &project.Project{}
	_ = &iam_attestation_domain.AttestationDomain{}
	_ = &iam_iam_common.PCR{}
	_ = &iam_service_account.ServiceAccount{}
	_ = &duration.Duration{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
)

type Device_FieldMask struct {
	Paths []Device_FieldPath
}

func FullDevice_FieldMask() *Device_FieldMask {
	res := &Device_FieldMask{}
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorSpec})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorPublicListingSpec})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorDisplayName})
	return res
}

func (fieldMask *Device_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDevice_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Device_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDevice_FieldPath(raw)
	})
}

func (fieldMask *Device_FieldMask) ProtoMessage() {}

func (fieldMask *Device_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_FieldMask) Subtract(other *Device_FieldMask) *Device_FieldMask {
	result := &Device_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[Device_FieldPathSelector]gotenobject.FieldMask{
		Device_FieldPathSelectorMetadata:          &ntt_meta.Meta_FieldMask{},
		Device_FieldPathSelectorSpec:              &Device_Spec_FieldMask{},
		Device_FieldPathSelectorStatus:            &Device_Status_FieldMask{},
		Device_FieldPathSelectorPublicListingSpec: &Device_PublicListingSpec_FieldMask{},
	}
	mySubMasks := map[Device_FieldPathSelector]gotenobject.FieldMask{
		Device_FieldPathSelectorMetadata:          &ntt_meta.Meta_FieldMask{},
		Device_FieldPathSelectorSpec:              &Device_Spec_FieldMask{},
		Device_FieldPathSelectorStatus:            &Device_Status_FieldMask{},
		Device_FieldPathSelectorPublicListingSpec: &Device_PublicListingSpec_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Device_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Device_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Device_FieldTerminalPath); ok {
					switch tp.selector {
					case Device_FieldPathSelectorMetadata:
						mySubMasks[Device_FieldPathSelectorMetadata] = ntt_meta.FullMeta_FieldMask()
					case Device_FieldPathSelectorSpec:
						mySubMasks[Device_FieldPathSelectorSpec] = FullDevice_Spec_FieldMask()
					case Device_FieldPathSelectorStatus:
						mySubMasks[Device_FieldPathSelectorStatus] = FullDevice_Status_FieldMask()
					case Device_FieldPathSelectorPublicListingSpec:
						mySubMasks[Device_FieldPathSelectorPublicListingSpec] = FullDevice_PublicListingSpec_FieldMask()
					}
				} else if tp, ok := path.(*Device_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Device_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_FieldMask) FilterInputFields() *Device_FieldMask {
	result := &Device_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case Device_FieldPathSelectorMetadata:
			if _, ok := path.(*Device_FieldTerminalPath); ok {
				for _, subpath := range ntt_meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Device_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Device_FieldSubPath); ok {
				selectedMask := &ntt_meta.Meta_FieldMask{
					Paths: []ntt_meta.Meta_FieldPath{sub.subPath.(ntt_meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Device_FieldSubPath{selector: Device_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Device_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDevice_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_FieldMask) AppendPath(path Device_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Device_FieldPath))
}

func (fieldMask *Device_FieldMask) GetPaths() []Device_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDevice_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_FieldMask) Set(target, source *Device) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device), source.(*Device))
}

func (fieldMask *Device_FieldMask) Project(source *Device) *Device {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device{}
	metadataMask := &ntt_meta.Meta_FieldMask{}
	wholeMetadataAccepted := false
	specMask := &Device_Spec_FieldMask{}
	wholeSpecAccepted := false
	statusMask := &Device_Status_FieldMask{}
	wholeStatusAccepted := false
	publicListingSpecMask := &Device_PublicListingSpec_FieldMask{}
	wholePublicListingSpecAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Device_FieldTerminalPath:
			switch tp.selector {
			case Device_FieldPathSelectorName:
				result.Name = source.Name
			case Device_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case Device_FieldPathSelectorSpec:
				result.Spec = source.Spec
				wholeSpecAccepted = true
			case Device_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			case Device_FieldPathSelectorPublicListingSpec:
				result.PublicListingSpec = source.PublicListingSpec
				wholePublicListingSpecAccepted = true
			case Device_FieldPathSelectorDisplayName:
				result.DisplayName = source.DisplayName
			}
		case *Device_FieldSubPath:
			switch tp.selector {
			case Device_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(ntt_meta.Meta_FieldPath))
			case Device_FieldPathSelectorSpec:
				specMask.AppendPath(tp.subPath.(DeviceSpec_FieldPath))
			case Device_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(DeviceStatus_FieldPath))
			case Device_FieldPathSelectorPublicListingSpec:
				publicListingSpecMask.AppendPath(tp.subPath.(DevicePublicListingSpec_FieldPath))
			}
		}
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	if wholeSpecAccepted == false && len(specMask.Paths) > 0 {
		result.Spec = specMask.Project(source.GetSpec())
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	if wholePublicListingSpecAccepted == false && len(publicListingSpecMask.Paths) > 0 {
		result.PublicListingSpec = publicListingSpecMask.Project(source.GetPublicListingSpec())
	}
	return result
}

func (fieldMask *Device_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device))
}

func (fieldMask *Device_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_FieldMask struct {
	Paths []DeviceSpec_FieldPath
}

func FullDevice_Spec_FieldMask() *Device_Spec_FieldMask {
	res := &Device_Spec_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorServiceAccount})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorOsVersion})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorNetConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorNetConfigMode})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorOsImageUrl})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorSshConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorAttestationConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorDisableDeviceDiscovery})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorLoggingConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorProxyConfig})
	return res
}

func (fieldMask *Device_Spec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpec_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_FieldMask) Subtract(other *Device_Spec_FieldMask) *Device_Spec_FieldMask {
	result := &Device_Spec_FieldMask{}
	removedSelectors := make([]bool, 10)
	otherSubMasks := map[DeviceSpec_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpec_FieldPathSelectorNetConfig:         &Device_Spec_NetworkConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorSshConfig:         &Device_Spec_SSHConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorAttestationConfig: &Device_Spec_AttestationConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLoggingConfig:     &Device_Spec_LoggingConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorProxyConfig:       &Device_Spec_ProxyConfig_FieldMask{},
	}
	mySubMasks := map[DeviceSpec_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpec_FieldPathSelectorNetConfig:         &Device_Spec_NetworkConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorSshConfig:         &Device_Spec_SSHConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorAttestationConfig: &Device_Spec_AttestationConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLoggingConfig:     &Device_Spec_LoggingConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorProxyConfig:       &Device_Spec_ProxyConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpec_FieldPathSelectorNetConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorNetConfig] = FullDevice_Spec_NetworkConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorSshConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorSshConfig] = FullDevice_Spec_SSHConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorAttestationConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorAttestationConfig] = FullDevice_Spec_AttestationConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorLoggingConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorLoggingConfig] = FullDevice_Spec_LoggingConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorProxyConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorProxyConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_FieldMask) FilterInputFields() *Device_Spec_FieldMask {
	result := &Device_Spec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) AppendPath(path DeviceSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpec_FieldPath))
}

func (fieldMask *Device_Spec_FieldMask) GetPaths() []DeviceSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_FieldMask) Set(target, source *Device_Spec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec), source.(*Device_Spec))
}

func (fieldMask *Device_Spec_FieldMask) Project(source *Device_Spec) *Device_Spec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec{}
	netConfigMask := &Device_Spec_NetworkConfig_FieldMask{}
	wholeNetConfigAccepted := false
	sshConfigMask := &Device_Spec_SSHConfig_FieldMask{}
	wholeSshConfigAccepted := false
	attestationConfigMask := &Device_Spec_AttestationConfig_FieldMask{}
	wholeAttestationConfigAccepted := false
	loggingConfigMask := &Device_Spec_LoggingConfig_FieldMask{}
	wholeLoggingConfigAccepted := false
	proxyConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeProxyConfigAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpec_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpec_FieldPathSelectorServiceAccount:
				result.ServiceAccount = source.ServiceAccount
			case DeviceSpec_FieldPathSelectorOsVersion:
				result.OsVersion = source.OsVersion
			case DeviceSpec_FieldPathSelectorNetConfig:
				result.NetConfig = source.NetConfig
				wholeNetConfigAccepted = true
			case DeviceSpec_FieldPathSelectorNetConfigMode:
				result.NetConfigMode = source.NetConfigMode
			case DeviceSpec_FieldPathSelectorOsImageUrl:
				result.OsImageUrl = source.OsImageUrl
			case DeviceSpec_FieldPathSelectorSshConfig:
				result.SshConfig = source.SshConfig
				wholeSshConfigAccepted = true
			case DeviceSpec_FieldPathSelectorAttestationConfig:
				result.AttestationConfig = source.AttestationConfig
				wholeAttestationConfigAccepted = true
			case DeviceSpec_FieldPathSelectorDisableDeviceDiscovery:
				result.DisableDeviceDiscovery = source.DisableDeviceDiscovery
			case DeviceSpec_FieldPathSelectorLoggingConfig:
				result.LoggingConfig = source.LoggingConfig
				wholeLoggingConfigAccepted = true
			case DeviceSpec_FieldPathSelectorProxyConfig:
				result.ProxyConfig = source.ProxyConfig
				wholeProxyConfigAccepted = true
			}
		case *DeviceSpec_FieldSubPath:
			switch tp.selector {
			case DeviceSpec_FieldPathSelectorNetConfig:
				netConfigMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorSshConfig:
				sshConfigMask.AppendPath(tp.subPath.(DeviceSpecSSHConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorAttestationConfig:
				attestationConfigMask.AppendPath(tp.subPath.(DeviceSpecAttestationConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorLoggingConfig:
				loggingConfigMask.AppendPath(tp.subPath.(DeviceSpecLoggingConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorProxyConfig:
				proxyConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			}
		}
	}
	if wholeNetConfigAccepted == false && len(netConfigMask.Paths) > 0 {
		result.NetConfig = netConfigMask.Project(source.GetNetConfig())
	}
	if wholeSshConfigAccepted == false && len(sshConfigMask.Paths) > 0 {
		result.SshConfig = sshConfigMask.Project(source.GetSshConfig())
	}
	if wholeAttestationConfigAccepted == false && len(attestationConfigMask.Paths) > 0 {
		result.AttestationConfig = attestationConfigMask.Project(source.GetAttestationConfig())
	}
	if wholeLoggingConfigAccepted == false && len(loggingConfigMask.Paths) > 0 {
		result.LoggingConfig = loggingConfigMask.Project(source.GetLoggingConfig())
	}
	if wholeProxyConfigAccepted == false && len(proxyConfigMask.Paths) > 0 {
		result.ProxyConfig = proxyConfigMask.Project(source.GetProxyConfig())
	}
	return result
}

func (fieldMask *Device_Spec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec))
}

func (fieldMask *Device_Spec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_FieldMask struct {
	Paths []DeviceStatus_FieldPath
}

func FullDevice_Status_FieldMask() *Device_Status_FieldMask {
	res := &Device_Status_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorConditions})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorDeviceInfo})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorAttestationStatus})
	return res
}

func (fieldMask *Device_Status_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_FieldMask) Subtract(other *Device_Status_FieldMask) *Device_Status_FieldMask {
	result := &Device_Status_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DeviceStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatus_FieldPathSelectorAddresses:         &Device_Status_Address_FieldMask{},
		DeviceStatus_FieldPathSelectorConditions:        &Device_Status_Condition_FieldMask{},
		DeviceStatus_FieldPathSelectorDeviceInfo:        &Device_Status_DeviceInfo_FieldMask{},
		DeviceStatus_FieldPathSelectorAttestationStatus: &iam_iam_common.PCR_FieldMask{},
	}
	mySubMasks := map[DeviceStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatus_FieldPathSelectorAddresses:         &Device_Status_Address_FieldMask{},
		DeviceStatus_FieldPathSelectorConditions:        &Device_Status_Condition_FieldMask{},
		DeviceStatus_FieldPathSelectorDeviceInfo:        &Device_Status_DeviceInfo_FieldMask{},
		DeviceStatus_FieldPathSelectorAttestationStatus: &iam_iam_common.PCR_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatus_FieldPathSelectorAddresses:
						mySubMasks[DeviceStatus_FieldPathSelectorAddresses] = FullDevice_Status_Address_FieldMask()
					case DeviceStatus_FieldPathSelectorConditions:
						mySubMasks[DeviceStatus_FieldPathSelectorConditions] = FullDevice_Status_Condition_FieldMask()
					case DeviceStatus_FieldPathSelectorDeviceInfo:
						mySubMasks[DeviceStatus_FieldPathSelectorDeviceInfo] = FullDevice_Status_DeviceInfo_FieldMask()
					case DeviceStatus_FieldPathSelectorAttestationStatus:
						mySubMasks[DeviceStatus_FieldPathSelectorAttestationStatus] = iam_iam_common.FullPCR_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_FieldMask) FilterInputFields() *Device_Status_FieldMask {
	result := &Device_Status_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) AppendPath(path DeviceStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatus_FieldPath))
}

func (fieldMask *Device_Status_FieldMask) GetPaths() []DeviceStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_FieldMask) Set(target, source *Device_Status) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status), source.(*Device_Status))
}

func (fieldMask *Device_Status_FieldMask) Project(source *Device_Status) *Device_Status {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status{}
	addressesMask := &Device_Status_Address_FieldMask{}
	wholeAddressesAccepted := false
	conditionsMask := &Device_Status_Condition_FieldMask{}
	wholeConditionsAccepted := false
	deviceInfoMask := &Device_Status_DeviceInfo_FieldMask{}
	wholeDeviceInfoAccepted := false
	attestationStatusMask := &iam_iam_common.PCR_FieldMask{}
	wholeAttestationStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatus_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
				wholeAddressesAccepted = true
			case DeviceStatus_FieldPathSelectorConditions:
				result.Conditions = source.Conditions
				wholeConditionsAccepted = true
			case DeviceStatus_FieldPathSelectorDeviceInfo:
				result.DeviceInfo = source.DeviceInfo
				wholeDeviceInfoAccepted = true
			case DeviceStatus_FieldPathSelectorAttestationStatus:
				result.AttestationStatus = source.AttestationStatus
				wholeAttestationStatusAccepted = true
			}
		case *DeviceStatus_FieldSubPath:
			switch tp.selector {
			case DeviceStatus_FieldPathSelectorAddresses:
				addressesMask.AppendPath(tp.subPath.(DeviceStatusAddress_FieldPath))
			case DeviceStatus_FieldPathSelectorConditions:
				conditionsMask.AppendPath(tp.subPath.(DeviceStatusCondition_FieldPath))
			case DeviceStatus_FieldPathSelectorDeviceInfo:
				deviceInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfo_FieldPath))
			case DeviceStatus_FieldPathSelectorAttestationStatus:
				attestationStatusMask.AppendPath(tp.subPath.(iam_iam_common.PCR_FieldPath))
			}
		}
	}
	if wholeAddressesAccepted == false && len(addressesMask.Paths) > 0 {
		for _, sourceItem := range source.GetAddresses() {
			result.Addresses = append(result.Addresses, addressesMask.Project(sourceItem))
		}
	}
	if wholeConditionsAccepted == false && len(conditionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetConditions() {
			result.Conditions = append(result.Conditions, conditionsMask.Project(sourceItem))
		}
	}
	if wholeDeviceInfoAccepted == false && len(deviceInfoMask.Paths) > 0 {
		result.DeviceInfo = deviceInfoMask.Project(source.GetDeviceInfo())
	}
	if wholeAttestationStatusAccepted == false && len(attestationStatusMask.Paths) > 0 {
		for _, sourceItem := range source.GetAttestationStatus() {
			result.AttestationStatus = append(result.AttestationStatus, attestationStatusMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status))
}

func (fieldMask *Device_Status_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_PublicListingSpec_FieldMask struct {
	Paths []DevicePublicListingSpec_FieldPath
}

func FullDevice_PublicListingSpec_FieldMask() *Device_PublicListingSpec_FieldMask {
	res := &Device_PublicListingSpec_FieldMask{}
	res.Paths = append(res.Paths, &DevicePublicListingSpec_FieldTerminalPath{selector: DevicePublicListingSpec_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &DevicePublicListingSpec_FieldTerminalPath{selector: DevicePublicListingSpec_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *Device_PublicListingSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_PublicListingSpec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDevicePublicListingSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DevicePublicListingSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDevicePublicListingSpec_FieldPath(raw)
	})
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProtoMessage() {}

func (fieldMask *Device_PublicListingSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Subtract(other *Device_PublicListingSpec_FieldMask) *Device_PublicListingSpec_FieldMask {
	result := &Device_PublicListingSpec_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DevicePublicListingSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_PublicListingSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_PublicListingSpec_FieldMask) FilterInputFields() *Device_PublicListingSpec_FieldMask {
	result := &Device_PublicListingSpec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_PublicListingSpec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_PublicListingSpec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DevicePublicListingSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDevicePublicListingSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_PublicListingSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_PublicListingSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_PublicListingSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) AppendPath(path DevicePublicListingSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_PublicListingSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DevicePublicListingSpec_FieldPath))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) GetPaths() []DevicePublicListingSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_PublicListingSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDevicePublicListingSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Set(target, source *Device_PublicListingSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_PublicListingSpec), source.(*Device_PublicListingSpec))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Project(source *Device_PublicListingSpec) *Device_PublicListingSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_PublicListingSpec{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DevicePublicListingSpec_FieldTerminalPath:
			switch tp.selector {
			case DevicePublicListingSpec_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case DevicePublicListingSpec_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		}
	}
	return result
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_PublicListingSpec))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_FieldMask struct {
	Paths []DeviceSpecNetworkConfig_FieldPath
}

func FullDevice_Spec_NetworkConfig_FieldMask() *Device_Spec_NetworkConfig_FieldMask {
	res := &Device_Spec_NetworkConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfig_FieldTerminalPath{selector: DeviceSpecNetworkConfig_FieldPathSelectorVersion})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfig_FieldTerminalPath{selector: DeviceSpecNetworkConfig_FieldPathSelectorEthernets})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfig_FieldTerminalPath{selector: DeviceSpecNetworkConfig_FieldPathSelectorWifis})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfig_FieldTerminalPath{selector: DeviceSpecNetworkConfig_FieldPathSelectorBridges})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfig_FieldTerminalPath{selector: DeviceSpecNetworkConfig_FieldPathSelectorBonds})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfig_FieldTerminalPath{selector: DeviceSpecNetworkConfig_FieldPathSelectorTunnels})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfig_FieldTerminalPath{selector: DeviceSpecNetworkConfig_FieldPathSelectorVlans})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) Subtract(other *Device_Spec_NetworkConfig_FieldMask) *Device_Spec_NetworkConfig_FieldMask {
	result := &Device_Spec_NetworkConfig_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[DeviceSpecNetworkConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfig_FieldPathSelectorEthernets: &Device_Spec_NetworkConfig_EthOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorWifis:     &Device_Spec_NetworkConfig_WifiOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorBridges:   &Device_Spec_NetworkConfig_BridgesOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorBonds:     &Device_Spec_NetworkConfig_BondsOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorTunnels:   &Device_Spec_NetworkConfig_TunnelsOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorVlans:     &Device_Spec_NetworkConfig_VlansOpts_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfig_FieldPathSelectorEthernets: &Device_Spec_NetworkConfig_EthOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorWifis:     &Device_Spec_NetworkConfig_WifiOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorBridges:   &Device_Spec_NetworkConfig_BridgesOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorBonds:     &Device_Spec_NetworkConfig_BondsOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorTunnels:   &Device_Spec_NetworkConfig_TunnelsOpts_FieldMask{},
		DeviceSpecNetworkConfig_FieldPathSelectorVlans:     &Device_Spec_NetworkConfig_VlansOpts_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkConfig_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkConfig_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkConfig_FieldPathSelectorEthernets:
						mySubMasks[DeviceSpecNetworkConfig_FieldPathSelectorEthernets] = FullDevice_Spec_NetworkConfig_EthOpts_FieldMask()
					case DeviceSpecNetworkConfig_FieldPathSelectorWifis:
						mySubMasks[DeviceSpecNetworkConfig_FieldPathSelectorWifis] = FullDevice_Spec_NetworkConfig_WifiOpts_FieldMask()
					case DeviceSpecNetworkConfig_FieldPathSelectorBridges:
						mySubMasks[DeviceSpecNetworkConfig_FieldPathSelectorBridges] = FullDevice_Spec_NetworkConfig_BridgesOpts_FieldMask()
					case DeviceSpecNetworkConfig_FieldPathSelectorBonds:
						mySubMasks[DeviceSpecNetworkConfig_FieldPathSelectorBonds] = FullDevice_Spec_NetworkConfig_BondsOpts_FieldMask()
					case DeviceSpecNetworkConfig_FieldPathSelectorTunnels:
						mySubMasks[DeviceSpecNetworkConfig_FieldPathSelectorTunnels] = FullDevice_Spec_NetworkConfig_TunnelsOpts_FieldMask()
					case DeviceSpecNetworkConfig_FieldPathSelectorVlans:
						mySubMasks[DeviceSpecNetworkConfig_FieldPathSelectorVlans] = FullDevice_Spec_NetworkConfig_VlansOpts_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkConfig_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkConfig_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_FieldMask {
	result := &Device_Spec_NetworkConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) AppendPath(path DeviceSpecNetworkConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfig_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) GetPaths() []DeviceSpecNetworkConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) Set(target, source *Device_Spec_NetworkConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig), source.(*Device_Spec_NetworkConfig))
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) Project(source *Device_Spec_NetworkConfig) *Device_Spec_NetworkConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig{}
	ethernetsMask := &Device_Spec_NetworkConfig_EthOpts_FieldMask{}
	wholeEthernetsAccepted := false
	wifisMask := &Device_Spec_NetworkConfig_WifiOpts_FieldMask{}
	wholeWifisAccepted := false
	bridgesMask := &Device_Spec_NetworkConfig_BridgesOpts_FieldMask{}
	wholeBridgesAccepted := false
	bondsMask := &Device_Spec_NetworkConfig_BondsOpts_FieldMask{}
	wholeBondsAccepted := false
	tunnelsMask := &Device_Spec_NetworkConfig_TunnelsOpts_FieldMask{}
	wholeTunnelsAccepted := false
	vlansMask := &Device_Spec_NetworkConfig_VlansOpts_FieldMask{}
	wholeVlansAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfig_FieldPathSelectorVersion:
				result.Version = source.Version
			case DeviceSpecNetworkConfig_FieldPathSelectorEthernets:
				result.Ethernets = source.Ethernets
				wholeEthernetsAccepted = true
			case DeviceSpecNetworkConfig_FieldPathSelectorWifis:
				result.Wifis = source.Wifis
				wholeWifisAccepted = true
			case DeviceSpecNetworkConfig_FieldPathSelectorBridges:
				result.Bridges = source.Bridges
				wholeBridgesAccepted = true
			case DeviceSpecNetworkConfig_FieldPathSelectorBonds:
				result.Bonds = source.Bonds
				wholeBondsAccepted = true
			case DeviceSpecNetworkConfig_FieldPathSelectorTunnels:
				result.Tunnels = source.Tunnels
				wholeTunnelsAccepted = true
			case DeviceSpecNetworkConfig_FieldPathSelectorVlans:
				result.Vlans = source.Vlans
				wholeVlansAccepted = true
			}
		case *DeviceSpecNetworkConfig_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkConfig_FieldPathSelectorEthernets:
				ethernetsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigEthOpts_FieldPath))
			case DeviceSpecNetworkConfig_FieldPathSelectorWifis:
				wifisMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigWifiOpts_FieldPath))
			case DeviceSpecNetworkConfig_FieldPathSelectorBridges:
				bridgesMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigBridgesOpts_FieldPath))
			case DeviceSpecNetworkConfig_FieldPathSelectorBonds:
				bondsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigBondsOpts_FieldPath))
			case DeviceSpecNetworkConfig_FieldPathSelectorTunnels:
				tunnelsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigTunnelsOpts_FieldPath))
			case DeviceSpecNetworkConfig_FieldPathSelectorVlans:
				vlansMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigVlansOpts_FieldPath))
			}
		}
	}
	if wholeEthernetsAccepted == false && len(ethernetsMask.Paths) > 0 {
		for _, sourceItem := range source.GetEthernets() {
			result.Ethernets = append(result.Ethernets, ethernetsMask.Project(sourceItem))
		}
	}
	if wholeWifisAccepted == false && len(wifisMask.Paths) > 0 {
		for _, sourceItem := range source.GetWifis() {
			result.Wifis = append(result.Wifis, wifisMask.Project(sourceItem))
		}
	}
	if wholeBridgesAccepted == false && len(bridgesMask.Paths) > 0 {
		for _, sourceItem := range source.GetBridges() {
			result.Bridges = append(result.Bridges, bridgesMask.Project(sourceItem))
		}
	}
	if wholeBondsAccepted == false && len(bondsMask.Paths) > 0 {
		for _, sourceItem := range source.GetBonds() {
			result.Bonds = append(result.Bonds, bondsMask.Project(sourceItem))
		}
	}
	if wholeTunnelsAccepted == false && len(tunnelsMask.Paths) > 0 {
		for _, sourceItem := range source.GetTunnels() {
			result.Tunnels = append(result.Tunnels, tunnelsMask.Project(sourceItem))
		}
	}
	if wholeVlansAccepted == false && len(vlansMask.Paths) > 0 {
		for _, sourceItem := range source.GetVlans() {
			result.Vlans = append(result.Vlans, vlansMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig))
}

func (fieldMask *Device_Spec_NetworkConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_SSHConfig_FieldMask struct {
	Paths []DeviceSpecSSHConfig_FieldPath
}

func FullDevice_Spec_SSHConfig_FieldMask() *Device_Spec_SSHConfig_FieldMask {
	res := &Device_Spec_SSHConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshServer})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshPassword})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorIpAllowList})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorIpDenyList})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorRejectPeriod})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshAuthkey})
	return res
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_SSHConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecSSHConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecSSHConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecSSHConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Subtract(other *Device_Spec_SSHConfig_FieldMask) *Device_Spec_SSHConfig_FieldMask {
	result := &Device_Spec_SSHConfig_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[DeviceSpecSSHConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized: &Device_Spec_SSHConfig_AuthKey_FieldMask{},
	}
	mySubMasks := map[DeviceSpecSSHConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized: &Device_Spec_SSHConfig_AuthKey_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecSSHConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecSSHConfig_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecSSHConfig_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
						mySubMasks[DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized] = FullDevice_Spec_SSHConfig_AuthKey_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecSSHConfig_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecSSHConfig_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_SSHConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_SSHConfig_FieldMask) FilterInputFields() *Device_Spec_SSHConfig_FieldMask {
	result := &Device_Spec_SSHConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_SSHConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecSSHConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecSSHConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_SSHConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_SSHConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) AppendPath(path DeviceSpecSSHConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecSSHConfig_FieldPath))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) GetPaths() []DeviceSpecSSHConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecSSHConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Set(target, source *Device_Spec_SSHConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_SSHConfig), source.(*Device_Spec_SSHConfig))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Project(source *Device_Spec_SSHConfig) *Device_Spec_SSHConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_SSHConfig{}
	sshAuthorizedMask := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	wholeSshAuthorizedAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecSSHConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshServer:
				result.DisableSshServer = source.DisableSshServer
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshPassword:
				result.DisableSshPassword = source.DisableSshPassword
			case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
				result.SshAuthorized = source.SshAuthorized
				wholeSshAuthorizedAccepted = true
			case DeviceSpecSSHConfig_FieldPathSelectorIpAllowList:
				result.IpAllowList = source.IpAllowList
			case DeviceSpecSSHConfig_FieldPathSelectorIpDenyList:
				result.IpDenyList = source.IpDenyList
			case DeviceSpecSSHConfig_FieldPathSelectorRejectPeriod:
				result.RejectPeriod = source.RejectPeriod
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshAuthkey:
				result.DisableSshAuthkey = source.DisableSshAuthkey
			}
		case *DeviceSpecSSHConfig_FieldSubPath:
			switch tp.selector {
			case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
				sshAuthorizedMask.AppendPath(tp.subPath.(DeviceSpecSSHConfigAuthKey_FieldPath))
			}
		}
	}
	if wholeSshAuthorizedAccepted == false && len(sshAuthorizedMask.Paths) > 0 {
		for _, sourceItem := range source.GetSshAuthorized() {
			result.SshAuthorized = append(result.SshAuthorized, sshAuthorizedMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_SSHConfig))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_AttestationConfig_FieldMask struct {
	Paths []DeviceSpecAttestationConfig_FieldPath
}

func FullDevice_Spec_AttestationConfig_FieldMask() *Device_Spec_AttestationConfig_FieldMask {
	res := &Device_Spec_AttestationConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecAttestationConfig_FieldTerminalPath{selector: DeviceSpecAttestationConfig_FieldPathSelectorAttestationExpected})
	res.Paths = append(res.Paths, &DeviceSpecAttestationConfig_FieldTerminalPath{selector: DeviceSpecAttestationConfig_FieldPathSelectorAttestationDomain})
	res.Paths = append(res.Paths, &DeviceSpecAttestationConfig_FieldTerminalPath{selector: DeviceSpecAttestationConfig_FieldPathSelectorInsecureUseTpmSimulatorSeed})
	return res
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecAttestationConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecAttestationConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecAttestationConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Subtract(other *Device_Spec_AttestationConfig_FieldMask) *Device_Spec_AttestationConfig_FieldMask {
	result := &Device_Spec_AttestationConfig_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecAttestationConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_AttestationConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) FilterInputFields() *Device_Spec_AttestationConfig_FieldMask {
	result := &Device_Spec_AttestationConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecAttestationConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecAttestationConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_AttestationConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_AttestationConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) AppendPath(path DeviceSpecAttestationConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecAttestationConfig_FieldPath))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) GetPaths() []DeviceSpecAttestationConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecAttestationConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Set(target, source *Device_Spec_AttestationConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_AttestationConfig), source.(*Device_Spec_AttestationConfig))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Project(source *Device_Spec_AttestationConfig) *Device_Spec_AttestationConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_AttestationConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecAttestationConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecAttestationConfig_FieldPathSelectorAttestationExpected:
				result.AttestationExpected = source.AttestationExpected
			case DeviceSpecAttestationConfig_FieldPathSelectorAttestationDomain:
				result.AttestationDomain = source.AttestationDomain
			case DeviceSpecAttestationConfig_FieldPathSelectorInsecureUseTpmSimulatorSeed:
				result.InsecureUseTpmSimulatorSeed = source.InsecureUseTpmSimulatorSeed
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_AttestationConfig))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_LoggingConfig_FieldMask struct {
	Paths []DeviceSpecLoggingConfig_FieldPath
}

func FullDevice_Spec_LoggingConfig_FieldMask() *Device_Spec_LoggingConfig_FieldMask {
	res := &Device_Spec_LoggingConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorPriority})
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorUnits})
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorEnableJournalExport})
	return res
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecLoggingConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecLoggingConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecLoggingConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Subtract(other *Device_Spec_LoggingConfig_FieldMask) *Device_Spec_LoggingConfig_FieldMask {
	result := &Device_Spec_LoggingConfig_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecLoggingConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_LoggingConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) FilterInputFields() *Device_Spec_LoggingConfig_FieldMask {
	result := &Device_Spec_LoggingConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecLoggingConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecLoggingConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_LoggingConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_LoggingConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) AppendPath(path DeviceSpecLoggingConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecLoggingConfig_FieldPath))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) GetPaths() []DeviceSpecLoggingConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecLoggingConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Set(target, source *Device_Spec_LoggingConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_LoggingConfig), source.(*Device_Spec_LoggingConfig))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Project(source *Device_Spec_LoggingConfig) *Device_Spec_LoggingConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_LoggingConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecLoggingConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecLoggingConfig_FieldPathSelectorPriority:
				result.Priority = source.Priority
			case DeviceSpecLoggingConfig_FieldPathSelectorUnits:
				result.Units = source.Units
			case DeviceSpecLoggingConfig_FieldPathSelectorEnableJournalExport:
				result.EnableJournalExport = source.EnableJournalExport
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_LoggingConfig))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_ProxyConfig_FieldMask struct {
	Paths []DeviceSpecProxyConfig_FieldPath
}

func FullDevice_Spec_ProxyConfig_FieldMask() *Device_Spec_ProxyConfig_FieldMask {
	res := &Device_Spec_ProxyConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorHttpProxy})
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorHttpsProxy})
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorNoProxy})
	return res
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecProxyConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecProxyConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecProxyConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Subtract(other *Device_Spec_ProxyConfig_FieldMask) *Device_Spec_ProxyConfig_FieldMask {
	result := &Device_Spec_ProxyConfig_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecProxyConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_ProxyConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) FilterInputFields() *Device_Spec_ProxyConfig_FieldMask {
	result := &Device_Spec_ProxyConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecProxyConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecProxyConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_ProxyConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_ProxyConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) AppendPath(path DeviceSpecProxyConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecProxyConfig_FieldPath))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) GetPaths() []DeviceSpecProxyConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecProxyConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Set(target, source *Device_Spec_ProxyConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_ProxyConfig), source.(*Device_Spec_ProxyConfig))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Project(source *Device_Spec_ProxyConfig) *Device_Spec_ProxyConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_ProxyConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecProxyConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecProxyConfig_FieldPathSelectorHttpProxy:
				result.HttpProxy = source.HttpProxy
			case DeviceSpecProxyConfig_FieldPathSelectorHttpsProxy:
				result.HttpsProxy = source.HttpsProxy
			case DeviceSpecProxyConfig_FieldPathSelectorNoProxy:
				result.NoProxy = source.NoProxy
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_ProxyConfig))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_CommonOpts_FieldMask struct {
	Paths []DeviceSpecNetworkConfigCommonOpts_FieldPath
}

func FullDevice_Spec_NetworkConfig_CommonOpts_FieldMask() *Device_Spec_NetworkConfig_CommonOpts_FieldMask {
	res := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorIpv6Privacy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorLinkLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorCritical})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcpIdentifier})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAcceptRa})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorGateway4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorGateway6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorNameservers})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorOptional})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorOptionalAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutingPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAuth})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigCommonOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 21)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigCommonOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) Subtract(other *Device_Spec_NetworkConfig_CommonOpts_FieldMask) *Device_Spec_NetworkConfig_CommonOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	removedSelectors := make([]bool, 21)
	otherSubMasks := map[DeviceSpecNetworkConfigCommonOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkConfigCommonOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkConfigCommonOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4Overrides:
						mySubMasks[DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4Overrides] = FullDevice_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6Overrides:
						mySubMasks[DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6Overrides] = FullDevice_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorNameservers:
						mySubMasks[DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorNameservers] = FullDevice_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask()
					case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutes:
						mySubMasks[DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutes] = FullDevice_Spec_NetworkConfig_CommonOpts_Routes_FieldMask()
					case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutingPolicy:
						mySubMasks[DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutingPolicy] = FullDevice_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask()
					case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAuth] = FullDevice_Spec_NetworkConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkConfigCommonOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkConfigCommonOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_CommonOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_CommonOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigCommonOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigCommonOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_CommonOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_CommonOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) AppendPath(path DeviceSpecNetworkConfigCommonOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigCommonOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) GetPaths() []DeviceSpecNetworkConfigCommonOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigCommonOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) Set(target, source *Device_Spec_NetworkConfig_CommonOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_CommonOpts), source.(*Device_Spec_NetworkConfig_CommonOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) Project(source *Device_Spec_NetworkConfig_CommonOpts) *Device_Spec_NetworkConfig_CommonOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_CommonOpts{}
	dhcp4OverridesMask := &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp4OverridesAccepted := false
	dhcp6OverridesMask := &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp6OverridesAccepted := false
	nameserversMask := &Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask{}
	wholeNameserversAccepted := false
	routesMask := &Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask{}
	wholeRoutesAccepted := false
	routingPolicyMask := &Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask{}
	wholeRoutingPolicyAccepted := false
	authMask := &Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigCommonOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4:
				result.Dhcp4 = source.Dhcp4
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6:
				result.Dhcp6 = source.Dhcp6
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorIpv6Privacy:
				result.Ipv6Privacy = source.Ipv6Privacy
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorLinkLocal:
				result.LinkLocal = source.LinkLocal
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorCritical:
				result.Critical = source.Critical
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcpIdentifier:
				result.DhcpIdentifier = source.DhcpIdentifier
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4Overrides:
				result.Dhcp4Overrides = source.Dhcp4Overrides
				wholeDhcp4OverridesAccepted = true
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6Overrides:
				result.Dhcp6Overrides = source.Dhcp6Overrides
				wholeDhcp6OverridesAccepted = true
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAcceptRa:
				result.AcceptRa = source.AcceptRa
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorGateway4:
				result.Gateway4 = source.Gateway4
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorGateway6:
				result.Gateway6 = source.Gateway6
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorNameservers:
				result.Nameservers = source.Nameservers
				wholeNameserversAccepted = true
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorMtu:
				result.Mtu = source.Mtu
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorOptional:
				result.Optional = source.Optional
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorOptionalAddresses:
				result.OptionalAddresses = source.OptionalAddresses
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutes:
				result.Routes = source.Routes
				wholeRoutesAccepted = true
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutingPolicy:
				result.RoutingPolicy = source.RoutingPolicy
				wholeRoutingPolicyAccepted = true
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			}
		case *DeviceSpecNetworkConfigCommonOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp4Overrides:
				dhcp4OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorDhcp6Overrides:
				dhcp6OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorNameservers:
				nameserversMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOptsNameservers_FieldPath))
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutes:
				routesMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOptsRoutes_FieldPath))
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorRoutingPolicy:
				routingPolicyMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath))
			case DeviceSpecNetworkConfigCommonOpts_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOptsAuth_FieldPath))
			}
		}
	}
	if wholeDhcp4OverridesAccepted == false && len(dhcp4OverridesMask.Paths) > 0 {
		result.Dhcp4Overrides = dhcp4OverridesMask.Project(source.GetDhcp4Overrides())
	}
	if wholeDhcp6OverridesAccepted == false && len(dhcp6OverridesMask.Paths) > 0 {
		result.Dhcp6Overrides = dhcp6OverridesMask.Project(source.GetDhcp6Overrides())
	}
	if wholeNameserversAccepted == false && len(nameserversMask.Paths) > 0 {
		result.Nameservers = nameserversMask.Project(source.GetNameservers())
	}
	if wholeRoutesAccepted == false && len(routesMask.Paths) > 0 {
		for _, sourceItem := range source.GetRoutes() {
			result.Routes = append(result.Routes, routesMask.Project(sourceItem))
		}
	}
	if wholeRoutingPolicyAccepted == false && len(routingPolicyMask.Paths) > 0 {
		result.RoutingPolicy = routingPolicyMask.Project(source.GetRoutingPolicy())
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_CommonOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_EthOpts_FieldMask struct {
	Paths []DeviceSpecNetworkConfigEthOpts_FieldPath
}

func FullDevice_Spec_NetworkConfig_EthOpts_FieldMask() *Device_Spec_NetworkConfig_EthOpts_FieldMask {
	res := &Device_Spec_NetworkConfig_EthOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigEthOpts_FieldPathSelectorMatch})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigEthOpts_FieldPathSelectorSetName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigEthOpts_FieldPathSelectorWakeonlan})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigEthOpts_FieldPathSelectorOpts})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigEthOpts_FieldPathSelectorName})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigEthOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigEthOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigEthOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) Subtract(other *Device_Spec_NetworkConfig_EthOpts_FieldMask) *Device_Spec_NetworkConfig_EthOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_EthOpts_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[DeviceSpecNetworkConfigEthOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigEthOpts_FieldPathSelectorMatch: &Device_Spec_NetworkConfig_EthOpts_Match_FieldMask{},
		DeviceSpecNetworkConfigEthOpts_FieldPathSelectorOpts:  &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkConfigEthOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigEthOpts_FieldPathSelectorMatch: &Device_Spec_NetworkConfig_EthOpts_Match_FieldMask{},
		DeviceSpecNetworkConfigEthOpts_FieldPathSelectorOpts:  &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigEthOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkConfigEthOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkConfigEthOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorMatch:
						mySubMasks[DeviceSpecNetworkConfigEthOpts_FieldPathSelectorMatch] = FullDevice_Spec_NetworkConfig_EthOpts_Match_FieldMask()
					case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorOpts:
						mySubMasks[DeviceSpecNetworkConfigEthOpts_FieldPathSelectorOpts] = FullDevice_Spec_NetworkConfig_CommonOpts_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkConfigEthOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkConfigEthOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_EthOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_EthOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_EthOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigEthOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigEthOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_EthOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_EthOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) AppendPath(path DeviceSpecNetworkConfigEthOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigEthOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) GetPaths() []DeviceSpecNetworkConfigEthOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigEthOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) Set(target, source *Device_Spec_NetworkConfig_EthOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_EthOpts), source.(*Device_Spec_NetworkConfig_EthOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) Project(source *Device_Spec_NetworkConfig_EthOpts) *Device_Spec_NetworkConfig_EthOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_EthOpts{}
	matchMask := &Device_Spec_NetworkConfig_EthOpts_Match_FieldMask{}
	wholeMatchAccepted := false
	optsMask := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	wholeOptsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigEthOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorMatch:
				result.Match = source.Match
				wholeMatchAccepted = true
			case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorSetName:
				result.SetName = source.SetName
			case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorWakeonlan:
				result.Wakeonlan = source.Wakeonlan
			case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorOpts:
				result.Opts = source.Opts
				wholeOptsAccepted = true
			case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorName:
				result.Name = source.Name
			}
		case *DeviceSpecNetworkConfigEthOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorMatch:
				matchMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigEthOptsMatch_FieldPath))
			case DeviceSpecNetworkConfigEthOpts_FieldPathSelectorOpts:
				optsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOpts_FieldPath))
			}
		}
	}
	if wholeMatchAccepted == false && len(matchMask.Paths) > 0 {
		result.Match = matchMask.Project(source.GetMatch())
	}
	if wholeOptsAccepted == false && len(optsMask.Paths) > 0 {
		result.Opts = optsMask.Project(source.GetOpts())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_EthOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_WifiOpts_FieldMask struct {
	Paths []DeviceSpecNetworkConfigWifiOpts_FieldPath
}

func FullDevice_Spec_NetworkConfig_WifiOpts_FieldMask() *Device_Spec_NetworkConfig_WifiOpts_FieldMask {
	res := &Device_Spec_NetworkConfig_WifiOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorMatch})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorSetName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorWakeonlan})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorOpts})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorAccessPoints})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorName})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigWifiOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigWifiOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) Subtract(other *Device_Spec_NetworkConfig_WifiOpts_FieldMask) *Device_Spec_NetworkConfig_WifiOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_WifiOpts_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[DeviceSpecNetworkConfigWifiOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorMatch:        &Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask{},
		DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorOpts:         &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
		DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorAccessPoints: &Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkConfigWifiOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorMatch:        &Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask{},
		DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorOpts:         &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
		DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorAccessPoints: &Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkConfigWifiOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorMatch:
						mySubMasks[DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorMatch] = FullDevice_Spec_NetworkConfig_WifiOpts_Match_FieldMask()
					case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorOpts:
						mySubMasks[DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorOpts] = FullDevice_Spec_NetworkConfig_CommonOpts_FieldMask()
					case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorAccessPoints:
						mySubMasks[DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorAccessPoints] = FullDevice_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkConfigWifiOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkConfigWifiOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_WifiOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_WifiOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_WifiOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigWifiOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigWifiOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_WifiOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_WifiOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) AppendPath(path DeviceSpecNetworkConfigWifiOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigWifiOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) GetPaths() []DeviceSpecNetworkConfigWifiOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigWifiOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) Set(target, source *Device_Spec_NetworkConfig_WifiOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_WifiOpts), source.(*Device_Spec_NetworkConfig_WifiOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) Project(source *Device_Spec_NetworkConfig_WifiOpts) *Device_Spec_NetworkConfig_WifiOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_WifiOpts{}
	matchMask := &Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask{}
	wholeMatchAccepted := false
	optsMask := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	wholeOptsAccepted := false
	accessPointsMask := &Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask{}
	wholeAccessPointsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigWifiOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorMatch:
				result.Match = source.Match
				wholeMatchAccepted = true
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorSetName:
				result.SetName = source.SetName
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorWakeonlan:
				result.Wakeonlan = source.Wakeonlan
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorOpts:
				result.Opts = source.Opts
				wholeOptsAccepted = true
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorAccessPoints:
				result.AccessPoints = source.AccessPoints
				wholeAccessPointsAccepted = true
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorName:
				result.Name = source.Name
			}
		case *DeviceSpecNetworkConfigWifiOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorMatch:
				matchMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigWifiOptsMatch_FieldPath))
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorOpts:
				optsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOpts_FieldPath))
			case DeviceSpecNetworkConfigWifiOpts_FieldPathSelectorAccessPoints:
				accessPointsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath))
			}
		}
	}
	if wholeMatchAccepted == false && len(matchMask.Paths) > 0 {
		result.Match = matchMask.Project(source.GetMatch())
	}
	if wholeOptsAccepted == false && len(optsMask.Paths) > 0 {
		result.Opts = optsMask.Project(source.GetOpts())
	}
	if wholeAccessPointsAccepted == false && len(accessPointsMask.Paths) > 0 {
		for _, sourceItem := range source.GetAccessPoints() {
			result.AccessPoints = append(result.AccessPoints, accessPointsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_WifiOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_BridgesOpts_FieldMask struct {
	Paths []DeviceSpecNetworkConfigBridgesOpts_FieldPath
}

func FullDevice_Spec_NetworkConfig_BridgesOpts_FieldMask() *Device_Spec_NetworkConfig_BridgesOpts_FieldMask {
	res := &Device_Spec_NetworkConfig_BridgesOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorOpts})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorInterfaces})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorParameters})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorName})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigBridgesOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigBridgesOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigBridgesOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) Subtract(other *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) *Device_Spec_NetworkConfig_BridgesOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_BridgesOpts_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DeviceSpecNetworkConfigBridgesOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorOpts:       &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
		DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorParameters: &Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkConfigBridgesOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorOpts:       &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
		DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorParameters: &Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigBridgesOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkConfigBridgesOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkConfigBridgesOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorOpts:
						mySubMasks[DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorOpts] = FullDevice_Spec_NetworkConfig_CommonOpts_FieldMask()
					case DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorParameters:
						mySubMasks[DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorParameters] = FullDevice_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkConfigBridgesOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkConfigBridgesOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_BridgesOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_BridgesOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_BridgesOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigBridgesOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigBridgesOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_BridgesOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_BridgesOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) AppendPath(path DeviceSpecNetworkConfigBridgesOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigBridgesOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) GetPaths() []DeviceSpecNetworkConfigBridgesOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigBridgesOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) Set(target, source *Device_Spec_NetworkConfig_BridgesOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_BridgesOpts), source.(*Device_Spec_NetworkConfig_BridgesOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) Project(source *Device_Spec_NetworkConfig_BridgesOpts) *Device_Spec_NetworkConfig_BridgesOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_BridgesOpts{}
	optsMask := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	wholeOptsAccepted := false
	parametersMask := &Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask{}
	wholeParametersAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigBridgesOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorOpts:
				result.Opts = source.Opts
				wholeOptsAccepted = true
			case DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorInterfaces:
				result.Interfaces = source.Interfaces
			case DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorParameters:
				result.Parameters = source.Parameters
				wholeParametersAccepted = true
			case DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorName:
				result.Name = source.Name
			}
		case *DeviceSpecNetworkConfigBridgesOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorOpts:
				optsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOpts_FieldPath))
			case DeviceSpecNetworkConfigBridgesOpts_FieldPathSelectorParameters:
				parametersMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigBridgesOptsParameters_FieldPath))
			}
		}
	}
	if wholeOptsAccepted == false && len(optsMask.Paths) > 0 {
		result.Opts = optsMask.Project(source.GetOpts())
	}
	if wholeParametersAccepted == false && len(parametersMask.Paths) > 0 {
		result.Parameters = parametersMask.Project(source.GetParameters())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_BridgesOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_BondsOpts_FieldMask struct {
	Paths []DeviceSpecNetworkConfigBondsOpts_FieldPath
}

func FullDevice_Spec_NetworkConfig_BondsOpts_FieldMask() *Device_Spec_NetworkConfig_BondsOpts_FieldMask {
	res := &Device_Spec_NetworkConfig_BondsOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorOpts})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorInterfaces})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorParameters})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorName})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigBondsOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigBondsOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigBondsOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) Subtract(other *Device_Spec_NetworkConfig_BondsOpts_FieldMask) *Device_Spec_NetworkConfig_BondsOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_BondsOpts_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DeviceSpecNetworkConfigBondsOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorOpts:       &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
		DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorParameters: &Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkConfigBondsOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorOpts:       &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
		DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorParameters: &Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigBondsOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkConfigBondsOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkConfigBondsOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorOpts:
						mySubMasks[DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorOpts] = FullDevice_Spec_NetworkConfig_CommonOpts_FieldMask()
					case DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorParameters:
						mySubMasks[DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorParameters] = FullDevice_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkConfigBondsOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkConfigBondsOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_BondsOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_BondsOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_BondsOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigBondsOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigBondsOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_BondsOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_BondsOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) AppendPath(path DeviceSpecNetworkConfigBondsOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigBondsOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) GetPaths() []DeviceSpecNetworkConfigBondsOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigBondsOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) Set(target, source *Device_Spec_NetworkConfig_BondsOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_BondsOpts), source.(*Device_Spec_NetworkConfig_BondsOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) Project(source *Device_Spec_NetworkConfig_BondsOpts) *Device_Spec_NetworkConfig_BondsOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_BondsOpts{}
	optsMask := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	wholeOptsAccepted := false
	parametersMask := &Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask{}
	wholeParametersAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigBondsOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorOpts:
				result.Opts = source.Opts
				wholeOptsAccepted = true
			case DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorInterfaces:
				result.Interfaces = source.Interfaces
			case DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorParameters:
				result.Parameters = source.Parameters
				wholeParametersAccepted = true
			case DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorName:
				result.Name = source.Name
			}
		case *DeviceSpecNetworkConfigBondsOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorOpts:
				optsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOpts_FieldPath))
			case DeviceSpecNetworkConfigBondsOpts_FieldPathSelectorParameters:
				parametersMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigBondsOptsParameters_FieldPath))
			}
		}
	}
	if wholeOptsAccepted == false && len(optsMask.Paths) > 0 {
		result.Opts = optsMask.Project(source.GetOpts())
	}
	if wholeParametersAccepted == false && len(parametersMask.Paths) > 0 {
		result.Parameters = parametersMask.Project(source.GetParameters())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_BondsOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_TunnelsOpts_FieldMask struct {
	Paths []DeviceSpecNetworkConfigTunnelsOpts_FieldPath
}

func FullDevice_Spec_NetworkConfig_TunnelsOpts_FieldMask() *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask {
	res := &Device_Spec_NetworkConfig_TunnelsOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorOpts})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorMode})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorRemote})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorName})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigTunnelsOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigTunnelsOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) Subtract(other *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_TunnelsOpts_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorOpts: &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorOpts: &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkConfigTunnelsOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorOpts:
						mySubMasks[DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorOpts] = FullDevice_Spec_NetworkConfig_CommonOpts_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkConfigTunnelsOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkConfigTunnelsOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_TunnelsOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_TunnelsOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigTunnelsOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigTunnelsOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) AppendPath(path DeviceSpecNetworkConfigTunnelsOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigTunnelsOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) GetPaths() []DeviceSpecNetworkConfigTunnelsOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigTunnelsOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) Set(target, source *Device_Spec_NetworkConfig_TunnelsOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_TunnelsOpts), source.(*Device_Spec_NetworkConfig_TunnelsOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) Project(source *Device_Spec_NetworkConfig_TunnelsOpts) *Device_Spec_NetworkConfig_TunnelsOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_TunnelsOpts{}
	optsMask := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	wholeOptsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigTunnelsOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorOpts:
				result.Opts = source.Opts
				wholeOptsAccepted = true
			case DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorMode:
				result.Mode = source.Mode
			case DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorLocal:
				result.Local = source.Local
			case DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorRemote:
				result.Remote = source.Remote
			case DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorKey:
				result.Key = source.Key
			case DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorName:
				result.Name = source.Name
			}
		case *DeviceSpecNetworkConfigTunnelsOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigTunnelsOpts_FieldPathSelectorOpts:
				optsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOpts_FieldPath))
			}
		}
	}
	if wholeOptsAccepted == false && len(optsMask.Paths) > 0 {
		result.Opts = optsMask.Project(source.GetOpts())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_TunnelsOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_VlansOpts_FieldMask struct {
	Paths []DeviceSpecNetworkConfigVlansOpts_FieldPath
}

func FullDevice_Spec_NetworkConfig_VlansOpts_FieldMask() *Device_Spec_NetworkConfig_VlansOpts_FieldMask {
	res := &Device_Spec_NetworkConfig_VlansOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorOpts})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorId})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorLink})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorName})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigVlansOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigVlansOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigVlansOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) Subtract(other *Device_Spec_NetworkConfig_VlansOpts_FieldMask) *Device_Spec_NetworkConfig_VlansOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_VlansOpts_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DeviceSpecNetworkConfigVlansOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorOpts: &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkConfigVlansOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorOpts: &Device_Spec_NetworkConfig_CommonOpts_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigVlansOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkConfigVlansOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkConfigVlansOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorOpts:
						mySubMasks[DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorOpts] = FullDevice_Spec_NetworkConfig_CommonOpts_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkConfigVlansOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkConfigVlansOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_VlansOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_VlansOpts_FieldMask {
	result := &Device_Spec_NetworkConfig_VlansOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigVlansOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigVlansOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_VlansOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_VlansOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) AppendPath(path DeviceSpecNetworkConfigVlansOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigVlansOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) GetPaths() []DeviceSpecNetworkConfigVlansOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigVlansOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) Set(target, source *Device_Spec_NetworkConfig_VlansOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_VlansOpts), source.(*Device_Spec_NetworkConfig_VlansOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) Project(source *Device_Spec_NetworkConfig_VlansOpts) *Device_Spec_NetworkConfig_VlansOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_VlansOpts{}
	optsMask := &Device_Spec_NetworkConfig_CommonOpts_FieldMask{}
	wholeOptsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigVlansOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorOpts:
				result.Opts = source.Opts
				wholeOptsAccepted = true
			case DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorId:
				result.Id = source.Id
			case DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorLink:
				result.Link = source.Link
			case DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorName:
				result.Name = source.Name
			}
		case *DeviceSpecNetworkConfigVlansOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigVlansOpts_FieldPathSelectorOpts:
				optsMask.AppendPath(tp.subPath.(DeviceSpecNetworkConfigCommonOpts_FieldPath))
			}
		}
	}
	if wholeOptsAccepted == false && len(optsMask.Paths) > 0 {
		result.Opts = optsMask.Project(source.GetOpts())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_VlansOpts))
}

func (fieldMask *Device_Spec_NetworkConfig_VlansOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask struct {
	Paths []DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath
}

func FullDevice_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask() *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask {
	res := &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseDns})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseNtp})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorSendHostname})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseHostname})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorHostname})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorRouteMetric})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) Subtract(other *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) AppendPath(path DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) GetPaths() []DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) Set(target, source *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides), source.(*Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) Project(source *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides) *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseDns:
				result.UseDns = source.UseDns
			case DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseNtp:
				result.UseNtp = source.UseNtp
			case DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorSendHostname:
				result.SendHostname = source.SendHostname
			case DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseHostname:
				result.UseHostname = source.UseHostname
			case DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseMtu:
				result.UseMtu = source.UseMtu
			case DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorHostname:
				result.Hostname = source.Hostname
			case DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorUseRoutes:
				result.UseRoutes = source.UseRoutes
			case DeviceSpecNetworkConfigCommonOptsDHCPOverrides_FieldPathSelectorRouteMetric:
				result.RouteMetric = source.RouteMetric
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_DHCPOverrides_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask struct {
	Paths []DeviceSpecNetworkConfigCommonOptsNameservers_FieldPath
}

func FullDevice_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask() *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask {
	res := &Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsNameservers_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsNameservers_FieldPathSelectorSearch})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsNameservers_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsNameservers_FieldPathSelectorAddresses})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigCommonOptsNameservers_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigCommonOptsNameservers_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigCommonOptsNameservers_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) Subtract(other *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigCommonOptsNameservers_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigCommonOptsNameservers_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigCommonOptsNameservers_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) AppendPath(path DeviceSpecNetworkConfigCommonOptsNameservers_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigCommonOptsNameservers_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) GetPaths() []DeviceSpecNetworkConfigCommonOptsNameservers_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigCommonOptsNameservers_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) Set(target, source *Device_Spec_NetworkConfig_CommonOpts_Nameservers) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_CommonOpts_Nameservers), source.(*Device_Spec_NetworkConfig_CommonOpts_Nameservers))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) Project(source *Device_Spec_NetworkConfig_CommonOpts_Nameservers) *Device_Spec_NetworkConfig_CommonOpts_Nameservers {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_CommonOpts_Nameservers{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigCommonOptsNameservers_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigCommonOptsNameservers_FieldPathSelectorSearch:
				result.Search = source.Search
			case DeviceSpecNetworkConfigCommonOptsNameservers_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_CommonOpts_Nameservers))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Nameservers_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask struct {
	Paths []DeviceSpecNetworkConfigCommonOptsRoutes_FieldPath
}

func FullDevice_Spec_NetworkConfig_CommonOpts_Routes_FieldMask() *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask {
	res := &Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorFrom})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorTo})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorVia})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorOnLink})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorMetric})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorType})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorScope})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorTable})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigCommonOptsRoutes_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigCommonOptsRoutes_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) Subtract(other *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigCommonOptsRoutes_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigCommonOptsRoutes_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) AppendPath(path DeviceSpecNetworkConfigCommonOptsRoutes_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigCommonOptsRoutes_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) GetPaths() []DeviceSpecNetworkConfigCommonOptsRoutes_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigCommonOptsRoutes_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) Set(target, source *Device_Spec_NetworkConfig_CommonOpts_Routes) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_CommonOpts_Routes), source.(*Device_Spec_NetworkConfig_CommonOpts_Routes))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) Project(source *Device_Spec_NetworkConfig_CommonOpts_Routes) *Device_Spec_NetworkConfig_CommonOpts_Routes {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_CommonOpts_Routes{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigCommonOptsRoutes_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorFrom:
				result.From = source.From
			case DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorTo:
				result.To = source.To
			case DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorVia:
				result.Via = source.Via
			case DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorOnLink:
				result.OnLink = source.OnLink
			case DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorMetric:
				result.Metric = source.Metric
			case DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorType:
				result.Type = source.Type
			case DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorScope:
				result.Scope = source.Scope
			case DeviceSpecNetworkConfigCommonOptsRoutes_FieldPathSelectorTable:
				result.Table = source.Table
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_CommonOpts_Routes))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Routes_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask struct {
	Paths []DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath
}

func FullDevice_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask() *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask {
	res := &Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorFrom})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorTo})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorTable})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorPriority})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorMark})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorTypeOfService})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) Subtract(other *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) AppendPath(path DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) GetPaths() []DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) Set(target, source *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy), source.(*Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) Project(source *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy) *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorFrom:
				result.From = source.From
			case DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorTo:
				result.To = source.To
			case DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorTable:
				result.Table = source.Table
			case DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorPriority:
				result.Priority = source.Priority
			case DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorMark:
				result.Mark = source.Mark
			case DeviceSpecNetworkConfigCommonOptsRoutingPolicy_FieldPathSelectorTypeOfService:
				result.TypeOfService = source.TypeOfService
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_RoutingPolicy_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask struct {
	Paths []DeviceSpecNetworkConfigCommonOptsAuth_FieldPath
}

func FullDevice_Spec_NetworkConfig_CommonOpts_Auth_FieldMask() *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask {
	res := &Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorPassword})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorMethod})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorIdentity})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorAnonymousIdentity})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorCaCertificate})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorClientCertificate})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorClientKey})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorClientKeyPassword})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigCommonOptsAuth_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigCommonOptsAuth_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) Subtract(other *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask{}
	removedSelectors := make([]bool, 9)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask {
	result := &Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigCommonOptsAuth_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigCommonOptsAuth_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) AppendPath(path DeviceSpecNetworkConfigCommonOptsAuth_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigCommonOptsAuth_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) GetPaths() []DeviceSpecNetworkConfigCommonOptsAuth_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigCommonOptsAuth_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) Set(target, source *Device_Spec_NetworkConfig_CommonOpts_Auth) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_CommonOpts_Auth), source.(*Device_Spec_NetworkConfig_CommonOpts_Auth))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) Project(source *Device_Spec_NetworkConfig_CommonOpts_Auth) *Device_Spec_NetworkConfig_CommonOpts_Auth {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_CommonOpts_Auth{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigCommonOptsAuth_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorKey:
				result.Key = source.Key
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorPassword:
				result.Password = source.Password
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorMethod:
				result.Method = source.Method
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorIdentity:
				result.Identity = source.Identity
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorAnonymousIdentity:
				result.AnonymousIdentity = source.AnonymousIdentity
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorCaCertificate:
				result.CaCertificate = source.CaCertificate
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorClientCertificate:
				result.ClientCertificate = source.ClientCertificate
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorClientKey:
				result.ClientKey = source.ClientKey
			case DeviceSpecNetworkConfigCommonOptsAuth_FieldPathSelectorClientKeyPassword:
				result.ClientKeyPassword = source.ClientKeyPassword
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_CommonOpts_Auth))
}

func (fieldMask *Device_Spec_NetworkConfig_CommonOpts_Auth_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_EthOpts_Match_FieldMask struct {
	Paths []DeviceSpecNetworkConfigEthOptsMatch_FieldPath
}

func FullDevice_Spec_NetworkConfig_EthOpts_Match_FieldMask() *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask {
	res := &Device_Spec_NetworkConfig_EthOpts_Match_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigEthOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkConfigEthOptsMatch_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigEthOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkConfigEthOptsMatch_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigEthOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkConfigEthOptsMatch_FieldPathSelectorDriver})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigEthOptsMatch_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigEthOptsMatch_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigEthOptsMatch_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) Subtract(other *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask {
	result := &Device_Spec_NetworkConfig_EthOpts_Match_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigEthOptsMatch_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_EthOpts_Match_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask {
	result := &Device_Spec_NetworkConfig_EthOpts_Match_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigEthOptsMatch_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigEthOptsMatch_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) AppendPath(path DeviceSpecNetworkConfigEthOptsMatch_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigEthOptsMatch_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) GetPaths() []DeviceSpecNetworkConfigEthOptsMatch_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigEthOptsMatch_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) Set(target, source *Device_Spec_NetworkConfig_EthOpts_Match) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_EthOpts_Match), source.(*Device_Spec_NetworkConfig_EthOpts_Match))
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) Project(source *Device_Spec_NetworkConfig_EthOpts_Match) *Device_Spec_NetworkConfig_EthOpts_Match {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_EthOpts_Match{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigEthOptsMatch_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigEthOptsMatch_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceSpecNetworkConfigEthOptsMatch_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkConfigEthOptsMatch_FieldPathSelectorDriver:
				result.Driver = source.Driver
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_EthOpts_Match))
}

func (fieldMask *Device_Spec_NetworkConfig_EthOpts_Match_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask struct {
	Paths []DeviceSpecNetworkConfigWifiOptsMatch_FieldPath
}

func FullDevice_Spec_NetworkConfig_WifiOpts_Match_FieldMask() *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask {
	res := &Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOptsMatch_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOptsMatch_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOptsMatch_FieldPathSelectorDriver})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigWifiOptsMatch_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigWifiOptsMatch_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigWifiOptsMatch_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) Subtract(other *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask {
	result := &Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigWifiOptsMatch_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask {
	result := &Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigWifiOptsMatch_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigWifiOptsMatch_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) AppendPath(path DeviceSpecNetworkConfigWifiOptsMatch_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigWifiOptsMatch_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) GetPaths() []DeviceSpecNetworkConfigWifiOptsMatch_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigWifiOptsMatch_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) Set(target, source *Device_Spec_NetworkConfig_WifiOpts_Match) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_WifiOpts_Match), source.(*Device_Spec_NetworkConfig_WifiOpts_Match))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) Project(source *Device_Spec_NetworkConfig_WifiOpts_Match) *Device_Spec_NetworkConfig_WifiOpts_Match {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_WifiOpts_Match{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigWifiOptsMatch_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigWifiOptsMatch_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceSpecNetworkConfigWifiOptsMatch_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkConfigWifiOptsMatch_FieldPathSelectorDriver:
				result.Driver = source.Driver
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_WifiOpts_Match))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_Match_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask struct {
	Paths []DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath
}

func FullDevice_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask() *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask {
	res := &Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPathSelectorPassword})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPathSelectorMode})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) Subtract(other *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask {
	result := &Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask {
	result := &Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) AppendPath(path DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) GetPaths() []DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) Set(target, source *Device_Spec_NetworkConfig_WifiOpts_AccessPoint) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_WifiOpts_AccessPoint), source.(*Device_Spec_NetworkConfig_WifiOpts_AccessPoint))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) Project(source *Device_Spec_NetworkConfig_WifiOpts_AccessPoint) *Device_Spec_NetworkConfig_WifiOpts_AccessPoint {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_WifiOpts_AccessPoint{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPathSelectorPassword:
				result.Password = source.Password
			case DeviceSpecNetworkConfigWifiOptsAccessPoint_FieldPathSelectorMode:
				result.Mode = source.Mode
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_WifiOpts_AccessPoint))
}

func (fieldMask *Device_Spec_NetworkConfig_WifiOpts_AccessPoint_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask struct {
	Paths []DeviceSpecNetworkConfigBridgesOptsParameters_FieldPath
}

func FullDevice_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask() *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask {
	res := &Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorAgeingTime})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorPriority})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorPortPriority})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorForwardDelay})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorHelloTime})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorMaxAge})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorPathCost})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorStp})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigBridgesOptsParameters_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigBridgesOptsParameters_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) Subtract(other *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask {
	result := &Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask {
	result := &Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigBridgesOptsParameters_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigBridgesOptsParameters_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) AppendPath(path DeviceSpecNetworkConfigBridgesOptsParameters_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigBridgesOptsParameters_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) GetPaths() []DeviceSpecNetworkConfigBridgesOptsParameters_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigBridgesOptsParameters_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) Set(target, source *Device_Spec_NetworkConfig_BridgesOpts_Parameters) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_BridgesOpts_Parameters), source.(*Device_Spec_NetworkConfig_BridgesOpts_Parameters))
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) Project(source *Device_Spec_NetworkConfig_BridgesOpts_Parameters) *Device_Spec_NetworkConfig_BridgesOpts_Parameters {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_BridgesOpts_Parameters{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigBridgesOptsParameters_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorAgeingTime:
				result.AgeingTime = source.AgeingTime
			case DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorPriority:
				result.Priority = source.Priority
			case DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorPortPriority:
				result.PortPriority = source.PortPriority
			case DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorForwardDelay:
				result.ForwardDelay = source.ForwardDelay
			case DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorHelloTime:
				result.HelloTime = source.HelloTime
			case DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorMaxAge:
				result.MaxAge = source.MaxAge
			case DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorPathCost:
				result.PathCost = source.PathCost
			case DeviceSpecNetworkConfigBridgesOptsParameters_FieldPathSelectorStp:
				result.Stp = source.Stp
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_BridgesOpts_Parameters))
}

func (fieldMask *Device_Spec_NetworkConfig_BridgesOpts_Parameters_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask struct {
	Paths []DeviceSpecNetworkConfigBondsOptsParameters_FieldPath
}

func FullDevice_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask() *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask {
	res := &Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorMode})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorLacpRate})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorMiiMonitorInterval})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorMinLinks})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorTransmitHashPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorAdSelect})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorAllSlavesActive})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorArpIpTargets})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorArpValidate})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorArpAllTargets})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorUpDelay})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorFailOverMacPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorGratuitousArp})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorPacketsPerSlave})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorPrimaryReselectPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorResendIgmp})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorLearnPacketInterval})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorPrimary})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigBondsOptsParameters_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 18)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigBondsOptsParameters_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) Subtract(other *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask {
	result := &Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask{}
	removedSelectors := make([]bool, 18)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask {
	result := &Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigBondsOptsParameters_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigBondsOptsParameters_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) AppendPath(path DeviceSpecNetworkConfigBondsOptsParameters_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigBondsOptsParameters_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) GetPaths() []DeviceSpecNetworkConfigBondsOptsParameters_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigBondsOptsParameters_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) Set(target, source *Device_Spec_NetworkConfig_BondsOpts_Parameters) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_BondsOpts_Parameters), source.(*Device_Spec_NetworkConfig_BondsOpts_Parameters))
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) Project(source *Device_Spec_NetworkConfig_BondsOpts_Parameters) *Device_Spec_NetworkConfig_BondsOpts_Parameters {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_BondsOpts_Parameters{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigBondsOptsParameters_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorMode:
				result.Mode = source.Mode
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorLacpRate:
				result.LacpRate = source.LacpRate
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorMiiMonitorInterval:
				result.MiiMonitorInterval = source.MiiMonitorInterval
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorMinLinks:
				result.MinLinks = source.MinLinks
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorTransmitHashPolicy:
				result.TransmitHashPolicy = source.TransmitHashPolicy
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorAdSelect:
				result.AdSelect = source.AdSelect
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorAllSlavesActive:
				result.AllSlavesActive = source.AllSlavesActive
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorArpIpTargets:
				result.ArpIpTargets = source.ArpIpTargets
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorArpValidate:
				result.ArpValidate = source.ArpValidate
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorArpAllTargets:
				result.ArpAllTargets = source.ArpAllTargets
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorUpDelay:
				result.UpDelay = source.UpDelay
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorFailOverMacPolicy:
				result.FailOverMacPolicy = source.FailOverMacPolicy
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorGratuitousArp:
				result.GratuitousArp = source.GratuitousArp
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorPacketsPerSlave:
				result.PacketsPerSlave = source.PacketsPerSlave
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorPrimaryReselectPolicy:
				result.PrimaryReselectPolicy = source.PrimaryReselectPolicy
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorResendIgmp:
				result.ResendIgmp = source.ResendIgmp
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorLearnPacketInterval:
				result.LearnPacketInterval = source.LearnPacketInterval
			case DeviceSpecNetworkConfigBondsOptsParameters_FieldPathSelectorPrimary:
				result.Primary = source.Primary
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_BondsOpts_Parameters))
}

func (fieldMask *Device_Spec_NetworkConfig_BondsOpts_Parameters_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask struct {
	Paths []DeviceSpecNetworkConfigTunnelsOptsKey_FieldPath
}

func FullDevice_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask() *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask {
	res := &Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigTunnelsOptsKey_FieldTerminalPath{selector: DeviceSpecNetworkConfigTunnelsOptsKey_FieldPathSelectorInput})
	res.Paths = append(res.Paths, &DeviceSpecNetworkConfigTunnelsOptsKey_FieldTerminalPath{selector: DeviceSpecNetworkConfigTunnelsOptsKey_FieldPathSelectorOutput})
	return res
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkConfigTunnelsOptsKey_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkConfigTunnelsOptsKey_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkConfigTunnelsOptsKey_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) Subtract(other *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask {
	result := &Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkConfigTunnelsOptsKey_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) FilterInputFields() *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask {
	result := &Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkConfigTunnelsOptsKey_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkConfigTunnelsOptsKey_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) AppendPath(path DeviceSpecNetworkConfigTunnelsOptsKey_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkConfigTunnelsOptsKey_FieldPath))
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) GetPaths() []DeviceSpecNetworkConfigTunnelsOptsKey_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkConfigTunnelsOptsKey_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) Set(target, source *Device_Spec_NetworkConfig_TunnelsOpts_Key) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkConfig_TunnelsOpts_Key), source.(*Device_Spec_NetworkConfig_TunnelsOpts_Key))
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) Project(source *Device_Spec_NetworkConfig_TunnelsOpts_Key) *Device_Spec_NetworkConfig_TunnelsOpts_Key {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkConfig_TunnelsOpts_Key{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkConfigTunnelsOptsKey_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkConfigTunnelsOptsKey_FieldPathSelectorInput:
				result.Input = source.Input
			case DeviceSpecNetworkConfigTunnelsOptsKey_FieldPathSelectorOutput:
				result.Output = source.Output
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkConfig_TunnelsOpts_Key))
}

func (fieldMask *Device_Spec_NetworkConfig_TunnelsOpts_Key_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_SSHConfig_AuthKey_FieldMask struct {
	Paths []DeviceSpecSSHConfigAuthKey_FieldPath
}

func FullDevice_Spec_SSHConfig_AuthKey_FieldMask() *Device_Spec_SSHConfig_AuthKey_FieldMask {
	res := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorSshaKey})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorCertAuthority})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorCommand})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorEnvironment})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorFrom})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoAgentForwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPortForwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPty})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoUserRc})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoX11Forwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorPermitopen})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorPrincipals})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorTunnel})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorRestrict})
	return res
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 14)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecSSHConfigAuthKey_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecSSHConfigAuthKey_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Subtract(other *Device_Spec_SSHConfig_AuthKey_FieldMask) *Device_Spec_SSHConfig_AuthKey_FieldMask {
	result := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	removedSelectors := make([]bool, 14)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecSSHConfigAuthKey_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_SSHConfig_AuthKey_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) FilterInputFields() *Device_Spec_SSHConfig_AuthKey_FieldMask {
	result := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecSSHConfigAuthKey_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_SSHConfig_AuthKey_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_SSHConfig_AuthKey_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) AppendPath(path DeviceSpecSSHConfigAuthKey_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecSSHConfigAuthKey_FieldPath))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) GetPaths() []DeviceSpecSSHConfigAuthKey_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Set(target, source *Device_Spec_SSHConfig_AuthKey) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_SSHConfig_AuthKey), source.(*Device_Spec_SSHConfig_AuthKey))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Project(source *Device_Spec_SSHConfig_AuthKey) *Device_Spec_SSHConfig_AuthKey {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_SSHConfig_AuthKey{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecSSHConfigAuthKey_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorSshaKey:
				result.SshaKey = source.SshaKey
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorCertAuthority:
				result.CertAuthority = source.CertAuthority
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorCommand:
				result.Command = source.Command
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorEnvironment:
				result.Environment = source.Environment
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorFrom:
				result.From = source.From
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoAgentForwarding:
				result.NoAgentForwarding = source.NoAgentForwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPortForwarding:
				result.NoPortForwarding = source.NoPortForwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPty:
				result.NoPty = source.NoPty
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoUserRc:
				result.NoUserRc = source.NoUserRc
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoX11Forwarding:
				result.NoX11Forwarding = source.NoX11Forwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorPermitopen:
				result.Permitopen = source.Permitopen
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorPrincipals:
				result.Principals = source.Principals
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorTunnel:
				result.Tunnel = source.Tunnel
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorRestrict:
				result.Restrict = source.Restrict
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_SSHConfig_AuthKey))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_Address_FieldMask struct {
	Paths []DeviceStatusAddress_FieldPath
}

func FullDevice_Status_Address_FieldMask() *Device_Status_Address_FieldMask {
	res := &Device_Status_Address_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusAddress_FieldTerminalPath{selector: DeviceStatusAddress_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceStatusAddress_FieldTerminalPath{selector: DeviceStatusAddress_FieldPathSelectorType})
	return res
}

func (fieldMask *Device_Status_Address_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_Address_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_Address_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusAddress_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusAddress_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_Address_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusAddress_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_Address_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_Address_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_Address_FieldMask) Subtract(other *Device_Status_Address_FieldMask) *Device_Status_Address_FieldMask {
	result := &Device_Status_Address_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusAddress_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_Address_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_Address_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_Address_FieldMask) FilterInputFields() *Device_Status_Address_FieldMask {
	result := &Device_Status_Address_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_Address_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_Address_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusAddress_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusAddress_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_Address_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_Address_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_Address_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_Address_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) AppendPath(path DeviceStatusAddress_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_Address_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusAddress_FieldPath))
}

func (fieldMask *Device_Status_Address_FieldMask) GetPaths() []DeviceStatusAddress_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_Address_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_Address_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusAddress_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) Set(target, source *Device_Status_Address) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_Address_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_Address), source.(*Device_Status_Address))
}

func (fieldMask *Device_Status_Address_FieldMask) Project(source *Device_Status_Address) *Device_Status_Address {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_Address{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusAddress_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusAddress_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceStatusAddress_FieldPathSelectorType:
				result.Type = source.Type
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_Address_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_Address))
}

func (fieldMask *Device_Status_Address_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_Condition_FieldMask struct {
	Paths []DeviceStatusCondition_FieldPath
}

func FullDevice_Status_Condition_FieldMask() *Device_Status_Condition_FieldMask {
	res := &Device_Status_Condition_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorMessage})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorReason})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorType})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorLastHeartBeatTime})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorLastTransitionTime})
	return res
}

func (fieldMask *Device_Status_Condition_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_Condition_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_Condition_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusCondition_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusCondition_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_Condition_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusCondition_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_Condition_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_Condition_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_Condition_FieldMask) Subtract(other *Device_Status_Condition_FieldMask) *Device_Status_Condition_FieldMask {
	result := &Device_Status_Condition_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusCondition_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_Condition_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_Condition_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_Condition_FieldMask) FilterInputFields() *Device_Status_Condition_FieldMask {
	result := &Device_Status_Condition_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_Condition_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_Condition_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusCondition_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusCondition_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_Condition_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_Condition_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_Condition_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_Condition_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) AppendPath(path DeviceStatusCondition_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_Condition_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusCondition_FieldPath))
}

func (fieldMask *Device_Status_Condition_FieldMask) GetPaths() []DeviceStatusCondition_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_Condition_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_Condition_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusCondition_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) Set(target, source *Device_Status_Condition) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_Condition_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_Condition), source.(*Device_Status_Condition))
}

func (fieldMask *Device_Status_Condition_FieldMask) Project(source *Device_Status_Condition) *Device_Status_Condition {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_Condition{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusCondition_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusCondition_FieldPathSelectorMessage:
				result.Message = source.Message
			case DeviceStatusCondition_FieldPathSelectorReason:
				result.Reason = source.Reason
			case DeviceStatusCondition_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusCondition_FieldPathSelectorType:
				result.Type = source.Type
			case DeviceStatusCondition_FieldPathSelectorLastHeartBeatTime:
				result.LastHeartBeatTime = source.LastHeartBeatTime
			case DeviceStatusCondition_FieldPathSelectorLastTransitionTime:
				result.LastTransitionTime = source.LastTransitionTime
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_Condition_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_Condition))
}

func (fieldMask *Device_Status_Condition_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_FieldMask() *Device_Status_DeviceInfo_FieldMask {
	res := &Device_Status_DeviceInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorArchitecture})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOperatingSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorKernelVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOsImage})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorContainerRuntimeVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOsVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorDriver})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_FieldMask) *Device_Status_DeviceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[DeviceStatusDeviceInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation: &Device_Status_DeviceInfo_HardwareInformation_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation: &Device_Status_DeviceInfo_HardwareInformation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
						mySubMasks[DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation] = FullDevice_Status_DeviceInfo_HardwareInformation_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo), source.(*Device_Status_DeviceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Project(source *Device_Status_DeviceInfo) *Device_Status_DeviceInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo{}
	hardwareInformationMask := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	wholeHardwareInformationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfo_FieldPathSelectorArchitecture:
				result.Architecture = source.Architecture
			case DeviceStatusDeviceInfo_FieldPathSelectorOperatingSystem:
				result.OperatingSystem = source.OperatingSystem
			case DeviceStatusDeviceInfo_FieldPathSelectorKernelVersion:
				result.KernelVersion = source.KernelVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorOsImage:
				result.OsImage = source.OsImage
			case DeviceStatusDeviceInfo_FieldPathSelectorContainerRuntimeVersion:
				result.ContainerRuntimeVersion = source.ContainerRuntimeVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorOsVersion:
				result.OsVersion = source.OsVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorDriver:
				result.Driver = source.Driver
			case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
				result.HardwareInformation = source.HardwareInformation
				wholeHardwareInformationAccepted = true
			}
		case *DeviceStatusDeviceInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
				hardwareInformationMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformation_FieldPath))
			}
		}
	}
	if wholeHardwareInformationAccepted == false && len(hardwareInformationMask.Paths) > 0 {
		result.HardwareInformation = hardwareInformationMask.Project(source.GetHardwareInformation())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformation_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	removedSelectors := make([]bool, 10)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:         &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:       &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:     &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:        &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:      &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:    &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:        &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:  &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo: &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:         &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:       &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:     &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:        &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:      &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:    &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:        &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:  &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo: &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformation_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs] = FullDevice_Status_DeviceInfo_HardwareInformation_OS_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios] = FullDevice_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem] = FullDevice_Status_DeviceInfo_HardwareInformation_System_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork] = FullDevice_Status_DeviceInfo_HardwareInformation_Network_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu] = FullDevice_Status_DeviceInfo_HardwareInformation_GPU_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformation_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation), source.(*Device_Status_DeviceInfo_HardwareInformation))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation) *Device_Status_DeviceInfo_HardwareInformation {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation{}
	osMask := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	wholeOsAccepted := false
	biosMask := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	wholeBiosAccepted := false
	systemMask := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	wholeSystemAccepted := false
	cpuMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	wholeCpuAccepted := false
	blockMask := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	wholeBlockAccepted := false
	networkMask := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	wholeNetworkAccepted := false
	gpuMask := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	wholeGpuAccepted := false
	memoryInfoMask := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	wholeMemoryInfoAccepted := false
	hailoInfoMask := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	wholeHailoInfoAccepted := false
	nvidiaInfoMask := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	wholeNvidiaInfoAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
				result.Os = source.Os
				wholeOsAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
				result.Bios = source.Bios
				wholeBiosAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
				result.System = source.System
				wholeSystemAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
				result.Cpu = source.Cpu
				wholeCpuAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
				result.Block = source.Block
				wholeBlockAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
				result.Network = source.Network
				wholeNetworkAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
				result.Gpu = source.Gpu
				wholeGpuAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
				result.MemoryInfo = source.MemoryInfo
				wholeMemoryInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
				result.HailoInfo = source.HailoInfo
				wholeHailoInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
				result.NvidiaInfo = source.NvidiaInfo
				wholeNvidiaInfoAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformation_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
				osMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationOS_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
				biosMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
				systemMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
				cpuMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
				blockMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
				networkMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
				gpuMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
				memoryInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
				hailoInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
				nvidiaInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath))
			}
		}
	}
	if wholeOsAccepted == false && len(osMask.Paths) > 0 {
		result.Os = osMask.Project(source.GetOs())
	}
	if wholeBiosAccepted == false && len(biosMask.Paths) > 0 {
		result.Bios = biosMask.Project(source.GetBios())
	}
	if wholeSystemAccepted == false && len(systemMask.Paths) > 0 {
		result.System = systemMask.Project(source.GetSystem())
	}
	if wholeCpuAccepted == false && len(cpuMask.Paths) > 0 {
		result.Cpu = cpuMask.Project(source.GetCpu())
	}
	if wholeBlockAccepted == false && len(blockMask.Paths) > 0 {
		result.Block = blockMask.Project(source.GetBlock())
	}
	if wholeNetworkAccepted == false && len(networkMask.Paths) > 0 {
		result.Network = networkMask.Project(source.GetNetwork())
	}
	if wholeGpuAccepted == false && len(gpuMask.Paths) > 0 {
		result.Gpu = gpuMask.Project(source.GetGpu())
	}
	if wholeMemoryInfoAccepted == false && len(memoryInfoMask.Paths) > 0 {
		result.MemoryInfo = memoryInfoMask.Project(source.GetMemoryInfo())
	}
	if wholeHailoInfoAccepted == false && len(hailoInfoMask.Paths) > 0 {
		result.HailoInfo = hailoInfoMask.Project(source.GetHailoInfo())
	}
	if wholeNvidiaInfoAccepted == false && len(nvidiaInfoMask.Paths) > 0 {
		result.NvidiaInfo = nvidiaInfoMask.Project(source.GetNvidiaInfo())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Capability_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorDescription})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Capability) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Capability), source.(*Device_Status_DeviceInfo_HardwareInformation_Capability))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Capability) *Device_Status_DeviceInfo_HardwareInformation_Capability {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorDescription:
				result.Description = source.Description
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Capability))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationOS_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_OS_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOperatingSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorKernelVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOsImage})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorContainerRuntimeVersion})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationOS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationOS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationOS_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationOS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_OS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_OS), source.(*Device_Status_DeviceInfo_HardwareInformation_OS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_OS) *Device_Status_DeviceInfo_HardwareInformation_OS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_OS{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOperatingSystem:
				result.OperatingSystem = source.OperatingSystem
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorKernelVersion:
				result.KernelVersion = source.KernelVersion
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOsImage:
				result.OsImage = source.OsImage
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorContainerRuntimeVersion:
				result.ContainerRuntimeVersion = source.ContainerRuntimeVersion
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_OS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorBiosVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorReleaseDate})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_BIOS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_BIOS), source.(*Device_Status_DeviceInfo_HardwareInformation_BIOS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_BIOS) *Device_Status_DeviceInfo_HardwareInformation_BIOS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorBiosVersion:
				result.BiosVersion = source.BiosVersion
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorReleaseDate:
				result.ReleaseDate = source.ReleaseDate
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_BIOS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_System_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_System_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorManufacturer})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration: &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration: &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration] = FullDevice_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_System_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_System) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_System), source.(*Device_Status_DeviceInfo_HardwareInformation_System))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_System) *Device_Status_DeviceInfo_HardwareInformation_System {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_System{}
	configurationMask := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	wholeConfigurationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorManufacturer:
				result.Manufacturer = source.Manufacturer
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorVersion:
				result.Version = source.Version
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
				result.Configuration = source.Configuration
				wholeConfigurationAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
				configurationMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath))
			}
		}
	}
	if wholeConfigurationAccepted == false && len(configurationMask.Paths) > 0 {
		result.Configuration = configurationMask.Project(source.GetConfiguration())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_System))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors: &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors: &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU) *Device_Status_DeviceInfo_HardwareInformation_CPU {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU{}
	processorsMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	wholeProcessorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
				result.Processors = source.Processors
				wholeProcessorsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
				processorsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath))
			}
		}
	}
	if wholeProcessorsAccepted == false && len(processorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProcessors() {
			result.Processors = append(result.Processors, processorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block), source.(*Device_Status_DeviceInfo_HardwareInformation_Block))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block) *Device_Status_DeviceInfo_HardwareInformation_Block {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block{}
	disksMask := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	wholeDisksAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
				result.Disks = source.Disks
				wholeDisksAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
				disksMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath))
			}
		}
	}
	if wholeDisksAccepted == false && len(disksMask.Paths) > 0 {
		for _, sourceItem := range source.GetDisks() {
			result.Disks = append(result.Disks, disksMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Network_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics: &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics: &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics] = FullDevice_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Network) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Network), source.(*Device_Status_DeviceInfo_HardwareInformation_Network))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Network) *Device_Status_DeviceInfo_HardwareInformation_Network {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Network{}
	nicsMask := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	wholeNicsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
				result.Nics = source.Nics
				wholeNicsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
				nicsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath))
			}
		}
	}
	if wholeNicsAccepted == false && len(nicsMask.Paths) > 0 {
		for _, sourceItem := range source.GetNics() {
			result.Nics = append(result.Nics, nicsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Network))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_GPU_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards: &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards: &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards] = FullDevice_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_GPU) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_GPU), source.(*Device_Status_DeviceInfo_HardwareInformation_GPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_GPU) *Device_Status_DeviceInfo_HardwareInformation_GPU {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU{}
	graphicCardsMask := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	wholeGraphicCardsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
				result.GraphicCards = source.GraphicCards
				wholeGraphicCardsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
				graphicCardsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath))
			}
		}
	}
	if wholeGraphicCardsAccepted == false && len(graphicCardsMask.Paths) > 0 {
		for _, sourceItem := range source.GetGraphicCards() {
			result.GraphicCards = append(result.GraphicCards, graphicCardsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_GPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorProduct})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorSubvendor})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_PCIDevice) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice), source.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_PCIDevice) *Device_Status_DeviceInfo_HardwareInformation_PCIDevice {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorProduct:
				result.Product = source.Product
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorSubvendor:
				result.Subvendor = source.Subvendor
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory] = FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo{}
	memoryMask := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{}
	wholeMemoryAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory:
				result.Memory = source.Memory
				wholeMemoryAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory:
				memoryMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath))
			}
		}
	}
	if wholeMemoryAccepted == false && len(memoryMask.Paths) > 0 {
		for _, sourceItem := range source.GetMemory() {
			result.Memory = append(result.Memory, memoryMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorCliVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules: &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules: &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules] = FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo{}
	modulesMask := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	wholeModulesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorCliVersion:
				result.CliVersion = source.CliVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
				result.Modules = source.Modules
				wholeModulesAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
				modulesMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath))
			}
		}
	}
	if wholeModulesAccepted == false && len(modulesMask.Paths) > 0 {
		for _, sourceItem := range source.GetModules() {
			result.Modules = append(result.Modules, modulesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorDriverVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorCudaVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus: &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus: &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus] = FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo{}
	gpusMask := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	wholeGpusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorDriverVersion:
				result.DriverVersion = source.DriverVersion
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorCudaVersion:
				result.CudaVersion = source.CudaVersion
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
				result.Gpus = source.Gpus
				wholeGpusAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
				gpusMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath))
			}
		}
	}
	if wholeGpusAccepted == false && len(gpusMask.Paths) > 0 {
		for _, sourceItem := range source.GetGpus() {
			result.Gpus = append(result.Gpus, gpusMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorChassis})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorUuid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorSkuNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorFamily})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_System_Configuration) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration), source.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_System_Configuration) *Device_Status_DeviceInfo_HardwareInformation_System_Configuration {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorChassis:
				result.Chassis = source.Chassis
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorUuid:
				result.Uuid = source.Uuid
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorSkuNumber:
				result.SkuNumber = source.SkuNumber
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorFamily:
				result.Family = source.Family
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumThreads})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumCores})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumEnabledCores})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorSerial})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorFrequencyMhz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorMaxFrequencyMhz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorDriver})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorLatency})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorClock})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 14)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	removedSelectors := make([]bool, 14)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities: &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:    &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities: &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:    &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities] = FullDevice_Status_DeviceInfo_HardwareInformation_Capability_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor{}
	capabilitiesMask := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	wholeCapabilitiesAccepted := false
	cacheInfoMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	wholeCacheInfoAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorModel:
				result.Model = source.Model
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
				result.Capabilities = source.Capabilities
				wholeCapabilitiesAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumThreads:
				result.NumThreads = source.NumThreads
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumCores:
				result.NumCores = source.NumCores
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumEnabledCores:
				result.NumEnabledCores = source.NumEnabledCores
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorSerial:
				result.Serial = source.Serial
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorFrequencyMhz:
				result.FrequencyMhz = source.FrequencyMhz
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorMaxFrequencyMhz:
				result.MaxFrequencyMhz = source.MaxFrequencyMhz
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
				result.CacheInfo = source.CacheInfo
				wholeCacheInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorDriver:
				result.Driver = source.Driver
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorLatency:
				result.Latency = source.Latency
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorClock:
				result.Clock = source.Clock
			}
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
				capabilitiesMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
				cacheInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath))
			}
		}
	}
	if wholeCapabilitiesAccepted == false && len(capabilitiesMask.Paths) > 0 {
		for _, sourceItem := range source.GetCapabilities() {
			result.Capabilities = append(result.Capabilities, capabilitiesMask.Project(sourceItem))
		}
	}
	if wholeCacheInfoAccepted == false && len(cacheInfoMask.Paths) > 0 {
		for _, sourceItem := range source.GetCacheInfo() {
			result.CacheInfo = append(result.CacheInfo, cacheInfoMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorType})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorSizeBytes})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorType:
				result.Type = source.Type
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorDriveType})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorWwn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk), source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk{}
	partitionsMask := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	wholePartitionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorDriveType:
				result.DriveType = source.DriveType
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorModel:
				result.Model = source.Model
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorWwn:
				result.Wwn = source.Wwn
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
				result.Partitions = source.Partitions
				wholePartitionsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
				partitionsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath))
			}
		}
	}
	if wholePartitionsAccepted == false && len(partitionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetPartitions() {
			result.Partitions = append(result.Partitions, partitionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorMountPoint})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorType})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition), source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorMountPoint:
				result.MountPoint = source.MountPoint
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorType:
				result.Type = source.Type
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorMacAddress})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVirtual})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSubvendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Network_NIC) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC), source.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Network_NIC) *Device_Status_DeviceInfo_HardwareInformation_Network_NIC {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC{}
	var settingMapKeys []string
	wholeSettingAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorMacAddress:
				result.MacAddress = source.MacAddress
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVirtual:
				result.Virtual = source.Virtual
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSubvendor:
				result.Subvendor = source.Subvendor
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting:
				result.Setting = source.Setting
				wholeSettingAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathMap:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting:
				settingMapKeys = append(settingMapKeys, tp.key)
			}
		}
	}
	if wholeSettingAccepted == false && len(settingMapKeys) > 0 && source.GetSetting() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetSetting()
		for _, key := range settingMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Setting = copiedMap
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorIndex})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice: &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice: &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice] = FullDevice_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard), source.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard) *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard{}
	deviceMask := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	wholeDeviceAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorIndex:
				result.Index = source.Index
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
				result.Device = source.Device
				wholeDeviceAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
				deviceMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath))
			}
		}
	}
	if wholeDeviceAccepted == false && len(deviceMask.Paths) > 0 {
		result.Device = deviceMask.Project(source.GetDevice())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks] = FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory), source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory{}
	memoryBanksMask := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{}
	wholeMemoryBanksAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks:
				result.MemoryBanks = source.MemoryBanks
				wholeMemoryBanksAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks:
				memoryBanksMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath))
			}
		}
	}
	if wholeMemoryBanksAccepted == false && len(memoryBanksMask.Paths) > 0 {
		for _, sourceItem := range source.GetMemoryBanks() {
			result.MemoryBanks = append(result.MemoryBanks, memoryBanksMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorProduct})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSerial})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSlot})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorFrequencyHz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorWidthBits})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank), source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorProduct:
				result.Product = source.Product
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSerial:
				result.Serial = source.Serial
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSlot:
				result.Slot = source.Slot
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorFrequencyHz:
				result.FrequencyHz = source.FrequencyHz
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorWidthBits:
				result.WidthBits = source.WidthBits
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorDevId})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorControlProtoVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorFirmwareVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorLoggerVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorBoardName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorPartNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorNeuralNetworkCoreClockRate})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	removedSelectors := make([]bool, 9)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorDevId:
				result.DevId = source.DevId
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorControlProtoVersion:
				result.ControlProtoVersion = source.ControlProtoVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorFirmwareVersion:
				result.FirmwareVersion = source.FirmwareVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorLoggerVersion:
				result.LoggerVersion = source.LoggerVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorBoardName:
				result.BoardName = source.BoardName
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorPartNumber:
				result.PartNumber = source.PartNumber
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorNeuralNetworkCoreClockRate:
				result.NeuralNetworkCoreClockRate = source.NeuralNetworkCoreClockRate
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorId})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorProductName})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorId:
				result.Id = source.Id
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
