// Code generated by protoc-gen-goten-object
// File: edgelq/devices/proto/v1alpha2/device.proto
// DO NOT EDIT!!!

package device

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	ntt_meta "github.com/cloudwan/edgelq-sdk/common/types/meta"
	project "github.com/cloudwan/edgelq-sdk/devices/resources/v1alpha2/project"
	iam_attestation_domain "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/attestation_domain"
	iam_iam_common "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/common"
	iam_service_account "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/service_account"
	duration "github.com/golang/protobuf/ptypes/duration"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &ntt_meta.Meta{}
	_ = &project.Project{}
	_ = &iam_attestation_domain.AttestationDomain{}
	_ = &iam_iam_common.PCR{}
	_ = &iam_service_account.ServiceAccount{}
	_ = &duration.Duration{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
)

type Device_FieldMask struct {
	Paths []Device_FieldPath
}

func FullDevice_FieldMask() *Device_FieldMask {
	res := &Device_FieldMask{}
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorSpec})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorPublicListingSpec})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorDisplayName})
	return res
}

func (fieldMask *Device_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDevice_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Device_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDevice_FieldPath(raw)
	})
}

func (fieldMask *Device_FieldMask) ProtoMessage() {}

func (fieldMask *Device_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_FieldMask) Subtract(other *Device_FieldMask) *Device_FieldMask {
	result := &Device_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[Device_FieldPathSelector]gotenobject.FieldMask{
		Device_FieldPathSelectorMetadata:          &ntt_meta.Meta_FieldMask{},
		Device_FieldPathSelectorSpec:              &Device_Spec_FieldMask{},
		Device_FieldPathSelectorStatus:            &Device_Status_FieldMask{},
		Device_FieldPathSelectorPublicListingSpec: &Device_PublicListingSpec_FieldMask{},
	}
	mySubMasks := map[Device_FieldPathSelector]gotenobject.FieldMask{
		Device_FieldPathSelectorMetadata:          &ntt_meta.Meta_FieldMask{},
		Device_FieldPathSelectorSpec:              &Device_Spec_FieldMask{},
		Device_FieldPathSelectorStatus:            &Device_Status_FieldMask{},
		Device_FieldPathSelectorPublicListingSpec: &Device_PublicListingSpec_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Device_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Device_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Device_FieldTerminalPath); ok {
					switch tp.selector {
					case Device_FieldPathSelectorMetadata:
						mySubMasks[Device_FieldPathSelectorMetadata] = ntt_meta.FullMeta_FieldMask()
					case Device_FieldPathSelectorSpec:
						mySubMasks[Device_FieldPathSelectorSpec] = FullDevice_Spec_FieldMask()
					case Device_FieldPathSelectorStatus:
						mySubMasks[Device_FieldPathSelectorStatus] = FullDevice_Status_FieldMask()
					case Device_FieldPathSelectorPublicListingSpec:
						mySubMasks[Device_FieldPathSelectorPublicListingSpec] = FullDevice_PublicListingSpec_FieldMask()
					}
				} else if tp, ok := path.(*Device_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Device_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_FieldMask) FilterInputFields() *Device_FieldMask {
	result := &Device_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case Device_FieldPathSelectorMetadata:
			if _, ok := path.(*Device_FieldTerminalPath); ok {
				for _, subpath := range ntt_meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Device_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Device_FieldSubPath); ok {
				selectedMask := &ntt_meta.Meta_FieldMask{
					Paths: []ntt_meta.Meta_FieldPath{sub.subPath.(ntt_meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Device_FieldSubPath{selector: Device_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Device_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDevice_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_FieldMask) AppendPath(path Device_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Device_FieldPath))
}

func (fieldMask *Device_FieldMask) GetPaths() []Device_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDevice_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_FieldMask) Set(target, source *Device) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device), source.(*Device))
}

func (fieldMask *Device_FieldMask) Project(source *Device) *Device {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device{}
	metadataMask := &ntt_meta.Meta_FieldMask{}
	wholeMetadataAccepted := false
	specMask := &Device_Spec_FieldMask{}
	wholeSpecAccepted := false
	statusMask := &Device_Status_FieldMask{}
	wholeStatusAccepted := false
	publicListingSpecMask := &Device_PublicListingSpec_FieldMask{}
	wholePublicListingSpecAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Device_FieldTerminalPath:
			switch tp.selector {
			case Device_FieldPathSelectorName:
				result.Name = source.Name
			case Device_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case Device_FieldPathSelectorSpec:
				result.Spec = source.Spec
				wholeSpecAccepted = true
			case Device_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			case Device_FieldPathSelectorPublicListingSpec:
				result.PublicListingSpec = source.PublicListingSpec
				wholePublicListingSpecAccepted = true
			case Device_FieldPathSelectorDisplayName:
				result.DisplayName = source.DisplayName
			}
		case *Device_FieldSubPath:
			switch tp.selector {
			case Device_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(ntt_meta.Meta_FieldPath))
			case Device_FieldPathSelectorSpec:
				specMask.AppendPath(tp.subPath.(DeviceSpec_FieldPath))
			case Device_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(DeviceStatus_FieldPath))
			case Device_FieldPathSelectorPublicListingSpec:
				publicListingSpecMask.AppendPath(tp.subPath.(DevicePublicListingSpec_FieldPath))
			}
		}
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	if wholeSpecAccepted == false && len(specMask.Paths) > 0 {
		result.Spec = specMask.Project(source.GetSpec())
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	if wholePublicListingSpecAccepted == false && len(publicListingSpecMask.Paths) > 0 {
		result.PublicListingSpec = publicListingSpecMask.Project(source.GetPublicListingSpec())
	}
	return result
}

func (fieldMask *Device_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device))
}

func (fieldMask *Device_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_FieldMask struct {
	Paths []DeviceSpec_FieldPath
}

func FullDevice_Spec_FieldMask() *Device_Spec_FieldMask {
	res := &Device_Spec_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorServiceAccount})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorOsVersion})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorNetplanConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorNetplanApiConfigMode})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorOsImageUrl})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorSshConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorAttestationConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorDisableDeviceDiscovery})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorLoggingConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorProxyConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorLocation})
	return res
}

func (fieldMask *Device_Spec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpec_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_FieldMask) Subtract(other *Device_Spec_FieldMask) *Device_Spec_FieldMask {
	result := &Device_Spec_FieldMask{}
	removedSelectors := make([]bool, 11)
	otherSubMasks := map[DeviceSpec_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpec_FieldPathSelectorNetplanConfig:     &Device_Spec_NetplanConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorSshConfig:         &Device_Spec_SSHConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorAttestationConfig: &Device_Spec_AttestationConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLoggingConfig:     &Device_Spec_LoggingConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorProxyConfig:       &Device_Spec_ProxyConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLocation:          &Device_Spec_Location_FieldMask{},
	}
	mySubMasks := map[DeviceSpec_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpec_FieldPathSelectorNetplanConfig:     &Device_Spec_NetplanConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorSshConfig:         &Device_Spec_SSHConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorAttestationConfig: &Device_Spec_AttestationConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLoggingConfig:     &Device_Spec_LoggingConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorProxyConfig:       &Device_Spec_ProxyConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLocation:          &Device_Spec_Location_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpec_FieldPathSelectorNetplanConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorNetplanConfig] = FullDevice_Spec_NetplanConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorSshConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorSshConfig] = FullDevice_Spec_SSHConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorAttestationConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorAttestationConfig] = FullDevice_Spec_AttestationConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorLoggingConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorLoggingConfig] = FullDevice_Spec_LoggingConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorProxyConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorProxyConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorLocation:
						mySubMasks[DeviceSpec_FieldPathSelectorLocation] = FullDevice_Spec_Location_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_FieldMask) FilterInputFields() *Device_Spec_FieldMask {
	result := &Device_Spec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) AppendPath(path DeviceSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpec_FieldPath))
}

func (fieldMask *Device_Spec_FieldMask) GetPaths() []DeviceSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_FieldMask) Set(target, source *Device_Spec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec), source.(*Device_Spec))
}

func (fieldMask *Device_Spec_FieldMask) Project(source *Device_Spec) *Device_Spec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec{}
	netplanConfigMask := &Device_Spec_NetplanConfig_FieldMask{}
	wholeNetplanConfigAccepted := false
	sshConfigMask := &Device_Spec_SSHConfig_FieldMask{}
	wholeSshConfigAccepted := false
	attestationConfigMask := &Device_Spec_AttestationConfig_FieldMask{}
	wholeAttestationConfigAccepted := false
	loggingConfigMask := &Device_Spec_LoggingConfig_FieldMask{}
	wholeLoggingConfigAccepted := false
	proxyConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeProxyConfigAccepted := false
	locationMask := &Device_Spec_Location_FieldMask{}
	wholeLocationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpec_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpec_FieldPathSelectorServiceAccount:
				result.ServiceAccount = source.ServiceAccount
			case DeviceSpec_FieldPathSelectorOsVersion:
				result.OsVersion = source.OsVersion
			case DeviceSpec_FieldPathSelectorNetplanConfig:
				result.NetplanConfig = source.NetplanConfig
				wholeNetplanConfigAccepted = true
			case DeviceSpec_FieldPathSelectorNetplanApiConfigMode:
				result.NetplanApiConfigMode = source.NetplanApiConfigMode
			case DeviceSpec_FieldPathSelectorOsImageUrl:
				result.OsImageUrl = source.OsImageUrl
			case DeviceSpec_FieldPathSelectorSshConfig:
				result.SshConfig = source.SshConfig
				wholeSshConfigAccepted = true
			case DeviceSpec_FieldPathSelectorAttestationConfig:
				result.AttestationConfig = source.AttestationConfig
				wholeAttestationConfigAccepted = true
			case DeviceSpec_FieldPathSelectorDisableDeviceDiscovery:
				result.DisableDeviceDiscovery = source.DisableDeviceDiscovery
			case DeviceSpec_FieldPathSelectorLoggingConfig:
				result.LoggingConfig = source.LoggingConfig
				wholeLoggingConfigAccepted = true
			case DeviceSpec_FieldPathSelectorProxyConfig:
				result.ProxyConfig = source.ProxyConfig
				wholeProxyConfigAccepted = true
			case DeviceSpec_FieldPathSelectorLocation:
				result.Location = source.Location
				wholeLocationAccepted = true
			}
		case *DeviceSpec_FieldSubPath:
			switch tp.selector {
			case DeviceSpec_FieldPathSelectorNetplanConfig:
				netplanConfigMask.AppendPath(tp.subPath.(DeviceSpecNetplanConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorSshConfig:
				sshConfigMask.AppendPath(tp.subPath.(DeviceSpecSSHConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorAttestationConfig:
				attestationConfigMask.AppendPath(tp.subPath.(DeviceSpecAttestationConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorLoggingConfig:
				loggingConfigMask.AppendPath(tp.subPath.(DeviceSpecLoggingConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorProxyConfig:
				proxyConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorLocation:
				locationMask.AppendPath(tp.subPath.(DeviceSpecLocation_FieldPath))
			}
		}
	}
	if wholeNetplanConfigAccepted == false && len(netplanConfigMask.Paths) > 0 {
		result.NetplanConfig = netplanConfigMask.Project(source.GetNetplanConfig())
	}
	if wholeSshConfigAccepted == false && len(sshConfigMask.Paths) > 0 {
		result.SshConfig = sshConfigMask.Project(source.GetSshConfig())
	}
	if wholeAttestationConfigAccepted == false && len(attestationConfigMask.Paths) > 0 {
		result.AttestationConfig = attestationConfigMask.Project(source.GetAttestationConfig())
	}
	if wholeLoggingConfigAccepted == false && len(loggingConfigMask.Paths) > 0 {
		result.LoggingConfig = loggingConfigMask.Project(source.GetLoggingConfig())
	}
	if wholeProxyConfigAccepted == false && len(proxyConfigMask.Paths) > 0 {
		result.ProxyConfig = proxyConfigMask.Project(source.GetProxyConfig())
	}
	if wholeLocationAccepted == false && len(locationMask.Paths) > 0 {
		result.Location = locationMask.Project(source.GetLocation())
	}
	return result
}

func (fieldMask *Device_Spec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec))
}

func (fieldMask *Device_Spec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_FieldMask struct {
	Paths []DeviceStatus_FieldPath
}

func FullDevice_Status_FieldMask() *Device_Status_FieldMask {
	res := &Device_Status_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorConditions})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorNetworkConfigState})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorProxyConfigStatus})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorDeviceInfo})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorAttestationStatus})
	return res
}

func (fieldMask *Device_Status_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_FieldMask) Subtract(other *Device_Status_FieldMask) *Device_Status_FieldMask {
	result := &Device_Status_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[DeviceStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatus_FieldPathSelectorAddresses:          &Device_Status_Address_FieldMask{},
		DeviceStatus_FieldPathSelectorConditions:         &Device_Status_Condition_FieldMask{},
		DeviceStatus_FieldPathSelectorNetworkConfigState: &Device_Status_NetworkConfigState_FieldMask{},
		DeviceStatus_FieldPathSelectorProxyConfigStatus:  &Device_Status_ProxyConfigStatus_FieldMask{},
		DeviceStatus_FieldPathSelectorDeviceInfo:         &Device_Status_DeviceInfo_FieldMask{},
		DeviceStatus_FieldPathSelectorAttestationStatus:  &iam_iam_common.PCR_FieldMask{},
	}
	mySubMasks := map[DeviceStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatus_FieldPathSelectorAddresses:          &Device_Status_Address_FieldMask{},
		DeviceStatus_FieldPathSelectorConditions:         &Device_Status_Condition_FieldMask{},
		DeviceStatus_FieldPathSelectorNetworkConfigState: &Device_Status_NetworkConfigState_FieldMask{},
		DeviceStatus_FieldPathSelectorProxyConfigStatus:  &Device_Status_ProxyConfigStatus_FieldMask{},
		DeviceStatus_FieldPathSelectorDeviceInfo:         &Device_Status_DeviceInfo_FieldMask{},
		DeviceStatus_FieldPathSelectorAttestationStatus:  &iam_iam_common.PCR_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatus_FieldPathSelectorAddresses:
						mySubMasks[DeviceStatus_FieldPathSelectorAddresses] = FullDevice_Status_Address_FieldMask()
					case DeviceStatus_FieldPathSelectorConditions:
						mySubMasks[DeviceStatus_FieldPathSelectorConditions] = FullDevice_Status_Condition_FieldMask()
					case DeviceStatus_FieldPathSelectorNetworkConfigState:
						mySubMasks[DeviceStatus_FieldPathSelectorNetworkConfigState] = FullDevice_Status_NetworkConfigState_FieldMask()
					case DeviceStatus_FieldPathSelectorProxyConfigStatus:
						mySubMasks[DeviceStatus_FieldPathSelectorProxyConfigStatus] = FullDevice_Status_ProxyConfigStatus_FieldMask()
					case DeviceStatus_FieldPathSelectorDeviceInfo:
						mySubMasks[DeviceStatus_FieldPathSelectorDeviceInfo] = FullDevice_Status_DeviceInfo_FieldMask()
					case DeviceStatus_FieldPathSelectorAttestationStatus:
						mySubMasks[DeviceStatus_FieldPathSelectorAttestationStatus] = iam_iam_common.FullPCR_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_FieldMask) FilterInputFields() *Device_Status_FieldMask {
	result := &Device_Status_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) AppendPath(path DeviceStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatus_FieldPath))
}

func (fieldMask *Device_Status_FieldMask) GetPaths() []DeviceStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_FieldMask) Set(target, source *Device_Status) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status), source.(*Device_Status))
}

func (fieldMask *Device_Status_FieldMask) Project(source *Device_Status) *Device_Status {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status{}
	addressesMask := &Device_Status_Address_FieldMask{}
	wholeAddressesAccepted := false
	conditionsMask := &Device_Status_Condition_FieldMask{}
	wholeConditionsAccepted := false
	networkConfigStateMask := &Device_Status_NetworkConfigState_FieldMask{}
	wholeNetworkConfigStateAccepted := false
	proxyConfigStatusMask := &Device_Status_ProxyConfigStatus_FieldMask{}
	wholeProxyConfigStatusAccepted := false
	deviceInfoMask := &Device_Status_DeviceInfo_FieldMask{}
	wholeDeviceInfoAccepted := false
	attestationStatusMask := &iam_iam_common.PCR_FieldMask{}
	wholeAttestationStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatus_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
				wholeAddressesAccepted = true
			case DeviceStatus_FieldPathSelectorConditions:
				result.Conditions = source.Conditions
				wholeConditionsAccepted = true
			case DeviceStatus_FieldPathSelectorNetworkConfigState:
				result.NetworkConfigState = source.NetworkConfigState
				wholeNetworkConfigStateAccepted = true
			case DeviceStatus_FieldPathSelectorProxyConfigStatus:
				result.ProxyConfigStatus = source.ProxyConfigStatus
				wholeProxyConfigStatusAccepted = true
			case DeviceStatus_FieldPathSelectorDeviceInfo:
				result.DeviceInfo = source.DeviceInfo
				wholeDeviceInfoAccepted = true
			case DeviceStatus_FieldPathSelectorAttestationStatus:
				result.AttestationStatus = source.AttestationStatus
				wholeAttestationStatusAccepted = true
			}
		case *DeviceStatus_FieldSubPath:
			switch tp.selector {
			case DeviceStatus_FieldPathSelectorAddresses:
				addressesMask.AppendPath(tp.subPath.(DeviceStatusAddress_FieldPath))
			case DeviceStatus_FieldPathSelectorConditions:
				conditionsMask.AppendPath(tp.subPath.(DeviceStatusCondition_FieldPath))
			case DeviceStatus_FieldPathSelectorNetworkConfigState:
				networkConfigStateMask.AppendPath(tp.subPath.(DeviceStatusNetworkConfigState_FieldPath))
			case DeviceStatus_FieldPathSelectorProxyConfigStatus:
				proxyConfigStatusMask.AppendPath(tp.subPath.(DeviceStatusProxyConfigStatus_FieldPath))
			case DeviceStatus_FieldPathSelectorDeviceInfo:
				deviceInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfo_FieldPath))
			case DeviceStatus_FieldPathSelectorAttestationStatus:
				attestationStatusMask.AppendPath(tp.subPath.(iam_iam_common.PCR_FieldPath))
			}
		}
	}
	if wholeAddressesAccepted == false && len(addressesMask.Paths) > 0 {
		for _, sourceItem := range source.GetAddresses() {
			result.Addresses = append(result.Addresses, addressesMask.Project(sourceItem))
		}
	}
	if wholeConditionsAccepted == false && len(conditionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetConditions() {
			result.Conditions = append(result.Conditions, conditionsMask.Project(sourceItem))
		}
	}
	if wholeNetworkConfigStateAccepted == false && len(networkConfigStateMask.Paths) > 0 {
		result.NetworkConfigState = networkConfigStateMask.Project(source.GetNetworkConfigState())
	}
	if wholeProxyConfigStatusAccepted == false && len(proxyConfigStatusMask.Paths) > 0 {
		result.ProxyConfigStatus = proxyConfigStatusMask.Project(source.GetProxyConfigStatus())
	}
	if wholeDeviceInfoAccepted == false && len(deviceInfoMask.Paths) > 0 {
		result.DeviceInfo = deviceInfoMask.Project(source.GetDeviceInfo())
	}
	if wholeAttestationStatusAccepted == false && len(attestationStatusMask.Paths) > 0 {
		for _, sourceItem := range source.GetAttestationStatus() {
			result.AttestationStatus = append(result.AttestationStatus, attestationStatusMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status))
}

func (fieldMask *Device_Status_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_PublicListingSpec_FieldMask struct {
	Paths []DevicePublicListingSpec_FieldPath
}

func FullDevice_PublicListingSpec_FieldMask() *Device_PublicListingSpec_FieldMask {
	res := &Device_PublicListingSpec_FieldMask{}
	res.Paths = append(res.Paths, &DevicePublicListingSpec_FieldTerminalPath{selector: DevicePublicListingSpec_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &DevicePublicListingSpec_FieldTerminalPath{selector: DevicePublicListingSpec_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *Device_PublicListingSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_PublicListingSpec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDevicePublicListingSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DevicePublicListingSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDevicePublicListingSpec_FieldPath(raw)
	})
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProtoMessage() {}

func (fieldMask *Device_PublicListingSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Subtract(other *Device_PublicListingSpec_FieldMask) *Device_PublicListingSpec_FieldMask {
	result := &Device_PublicListingSpec_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DevicePublicListingSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_PublicListingSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_PublicListingSpec_FieldMask) FilterInputFields() *Device_PublicListingSpec_FieldMask {
	result := &Device_PublicListingSpec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_PublicListingSpec_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_PublicListingSpec_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DevicePublicListingSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDevicePublicListingSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_PublicListingSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_PublicListingSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_PublicListingSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) AppendPath(path DevicePublicListingSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_PublicListingSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DevicePublicListingSpec_FieldPath))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) GetPaths() []DevicePublicListingSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_PublicListingSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDevicePublicListingSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Set(target, source *Device_PublicListingSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_PublicListingSpec), source.(*Device_PublicListingSpec))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Project(source *Device_PublicListingSpec) *Device_PublicListingSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_PublicListingSpec{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DevicePublicListingSpec_FieldTerminalPath:
			switch tp.selector {
			case DevicePublicListingSpec_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case DevicePublicListingSpec_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		}
	}
	return result
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_PublicListingSpec))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_FieldMask struct {
	Paths []DeviceSpecNetworkingConfig_FieldPath
}

func FullDevice_Spec_NetworkingConfig_FieldMask() *Device_Spec_NetworkingConfig_FieldMask {
	res := &Device_Spec_NetworkingConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorVersion})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorEthernets})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorWifis})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorBridges})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorBonds})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorTunnels})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorVlans})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfig_FieldTerminalPath{selector: DeviceSpecNetworkingConfig_FieldPathSelectorModems})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_FieldMask) *Device_Spec_NetworkingConfig_FieldMask {
	result := &Device_Spec_NetworkingConfig_FieldMask{}
	removedSelectors := make([]bool, 9)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_FieldMask {
	result := &Device_Spec_NetworkingConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) AppendPath(path DeviceSpecNetworkingConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfig_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) GetPaths() []DeviceSpecNetworkingConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) Set(target, source *Device_Spec_NetworkingConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig), source.(*Device_Spec_NetworkingConfig))
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) Project(source *Device_Spec_NetworkingConfig) *Device_Spec_NetworkingConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig{}
	var ethernetsMapKeys []string
	wholeEthernetsAccepted := false
	var wifisMapKeys []string
	wholeWifisAccepted := false
	var bridgesMapKeys []string
	wholeBridgesAccepted := false
	var bondsMapKeys []string
	wholeBondsAccepted := false
	var tunnelsMapKeys []string
	wholeTunnelsAccepted := false
	var vlansMapKeys []string
	wholeVlansAccepted := false
	var modemsMapKeys []string
	wholeModemsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfig_FieldPathSelectorVersion:
				result.Version = source.Version
			case DeviceSpecNetworkingConfig_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkingConfig_FieldPathSelectorEthernets:
				result.Ethernets = source.Ethernets
				wholeEthernetsAccepted = true
			case DeviceSpecNetworkingConfig_FieldPathSelectorWifis:
				result.Wifis = source.Wifis
				wholeWifisAccepted = true
			case DeviceSpecNetworkingConfig_FieldPathSelectorBridges:
				result.Bridges = source.Bridges
				wholeBridgesAccepted = true
			case DeviceSpecNetworkingConfig_FieldPathSelectorBonds:
				result.Bonds = source.Bonds
				wholeBondsAccepted = true
			case DeviceSpecNetworkingConfig_FieldPathSelectorTunnels:
				result.Tunnels = source.Tunnels
				wholeTunnelsAccepted = true
			case DeviceSpecNetworkingConfig_FieldPathSelectorVlans:
				result.Vlans = source.Vlans
				wholeVlansAccepted = true
			case DeviceSpecNetworkingConfig_FieldPathSelectorModems:
				result.Modems = source.Modems
				wholeModemsAccepted = true
			}
		case *DeviceSpecNetworkingConfig_FieldPathMap:
			switch tp.selector {
			case DeviceSpecNetworkingConfig_FieldPathSelectorEthernets:
				ethernetsMapKeys = append(ethernetsMapKeys, tp.key)
			case DeviceSpecNetworkingConfig_FieldPathSelectorWifis:
				wifisMapKeys = append(wifisMapKeys, tp.key)
			case DeviceSpecNetworkingConfig_FieldPathSelectorBridges:
				bridgesMapKeys = append(bridgesMapKeys, tp.key)
			case DeviceSpecNetworkingConfig_FieldPathSelectorBonds:
				bondsMapKeys = append(bondsMapKeys, tp.key)
			case DeviceSpecNetworkingConfig_FieldPathSelectorTunnels:
				tunnelsMapKeys = append(tunnelsMapKeys, tp.key)
			case DeviceSpecNetworkingConfig_FieldPathSelectorVlans:
				vlansMapKeys = append(vlansMapKeys, tp.key)
			case DeviceSpecNetworkingConfig_FieldPathSelectorModems:
				modemsMapKeys = append(modemsMapKeys, tp.key)
			}
		}
	}
	if wholeEthernetsAccepted == false && len(ethernetsMapKeys) > 0 && source.GetEthernets() != nil {
		copiedMap := map[string]*Device_Spec_NetworkingConfig_EthOpts{}
		sourceMap := source.GetEthernets()
		for _, key := range ethernetsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Ethernets = copiedMap
	}
	if wholeWifisAccepted == false && len(wifisMapKeys) > 0 && source.GetWifis() != nil {
		copiedMap := map[string]*Device_Spec_NetworkingConfig_WifiOpts{}
		sourceMap := source.GetWifis()
		for _, key := range wifisMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Wifis = copiedMap
	}
	if wholeBridgesAccepted == false && len(bridgesMapKeys) > 0 && source.GetBridges() != nil {
		copiedMap := map[string]*Device_Spec_NetworkingConfig_BridgesOpts{}
		sourceMap := source.GetBridges()
		for _, key := range bridgesMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Bridges = copiedMap
	}
	if wholeBondsAccepted == false && len(bondsMapKeys) > 0 && source.GetBonds() != nil {
		copiedMap := map[string]*Device_Spec_NetworkingConfig_BondsOpts{}
		sourceMap := source.GetBonds()
		for _, key := range bondsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Bonds = copiedMap
	}
	if wholeTunnelsAccepted == false && len(tunnelsMapKeys) > 0 && source.GetTunnels() != nil {
		copiedMap := map[string]*Device_Spec_NetworkingConfig_TunnelsOpts{}
		sourceMap := source.GetTunnels()
		for _, key := range tunnelsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Tunnels = copiedMap
	}
	if wholeVlansAccepted == false && len(vlansMapKeys) > 0 && source.GetVlans() != nil {
		copiedMap := map[string]*Device_Spec_NetworkingConfig_VlansOpts{}
		sourceMap := source.GetVlans()
		for _, key := range vlansMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Vlans = copiedMap
	}
	if wholeModemsAccepted == false && len(modemsMapKeys) > 0 && source.GetModems() != nil {
		copiedMap := map[string]*Device_Spec_NetworkingConfig_ModemOpts{}
		sourceMap := source.GetModems()
		for _, key := range modemsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Modems = copiedMap
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig))
}

func (fieldMask *Device_Spec_NetworkingConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetplanConfig_FieldMask struct {
	Paths []DeviceSpecNetplanConfig_FieldPath
}

func FullDevice_Spec_NetplanConfig_FieldMask() *Device_Spec_NetplanConfig_FieldMask {
	res := &Device_Spec_NetplanConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetplanConfig_FieldTerminalPath{selector: DeviceSpecNetplanConfig_FieldPathSelectorNetwork})
	return res
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetplanConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetplanConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetplanConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetplanConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) Subtract(other *Device_Spec_NetplanConfig_FieldMask) *Device_Spec_NetplanConfig_FieldMask {
	result := &Device_Spec_NetplanConfig_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceSpecNetplanConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetplanConfig_FieldPathSelectorNetwork: &Device_Spec_NetworkingConfig_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetplanConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetplanConfig_FieldPathSelectorNetwork: &Device_Spec_NetworkingConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetplanConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetplanConfig_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetplanConfig_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetplanConfig_FieldPathSelectorNetwork:
						mySubMasks[DeviceSpecNetplanConfig_FieldPathSelectorNetwork] = FullDevice_Spec_NetworkingConfig_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetplanConfig_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetplanConfig_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetplanConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetplanConfig_FieldMask) FilterInputFields() *Device_Spec_NetplanConfig_FieldMask {
	result := &Device_Spec_NetplanConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetplanConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetplanConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetplanConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetplanConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetplanConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) AppendPath(path DeviceSpecNetplanConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetplanConfig_FieldPath))
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) GetPaths() []DeviceSpecNetplanConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetplanConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) Set(target, source *Device_Spec_NetplanConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetplanConfig), source.(*Device_Spec_NetplanConfig))
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) Project(source *Device_Spec_NetplanConfig) *Device_Spec_NetplanConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetplanConfig{}
	networkMask := &Device_Spec_NetworkingConfig_FieldMask{}
	wholeNetworkAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetplanConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetplanConfig_FieldPathSelectorNetwork:
				result.Network = source.Network
				wholeNetworkAccepted = true
			}
		case *DeviceSpecNetplanConfig_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetplanConfig_FieldPathSelectorNetwork:
				networkMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfig_FieldPath))
			}
		}
	}
	if wholeNetworkAccepted == false && len(networkMask.Paths) > 0 {
		result.Network = networkMask.Project(source.GetNetwork())
	}
	return result
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetplanConfig))
}

func (fieldMask *Device_Spec_NetplanConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_SSHConfig_FieldMask struct {
	Paths []DeviceSpecSSHConfig_FieldPath
}

func FullDevice_Spec_SSHConfig_FieldMask() *Device_Spec_SSHConfig_FieldMask {
	res := &Device_Spec_SSHConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshServer})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshPassword})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorIpAllowList})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorIpDenyList})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorRejectPeriod})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshAuthkey})
	return res
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_SSHConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecSSHConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecSSHConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecSSHConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Subtract(other *Device_Spec_SSHConfig_FieldMask) *Device_Spec_SSHConfig_FieldMask {
	result := &Device_Spec_SSHConfig_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[DeviceSpecSSHConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized: &Device_Spec_SSHConfig_AuthKey_FieldMask{},
	}
	mySubMasks := map[DeviceSpecSSHConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized: &Device_Spec_SSHConfig_AuthKey_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecSSHConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecSSHConfig_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecSSHConfig_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
						mySubMasks[DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized] = FullDevice_Spec_SSHConfig_AuthKey_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecSSHConfig_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecSSHConfig_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_SSHConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_SSHConfig_FieldMask) FilterInputFields() *Device_Spec_SSHConfig_FieldMask {
	result := &Device_Spec_SSHConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_SSHConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecSSHConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecSSHConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_SSHConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_SSHConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) AppendPath(path DeviceSpecSSHConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecSSHConfig_FieldPath))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) GetPaths() []DeviceSpecSSHConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecSSHConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Set(target, source *Device_Spec_SSHConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_SSHConfig), source.(*Device_Spec_SSHConfig))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Project(source *Device_Spec_SSHConfig) *Device_Spec_SSHConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_SSHConfig{}
	sshAuthorizedMask := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	wholeSshAuthorizedAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecSSHConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshServer:
				result.DisableSshServer = source.DisableSshServer
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshPassword:
				result.DisableSshPassword = source.DisableSshPassword
			case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
				result.SshAuthorized = source.SshAuthorized
				wholeSshAuthorizedAccepted = true
			case DeviceSpecSSHConfig_FieldPathSelectorIpAllowList:
				result.IpAllowList = source.IpAllowList
			case DeviceSpecSSHConfig_FieldPathSelectorIpDenyList:
				result.IpDenyList = source.IpDenyList
			case DeviceSpecSSHConfig_FieldPathSelectorRejectPeriod:
				result.RejectPeriod = source.RejectPeriod
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshAuthkey:
				result.DisableSshAuthkey = source.DisableSshAuthkey
			}
		case *DeviceSpecSSHConfig_FieldSubPath:
			switch tp.selector {
			case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
				sshAuthorizedMask.AppendPath(tp.subPath.(DeviceSpecSSHConfigAuthKey_FieldPath))
			}
		}
	}
	if wholeSshAuthorizedAccepted == false && len(sshAuthorizedMask.Paths) > 0 {
		for _, sourceItem := range source.GetSshAuthorized() {
			result.SshAuthorized = append(result.SshAuthorized, sshAuthorizedMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_SSHConfig))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_AttestationConfig_FieldMask struct {
	Paths []DeviceSpecAttestationConfig_FieldPath
}

func FullDevice_Spec_AttestationConfig_FieldMask() *Device_Spec_AttestationConfig_FieldMask {
	res := &Device_Spec_AttestationConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecAttestationConfig_FieldTerminalPath{selector: DeviceSpecAttestationConfig_FieldPathSelectorAttestationExpected})
	res.Paths = append(res.Paths, &DeviceSpecAttestationConfig_FieldTerminalPath{selector: DeviceSpecAttestationConfig_FieldPathSelectorAttestationDomain})
	res.Paths = append(res.Paths, &DeviceSpecAttestationConfig_FieldTerminalPath{selector: DeviceSpecAttestationConfig_FieldPathSelectorInsecureUseTpmSimulatorSeed})
	return res
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecAttestationConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecAttestationConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecAttestationConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Subtract(other *Device_Spec_AttestationConfig_FieldMask) *Device_Spec_AttestationConfig_FieldMask {
	result := &Device_Spec_AttestationConfig_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecAttestationConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_AttestationConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) FilterInputFields() *Device_Spec_AttestationConfig_FieldMask {
	result := &Device_Spec_AttestationConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecAttestationConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecAttestationConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_AttestationConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_AttestationConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) AppendPath(path DeviceSpecAttestationConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecAttestationConfig_FieldPath))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) GetPaths() []DeviceSpecAttestationConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecAttestationConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Set(target, source *Device_Spec_AttestationConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_AttestationConfig), source.(*Device_Spec_AttestationConfig))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Project(source *Device_Spec_AttestationConfig) *Device_Spec_AttestationConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_AttestationConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecAttestationConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecAttestationConfig_FieldPathSelectorAttestationExpected:
				result.AttestationExpected = source.AttestationExpected
			case DeviceSpecAttestationConfig_FieldPathSelectorAttestationDomain:
				result.AttestationDomain = source.AttestationDomain
			case DeviceSpecAttestationConfig_FieldPathSelectorInsecureUseTpmSimulatorSeed:
				result.InsecureUseTpmSimulatorSeed = source.InsecureUseTpmSimulatorSeed
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_AttestationConfig))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_LoggingConfig_FieldMask struct {
	Paths []DeviceSpecLoggingConfig_FieldPath
}

func FullDevice_Spec_LoggingConfig_FieldMask() *Device_Spec_LoggingConfig_FieldMask {
	res := &Device_Spec_LoggingConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorPriority})
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorUnits})
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorEnableJournalExport})
	return res
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecLoggingConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecLoggingConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecLoggingConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Subtract(other *Device_Spec_LoggingConfig_FieldMask) *Device_Spec_LoggingConfig_FieldMask {
	result := &Device_Spec_LoggingConfig_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecLoggingConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_LoggingConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) FilterInputFields() *Device_Spec_LoggingConfig_FieldMask {
	result := &Device_Spec_LoggingConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecLoggingConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecLoggingConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_LoggingConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_LoggingConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) AppendPath(path DeviceSpecLoggingConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecLoggingConfig_FieldPath))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) GetPaths() []DeviceSpecLoggingConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecLoggingConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Set(target, source *Device_Spec_LoggingConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_LoggingConfig), source.(*Device_Spec_LoggingConfig))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Project(source *Device_Spec_LoggingConfig) *Device_Spec_LoggingConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_LoggingConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecLoggingConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecLoggingConfig_FieldPathSelectorPriority:
				result.Priority = source.Priority
			case DeviceSpecLoggingConfig_FieldPathSelectorUnits:
				result.Units = source.Units
			case DeviceSpecLoggingConfig_FieldPathSelectorEnableJournalExport:
				result.EnableJournalExport = source.EnableJournalExport
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_LoggingConfig))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_ProxyConfig_FieldMask struct {
	Paths []DeviceSpecProxyConfig_FieldPath
}

func FullDevice_Spec_ProxyConfig_FieldMask() *Device_Spec_ProxyConfig_FieldMask {
	res := &Device_Spec_ProxyConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorHttpProxy})
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorHttpsProxy})
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorNoProxy})
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorProxyInterfaces})
	return res
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecProxyConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecProxyConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecProxyConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Subtract(other *Device_Spec_ProxyConfig_FieldMask) *Device_Spec_ProxyConfig_FieldMask {
	result := &Device_Spec_ProxyConfig_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecProxyConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_ProxyConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) FilterInputFields() *Device_Spec_ProxyConfig_FieldMask {
	result := &Device_Spec_ProxyConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecProxyConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecProxyConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_ProxyConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_ProxyConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) AppendPath(path DeviceSpecProxyConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecProxyConfig_FieldPath))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) GetPaths() []DeviceSpecProxyConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecProxyConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Set(target, source *Device_Spec_ProxyConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_ProxyConfig), source.(*Device_Spec_ProxyConfig))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Project(source *Device_Spec_ProxyConfig) *Device_Spec_ProxyConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_ProxyConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecProxyConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecProxyConfig_FieldPathSelectorHttpProxy:
				result.HttpProxy = source.HttpProxy
			case DeviceSpecProxyConfig_FieldPathSelectorHttpsProxy:
				result.HttpsProxy = source.HttpsProxy
			case DeviceSpecProxyConfig_FieldPathSelectorNoProxy:
				result.NoProxy = source.NoProxy
			case DeviceSpecProxyConfig_FieldPathSelectorProxyInterfaces:
				result.ProxyInterfaces = source.ProxyInterfaces
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_ProxyConfig))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_Location_FieldMask struct {
	Paths []DeviceSpecLocation_FieldPath
}

func FullDevice_Spec_Location_FieldMask() *Device_Spec_Location_FieldMask {
	res := &Device_Spec_Location_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecLocation_FieldTerminalPath{selector: DeviceSpecLocation_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceSpecLocation_FieldTerminalPath{selector: DeviceSpecLocation_FieldPathSelectorPlacement})
	return res
}

func (fieldMask *Device_Spec_Location_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_Location_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_Location_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecLocation_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_Location_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecLocation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_Location_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecLocation_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_Location_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_Location_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_Location_FieldMask) Subtract(other *Device_Spec_Location_FieldMask) *Device_Spec_Location_FieldMask {
	result := &Device_Spec_Location_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecLocation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_Location_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_Location_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_Location_FieldMask) FilterInputFields() *Device_Spec_Location_FieldMask {
	result := &Device_Spec_Location_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_Location_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_Location_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecLocation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecLocation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_Location_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_Location_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_Location_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_Location_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_Location_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_Location_FieldMask) AppendPath(path DeviceSpecLocation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_Location_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecLocation_FieldPath))
}

func (fieldMask *Device_Spec_Location_FieldMask) GetPaths() []DeviceSpecLocation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_Location_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_Location_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecLocation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_Location_FieldMask) Set(target, source *Device_Spec_Location) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_Location_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_Location), source.(*Device_Spec_Location))
}

func (fieldMask *Device_Spec_Location_FieldMask) Project(source *Device_Spec_Location) *Device_Spec_Location {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_Location{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecLocation_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecLocation_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceSpecLocation_FieldPathSelectorPlacement:
				result.Placement = source.Placement
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_Location_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_Location))
}

func (fieldMask *Device_Spec_Location_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_CommonOpts_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigCommonOpts_FieldPath
}

func FullDevice_Spec_NetworkingConfig_CommonOpts_FieldMask() *Device_Spec_NetworkingConfig_CommonOpts_FieldMask {
	res := &Device_Spec_NetworkingConfig_CommonOpts_FieldMask{}
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigCommonOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigCommonOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigCommonOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) *Device_Spec_NetworkingConfig_CommonOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigCommonOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_CommonOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_CommonOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigCommonOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigCommonOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) AppendPath(path DeviceSpecNetworkingConfigCommonOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigCommonOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) GetPaths() []DeviceSpecNetworkingConfigCommonOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigCommonOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_CommonOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_CommonOpts), source.(*Device_Spec_NetworkingConfig_CommonOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) Project(source *Device_Spec_NetworkingConfig_CommonOpts) *Device_Spec_NetworkingConfig_CommonOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_CommonOpts{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigCommonOpts_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_CommonOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_EthOpts_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigEthOpts_FieldPath
}

func FullDevice_Spec_NetworkingConfig_EthOpts_FieldMask() *Device_Spec_NetworkingConfig_EthOpts_FieldMask {
	res := &Device_Spec_NetworkingConfig_EthOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMatch})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorSetName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorWakeonlan})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorIpv6Privacy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorLinkLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorCritical})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcpIdentifier})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAcceptRa})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorNameservers})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorOptional})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorOptionalAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutingPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAuth})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorGateway4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorGateway6})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigEthOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 24)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigEthOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_EthOpts_FieldMask) *Device_Spec_NetworkingConfig_EthOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_EthOpts_FieldMask{}
	removedSelectors := make([]bool, 24)
	otherSubMasks := map[DeviceSpecNetworkingConfigEthOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMatch:          &Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkingConfigEthOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMatch:          &Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkingConfigEthOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMatch:
						mySubMasks[DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMatch] = FullDevice_Spec_NetworkingConfig_EthOpts_Match_FieldMask()
					case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4Overrides:
						mySubMasks[DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6Overrides:
						mySubMasks[DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorNameservers:
						mySubMasks[DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorNameservers] = FullDevice_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask()
					case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutes:
						mySubMasks[DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutes] = FullDevice_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask()
					case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutingPolicy:
						mySubMasks[DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutingPolicy] = FullDevice_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask()
					case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAuth] = FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkingConfigEthOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkingConfigEthOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_EthOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_EthOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_EthOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigEthOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigEthOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_EthOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_EthOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) AppendPath(path DeviceSpecNetworkingConfigEthOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigEthOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) GetPaths() []DeviceSpecNetworkingConfigEthOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigEthOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_EthOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_EthOpts), source.(*Device_Spec_NetworkingConfig_EthOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) Project(source *Device_Spec_NetworkingConfig_EthOpts) *Device_Spec_NetworkingConfig_EthOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_EthOpts{}
	matchMask := &Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask{}
	wholeMatchAccepted := false
	dhcp4OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp4OverridesAccepted := false
	dhcp6OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp6OverridesAccepted := false
	nameserversMask := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	wholeNameserversAccepted := false
	routesMask := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	wholeRoutesAccepted := false
	routingPolicyMask := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	wholeRoutingPolicyAccepted := false
	authMask := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigEthOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMatch:
				result.Match = source.Match
				wholeMatchAccepted = true
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorSetName:
				result.SetName = source.SetName
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorWakeonlan:
				result.Wakeonlan = source.Wakeonlan
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4:
				result.Dhcp4 = source.Dhcp4
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6:
				result.Dhcp6 = source.Dhcp6
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorIpv6Privacy:
				result.Ipv6Privacy = source.Ipv6Privacy
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorLinkLocal:
				result.LinkLocal = source.LinkLocal
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorCritical:
				result.Critical = source.Critical
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcpIdentifier:
				result.DhcpIdentifier = source.DhcpIdentifier
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4Overrides:
				result.Dhcp4Overrides = source.Dhcp4Overrides
				wholeDhcp4OverridesAccepted = true
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6Overrides:
				result.Dhcp6Overrides = source.Dhcp6Overrides
				wholeDhcp6OverridesAccepted = true
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAcceptRa:
				result.AcceptRa = source.AcceptRa
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorNameservers:
				result.Nameservers = source.Nameservers
				wholeNameserversAccepted = true
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMtu:
				result.Mtu = source.Mtu
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorOptional:
				result.Optional = source.Optional
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorOptionalAddresses:
				result.OptionalAddresses = source.OptionalAddresses
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutes:
				result.Routes = source.Routes
				wholeRoutesAccepted = true
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutingPolicy:
				result.RoutingPolicy = source.RoutingPolicy
				wholeRoutingPolicyAccepted = true
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorGateway4:
				result.Gateway4 = source.Gateway4
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorGateway6:
				result.Gateway6 = source.Gateway6
			}
		case *DeviceSpecNetworkingConfigEthOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorMatch:
				matchMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigEthOptsMatch_FieldPath))
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp4Overrides:
				dhcp4OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorDhcp6Overrides:
				dhcp6OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorNameservers:
				nameserversMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath))
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutes:
				routesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath))
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorRoutingPolicy:
				routingPolicyMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath))
			case DeviceSpecNetworkingConfigEthOpts_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
			}
		}
	}
	if wholeMatchAccepted == false && len(matchMask.Paths) > 0 {
		result.Match = matchMask.Project(source.GetMatch())
	}
	if wholeDhcp4OverridesAccepted == false && len(dhcp4OverridesMask.Paths) > 0 {
		result.Dhcp4Overrides = dhcp4OverridesMask.Project(source.GetDhcp4Overrides())
	}
	if wholeDhcp6OverridesAccepted == false && len(dhcp6OverridesMask.Paths) > 0 {
		result.Dhcp6Overrides = dhcp6OverridesMask.Project(source.GetDhcp6Overrides())
	}
	if wholeNameserversAccepted == false && len(nameserversMask.Paths) > 0 {
		result.Nameservers = nameserversMask.Project(source.GetNameservers())
	}
	if wholeRoutesAccepted == false && len(routesMask.Paths) > 0 {
		for _, sourceItem := range source.GetRoutes() {
			result.Routes = append(result.Routes, routesMask.Project(sourceItem))
		}
	}
	if wholeRoutingPolicyAccepted == false && len(routingPolicyMask.Paths) > 0 {
		result.RoutingPolicy = routingPolicyMask.Project(source.GetRoutingPolicy())
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_EthOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_WifiOpts_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigWifiOpts_FieldPath
}

func FullDevice_Spec_NetworkingConfig_WifiOpts_FieldMask() *Device_Spec_NetworkingConfig_WifiOpts_FieldMask {
	res := &Device_Spec_NetworkingConfig_WifiOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMatch})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorSetName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorWakeonlan})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAccessPoints})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorWakeonwlan})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRegulatoryDomain})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorIpv6Privacy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorLinkLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorCritical})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcpIdentifier})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAcceptRa})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorNameservers})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorOptional})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorOptionalAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutingPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAuth})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorGateway4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorGateway6})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigWifiOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 27)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigWifiOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) *Device_Spec_NetworkingConfig_WifiOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_WifiOpts_FieldMask{}
	removedSelectors := make([]bool, 27)
	otherSubMasks := map[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMatch:          &Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMatch:          &Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkingConfigWifiOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMatch:
						mySubMasks[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMatch] = FullDevice_Spec_NetworkingConfig_WifiOpts_Match_FieldMask()
					case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4Overrides:
						mySubMasks[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6Overrides:
						mySubMasks[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorNameservers:
						mySubMasks[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorNameservers] = FullDevice_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask()
					case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutes:
						mySubMasks[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutes] = FullDevice_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask()
					case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutingPolicy:
						mySubMasks[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutingPolicy] = FullDevice_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask()
					case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAuth] = FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkingConfigWifiOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkingConfigWifiOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_WifiOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_WifiOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_WifiOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigWifiOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigWifiOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_WifiOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_WifiOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) AppendPath(path DeviceSpecNetworkingConfigWifiOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigWifiOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) GetPaths() []DeviceSpecNetworkingConfigWifiOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigWifiOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_WifiOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_WifiOpts), source.(*Device_Spec_NetworkingConfig_WifiOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) Project(source *Device_Spec_NetworkingConfig_WifiOpts) *Device_Spec_NetworkingConfig_WifiOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_WifiOpts{}
	matchMask := &Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask{}
	wholeMatchAccepted := false
	dhcp4OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp4OverridesAccepted := false
	dhcp6OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp6OverridesAccepted := false
	nameserversMask := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	wholeNameserversAccepted := false
	routesMask := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	wholeRoutesAccepted := false
	routingPolicyMask := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	wholeRoutingPolicyAccepted := false
	authMask := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false
	var accessPointsMapKeys []string
	wholeAccessPointsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigWifiOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMatch:
				result.Match = source.Match
				wholeMatchAccepted = true
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorSetName:
				result.SetName = source.SetName
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorWakeonlan:
				result.Wakeonlan = source.Wakeonlan
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAccessPoints:
				result.AccessPoints = source.AccessPoints
				wholeAccessPointsAccepted = true
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorWakeonwlan:
				result.Wakeonwlan = source.Wakeonwlan
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRegulatoryDomain:
				result.RegulatoryDomain = source.RegulatoryDomain
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4:
				result.Dhcp4 = source.Dhcp4
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6:
				result.Dhcp6 = source.Dhcp6
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorIpv6Privacy:
				result.Ipv6Privacy = source.Ipv6Privacy
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorLinkLocal:
				result.LinkLocal = source.LinkLocal
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorCritical:
				result.Critical = source.Critical
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcpIdentifier:
				result.DhcpIdentifier = source.DhcpIdentifier
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4Overrides:
				result.Dhcp4Overrides = source.Dhcp4Overrides
				wholeDhcp4OverridesAccepted = true
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6Overrides:
				result.Dhcp6Overrides = source.Dhcp6Overrides
				wholeDhcp6OverridesAccepted = true
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAcceptRa:
				result.AcceptRa = source.AcceptRa
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorNameservers:
				result.Nameservers = source.Nameservers
				wholeNameserversAccepted = true
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMtu:
				result.Mtu = source.Mtu
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorOptional:
				result.Optional = source.Optional
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorOptionalAddresses:
				result.OptionalAddresses = source.OptionalAddresses
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutes:
				result.Routes = source.Routes
				wholeRoutesAccepted = true
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutingPolicy:
				result.RoutingPolicy = source.RoutingPolicy
				wholeRoutingPolicyAccepted = true
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorGateway4:
				result.Gateway4 = source.Gateway4
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorGateway6:
				result.Gateway6 = source.Gateway6
			}
		case *DeviceSpecNetworkingConfigWifiOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorMatch:
				matchMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigWifiOptsMatch_FieldPath))
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp4Overrides:
				dhcp4OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorDhcp6Overrides:
				dhcp6OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorNameservers:
				nameserversMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath))
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutes:
				routesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath))
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorRoutingPolicy:
				routingPolicyMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath))
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
			}
		case *DeviceSpecNetworkingConfigWifiOpts_FieldPathMap:
			switch tp.selector {
			case DeviceSpecNetworkingConfigWifiOpts_FieldPathSelectorAccessPoints:
				accessPointsMapKeys = append(accessPointsMapKeys, tp.key)
			}
		}
	}
	if wholeMatchAccepted == false && len(matchMask.Paths) > 0 {
		result.Match = matchMask.Project(source.GetMatch())
	}
	if wholeAccessPointsAccepted == false && len(accessPointsMapKeys) > 0 && source.GetAccessPoints() != nil {
		copiedMap := map[string]*Device_Spec_NetworkingConfig_WifiOpts_AccessPoint{}
		sourceMap := source.GetAccessPoints()
		for _, key := range accessPointsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.AccessPoints = copiedMap
	}
	if wholeDhcp4OverridesAccepted == false && len(dhcp4OverridesMask.Paths) > 0 {
		result.Dhcp4Overrides = dhcp4OverridesMask.Project(source.GetDhcp4Overrides())
	}
	if wholeDhcp6OverridesAccepted == false && len(dhcp6OverridesMask.Paths) > 0 {
		result.Dhcp6Overrides = dhcp6OverridesMask.Project(source.GetDhcp6Overrides())
	}
	if wholeNameserversAccepted == false && len(nameserversMask.Paths) > 0 {
		result.Nameservers = nameserversMask.Project(source.GetNameservers())
	}
	if wholeRoutesAccepted == false && len(routesMask.Paths) > 0 {
		for _, sourceItem := range source.GetRoutes() {
			result.Routes = append(result.Routes, routesMask.Project(sourceItem))
		}
	}
	if wholeRoutingPolicyAccepted == false && len(routingPolicyMask.Paths) > 0 {
		result.RoutingPolicy = routingPolicyMask.Project(source.GetRoutingPolicy())
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_WifiOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_BridgesOpts_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigBridgesOpts_FieldPath
}

func FullDevice_Spec_NetworkingConfig_BridgesOpts_FieldMask() *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask {
	res := &Device_Spec_NetworkingConfig_BridgesOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorInterfaces})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorParameters})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorIpv6Privacy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorLinkLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorCritical})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcpIdentifier})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAcceptRa})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorNameservers})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorOptional})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorOptionalAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutingPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAuth})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorGateway4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorGateway6})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigBridgesOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 23)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigBridgesOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_BridgesOpts_FieldMask{}
	removedSelectors := make([]bool, 23)
	otherSubMasks := map[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorParameters:     &Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorParameters:     &Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkingConfigBridgesOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorParameters:
						mySubMasks[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorParameters] = FullDevice_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask()
					case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4Overrides:
						mySubMasks[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6Overrides:
						mySubMasks[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorNameservers:
						mySubMasks[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorNameservers] = FullDevice_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask()
					case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutes:
						mySubMasks[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutes] = FullDevice_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask()
					case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutingPolicy:
						mySubMasks[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutingPolicy] = FullDevice_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask()
					case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAuth] = FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkingConfigBridgesOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkingConfigBridgesOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_BridgesOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_BridgesOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigBridgesOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigBridgesOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) AppendPath(path DeviceSpecNetworkingConfigBridgesOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigBridgesOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) GetPaths() []DeviceSpecNetworkingConfigBridgesOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigBridgesOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_BridgesOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_BridgesOpts), source.(*Device_Spec_NetworkingConfig_BridgesOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) Project(source *Device_Spec_NetworkingConfig_BridgesOpts) *Device_Spec_NetworkingConfig_BridgesOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_BridgesOpts{}
	parametersMask := &Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask{}
	wholeParametersAccepted := false
	dhcp4OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp4OverridesAccepted := false
	dhcp6OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp6OverridesAccepted := false
	nameserversMask := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	wholeNameserversAccepted := false
	routesMask := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	wholeRoutesAccepted := false
	routingPolicyMask := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	wholeRoutingPolicyAccepted := false
	authMask := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigBridgesOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorInterfaces:
				result.Interfaces = source.Interfaces
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorParameters:
				result.Parameters = source.Parameters
				wholeParametersAccepted = true
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4:
				result.Dhcp4 = source.Dhcp4
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6:
				result.Dhcp6 = source.Dhcp6
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorIpv6Privacy:
				result.Ipv6Privacy = source.Ipv6Privacy
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorLinkLocal:
				result.LinkLocal = source.LinkLocal
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorCritical:
				result.Critical = source.Critical
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcpIdentifier:
				result.DhcpIdentifier = source.DhcpIdentifier
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4Overrides:
				result.Dhcp4Overrides = source.Dhcp4Overrides
				wholeDhcp4OverridesAccepted = true
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6Overrides:
				result.Dhcp6Overrides = source.Dhcp6Overrides
				wholeDhcp6OverridesAccepted = true
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAcceptRa:
				result.AcceptRa = source.AcceptRa
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorNameservers:
				result.Nameservers = source.Nameservers
				wholeNameserversAccepted = true
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorMtu:
				result.Mtu = source.Mtu
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorOptional:
				result.Optional = source.Optional
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorOptionalAddresses:
				result.OptionalAddresses = source.OptionalAddresses
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutes:
				result.Routes = source.Routes
				wholeRoutesAccepted = true
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutingPolicy:
				result.RoutingPolicy = source.RoutingPolicy
				wholeRoutingPolicyAccepted = true
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorGateway4:
				result.Gateway4 = source.Gateway4
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorGateway6:
				result.Gateway6 = source.Gateway6
			}
		case *DeviceSpecNetworkingConfigBridgesOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorParameters:
				parametersMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath))
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp4Overrides:
				dhcp4OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorDhcp6Overrides:
				dhcp6OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorNameservers:
				nameserversMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath))
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutes:
				routesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath))
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorRoutingPolicy:
				routingPolicyMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath))
			case DeviceSpecNetworkingConfigBridgesOpts_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
			}
		}
	}
	if wholeParametersAccepted == false && len(parametersMask.Paths) > 0 {
		result.Parameters = parametersMask.Project(source.GetParameters())
	}
	if wholeDhcp4OverridesAccepted == false && len(dhcp4OverridesMask.Paths) > 0 {
		result.Dhcp4Overrides = dhcp4OverridesMask.Project(source.GetDhcp4Overrides())
	}
	if wholeDhcp6OverridesAccepted == false && len(dhcp6OverridesMask.Paths) > 0 {
		result.Dhcp6Overrides = dhcp6OverridesMask.Project(source.GetDhcp6Overrides())
	}
	if wholeNameserversAccepted == false && len(nameserversMask.Paths) > 0 {
		result.Nameservers = nameserversMask.Project(source.GetNameservers())
	}
	if wholeRoutesAccepted == false && len(routesMask.Paths) > 0 {
		for _, sourceItem := range source.GetRoutes() {
			result.Routes = append(result.Routes, routesMask.Project(sourceItem))
		}
	}
	if wholeRoutingPolicyAccepted == false && len(routingPolicyMask.Paths) > 0 {
		result.RoutingPolicy = routingPolicyMask.Project(source.GetRoutingPolicy())
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_BridgesOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_BondsOpts_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigBondsOpts_FieldPath
}

func FullDevice_Spec_NetworkingConfig_BondsOpts_FieldMask() *Device_Spec_NetworkingConfig_BondsOpts_FieldMask {
	res := &Device_Spec_NetworkingConfig_BondsOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorInterfaces})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorParameters})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorIpv6Privacy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorLinkLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorCritical})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcpIdentifier})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAcceptRa})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorNameservers})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorOptional})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorOptionalAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutingPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAuth})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorGateway4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorGateway6})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigBondsOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 23)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigBondsOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) *Device_Spec_NetworkingConfig_BondsOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_BondsOpts_FieldMask{}
	removedSelectors := make([]bool, 23)
	otherSubMasks := map[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorParameters:     &Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorParameters:     &Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkingConfigBondsOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorParameters:
						mySubMasks[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorParameters] = FullDevice_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask()
					case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4Overrides:
						mySubMasks[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6Overrides:
						mySubMasks[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorNameservers:
						mySubMasks[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorNameservers] = FullDevice_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask()
					case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutes:
						mySubMasks[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutes] = FullDevice_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask()
					case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutingPolicy:
						mySubMasks[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutingPolicy] = FullDevice_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask()
					case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAuth] = FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkingConfigBondsOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkingConfigBondsOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_BondsOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_BondsOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_BondsOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigBondsOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigBondsOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_BondsOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_BondsOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) AppendPath(path DeviceSpecNetworkingConfigBondsOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigBondsOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) GetPaths() []DeviceSpecNetworkingConfigBondsOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigBondsOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_BondsOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_BondsOpts), source.(*Device_Spec_NetworkingConfig_BondsOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) Project(source *Device_Spec_NetworkingConfig_BondsOpts) *Device_Spec_NetworkingConfig_BondsOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_BondsOpts{}
	parametersMask := &Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask{}
	wholeParametersAccepted := false
	dhcp4OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp4OverridesAccepted := false
	dhcp6OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp6OverridesAccepted := false
	nameserversMask := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	wholeNameserversAccepted := false
	routesMask := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	wholeRoutesAccepted := false
	routingPolicyMask := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	wholeRoutingPolicyAccepted := false
	authMask := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigBondsOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorInterfaces:
				result.Interfaces = source.Interfaces
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorParameters:
				result.Parameters = source.Parameters
				wholeParametersAccepted = true
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4:
				result.Dhcp4 = source.Dhcp4
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6:
				result.Dhcp6 = source.Dhcp6
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorIpv6Privacy:
				result.Ipv6Privacy = source.Ipv6Privacy
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorLinkLocal:
				result.LinkLocal = source.LinkLocal
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorCritical:
				result.Critical = source.Critical
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcpIdentifier:
				result.DhcpIdentifier = source.DhcpIdentifier
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4Overrides:
				result.Dhcp4Overrides = source.Dhcp4Overrides
				wholeDhcp4OverridesAccepted = true
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6Overrides:
				result.Dhcp6Overrides = source.Dhcp6Overrides
				wholeDhcp6OverridesAccepted = true
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAcceptRa:
				result.AcceptRa = source.AcceptRa
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorNameservers:
				result.Nameservers = source.Nameservers
				wholeNameserversAccepted = true
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorMtu:
				result.Mtu = source.Mtu
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorOptional:
				result.Optional = source.Optional
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorOptionalAddresses:
				result.OptionalAddresses = source.OptionalAddresses
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutes:
				result.Routes = source.Routes
				wholeRoutesAccepted = true
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutingPolicy:
				result.RoutingPolicy = source.RoutingPolicy
				wholeRoutingPolicyAccepted = true
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorGateway4:
				result.Gateway4 = source.Gateway4
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorGateway6:
				result.Gateway6 = source.Gateway6
			}
		case *DeviceSpecNetworkingConfigBondsOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorParameters:
				parametersMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigBondsOptsParameters_FieldPath))
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp4Overrides:
				dhcp4OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorDhcp6Overrides:
				dhcp6OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorNameservers:
				nameserversMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath))
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutes:
				routesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath))
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorRoutingPolicy:
				routingPolicyMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath))
			case DeviceSpecNetworkingConfigBondsOpts_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
			}
		}
	}
	if wholeParametersAccepted == false && len(parametersMask.Paths) > 0 {
		result.Parameters = parametersMask.Project(source.GetParameters())
	}
	if wholeDhcp4OverridesAccepted == false && len(dhcp4OverridesMask.Paths) > 0 {
		result.Dhcp4Overrides = dhcp4OverridesMask.Project(source.GetDhcp4Overrides())
	}
	if wholeDhcp6OverridesAccepted == false && len(dhcp6OverridesMask.Paths) > 0 {
		result.Dhcp6Overrides = dhcp6OverridesMask.Project(source.GetDhcp6Overrides())
	}
	if wholeNameserversAccepted == false && len(nameserversMask.Paths) > 0 {
		result.Nameservers = nameserversMask.Project(source.GetNameservers())
	}
	if wholeRoutesAccepted == false && len(routesMask.Paths) > 0 {
		for _, sourceItem := range source.GetRoutes() {
			result.Routes = append(result.Routes, routesMask.Project(sourceItem))
		}
	}
	if wholeRoutingPolicyAccepted == false && len(routingPolicyMask.Paths) > 0 {
		result.RoutingPolicy = routingPolicyMask.Project(source.GetRoutingPolicy())
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_BondsOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigTunnelsOpts_FieldPath
}

func FullDevice_Spec_NetworkingConfig_TunnelsOpts_FieldMask() *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask {
	res := &Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorMode})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRemote})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorIpv6Privacy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorLinkLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorCritical})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcpIdentifier})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAcceptRa})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorNameservers})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorOptional})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorOptionalAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutingPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAuth})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorGateway4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorGateway6})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigTunnelsOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 25)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigTunnelsOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask{}
	removedSelectors := make([]bool, 25)
	otherSubMasks := map[DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkingConfigTunnelsOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4Overrides:
						mySubMasks[DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6Overrides:
						mySubMasks[DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorNameservers:
						mySubMasks[DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorNameservers] = FullDevice_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask()
					case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutes:
						mySubMasks[DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutes] = FullDevice_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask()
					case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutingPolicy:
						mySubMasks[DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutingPolicy] = FullDevice_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask()
					case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAuth] = FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkingConfigTunnelsOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkingConfigTunnelsOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigTunnelsOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigTunnelsOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) AppendPath(path DeviceSpecNetworkingConfigTunnelsOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigTunnelsOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) GetPaths() []DeviceSpecNetworkingConfigTunnelsOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigTunnelsOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_TunnelsOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_TunnelsOpts), source.(*Device_Spec_NetworkingConfig_TunnelsOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) Project(source *Device_Spec_NetworkingConfig_TunnelsOpts) *Device_Spec_NetworkingConfig_TunnelsOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_TunnelsOpts{}
	dhcp4OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp4OverridesAccepted := false
	dhcp6OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp6OverridesAccepted := false
	nameserversMask := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	wholeNameserversAccepted := false
	routesMask := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	wholeRoutesAccepted := false
	routingPolicyMask := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	wholeRoutingPolicyAccepted := false
	authMask := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigTunnelsOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorMode:
				result.Mode = source.Mode
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorLocal:
				result.Local = source.Local
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRemote:
				result.Remote = source.Remote
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorKey:
				result.Key = source.Key
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4:
				result.Dhcp4 = source.Dhcp4
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6:
				result.Dhcp6 = source.Dhcp6
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorIpv6Privacy:
				result.Ipv6Privacy = source.Ipv6Privacy
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorLinkLocal:
				result.LinkLocal = source.LinkLocal
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorCritical:
				result.Critical = source.Critical
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcpIdentifier:
				result.DhcpIdentifier = source.DhcpIdentifier
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4Overrides:
				result.Dhcp4Overrides = source.Dhcp4Overrides
				wholeDhcp4OverridesAccepted = true
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6Overrides:
				result.Dhcp6Overrides = source.Dhcp6Overrides
				wholeDhcp6OverridesAccepted = true
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAcceptRa:
				result.AcceptRa = source.AcceptRa
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorNameservers:
				result.Nameservers = source.Nameservers
				wholeNameserversAccepted = true
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorMtu:
				result.Mtu = source.Mtu
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorOptional:
				result.Optional = source.Optional
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorOptionalAddresses:
				result.OptionalAddresses = source.OptionalAddresses
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutes:
				result.Routes = source.Routes
				wholeRoutesAccepted = true
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutingPolicy:
				result.RoutingPolicy = source.RoutingPolicy
				wholeRoutingPolicyAccepted = true
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorGateway4:
				result.Gateway4 = source.Gateway4
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorGateway6:
				result.Gateway6 = source.Gateway6
			}
		case *DeviceSpecNetworkingConfigTunnelsOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp4Overrides:
				dhcp4OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorDhcp6Overrides:
				dhcp6OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorNameservers:
				nameserversMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath))
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutes:
				routesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath))
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorRoutingPolicy:
				routingPolicyMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath))
			case DeviceSpecNetworkingConfigTunnelsOpts_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
			}
		}
	}
	if wholeDhcp4OverridesAccepted == false && len(dhcp4OverridesMask.Paths) > 0 {
		result.Dhcp4Overrides = dhcp4OverridesMask.Project(source.GetDhcp4Overrides())
	}
	if wholeDhcp6OverridesAccepted == false && len(dhcp6OverridesMask.Paths) > 0 {
		result.Dhcp6Overrides = dhcp6OverridesMask.Project(source.GetDhcp6Overrides())
	}
	if wholeNameserversAccepted == false && len(nameserversMask.Paths) > 0 {
		result.Nameservers = nameserversMask.Project(source.GetNameservers())
	}
	if wholeRoutesAccepted == false && len(routesMask.Paths) > 0 {
		for _, sourceItem := range source.GetRoutes() {
			result.Routes = append(result.Routes, routesMask.Project(sourceItem))
		}
	}
	if wholeRoutingPolicyAccepted == false && len(routingPolicyMask.Paths) > 0 {
		result.RoutingPolicy = routingPolicyMask.Project(source.GetRoutingPolicy())
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_TunnelsOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_VlansOpts_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigVlansOpts_FieldPath
}

func FullDevice_Spec_NetworkingConfig_VlansOpts_FieldMask() *Device_Spec_NetworkingConfig_VlansOpts_FieldMask {
	res := &Device_Spec_NetworkingConfig_VlansOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorId})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorLink})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorIpv6Privacy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorLinkLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorCritical})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcpIdentifier})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAcceptRa})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorNameservers})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorOptional})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorOptionalAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutingPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAuth})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorGateway4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorGateway6})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigVlansOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 23)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigVlansOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) *Device_Spec_NetworkingConfig_VlansOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_VlansOpts_FieldMask{}
	removedSelectors := make([]bool, 23)
	otherSubMasks := map[DeviceSpecNetworkingConfigVlansOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkingConfigVlansOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkingConfigVlansOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4Overrides:
						mySubMasks[DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6Overrides:
						mySubMasks[DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorNameservers:
						mySubMasks[DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorNameservers] = FullDevice_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask()
					case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutes:
						mySubMasks[DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutes] = FullDevice_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask()
					case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutingPolicy:
						mySubMasks[DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutingPolicy] = FullDevice_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask()
					case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAuth] = FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkingConfigVlansOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkingConfigVlansOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_VlansOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_VlansOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_VlansOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigVlansOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigVlansOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_VlansOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_VlansOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) AppendPath(path DeviceSpecNetworkingConfigVlansOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigVlansOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) GetPaths() []DeviceSpecNetworkingConfigVlansOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigVlansOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_VlansOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_VlansOpts), source.(*Device_Spec_NetworkingConfig_VlansOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) Project(source *Device_Spec_NetworkingConfig_VlansOpts) *Device_Spec_NetworkingConfig_VlansOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_VlansOpts{}
	dhcp4OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp4OverridesAccepted := false
	dhcp6OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp6OverridesAccepted := false
	nameserversMask := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	wholeNameserversAccepted := false
	routesMask := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	wholeRoutesAccepted := false
	routingPolicyMask := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	wholeRoutingPolicyAccepted := false
	authMask := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigVlansOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorId:
				result.Id = source.Id
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorLink:
				result.Link = source.Link
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4:
				result.Dhcp4 = source.Dhcp4
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6:
				result.Dhcp6 = source.Dhcp6
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorIpv6Privacy:
				result.Ipv6Privacy = source.Ipv6Privacy
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorLinkLocal:
				result.LinkLocal = source.LinkLocal
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorCritical:
				result.Critical = source.Critical
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcpIdentifier:
				result.DhcpIdentifier = source.DhcpIdentifier
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4Overrides:
				result.Dhcp4Overrides = source.Dhcp4Overrides
				wholeDhcp4OverridesAccepted = true
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6Overrides:
				result.Dhcp6Overrides = source.Dhcp6Overrides
				wholeDhcp6OverridesAccepted = true
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAcceptRa:
				result.AcceptRa = source.AcceptRa
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorNameservers:
				result.Nameservers = source.Nameservers
				wholeNameserversAccepted = true
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorMtu:
				result.Mtu = source.Mtu
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorOptional:
				result.Optional = source.Optional
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorOptionalAddresses:
				result.OptionalAddresses = source.OptionalAddresses
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutes:
				result.Routes = source.Routes
				wholeRoutesAccepted = true
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutingPolicy:
				result.RoutingPolicy = source.RoutingPolicy
				wholeRoutingPolicyAccepted = true
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorGateway4:
				result.Gateway4 = source.Gateway4
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorGateway6:
				result.Gateway6 = source.Gateway6
			}
		case *DeviceSpecNetworkingConfigVlansOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp4Overrides:
				dhcp4OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorDhcp6Overrides:
				dhcp6OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorNameservers:
				nameserversMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath))
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutes:
				routesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath))
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorRoutingPolicy:
				routingPolicyMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath))
			case DeviceSpecNetworkingConfigVlansOpts_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
			}
		}
	}
	if wholeDhcp4OverridesAccepted == false && len(dhcp4OverridesMask.Paths) > 0 {
		result.Dhcp4Overrides = dhcp4OverridesMask.Project(source.GetDhcp4Overrides())
	}
	if wholeDhcp6OverridesAccepted == false && len(dhcp6OverridesMask.Paths) > 0 {
		result.Dhcp6Overrides = dhcp6OverridesMask.Project(source.GetDhcp6Overrides())
	}
	if wholeNameserversAccepted == false && len(nameserversMask.Paths) > 0 {
		result.Nameservers = nameserversMask.Project(source.GetNameservers())
	}
	if wholeRoutesAccepted == false && len(routesMask.Paths) > 0 {
		for _, sourceItem := range source.GetRoutes() {
			result.Routes = append(result.Routes, routesMask.Project(sourceItem))
		}
	}
	if wholeRoutingPolicyAccepted == false && len(routingPolicyMask.Paths) > 0 {
		result.RoutingPolicy = routingPolicyMask.Project(source.GetRoutingPolicy())
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_VlansOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_VlansOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_ModemOpts_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigModemOpts_FieldPath
}

func FullDevice_Spec_NetworkingConfig_ModemOpts_FieldMask() *Device_Spec_NetworkingConfig_ModemOpts_FieldMask {
	res := &Device_Spec_NetworkingConfig_ModemOpts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorApn})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorUsername})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorPassword})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNumber})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNetworkId})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDeviceId})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorPin})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorSimId})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorSimOperatorId})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAutoConfig})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRenderer})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorIpv6Privacy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorLinkLocal})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorCritical})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcpIdentifier})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6Overrides})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAcceptRa})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNameservers})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorOptional})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorOptionalAddresses})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutingPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAuth})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorGateway4})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath{selector: DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorGateway6})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigModemOpts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 31)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigModemOpts_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) *Device_Spec_NetworkingConfig_ModemOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_ModemOpts_FieldMask{}
	removedSelectors := make([]bool, 31)
	otherSubMasks := map[DeviceSpecNetworkingConfigModemOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkingConfigModemOpts_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6Overrides: &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNameservers:    &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutes:         &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutingPolicy:  &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{},
		DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAuth:           &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkingConfigModemOpts_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4Overrides:
						mySubMasks[DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6Overrides:
						mySubMasks[DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6Overrides] = FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask()
					case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNameservers:
						mySubMasks[DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNameservers] = FullDevice_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask()
					case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutes:
						mySubMasks[DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutes] = FullDevice_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask()
					case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutingPolicy:
						mySubMasks[DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutingPolicy] = FullDevice_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask()
					case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAuth] = FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkingConfigModemOpts_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkingConfigModemOpts_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_ModemOpts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_ModemOpts_FieldMask {
	result := &Device_Spec_NetworkingConfig_ModemOpts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigModemOpts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigModemOpts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_ModemOpts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_ModemOpts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) AppendPath(path DeviceSpecNetworkingConfigModemOpts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigModemOpts_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) GetPaths() []DeviceSpecNetworkingConfigModemOpts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigModemOpts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_ModemOpts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_ModemOpts), source.(*Device_Spec_NetworkingConfig_ModemOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) Project(source *Device_Spec_NetworkingConfig_ModemOpts) *Device_Spec_NetworkingConfig_ModemOpts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_ModemOpts{}
	dhcp4OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp4OverridesAccepted := false
	dhcp6OverridesMask := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	wholeDhcp6OverridesAccepted := false
	nameserversMask := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	wholeNameserversAccepted := false
	routesMask := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	wholeRoutesAccepted := false
	routingPolicyMask := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	wholeRoutingPolicyAccepted := false
	authMask := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigModemOpts_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorApn:
				result.Apn = source.Apn
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorUsername:
				result.Username = source.Username
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorPassword:
				result.Password = source.Password
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNumber:
				result.Number = source.Number
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNetworkId:
				result.NetworkId = source.NetworkId
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDeviceId:
				result.DeviceId = source.DeviceId
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorPin:
				result.Pin = source.Pin
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorSimId:
				result.SimId = source.SimId
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorSimOperatorId:
				result.SimOperatorId = source.SimOperatorId
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAutoConfig:
				result.AutoConfig = source.AutoConfig
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRenderer:
				result.Renderer = source.Renderer
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4:
				result.Dhcp4 = source.Dhcp4
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6:
				result.Dhcp6 = source.Dhcp6
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorIpv6Privacy:
				result.Ipv6Privacy = source.Ipv6Privacy
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorLinkLocal:
				result.LinkLocal = source.LinkLocal
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorCritical:
				result.Critical = source.Critical
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcpIdentifier:
				result.DhcpIdentifier = source.DhcpIdentifier
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4Overrides:
				result.Dhcp4Overrides = source.Dhcp4Overrides
				wholeDhcp4OverridesAccepted = true
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6Overrides:
				result.Dhcp6Overrides = source.Dhcp6Overrides
				wholeDhcp6OverridesAccepted = true
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAcceptRa:
				result.AcceptRa = source.AcceptRa
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNameservers:
				result.Nameservers = source.Nameservers
				wholeNameserversAccepted = true
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorMtu:
				result.Mtu = source.Mtu
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorOptional:
				result.Optional = source.Optional
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorOptionalAddresses:
				result.OptionalAddresses = source.OptionalAddresses
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutes:
				result.Routes = source.Routes
				wholeRoutesAccepted = true
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutingPolicy:
				result.RoutingPolicy = source.RoutingPolicy
				wholeRoutingPolicyAccepted = true
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorGateway4:
				result.Gateway4 = source.Gateway4
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorGateway6:
				result.Gateway6 = source.Gateway6
			}
		case *DeviceSpecNetworkingConfigModemOpts_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp4Overrides:
				dhcp4OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorDhcp6Overrides:
				dhcp6OverridesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorNameservers:
				nameserversMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath))
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutes:
				routesMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath))
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorRoutingPolicy:
				routingPolicyMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath))
			case DeviceSpecNetworkingConfigModemOpts_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
			}
		}
	}
	if wholeDhcp4OverridesAccepted == false && len(dhcp4OverridesMask.Paths) > 0 {
		result.Dhcp4Overrides = dhcp4OverridesMask.Project(source.GetDhcp4Overrides())
	}
	if wholeDhcp6OverridesAccepted == false && len(dhcp6OverridesMask.Paths) > 0 {
		result.Dhcp6Overrides = dhcp6OverridesMask.Project(source.GetDhcp6Overrides())
	}
	if wholeNameserversAccepted == false && len(nameserversMask.Paths) > 0 {
		result.Nameservers = nameserversMask.Project(source.GetNameservers())
	}
	if wholeRoutesAccepted == false && len(routesMask.Paths) > 0 {
		for _, sourceItem := range source.GetRoutes() {
			result.Routes = append(result.Routes, routesMask.Project(sourceItem))
		}
	}
	if wholeRoutingPolicyAccepted == false && len(routingPolicyMask.Paths) > 0 {
		result.RoutingPolicy = routingPolicyMask.Project(source.GetRoutingPolicy())
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_ModemOpts))
}

func (fieldMask *Device_Spec_NetworkingConfig_ModemOpts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath
}

func FullDevice_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask() *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask {
	res := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseDns})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseNtp})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorSendHostname})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseHostname})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseMtu})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorHostname})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseRoutes})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorRouteMetric})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) AppendPath(path DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) GetPaths() []DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides), source.(*Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) Project(source *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides) *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseDns:
				result.UseDns = source.UseDns
			case DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseNtp:
				result.UseNtp = source.UseNtp
			case DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorSendHostname:
				result.SendHostname = source.SendHostname
			case DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseHostname:
				result.UseHostname = source.UseHostname
			case DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseMtu:
				result.UseMtu = source.UseMtu
			case DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorHostname:
				result.Hostname = source.Hostname
			case DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorUseRoutes:
				result.UseRoutes = source.UseRoutes
			case DeviceSpecNetworkingConfigCommonOptsDHCPOverrides_FieldPathSelectorRouteMetric:
				result.RouteMetric = source.RouteMetric
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_DHCPOverrides_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath
}

func FullDevice_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask() *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask {
	res := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsNameservers_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPathSelectorSearch})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsNameservers_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPathSelectorAddresses})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigCommonOptsNameservers_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsNameservers_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) AppendPath(path DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) GetPaths() []DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigCommonOptsNameservers_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_CommonOpts_Nameservers) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_CommonOpts_Nameservers), source.(*Device_Spec_NetworkingConfig_CommonOpts_Nameservers))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) Project(source *Device_Spec_NetworkingConfig_CommonOpts_Nameservers) *Device_Spec_NetworkingConfig_CommonOpts_Nameservers {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_CommonOpts_Nameservers{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsNameservers_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPathSelectorSearch:
				result.Search = source.Search
			case DeviceSpecNetworkingConfigCommonOptsNameservers_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_CommonOpts_Nameservers))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Nameservers_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath
}

func FullDevice_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask() *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask {
	res := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorFrom})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorTo})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorVia})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorOnLink})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorMetric})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorType})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorScope})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorTable})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) AppendPath(path DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) GetPaths() []DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigCommonOptsRoutes_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_CommonOpts_Routes) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_CommonOpts_Routes), source.(*Device_Spec_NetworkingConfig_CommonOpts_Routes))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) Project(source *Device_Spec_NetworkingConfig_CommonOpts_Routes) *Device_Spec_NetworkingConfig_CommonOpts_Routes {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_CommonOpts_Routes{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsRoutes_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorFrom:
				result.From = source.From
			case DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorTo:
				result.To = source.To
			case DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorVia:
				result.Via = source.Via
			case DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorOnLink:
				result.OnLink = source.OnLink
			case DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorMetric:
				result.Metric = source.Metric
			case DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorType:
				result.Type = source.Type
			case DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorScope:
				result.Scope = source.Scope
			case DeviceSpecNetworkingConfigCommonOptsRoutes_FieldPathSelectorTable:
				result.Table = source.Table
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_CommonOpts_Routes))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Routes_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath
}

func FullDevice_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask() *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask {
	res := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorFrom})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorTo})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorTable})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorPriority})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorMark})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorTypeOfService})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) AppendPath(path DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) GetPaths() []DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy), source.(*Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) Project(source *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy) *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorFrom:
				result.From = source.From
			case DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorTo:
				result.To = source.To
			case DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorTable:
				result.Table = source.Table
			case DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorPriority:
				result.Priority = source.Priority
			case DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorMark:
				result.Mark = source.Mark
			case DeviceSpecNetworkingConfigCommonOptsRoutingPolicy_FieldPathSelectorTypeOfService:
				result.TypeOfService = source.TypeOfService
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_RoutingPolicy_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath
}

func FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask() *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask {
	res := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorKeyManagement})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorPassword})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorMethod})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorIdentity})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorAnonymousIdentity})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorCaCertificate})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorClientCertificate})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorClientKey})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorClientKeyPassword})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath{selector: DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorPhase2Auth})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigCommonOptsAuth_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigCommonOptsAuth_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask {
	result := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigCommonOptsAuth_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) AppendPath(path DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) GetPaths() []DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigCommonOptsAuth_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_CommonOpts_Auth) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_CommonOpts_Auth), source.(*Device_Spec_NetworkingConfig_CommonOpts_Auth))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) Project(source *Device_Spec_NetworkingConfig_CommonOpts_Auth) *Device_Spec_NetworkingConfig_CommonOpts_Auth {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_CommonOpts_Auth{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigCommonOptsAuth_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorKeyManagement:
				result.KeyManagement = source.KeyManagement
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorPassword:
				result.Password = source.Password
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorMethod:
				result.Method = source.Method
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorIdentity:
				result.Identity = source.Identity
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorAnonymousIdentity:
				result.AnonymousIdentity = source.AnonymousIdentity
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorCaCertificate:
				result.CaCertificate = source.CaCertificate
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorClientCertificate:
				result.ClientCertificate = source.ClientCertificate
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorClientKey:
				result.ClientKey = source.ClientKey
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorClientKeyPassword:
				result.ClientKeyPassword = source.ClientKeyPassword
			case DeviceSpecNetworkingConfigCommonOptsAuth_FieldPathSelectorPhase2Auth:
				result.Phase2Auth = source.Phase2Auth
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_CommonOpts_Auth))
}

func (fieldMask *Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigEthOptsMatch_FieldPath
}

func FullDevice_Spec_NetworkingConfig_EthOpts_Match_FieldMask() *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask {
	res := &Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOptsMatch_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOptsMatch_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigEthOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkingConfigEthOptsMatch_FieldPathSelectorDriver})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigEthOptsMatch_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigEthOptsMatch_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigEthOptsMatch_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask {
	result := &Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigEthOptsMatch_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask {
	result := &Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigEthOptsMatch_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigEthOptsMatch_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) AppendPath(path DeviceSpecNetworkingConfigEthOptsMatch_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigEthOptsMatch_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) GetPaths() []DeviceSpecNetworkingConfigEthOptsMatch_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigEthOptsMatch_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_EthOpts_Match) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_EthOpts_Match), source.(*Device_Spec_NetworkingConfig_EthOpts_Match))
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) Project(source *Device_Spec_NetworkingConfig_EthOpts_Match) *Device_Spec_NetworkingConfig_EthOpts_Match {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_EthOpts_Match{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigEthOptsMatch_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigEthOptsMatch_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceSpecNetworkingConfigEthOptsMatch_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigEthOptsMatch_FieldPathSelectorDriver:
				result.Driver = source.Driver
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_EthOpts_Match))
}

func (fieldMask *Device_Spec_NetworkingConfig_EthOpts_Match_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigWifiOptsMatch_FieldPath
}

func FullDevice_Spec_NetworkingConfig_WifiOpts_Match_FieldMask() *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask {
	res := &Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsMatch_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsMatch_FieldPathSelectorMacaddress})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsMatch_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsMatch_FieldPathSelectorDriver})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigWifiOptsMatch_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigWifiOptsMatch_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigWifiOptsMatch_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask {
	result := &Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigWifiOptsMatch_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask {
	result := &Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigWifiOptsMatch_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigWifiOptsMatch_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) AppendPath(path DeviceSpecNetworkingConfigWifiOptsMatch_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigWifiOptsMatch_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) GetPaths() []DeviceSpecNetworkingConfigWifiOptsMatch_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigWifiOptsMatch_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_WifiOpts_Match) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_WifiOpts_Match), source.(*Device_Spec_NetworkingConfig_WifiOpts_Match))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) Project(source *Device_Spec_NetworkingConfig_WifiOpts_Match) *Device_Spec_NetworkingConfig_WifiOpts_Match {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_WifiOpts_Match{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigWifiOptsMatch_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigWifiOptsMatch_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceSpecNetworkingConfigWifiOptsMatch_FieldPathSelectorMacaddress:
				result.Macaddress = source.Macaddress
			case DeviceSpecNetworkingConfigWifiOptsMatch_FieldPathSelectorDriver:
				result.Driver = source.Driver
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_WifiOpts_Match))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_Match_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath
}

func FullDevice_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask() *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask {
	res := &Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorPassword})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorMode})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorBssid})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorBand})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorChannel})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorHidden})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath{selector: DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorAuth})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask {
	result := &Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorAuth: &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}
	mySubMasks := map[DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorAuth: &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorAuth:
						mySubMasks[DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorAuth] = FullDevice_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask {
	result := &Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) AppendPath(path DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) GetPaths() []DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_WifiOpts_AccessPoint), source.(*Device_Spec_NetworkingConfig_WifiOpts_AccessPoint))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) Project(source *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint) *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_WifiOpts_AccessPoint{}
	authMask := &Device_Spec_NetworkingConfig_CommonOpts_Auth_FieldMask{}
	wholeAuthAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorPassword:
				result.Password = source.Password
			case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorMode:
				result.Mode = source.Mode
			case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorBssid:
				result.Bssid = source.Bssid
			case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorBand:
				result.Band = source.Band
			case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorChannel:
				result.Channel = source.Channel
			case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorHidden:
				result.Hidden = source.Hidden
			case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorAuth:
				result.Auth = source.Auth
				wholeAuthAccepted = true
			}
		case *DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldSubPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigWifiOptsAccessPoint_FieldPathSelectorAuth:
				authMask.AppendPath(tp.subPath.(DeviceSpecNetworkingConfigCommonOptsAuth_FieldPath))
			}
		}
	}
	if wholeAuthAccepted == false && len(authMask.Paths) > 0 {
		result.Auth = authMask.Project(source.GetAuth())
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_WifiOpts_AccessPoint))
}

func (fieldMask *Device_Spec_NetworkingConfig_WifiOpts_AccessPoint_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath
}

func FullDevice_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask() *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask {
	res := &Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorAgeingTime})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorPriority})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorPortPriority})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorForwardDelay})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorHelloTime})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorMaxAge})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorPathCost})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorStp})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask {
	result := &Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask {
	result := &Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) AppendPath(path DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) GetPaths() []DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigBridgesOptsParameters_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_BridgesOpts_Parameters) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_BridgesOpts_Parameters), source.(*Device_Spec_NetworkingConfig_BridgesOpts_Parameters))
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) Project(source *Device_Spec_NetworkingConfig_BridgesOpts_Parameters) *Device_Spec_NetworkingConfig_BridgesOpts_Parameters {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_BridgesOpts_Parameters{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigBridgesOptsParameters_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorAgeingTime:
				result.AgeingTime = source.AgeingTime
			case DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorPriority:
				result.Priority = source.Priority
			case DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorPortPriority:
				result.PortPriority = source.PortPriority
			case DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorForwardDelay:
				result.ForwardDelay = source.ForwardDelay
			case DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorHelloTime:
				result.HelloTime = source.HelloTime
			case DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorMaxAge:
				result.MaxAge = source.MaxAge
			case DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorPathCost:
				result.PathCost = source.PathCost
			case DeviceSpecNetworkingConfigBridgesOptsParameters_FieldPathSelectorStp:
				result.Stp = source.Stp
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_BridgesOpts_Parameters))
}

func (fieldMask *Device_Spec_NetworkingConfig_BridgesOpts_Parameters_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigBondsOptsParameters_FieldPath
}

func FullDevice_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask() *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask {
	res := &Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorMode})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorLacpRate})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorMiiMonitorInterval})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorMinLinks})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorTransmitHashPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorAdSelect})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorAllSlavesActive})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorArpIpTargets})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorArpValidate})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorArpAllTargets})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorUpDelay})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorFailOverMacPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorGratuitousArp})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorPacketsPerSlave})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorPrimaryReselectPolicy})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorResendIgmp})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorLearnPacketInterval})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath{selector: DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorPrimary})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigBondsOptsParameters_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 18)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigBondsOptsParameters_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask {
	result := &Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask{}
	removedSelectors := make([]bool, 18)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask {
	result := &Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigBondsOptsParameters_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigBondsOptsParameters_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) AppendPath(path DeviceSpecNetworkingConfigBondsOptsParameters_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigBondsOptsParameters_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) GetPaths() []DeviceSpecNetworkingConfigBondsOptsParameters_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigBondsOptsParameters_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_BondsOpts_Parameters) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_BondsOpts_Parameters), source.(*Device_Spec_NetworkingConfig_BondsOpts_Parameters))
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) Project(source *Device_Spec_NetworkingConfig_BondsOpts_Parameters) *Device_Spec_NetworkingConfig_BondsOpts_Parameters {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_BondsOpts_Parameters{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigBondsOptsParameters_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorMode:
				result.Mode = source.Mode
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorLacpRate:
				result.LacpRate = source.LacpRate
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorMiiMonitorInterval:
				result.MiiMonitorInterval = source.MiiMonitorInterval
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorMinLinks:
				result.MinLinks = source.MinLinks
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorTransmitHashPolicy:
				result.TransmitHashPolicy = source.TransmitHashPolicy
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorAdSelect:
				result.AdSelect = source.AdSelect
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorAllSlavesActive:
				result.AllSlavesActive = source.AllSlavesActive
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorArpIpTargets:
				result.ArpIpTargets = source.ArpIpTargets
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorArpValidate:
				result.ArpValidate = source.ArpValidate
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorArpAllTargets:
				result.ArpAllTargets = source.ArpAllTargets
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorUpDelay:
				result.UpDelay = source.UpDelay
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorFailOverMacPolicy:
				result.FailOverMacPolicy = source.FailOverMacPolicy
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorGratuitousArp:
				result.GratuitousArp = source.GratuitousArp
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorPacketsPerSlave:
				result.PacketsPerSlave = source.PacketsPerSlave
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorPrimaryReselectPolicy:
				result.PrimaryReselectPolicy = source.PrimaryReselectPolicy
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorResendIgmp:
				result.ResendIgmp = source.ResendIgmp
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorLearnPacketInterval:
				result.LearnPacketInterval = source.LearnPacketInterval
			case DeviceSpecNetworkingConfigBondsOptsParameters_FieldPathSelectorPrimary:
				result.Primary = source.Primary
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_BondsOpts_Parameters))
}

func (fieldMask *Device_Spec_NetworkingConfig_BondsOpts_Parameters_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask struct {
	Paths []DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath
}

func FullDevice_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask() *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask {
	res := &Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOptsKey_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPathSelectorInput})
	res.Paths = append(res.Paths, &DeviceSpecNetworkingConfigTunnelsOptsKey_FieldTerminalPath{selector: DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPathSelectorOutput})
	return res
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecNetworkingConfigTunnelsOptsKey_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) Subtract(other *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask {
	result := &Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecNetworkingConfigTunnelsOptsKey_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) FilterInputFields() *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask {
	result := &Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) AppendPath(path DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath))
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) GetPaths() []DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecNetworkingConfigTunnelsOptsKey_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) Set(target, source *Device_Spec_NetworkingConfig_TunnelsOpts_Key) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_NetworkingConfig_TunnelsOpts_Key), source.(*Device_Spec_NetworkingConfig_TunnelsOpts_Key))
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) Project(source *Device_Spec_NetworkingConfig_TunnelsOpts_Key) *Device_Spec_NetworkingConfig_TunnelsOpts_Key {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_NetworkingConfig_TunnelsOpts_Key{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecNetworkingConfigTunnelsOptsKey_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPathSelectorInput:
				result.Input = source.Input
			case DeviceSpecNetworkingConfigTunnelsOptsKey_FieldPathSelectorOutput:
				result.Output = source.Output
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_NetworkingConfig_TunnelsOpts_Key))
}

func (fieldMask *Device_Spec_NetworkingConfig_TunnelsOpts_Key_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_SSHConfig_AuthKey_FieldMask struct {
	Paths []DeviceSpecSSHConfigAuthKey_FieldPath
}

func FullDevice_Spec_SSHConfig_AuthKey_FieldMask() *Device_Spec_SSHConfig_AuthKey_FieldMask {
	res := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorSshaKey})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorCertAuthority})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorCommand})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorEnvironment})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorFrom})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoAgentForwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPortForwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPty})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoUserRc})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoX11Forwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorPermitopen})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorPrincipals})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorTunnel})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorRestrict})
	return res
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 14)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecSSHConfigAuthKey_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecSSHConfigAuthKey_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Subtract(other *Device_Spec_SSHConfig_AuthKey_FieldMask) *Device_Spec_SSHConfig_AuthKey_FieldMask {
	result := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	removedSelectors := make([]bool, 14)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecSSHConfigAuthKey_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_SSHConfig_AuthKey_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) FilterInputFields() *Device_Spec_SSHConfig_AuthKey_FieldMask {
	result := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecSSHConfigAuthKey_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_SSHConfig_AuthKey_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_SSHConfig_AuthKey_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) AppendPath(path DeviceSpecSSHConfigAuthKey_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecSSHConfigAuthKey_FieldPath))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) GetPaths() []DeviceSpecSSHConfigAuthKey_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Set(target, source *Device_Spec_SSHConfig_AuthKey) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_SSHConfig_AuthKey), source.(*Device_Spec_SSHConfig_AuthKey))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Project(source *Device_Spec_SSHConfig_AuthKey) *Device_Spec_SSHConfig_AuthKey {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_SSHConfig_AuthKey{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecSSHConfigAuthKey_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorSshaKey:
				result.SshaKey = source.SshaKey
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorCertAuthority:
				result.CertAuthority = source.CertAuthority
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorCommand:
				result.Command = source.Command
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorEnvironment:
				result.Environment = source.Environment
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorFrom:
				result.From = source.From
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoAgentForwarding:
				result.NoAgentForwarding = source.NoAgentForwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPortForwarding:
				result.NoPortForwarding = source.NoPortForwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPty:
				result.NoPty = source.NoPty
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoUserRc:
				result.NoUserRc = source.NoUserRc
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoX11Forwarding:
				result.NoX11Forwarding = source.NoX11Forwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorPermitopen:
				result.Permitopen = source.Permitopen
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorPrincipals:
				result.Principals = source.Principals
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorTunnel:
				result.Tunnel = source.Tunnel
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorRestrict:
				result.Restrict = source.Restrict
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_SSHConfig_AuthKey))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_Address_FieldMask struct {
	Paths []DeviceStatusAddress_FieldPath
}

func FullDevice_Status_Address_FieldMask() *Device_Status_Address_FieldMask {
	res := &Device_Status_Address_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusAddress_FieldTerminalPath{selector: DeviceStatusAddress_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceStatusAddress_FieldTerminalPath{selector: DeviceStatusAddress_FieldPathSelectorType})
	return res
}

func (fieldMask *Device_Status_Address_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_Address_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_Address_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusAddress_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusAddress_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_Address_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusAddress_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_Address_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_Address_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_Address_FieldMask) Subtract(other *Device_Status_Address_FieldMask) *Device_Status_Address_FieldMask {
	result := &Device_Status_Address_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusAddress_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_Address_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_Address_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_Address_FieldMask) FilterInputFields() *Device_Status_Address_FieldMask {
	result := &Device_Status_Address_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_Address_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_Address_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusAddress_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusAddress_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_Address_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_Address_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_Address_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_Address_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) AppendPath(path DeviceStatusAddress_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_Address_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusAddress_FieldPath))
}

func (fieldMask *Device_Status_Address_FieldMask) GetPaths() []DeviceStatusAddress_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_Address_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_Address_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusAddress_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) Set(target, source *Device_Status_Address) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_Address_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_Address), source.(*Device_Status_Address))
}

func (fieldMask *Device_Status_Address_FieldMask) Project(source *Device_Status_Address) *Device_Status_Address {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_Address{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusAddress_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusAddress_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceStatusAddress_FieldPathSelectorType:
				result.Type = source.Type
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_Address_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_Address))
}

func (fieldMask *Device_Status_Address_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_Condition_FieldMask struct {
	Paths []DeviceStatusCondition_FieldPath
}

func FullDevice_Status_Condition_FieldMask() *Device_Status_Condition_FieldMask {
	res := &Device_Status_Condition_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorMessage})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorReason})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorType})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorLastHeartBeatTime})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorLastTransitionTime})
	return res
}

func (fieldMask *Device_Status_Condition_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_Condition_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_Condition_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusCondition_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusCondition_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_Condition_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusCondition_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_Condition_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_Condition_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_Condition_FieldMask) Subtract(other *Device_Status_Condition_FieldMask) *Device_Status_Condition_FieldMask {
	result := &Device_Status_Condition_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusCondition_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_Condition_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_Condition_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_Condition_FieldMask) FilterInputFields() *Device_Status_Condition_FieldMask {
	result := &Device_Status_Condition_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_Condition_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_Condition_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusCondition_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusCondition_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_Condition_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_Condition_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_Condition_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_Condition_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) AppendPath(path DeviceStatusCondition_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_Condition_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusCondition_FieldPath))
}

func (fieldMask *Device_Status_Condition_FieldMask) GetPaths() []DeviceStatusCondition_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_Condition_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_Condition_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusCondition_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) Set(target, source *Device_Status_Condition) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_Condition_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_Condition), source.(*Device_Status_Condition))
}

func (fieldMask *Device_Status_Condition_FieldMask) Project(source *Device_Status_Condition) *Device_Status_Condition {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_Condition{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusCondition_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusCondition_FieldPathSelectorMessage:
				result.Message = source.Message
			case DeviceStatusCondition_FieldPathSelectorReason:
				result.Reason = source.Reason
			case DeviceStatusCondition_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusCondition_FieldPathSelectorType:
				result.Type = source.Type
			case DeviceStatusCondition_FieldPathSelectorLastHeartBeatTime:
				result.LastHeartBeatTime = source.LastHeartBeatTime
			case DeviceStatusCondition_FieldPathSelectorLastTransitionTime:
				result.LastTransitionTime = source.LastTransitionTime
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_Condition_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_Condition))
}

func (fieldMask *Device_Status_Condition_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_NetworkConfigState_FieldMask struct {
	Paths []DeviceStatusNetworkConfigState_FieldPath
}

func FullDevice_Status_NetworkConfigState_FieldMask() *Device_Status_NetworkConfigState_FieldMask {
	res := &Device_Status_NetworkConfigState_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorActiveNetworkConfigSource})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetworkConfigSource})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetworkConfigError})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorDefaultConfig})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorActiveConfig})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorDesiredConfig})
	return res
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_NetworkConfigState_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusNetworkConfigState_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusNetworkConfigState_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusNetworkConfigState_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Subtract(other *Device_Status_NetworkConfigState_FieldMask) *Device_Status_NetworkConfigState_FieldMask {
	result := &Device_Status_NetworkConfigState_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[DeviceStatusNetworkConfigState_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusNetworkConfigState_FieldPathSelectorDefaultConfig: &Device_Spec_NetplanConfig_FieldMask{},
		DeviceStatusNetworkConfigState_FieldPathSelectorActiveConfig:  &Device_Spec_NetplanConfig_FieldMask{},
		DeviceStatusNetworkConfigState_FieldPathSelectorDesiredConfig: &Device_Spec_NetplanConfig_FieldMask{},
	}
	mySubMasks := map[DeviceStatusNetworkConfigState_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusNetworkConfigState_FieldPathSelectorDefaultConfig: &Device_Spec_NetplanConfig_FieldMask{},
		DeviceStatusNetworkConfigState_FieldPathSelectorActiveConfig:  &Device_Spec_NetplanConfig_FieldMask{},
		DeviceStatusNetworkConfigState_FieldPathSelectorDesiredConfig: &Device_Spec_NetplanConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusNetworkConfigState_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusNetworkConfigState_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusNetworkConfigState_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusNetworkConfigState_FieldPathSelectorDefaultConfig:
						mySubMasks[DeviceStatusNetworkConfigState_FieldPathSelectorDefaultConfig] = FullDevice_Spec_NetplanConfig_FieldMask()
					case DeviceStatusNetworkConfigState_FieldPathSelectorActiveConfig:
						mySubMasks[DeviceStatusNetworkConfigState_FieldPathSelectorActiveConfig] = FullDevice_Spec_NetplanConfig_FieldMask()
					case DeviceStatusNetworkConfigState_FieldPathSelectorDesiredConfig:
						mySubMasks[DeviceStatusNetworkConfigState_FieldPathSelectorDesiredConfig] = FullDevice_Spec_NetplanConfig_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusNetworkConfigState_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusNetworkConfigState_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_NetworkConfigState_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_NetworkConfigState_FieldMask) FilterInputFields() *Device_Status_NetworkConfigState_FieldMask {
	result := &Device_Status_NetworkConfigState_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_NetworkConfigState_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusNetworkConfigState_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusNetworkConfigState_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_NetworkConfigState_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_NetworkConfigState_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) AppendPath(path DeviceStatusNetworkConfigState_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusNetworkConfigState_FieldPath))
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) GetPaths() []DeviceStatusNetworkConfigState_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusNetworkConfigState_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Set(target, source *Device_Status_NetworkConfigState) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_NetworkConfigState), source.(*Device_Status_NetworkConfigState))
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Project(source *Device_Status_NetworkConfigState) *Device_Status_NetworkConfigState {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_NetworkConfigState{}
	defaultConfigMask := &Device_Spec_NetplanConfig_FieldMask{}
	wholeDefaultConfigAccepted := false
	activeConfigMask := &Device_Spec_NetplanConfig_FieldMask{}
	wholeActiveConfigAccepted := false
	desiredConfigMask := &Device_Spec_NetplanConfig_FieldMask{}
	wholeDesiredConfigAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusNetworkConfigState_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusNetworkConfigState_FieldPathSelectorActiveNetworkConfigSource:
				result.ActiveNetworkConfigSource = source.ActiveNetworkConfigSource
			case DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetworkConfigSource:
				result.DesiredNetworkConfigSource = source.DesiredNetworkConfigSource
			case DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetworkConfigError:
				result.DesiredNetworkConfigError = source.DesiredNetworkConfigError
			case DeviceStatusNetworkConfigState_FieldPathSelectorDefaultConfig:
				result.DefaultConfig = source.DefaultConfig
				wholeDefaultConfigAccepted = true
			case DeviceStatusNetworkConfigState_FieldPathSelectorActiveConfig:
				result.ActiveConfig = source.ActiveConfig
				wholeActiveConfigAccepted = true
			case DeviceStatusNetworkConfigState_FieldPathSelectorDesiredConfig:
				result.DesiredConfig = source.DesiredConfig
				wholeDesiredConfigAccepted = true
			}
		case *DeviceStatusNetworkConfigState_FieldSubPath:
			switch tp.selector {
			case DeviceStatusNetworkConfigState_FieldPathSelectorDefaultConfig:
				defaultConfigMask.AppendPath(tp.subPath.(DeviceSpecNetplanConfig_FieldPath))
			case DeviceStatusNetworkConfigState_FieldPathSelectorActiveConfig:
				activeConfigMask.AppendPath(tp.subPath.(DeviceSpecNetplanConfig_FieldPath))
			case DeviceStatusNetworkConfigState_FieldPathSelectorDesiredConfig:
				desiredConfigMask.AppendPath(tp.subPath.(DeviceSpecNetplanConfig_FieldPath))
			}
		}
	}
	if wholeDefaultConfigAccepted == false && len(defaultConfigMask.Paths) > 0 {
		result.DefaultConfig = defaultConfigMask.Project(source.GetDefaultConfig())
	}
	if wholeActiveConfigAccepted == false && len(activeConfigMask.Paths) > 0 {
		result.ActiveConfig = activeConfigMask.Project(source.GetActiveConfig())
	}
	if wholeDesiredConfigAccepted == false && len(desiredConfigMask.Paths) > 0 {
		result.DesiredConfig = desiredConfigMask.Project(source.GetDesiredConfig())
	}
	return result
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_NetworkConfigState))
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_ProxyConfigStatus_FieldMask struct {
	Paths []DeviceStatusProxyConfigStatus_FieldPath
}

func FullDevice_Status_ProxyConfigStatus_FieldMask() *Device_Status_ProxyConfigStatus_FieldMask {
	res := &Device_Status_ProxyConfigStatus_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfigSource})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorDesiredConfigSource})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorProxyConfigError})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig})
	return res
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusProxyConfigStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusProxyConfigStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusProxyConfigStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Subtract(other *Device_Status_ProxyConfigStatus_FieldMask) *Device_Status_ProxyConfigStatus_FieldMask {
	result := &Device_Status_ProxyConfigStatus_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[DeviceStatusProxyConfigStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig: &Device_Spec_ProxyConfig_FieldMask{},
		DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:  &Device_Spec_ProxyConfig_FieldMask{},
		DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:     &Device_Spec_ProxyConfig_FieldMask{},
	}
	mySubMasks := map[DeviceStatusProxyConfigStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig: &Device_Spec_ProxyConfig_FieldMask{},
		DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:  &Device_Spec_ProxyConfig_FieldMask{},
		DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:     &Device_Spec_ProxyConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusProxyConfigStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusProxyConfigStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusProxyConfigStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig:
						mySubMasks[DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					case DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:
						mySubMasks[DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					case DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:
						mySubMasks[DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusProxyConfigStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusProxyConfigStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_ProxyConfigStatus_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) FilterInputFields() *Device_Status_ProxyConfigStatus_FieldMask {
	result := &Device_Status_ProxyConfigStatus_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusProxyConfigStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusProxyConfigStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_ProxyConfigStatus_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_ProxyConfigStatus_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) AppendPath(path DeviceStatusProxyConfigStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusProxyConfigStatus_FieldPath))
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) GetPaths() []DeviceStatusProxyConfigStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusProxyConfigStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Set(target, source *Device_Status_ProxyConfigStatus) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_ProxyConfigStatus), source.(*Device_Status_ProxyConfigStatus))
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Project(source *Device_Status_ProxyConfigStatus) *Device_Status_ProxyConfigStatus {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_ProxyConfigStatus{}
	defaultConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeDefaultConfigAccepted := false
	activeConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeActiveConfigAccepted := false
	apiConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeApiConfigAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusProxyConfigStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfigSource:
				result.ActiveConfigSource = source.ActiveConfigSource
			case DeviceStatusProxyConfigStatus_FieldPathSelectorDesiredConfigSource:
				result.DesiredConfigSource = source.DesiredConfigSource
			case DeviceStatusProxyConfigStatus_FieldPathSelectorProxyConfigError:
				result.ProxyConfigError = source.ProxyConfigError
			case DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig:
				result.DefaultConfig = source.DefaultConfig
				wholeDefaultConfigAccepted = true
			case DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:
				result.ActiveConfig = source.ActiveConfig
				wholeActiveConfigAccepted = true
			case DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:
				result.ApiConfig = source.ApiConfig
				wholeApiConfigAccepted = true
			}
		case *DeviceStatusProxyConfigStatus_FieldSubPath:
			switch tp.selector {
			case DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig:
				defaultConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			case DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:
				activeConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			case DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:
				apiConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			}
		}
	}
	if wholeDefaultConfigAccepted == false && len(defaultConfigMask.Paths) > 0 {
		result.DefaultConfig = defaultConfigMask.Project(source.GetDefaultConfig())
	}
	if wholeActiveConfigAccepted == false && len(activeConfigMask.Paths) > 0 {
		result.ActiveConfig = activeConfigMask.Project(source.GetActiveConfig())
	}
	if wholeApiConfigAccepted == false && len(apiConfigMask.Paths) > 0 {
		result.ApiConfig = apiConfigMask.Project(source.GetApiConfig())
	}
	return result
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_ProxyConfigStatus))
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_FieldMask() *Device_Status_DeviceInfo_FieldMask {
	res := &Device_Status_DeviceInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorArchitecture})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOperatingSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorKernelVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOsImage})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorContainerRuntimeVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOsVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorDriver})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorNetworkInterfaces})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_FieldMask) *Device_Status_DeviceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_FieldMask{}
	removedSelectors := make([]bool, 10)
	otherSubMasks := map[DeviceStatusDeviceInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:       &Device_Status_DeviceInfo_HardwareInformation_FieldMask{},
		DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo: &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:       &Device_Status_DeviceInfo_HardwareInformation_FieldMask{},
		DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo: &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
						mySubMasks[DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation] = FullDevice_Status_DeviceInfo_HardwareInformation_FieldMask()
					case DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo:
						mySubMasks[DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo] = FullDevice_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo), source.(*Device_Status_DeviceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Project(source *Device_Status_DeviceInfo) *Device_Status_DeviceInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo{}
	hardwareInformationMask := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	wholeHardwareInformationAccepted := false
	controlPlaneInterfaceInfoMask := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{}
	wholeControlPlaneInterfaceInfoAccepted := false
	var networkInterfacesMapKeys []string
	wholeNetworkInterfacesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfo_FieldPathSelectorArchitecture:
				result.Architecture = source.Architecture
			case DeviceStatusDeviceInfo_FieldPathSelectorOperatingSystem:
				result.OperatingSystem = source.OperatingSystem
			case DeviceStatusDeviceInfo_FieldPathSelectorKernelVersion:
				result.KernelVersion = source.KernelVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorOsImage:
				result.OsImage = source.OsImage
			case DeviceStatusDeviceInfo_FieldPathSelectorContainerRuntimeVersion:
				result.ContainerRuntimeVersion = source.ContainerRuntimeVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorOsVersion:
				result.OsVersion = source.OsVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorDriver:
				result.Driver = source.Driver
			case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
				result.HardwareInformation = source.HardwareInformation
				wholeHardwareInformationAccepted = true
			case DeviceStatusDeviceInfo_FieldPathSelectorNetworkInterfaces:
				result.NetworkInterfaces = source.NetworkInterfaces
				wholeNetworkInterfacesAccepted = true
			case DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo:
				result.ControlPlaneInterfaceInfo = source.ControlPlaneInterfaceInfo
				wholeControlPlaneInterfaceInfoAccepted = true
			}
		case *DeviceStatusDeviceInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
				hardwareInformationMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformation_FieldPath))
			case DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo:
				controlPlaneInterfaceInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath))
			}
		case *DeviceStatusDeviceInfo_FieldPathMap:
			switch tp.selector {
			case DeviceStatusDeviceInfo_FieldPathSelectorNetworkInterfaces:
				networkInterfacesMapKeys = append(networkInterfacesMapKeys, tp.key)
			}
		}
	}
	if wholeHardwareInformationAccepted == false && len(hardwareInformationMask.Paths) > 0 {
		result.HardwareInformation = hardwareInformationMask.Project(source.GetHardwareInformation())
	}
	if wholeNetworkInterfacesAccepted == false && len(networkInterfacesMapKeys) > 0 && source.GetNetworkInterfaces() != nil {
		copiedMap := map[string]*Device_Status_DeviceInfo_NetworkInterface{}
		sourceMap := source.GetNetworkInterfaces()
		for _, key := range networkInterfacesMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.NetworkInterfaces = copiedMap
	}
	if wholeControlPlaneInterfaceInfoAccepted == false && len(controlPlaneInterfaceInfoMask.Paths) > 0 {
		result.ControlPlaneInterfaceInfo = controlPlaneInterfaceInfoMask.Project(source.GetControlPlaneInterfaceInfo())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformation_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	removedSelectors := make([]bool, 11)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:          &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:        &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:      &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:         &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:       &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:     &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:         &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:  &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:   &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:  &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:          &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:        &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:      &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:         &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:       &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:     &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:         &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:  &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:   &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:  &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformation_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs] = FullDevice_Status_DeviceInfo_HardwareInformation_OS_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios] = FullDevice_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem] = FullDevice_Status_DeviceInfo_HardwareInformation_System_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork] = FullDevice_Status_DeviceInfo_HardwareInformation_Network_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu] = FullDevice_Status_DeviceInfo_HardwareInformation_GPU_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformation_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation), source.(*Device_Status_DeviceInfo_HardwareInformation))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation) *Device_Status_DeviceInfo_HardwareInformation {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation{}
	osMask := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	wholeOsAccepted := false
	biosMask := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	wholeBiosAccepted := false
	systemMask := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	wholeSystemAccepted := false
	cpuMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	wholeCpuAccepted := false
	blockMask := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	wholeBlockAccepted := false
	networkMask := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	wholeNetworkAccepted := false
	gpuMask := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	wholeGpuAccepted := false
	memoryInfoMask := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	wholeMemoryInfoAccepted := false
	hailoInfoMask := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	wholeHailoInfoAccepted := false
	nvidiaInfoMask := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	wholeNvidiaInfoAccepted := false
	modemStatusMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{}
	wholeModemStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
				result.Os = source.Os
				wholeOsAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
				result.Bios = source.Bios
				wholeBiosAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
				result.System = source.System
				wholeSystemAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
				result.Cpu = source.Cpu
				wholeCpuAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
				result.Block = source.Block
				wholeBlockAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
				result.Network = source.Network
				wholeNetworkAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
				result.Gpu = source.Gpu
				wholeGpuAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
				result.MemoryInfo = source.MemoryInfo
				wholeMemoryInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
				result.HailoInfo = source.HailoInfo
				wholeHailoInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
				result.NvidiaInfo = source.NvidiaInfo
				wholeNvidiaInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus:
				result.ModemStatus = source.ModemStatus
				wholeModemStatusAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformation_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
				osMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationOS_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
				biosMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
				systemMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
				cpuMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
				blockMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
				networkMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
				gpuMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
				memoryInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
				hailoInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
				nvidiaInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus:
				modemStatusMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath))
			}
		}
	}
	if wholeOsAccepted == false && len(osMask.Paths) > 0 {
		result.Os = osMask.Project(source.GetOs())
	}
	if wholeBiosAccepted == false && len(biosMask.Paths) > 0 {
		result.Bios = biosMask.Project(source.GetBios())
	}
	if wholeSystemAccepted == false && len(systemMask.Paths) > 0 {
		result.System = systemMask.Project(source.GetSystem())
	}
	if wholeCpuAccepted == false && len(cpuMask.Paths) > 0 {
		result.Cpu = cpuMask.Project(source.GetCpu())
	}
	if wholeBlockAccepted == false && len(blockMask.Paths) > 0 {
		result.Block = blockMask.Project(source.GetBlock())
	}
	if wholeNetworkAccepted == false && len(networkMask.Paths) > 0 {
		result.Network = networkMask.Project(source.GetNetwork())
	}
	if wholeGpuAccepted == false && len(gpuMask.Paths) > 0 {
		result.Gpu = gpuMask.Project(source.GetGpu())
	}
	if wholeMemoryInfoAccepted == false && len(memoryInfoMask.Paths) > 0 {
		result.MemoryInfo = memoryInfoMask.Project(source.GetMemoryInfo())
	}
	if wholeHailoInfoAccepted == false && len(hailoInfoMask.Paths) > 0 {
		result.HailoInfo = hailoInfoMask.Project(source.GetHailoInfo())
	}
	if wholeNvidiaInfoAccepted == false && len(nvidiaInfoMask.Paths) > 0 {
		result.NvidiaInfo = nvidiaInfoMask.Project(source.GetNvidiaInfo())
	}
	if wholeModemStatusAccepted == false && len(modemStatusMask.Paths) > 0 {
		for _, sourceItem := range source.GetModemStatus() {
			result.ModemStatus = append(result.ModemStatus, modemStatusMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_NetworkInterface_FieldMask struct {
	Paths []DeviceStatusDeviceInfoNetworkInterface_FieldPath
}

func FullDevice_Status_DeviceInfo_NetworkInterface_FieldMask() *Device_Status_DeviceInfo_NetworkInterface_FieldMask {
	res := &Device_Status_DeviceInfo_NetworkInterface_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorInterfaceName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorIpAddressV4})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorExternalIpAddressV4})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorIpAddressV6})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorExternalIpAddressV6})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoNetworkInterface_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoNetworkInterface_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Subtract(other *Device_Status_DeviceInfo_NetworkInterface_FieldMask) *Device_Status_DeviceInfo_NetworkInterface_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[DeviceStatusDeviceInfoNetworkInterface_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:  &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{},
		DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier: &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoNetworkInterface_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:  &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{},
		DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier: &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoNetworkInterface_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:
						mySubMasks[DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo] = FullDevice_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask()
					case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier:
						mySubMasks[DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier] = FullDevice_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoNetworkInterface_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_NetworkInterface_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_NetworkInterface_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoNetworkInterface_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoNetworkInterface_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_NetworkInterface_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_NetworkInterface_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) AppendPath(path DeviceStatusDeviceInfoNetworkInterface_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoNetworkInterface_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) GetPaths() []DeviceStatusDeviceInfoNetworkInterface_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoNetworkInterface_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Set(target, source *Device_Status_DeviceInfo_NetworkInterface) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_NetworkInterface), source.(*Device_Status_DeviceInfo_NetworkInterface))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Project(source *Device_Status_DeviceInfo_NetworkInterface) *Device_Status_DeviceInfo_NetworkInterface {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_NetworkInterface{}
	asInfoMask := &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{}
	wholeAsInfoAccepted := false
	carrierMask := &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{}
	wholeCarrierAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorInterfaceName:
				result.InterfaceName = source.InterfaceName
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorIpAddressV4:
				result.IpAddressV4 = source.IpAddressV4
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorExternalIpAddressV4:
				result.ExternalIpAddressV4 = source.ExternalIpAddressV4
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorIpAddressV6:
				result.IpAddressV6 = source.IpAddressV6
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorExternalIpAddressV6:
				result.ExternalIpAddressV6 = source.ExternalIpAddressV6
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:
				result.AsInfo = source.AsInfo
				wholeAsInfoAccepted = true
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier:
				result.Carrier = source.Carrier
				wholeCarrierAccepted = true
			}
		case *DeviceStatusDeviceInfoNetworkInterface_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:
				asInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath))
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier:
				carrierMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath))
			}
		}
	}
	if wholeAsInfoAccepted == false && len(asInfoMask.Paths) > 0 {
		result.AsInfo = asInfoMask.Project(source.GetAsInfo())
	}
	if wholeCarrierAccepted == false && len(carrierMask.Paths) > 0 {
		result.Carrier = carrierMask.Project(source.GetCarrier())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_NetworkInterface))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask() *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask {
	res := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorActiveControlPlaneInterface})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorUsesProxy})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorIsFallback})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_ControlPlaneInterfaceInfo), source.(*Device_Status_DeviceInfo_ControlPlaneInterfaceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Project(source *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo) *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorActiveControlPlaneInterface:
				result.ActiveControlPlaneInterface = source.ActiveControlPlaneInterface
			case DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorUsesProxy:
				result.UsesProxy = source.UsesProxy
			case DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorIsFallback:
				result.IsFallback = source.IsFallback
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_ControlPlaneInterfaceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Capability_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorDescription})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Capability) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Capability), source.(*Device_Status_DeviceInfo_HardwareInformation_Capability))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Capability) *Device_Status_DeviceInfo_HardwareInformation_Capability {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorDescription:
				result.Description = source.Description
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Capability))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationOS_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_OS_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOperatingSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorKernelVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOsImage})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorContainerRuntimeVersion})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationOS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationOS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationOS_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationOS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_OS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_OS), source.(*Device_Status_DeviceInfo_HardwareInformation_OS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_OS) *Device_Status_DeviceInfo_HardwareInformation_OS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_OS{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOperatingSystem:
				result.OperatingSystem = source.OperatingSystem
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorKernelVersion:
				result.KernelVersion = source.KernelVersion
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOsImage:
				result.OsImage = source.OsImage
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorContainerRuntimeVersion:
				result.ContainerRuntimeVersion = source.ContainerRuntimeVersion
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_OS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorBiosVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorReleaseDate})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_BIOS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_BIOS), source.(*Device_Status_DeviceInfo_HardwareInformation_BIOS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_BIOS) *Device_Status_DeviceInfo_HardwareInformation_BIOS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorBiosVersion:
				result.BiosVersion = source.BiosVersion
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorReleaseDate:
				result.ReleaseDate = source.ReleaseDate
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_BIOS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_System_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_System_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorManufacturer})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration: &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration: &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration] = FullDevice_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_System_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_System) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_System), source.(*Device_Status_DeviceInfo_HardwareInformation_System))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_System) *Device_Status_DeviceInfo_HardwareInformation_System {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_System{}
	configurationMask := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	wholeConfigurationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorManufacturer:
				result.Manufacturer = source.Manufacturer
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorVersion:
				result.Version = source.Version
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
				result.Configuration = source.Configuration
				wholeConfigurationAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
				configurationMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath))
			}
		}
	}
	if wholeConfigurationAccepted == false && len(configurationMask.Paths) > 0 {
		result.Configuration = configurationMask.Project(source.GetConfiguration())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_System))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors: &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors: &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU) *Device_Status_DeviceInfo_HardwareInformation_CPU {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU{}
	processorsMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	wholeProcessorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
				result.Processors = source.Processors
				wholeProcessorsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
				processorsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath))
			}
		}
	}
	if wholeProcessorsAccepted == false && len(processorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProcessors() {
			result.Processors = append(result.Processors, processorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block), source.(*Device_Status_DeviceInfo_HardwareInformation_Block))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block) *Device_Status_DeviceInfo_HardwareInformation_Block {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block{}
	disksMask := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	wholeDisksAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
				result.Disks = source.Disks
				wholeDisksAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
				disksMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath))
			}
		}
	}
	if wholeDisksAccepted == false && len(disksMask.Paths) > 0 {
		for _, sourceItem := range source.GetDisks() {
			result.Disks = append(result.Disks, disksMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Network_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics: &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics: &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics] = FullDevice_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Network) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Network), source.(*Device_Status_DeviceInfo_HardwareInformation_Network))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Network) *Device_Status_DeviceInfo_HardwareInformation_Network {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Network{}
	nicsMask := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	wholeNicsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
				result.Nics = source.Nics
				wholeNicsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
				nicsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath))
			}
		}
	}
	if wholeNicsAccepted == false && len(nicsMask.Paths) > 0 {
		for _, sourceItem := range source.GetNics() {
			result.Nics = append(result.Nics, nicsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Network))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_GPU_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards: &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards: &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards] = FullDevice_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_GPU) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_GPU), source.(*Device_Status_DeviceInfo_HardwareInformation_GPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_GPU) *Device_Status_DeviceInfo_HardwareInformation_GPU {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU{}
	graphicCardsMask := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	wholeGraphicCardsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
				result.GraphicCards = source.GraphicCards
				wholeGraphicCardsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
				graphicCardsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath))
			}
		}
	}
	if wholeGraphicCardsAccepted == false && len(graphicCardsMask.Paths) > 0 {
		for _, sourceItem := range source.GetGraphicCards() {
			result.GraphicCards = append(result.GraphicCards, graphicCardsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_GPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorProduct})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorSubvendor})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_PCIDevice) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice), source.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_PCIDevice) *Device_Status_DeviceInfo_HardwareInformation_PCIDevice {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorProduct:
				result.Product = source.Product
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorSubvendor:
				result.Subvendor = source.Subvendor
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory] = FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo{}
	memoryMask := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{}
	wholeMemoryAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory:
				result.Memory = source.Memory
				wholeMemoryAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemory:
				memoryMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath))
			}
		}
	}
	if wholeMemoryAccepted == false && len(memoryMask.Paths) > 0 {
		for _, sourceItem := range source.GetMemory() {
			result.Memory = append(result.Memory, memoryMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorCliVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules: &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules: &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules] = FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo{}
	modulesMask := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	wholeModulesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorCliVersion:
				result.CliVersion = source.CliVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
				result.Modules = source.Modules
				wholeModulesAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
				modulesMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath))
			}
		}
	}
	if wholeModulesAccepted == false && len(modulesMask.Paths) > 0 {
		for _, sourceItem := range source.GetModules() {
			result.Modules = append(result.Modules, modulesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorDriverVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorCudaVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus: &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus: &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus] = FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo{}
	gpusMask := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	wholeGpusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorDriverVersion:
				result.DriverVersion = source.DriverVersion
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorCudaVersion:
				result.CudaVersion = source.CudaVersion
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
				result.Gpus = source.Gpus
				wholeGpusAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
				gpusMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath))
			}
		}
	}
	if wholeGpusAccepted == false && len(gpusMask.Paths) > 0 {
		for _, sourceItem := range source.GetGpus() {
			result.Gpus = append(result.Gpus, gpusMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus{}
	modemMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{}
	wholeModemAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem:
				result.Modem = source.Modem
				wholeModemAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem:
				modemMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath))
			}
		}
	}
	if wholeModemAccepted == false && len(modemMask.Paths) > 0 {
		result.Modem = modemMask.Project(source.GetModem())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorChassis})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorUuid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorSkuNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorFamily})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_System_Configuration) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration), source.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_System_Configuration) *Device_Status_DeviceInfo_HardwareInformation_System_Configuration {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorChassis:
				result.Chassis = source.Chassis
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorUuid:
				result.Uuid = source.Uuid
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorSkuNumber:
				result.SkuNumber = source.SkuNumber
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorFamily:
				result.Family = source.Family
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumThreads})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumCores})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumEnabledCores})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorSerial})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorFrequencyMhz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorMaxFrequencyMhz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorDriver})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorLatency})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorClock})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 14)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	removedSelectors := make([]bool, 14)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities: &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:    &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities: &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:    &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities] = FullDevice_Status_DeviceInfo_HardwareInformation_Capability_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor{}
	capabilitiesMask := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	wholeCapabilitiesAccepted := false
	cacheInfoMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	wholeCacheInfoAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorModel:
				result.Model = source.Model
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
				result.Capabilities = source.Capabilities
				wholeCapabilitiesAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumThreads:
				result.NumThreads = source.NumThreads
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumCores:
				result.NumCores = source.NumCores
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumEnabledCores:
				result.NumEnabledCores = source.NumEnabledCores
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorSerial:
				result.Serial = source.Serial
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorFrequencyMhz:
				result.FrequencyMhz = source.FrequencyMhz
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorMaxFrequencyMhz:
				result.MaxFrequencyMhz = source.MaxFrequencyMhz
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
				result.CacheInfo = source.CacheInfo
				wholeCacheInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorDriver:
				result.Driver = source.Driver
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorLatency:
				result.Latency = source.Latency
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorClock:
				result.Clock = source.Clock
			}
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
				capabilitiesMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
				cacheInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath))
			}
		}
	}
	if wholeCapabilitiesAccepted == false && len(capabilitiesMask.Paths) > 0 {
		for _, sourceItem := range source.GetCapabilities() {
			result.Capabilities = append(result.Capabilities, capabilitiesMask.Project(sourceItem))
		}
	}
	if wholeCacheInfoAccepted == false && len(cacheInfoMask.Paths) > 0 {
		for _, sourceItem := range source.GetCacheInfo() {
			result.CacheInfo = append(result.CacheInfo, cacheInfoMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorType})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorSizeBytes})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorType:
				result.Type = source.Type
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorDriveType})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorWwn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk), source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk{}
	partitionsMask := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	wholePartitionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorDriveType:
				result.DriveType = source.DriveType
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorModel:
				result.Model = source.Model
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorWwn:
				result.Wwn = source.Wwn
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
				result.Partitions = source.Partitions
				wholePartitionsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
				partitionsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath))
			}
		}
	}
	if wholePartitionsAccepted == false && len(partitionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetPartitions() {
			result.Partitions = append(result.Partitions, partitionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorMountPoint})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorType})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition), source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorMountPoint:
				result.MountPoint = source.MountPoint
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorType:
				result.Type = source.Type
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorMacAddress})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVirtual})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSubvendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Network_NIC) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC), source.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Network_NIC) *Device_Status_DeviceInfo_HardwareInformation_Network_NIC {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC{}
	var settingMapKeys []string
	wholeSettingAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorMacAddress:
				result.MacAddress = source.MacAddress
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVirtual:
				result.Virtual = source.Virtual
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSubvendor:
				result.Subvendor = source.Subvendor
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting:
				result.Setting = source.Setting
				wholeSettingAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathMap:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting:
				settingMapKeys = append(settingMapKeys, tp.key)
			}
		}
	}
	if wholeSettingAccepted == false && len(settingMapKeys) > 0 && source.GetSetting() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetSetting()
		for _, key := range settingMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Setting = copiedMap
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorIndex})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice: &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice: &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice] = FullDevice_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard), source.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard) *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard{}
	deviceMask := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	wholeDeviceAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorIndex:
				result.Index = source.Index
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
				result.Device = source.Device
				wholeDeviceAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
				deviceMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath))
			}
		}
	}
	if wholeDeviceAccepted == false && len(deviceMask.Paths) > 0 {
		result.Device = deviceMask.Project(source.GetDevice())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks] = FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory), source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory{}
	memoryBanksMask := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{}
	wholeMemoryBanksAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks:
				result.MemoryBanks = source.MemoryBanks
				wholeMemoryBanksAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemory_FieldPathSelectorMemoryBanks:
				memoryBanksMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath))
			}
		}
	}
	if wholeMemoryBanksAccepted == false && len(memoryBanksMask.Paths) > 0 {
		for _, sourceItem := range source.GetMemoryBanks() {
			result.MemoryBanks = append(result.MemoryBanks, memoryBanksMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorProduct})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSerial})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSlot})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorFrequencyHz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorWidthBits})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank), source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorProduct:
				result.Product = source.Product
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSerial:
				result.Serial = source.Serial
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSlot:
				result.Slot = source.Slot
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorFrequencyHz:
				result.FrequencyHz = source.FrequencyHz
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryMemoryBank_FieldPathSelectorWidthBits:
				result.WidthBits = source.WidthBits
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_Memory_MemoryBank_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorDevId})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorControlProtoVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorFirmwareVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorLoggerVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorBoardName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorPartNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorNeuralNetworkCoreClockRate})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	removedSelectors := make([]bool, 9)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorDevId:
				result.DevId = source.DevId
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorControlProtoVersion:
				result.ControlProtoVersion = source.ControlProtoVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorFirmwareVersion:
				result.FirmwareVersion = source.FirmwareVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorLoggerVersion:
				result.LoggerVersion = source.LoggerVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorBoardName:
				result.BoardName = source.BoardName
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorPartNumber:
				result.PartNumber = source.PartNumber
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorNeuralNetworkCoreClockRate:
				result.NeuralNetworkCoreClockRate = source.NeuralNetworkCoreClockRate
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorId})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorProductName})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorId:
				result.Id = source.Id
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPathSelectorDrxCycle})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPathSelectorMicoMode})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPathSelectorDrxCycle:
				result.DrxCycle = source.DrxCycle
			case DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPathSelectorMicoMode:
				result.MicoMode = source.MicoMode
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr{}
	registrationSettingsMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{}
	wholeRegistrationSettingsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings:
				result.RegistrationSettings = source.RegistrationSettings
				wholeRegistrationSettingsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings:
				registrationSettingsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath))
			}
		}
	}
	if wholeRegistrationSettingsAccepted == false && len(registrationSettingsMask.Paths) > 0 {
		result.RegistrationSettings = registrationSettingsMask.Project(source.GetRegistrationSettings())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorApn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorIpType})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorPassword})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorUser})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorApn:
				result.Apn = source.Apn
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorIpType:
				result.IpType = source.IpType
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorPassword:
				result.Password = source.Password
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorUser:
				result.User = source.User
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorDbusPath})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer{}
	settingsMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{}
	wholeSettingsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorDbusPath:
				result.DbusPath = source.DbusPath
			case DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings:
				result.Settings = source.Settings
				wholeSettingsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings:
				settingsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath))
			}
		}
	}
	if wholeSettingsAccepted == false && len(settingsMask.Paths) > 0 {
		result.Settings = settingsMask.Project(source.GetSettings())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorUeModeOperation})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps{}
	initialBearerMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{}
	wholeInitialBearerAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer:
				result.InitialBearer = source.InitialBearer
				wholeInitialBearerAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorUeModeOperation:
				result.UeModeOperation = source.UeModeOperation
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer:
				initialBearerMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath))
			}
		}
	}
	if wholeInitialBearerAccepted == false && len(initialBearerMask.Paths) > 0 {
		result.InitialBearer = initialBearerMask.Project(source.GetInitialBearer())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEnabledLocks})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorImei})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorOperatorCode})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorOperatorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorPacketServiceState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorPco})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorRegistrationState})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{}
	removedSelectors := make([]bool, 9)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp{}
	fivegNrMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{}
	wholeFivegNrAccepted := false
	epsMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{}
	wholeEpsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr:
				result.FivegNr = source.FivegNr
				wholeFivegNrAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEnabledLocks:
				result.EnabledLocks = source.EnabledLocks
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:
				result.Eps = source.Eps
				wholeEpsAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorImei:
				result.Imei = source.Imei
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorOperatorCode:
				result.OperatorCode = source.OperatorCode
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorOperatorName:
				result.OperatorName = source.OperatorName
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorPacketServiceState:
				result.PacketServiceState = source.PacketServiceState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorPco:
				result.Pco = source.Pco
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorRegistrationState:
				result.RegistrationState = source.RegistrationState
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr:
				fivegNrMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:
				epsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath))
			}
		}
	}
	if wholeFivegNrAccepted == false && len(fivegNrMask.Paths) > 0 {
		result.FivegNr = fivegNrMask.Project(source.GetFivegNr())
	}
	if wholeEpsAccepted == false && len(epsMask.Paths) > 0 {
		result.Eps = epsMask.Project(source.GetEps())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorActivationState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorCdma1xRegistrationState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorEsn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorEvdoRegistrationState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorMeid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorNid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorSid})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorActivationState:
				result.ActivationState = source.ActivationState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorCdma1xRegistrationState:
				result.Cdma1XRegistrationState = source.Cdma1XRegistrationState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorEsn:
				result.Esn = source.Esn
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorEvdoRegistrationState:
				result.EvdoRegistrationState = source.EvdoRegistrationState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorMeid:
				result.Meid = source.Meid
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorNid:
				result.Nid = source.Nid
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorSid:
				result.Sid = source.Sid
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPathSelectorRecent})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPathSelectorValue})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPathSelectorRecent:
				result.Recent = source.Recent
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPathSelectorValue:
				result.Value = source.Value
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorAccessTechnologies})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorBearers})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCarrierConfiguration})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCarrierConfigurationRevision})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentBands})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentCapabilities})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentModes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDevice})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDeviceIdentifier})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDrivers})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorEquipmentIdentifier})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorHardwareRevision})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorManufacturer})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorOwnNumbers})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPlugin})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPorts})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPowerState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPrimaryPort})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPrimarySimSlot})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorRevision})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSim})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSimSlots})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorStateFailedReason})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedBands})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedCapabilities})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedIpFamilies})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedModes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorUnlockRequired})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorUnlockRetries})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 32)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{}
	removedSelectors := make([]bool, 32)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic{}
	signalQualityMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{}
	wholeSignalQualityAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorAccessTechnologies:
				result.AccessTechnologies = source.AccessTechnologies
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorBearers:
				result.Bearers = source.Bearers
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCarrierConfiguration:
				result.CarrierConfiguration = source.CarrierConfiguration
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCarrierConfigurationRevision:
				result.CarrierConfigurationRevision = source.CarrierConfigurationRevision
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentBands:
				result.CurrentBands = source.CurrentBands
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentCapabilities:
				result.CurrentCapabilities = source.CurrentCapabilities
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentModes:
				result.CurrentModes = source.CurrentModes
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDevice:
				result.Device = source.Device
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDeviceIdentifier:
				result.DeviceIdentifier = source.DeviceIdentifier
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDrivers:
				result.Drivers = source.Drivers
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorEquipmentIdentifier:
				result.EquipmentIdentifier = source.EquipmentIdentifier
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorHardwareRevision:
				result.HardwareRevision = source.HardwareRevision
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorManufacturer:
				result.Manufacturer = source.Manufacturer
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorModel:
				result.Model = source.Model
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorOwnNumbers:
				result.OwnNumbers = source.OwnNumbers
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPlugin:
				result.Plugin = source.Plugin
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPorts:
				result.Ports = source.Ports
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPowerState:
				result.PowerState = source.PowerState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPrimaryPort:
				result.PrimaryPort = source.PrimaryPort
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPrimarySimSlot:
				result.PrimarySimSlot = source.PrimarySimSlot
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorRevision:
				result.Revision = source.Revision
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality:
				result.SignalQuality = source.SignalQuality
				wholeSignalQualityAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSim:
				result.Sim = source.Sim
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSimSlots:
				result.SimSlots = source.SimSlots
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorState:
				result.State = source.State
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorStateFailedReason:
				result.StateFailedReason = source.StateFailedReason
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedBands:
				result.SupportedBands = source.SupportedBands
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedCapabilities:
				result.SupportedCapabilities = source.SupportedCapabilities
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedIpFamilies:
				result.SupportedIpFamilies = source.SupportedIpFamilies
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedModes:
				result.SupportedModes = source.SupportedModes
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorUnlockRequired:
				result.UnlockRequired = source.UnlockRequired
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorUnlockRetries:
				result.UnlockRetries = source.UnlockRetries
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality:
				signalQualityMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath))
			}
		}
	}
	if wholeSignalQualityAccepted == false && len(signalQualityMask.Paths) > 0 {
		result.SignalQuality = signalQualityMask.Project(source.GetSignalQuality())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPathSelectorErrorRate})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPathSelectorRsrp})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPathSelectorRsrq})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPathSelectorSnr})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPathSelectorErrorRate:
				result.ErrorRate = source.ErrorRate
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPathSelectorRsrp:
				result.Rsrp = source.Rsrp
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPathSelectorRsrq:
				result.Rsrq = source.Rsrq
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPathSelectorSnr:
				result.Snr = source.Snr
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPathSelectorEcio})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPathSelectorErrorRate})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPathSelectorRssi})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPathSelectorEcio:
				result.Ecio = source.Ecio
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPathSelectorErrorRate:
				result.ErrorRate = source.ErrorRate
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPathSelectorRssi:
				result.Rssi = source.Rssi
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorEcio})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorErrorRate})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorIo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorRssi})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorSinr})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorEcio:
				result.Ecio = source.Ecio
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorErrorRate:
				result.ErrorRate = source.ErrorRate
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorIo:
				result.Io = source.Io
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorRssi:
				result.Rssi = source.Rssi
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPathSelectorSinr:
				result.Sinr = source.Sinr
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPathSelectorErrorRate})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPathSelectorRssi})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPathSelectorErrorRate:
				result.ErrorRate = source.ErrorRate
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPathSelectorRssi:
				result.Rssi = source.Rssi
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorErrorRate})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorRsrp})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorRsrq})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorRssi})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorSnr})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorErrorRate:
				result.ErrorRate = source.ErrorRate
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorRsrp:
				result.Rsrp = source.Rsrp
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorRsrq:
				result.Rsrq = source.Rsrq
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorRssi:
				result.Rssi = source.Rssi
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPathSelectorSnr:
				result.Snr = source.Snr
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPathSelectorRate})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPathSelectorRate:
				result.Rate = source.Rate
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPathSelectorErrorRate})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPathSelectorRssi})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPathSelectorErrorRate:
				result.ErrorRate = source.ErrorRate
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPathSelectorRssi:
				result.Rssi = source.Rssi
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPathSelectorEcio})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPathSelectorErrorRate})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPathSelectorRscp})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPathSelectorRssi})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPathSelectorEcio:
				result.Ecio = source.Ecio
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPathSelectorErrorRate:
				result.ErrorRate = source.ErrorRate
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPathSelectorRscp:
				result.Rscp = source.Rscp
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPathSelectorRssi:
				result.Rssi = source.Rssi
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorFiveG})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorCdma1X})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorEvdo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorGsm})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorLteSignal})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorRefresh})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorThreshold})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorUmts})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorFiveG:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorCdma1X:    &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorEvdo:      &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorGsm:       &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorLteSignal: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorRefresh:   &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorThreshold: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorUmts:      &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorFiveG:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorCdma1X:    &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorEvdo:      &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorGsm:       &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorLteSignal: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorRefresh:   &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorThreshold: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorUmts:      &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorFiveG:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorFiveG] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorCdma1X:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorCdma1X] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorEvdo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorEvdo] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorGsm:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorGsm] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorLteSignal:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorLteSignal] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorRefresh:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorRefresh] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorThreshold:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorThreshold] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorUmts:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorUmts] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal{}
	fiveGMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal5G_FieldMask{}
	wholeFiveGAccepted := false
	cdma1XMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalCdma1X_FieldMask{}
	wholeCdma1XAccepted := false
	evdoMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalEvdo_FieldMask{}
	wholeEvdoAccepted := false
	gsmMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalGsm_FieldMask{}
	wholeGsmAccepted := false
	lteSignalMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalLte_FieldMask{}
	wholeLteSignalAccepted := false
	refreshMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalRefresh_FieldMask{}
	wholeRefreshAccepted := false
	thresholdMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalThreshold_FieldMask{}
	wholeThresholdAccepted := false
	umtsMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalUmts_FieldMask{}
	wholeUmtsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorFiveG:
				result.FiveG = source.FiveG
				wholeFiveGAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorCdma1X:
				result.Cdma1X = source.Cdma1X
				wholeCdma1XAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorEvdo:
				result.Evdo = source.Evdo
				wholeEvdoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorGsm:
				result.Gsm = source.Gsm
				wholeGsmAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorLteSignal:
				result.LteSignal = source.LteSignal
				wholeLteSignalAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorRefresh:
				result.Refresh = source.Refresh
				wholeRefreshAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorThreshold:
				result.Threshold = source.Threshold
				wholeThresholdAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorUmts:
				result.Umts = source.Umts
				wholeUmtsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorFiveG:
				fiveGMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignal5G_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorCdma1X:
				cdma1XMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalCdma1X_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorEvdo:
				evdoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalEvdo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorGsm:
				gsmMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalGsm_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorLteSignal:
				lteSignalMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalLte_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorRefresh:
				refreshMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalRefresh_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorThreshold:
				thresholdMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalThreshold_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPathSelectorUmts:
				umtsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalUmts_FieldPath))
			}
		}
	}
	if wholeFiveGAccepted == false && len(fiveGMask.Paths) > 0 {
		result.FiveG = fiveGMask.Project(source.GetFiveG())
	}
	if wholeCdma1XAccepted == false && len(cdma1XMask.Paths) > 0 {
		result.Cdma1X = cdma1XMask.Project(source.GetCdma1X())
	}
	if wholeEvdoAccepted == false && len(evdoMask.Paths) > 0 {
		result.Evdo = evdoMask.Project(source.GetEvdo())
	}
	if wholeGsmAccepted == false && len(gsmMask.Paths) > 0 {
		result.Gsm = gsmMask.Project(source.GetGsm())
	}
	if wholeLteSignalAccepted == false && len(lteSignalMask.Paths) > 0 {
		result.LteSignal = lteSignalMask.Project(source.GetLteSignal())
	}
	if wholeRefreshAccepted == false && len(refreshMask.Paths) > 0 {
		result.Refresh = refreshMask.Project(source.GetRefresh())
	}
	if wholeThresholdAccepted == false && len(thresholdMask.Paths) > 0 {
		result.Threshold = thresholdMask.Project(source.GetThreshold())
	}
	if wholeUmtsAccepted == false && len(umtsMask.Paths) > 0 {
		result.Umts = umtsMask.Project(source.GetUmts())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorDbusPath})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorActive})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEmergencyNumbers})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEsimStatus})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorGid1})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorGid2})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorIccid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorImsi})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorOperatorCode})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorOperatorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorRemovability})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorSimType})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 13)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask{}
	removedSelectors := make([]bool, 13)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorDbusPath:
				result.DbusPath = source.DbusPath
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorActive:
				result.Active = source.Active
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEid:
				result.Eid = source.Eid
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEmergencyNumbers:
				result.EmergencyNumbers = source.EmergencyNumbers
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEsimStatus:
				result.EsimStatus = source.EsimStatus
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorGid1:
				result.Gid1 = source.Gid1
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorGid2:
				result.Gid2 = source.Gid2
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorIccid:
				result.Iccid = source.Iccid
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorImsi:
				result.Imsi = source.Imsi
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorOperatorCode:
				result.OperatorCode = source.OperatorCode
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorOperatorName:
				result.OperatorName = source.OperatorName
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorRemovability:
				result.Removability = source.Removability
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorSimType:
				result.SimType = source.SimType
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorDbusPath})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSignal})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSimStatus})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:  &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSignal:   &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:  &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSignal:   &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSignal:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSignal] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem{}
	threeGPpMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{}
	wholeThreeGPpAccepted := false
	cdmaMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{}
	wholeCdmaAccepted := false
	genericMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{}
	wholeGenericAccepted := false
	signalMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Signal_FieldMask{}
	wholeSignalAccepted := false
	var simStatusMapKeys []string
	wholeSimStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp:
				result.ThreeGPp = source.ThreeGPp
				wholeThreeGPpAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:
				result.Cdma = source.Cdma
				wholeCdmaAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorDbusPath:
				result.DbusPath = source.DbusPath
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:
				result.Generic = source.Generic
				wholeGenericAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSignal:
				result.Signal = source.Signal
				wholeSignalAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSimStatus:
				result.SimStatus = source.SimStatus
				wholeSimStatusAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp:
				threeGPpMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:
				cdmaMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:
				genericMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSignal:
				signalMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignal_FieldPath))
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathMap:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSimStatus:
				simStatusMapKeys = append(simStatusMapKeys, tp.key)
			}
		}
	}
	if wholeThreeGPpAccepted == false && len(threeGPpMask.Paths) > 0 {
		result.ThreeGPp = threeGPpMask.Project(source.GetThreeGPp())
	}
	if wholeCdmaAccepted == false && len(cdmaMask.Paths) > 0 {
		result.Cdma = cdmaMask.Project(source.GetCdma())
	}
	if wholeGenericAccepted == false && len(genericMask.Paths) > 0 {
		result.Generic = genericMask.Project(source.GetGeneric())
	}
	if wholeSignalAccepted == false && len(signalMask.Paths) > 0 {
		result.Signal = signalMask.Project(source.GetSignal())
	}
	if wholeSimStatusAccepted == false && len(simStatusMapKeys) > 0 && source.GetSimStatus() != nil {
		copiedMap := map[string]*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus{}
		sourceMap := source.GetSimStatus()
		for _, key := range simStatusMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.SimStatus = copiedMap
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask() *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask {
	res := &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorAsn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorDomain})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorAsnType})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_NetworkInterface_ASInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_NetworkInterface_ASInfo), source.(*Device_Status_DeviceInfo_NetworkInterface_ASInfo))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Project(source *Device_Status_DeviceInfo_NetworkInterface_ASInfo) *Device_Status_DeviceInfo_NetworkInterface_ASInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_NetworkInterface_ASInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorAsn:
				result.Asn = source.Asn
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorDomain:
				result.Domain = source.Domain
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorRoutes:
				result.Routes = source.Routes
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorAsnType:
				result.AsnType = source.AsnType
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_NetworkInterface_ASInfo))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask struct {
	Paths []DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath
}

func FullDevice_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask() *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask {
	res := &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorMobileCountryCode})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorMobileNetworkCode})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorLocationAreaCode})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Subtract(other *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) AppendPath(path DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) GetPaths() []DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Set(target, source *Device_Status_DeviceInfo_NetworkInterface_Carrier) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_NetworkInterface_Carrier), source.(*Device_Status_DeviceInfo_NetworkInterface_Carrier))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Project(source *Device_Status_DeviceInfo_NetworkInterface_Carrier) *Device_Status_DeviceInfo_NetworkInterface_Carrier {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_NetworkInterface_Carrier{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorMobileCountryCode:
				result.MobileCountryCode = source.MobileCountryCode
			case DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorMobileNetworkCode:
				result.MobileNetworkCode = source.MobileNetworkCode
			case DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorLocationAreaCode:
				result.LocationAreaCode = source.LocationAreaCode
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_NetworkInterface_Carrier))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
