// Code generated by protoc-gen-goten-object
// File: edgelq/devices/proto/v1/device.proto
// DO NOT EDIT!!!

package device

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	project "github.com/cloudwan/edgelq-sdk/devices/resources/v1/project"
	iam_attestation_domain "github.com/cloudwan/edgelq-sdk/iam/resources/v1/attestation_domain"
	iam_iam_common "github.com/cloudwan/edgelq-sdk/iam/resources/v1/common"
	iam_service_account "github.com/cloudwan/edgelq-sdk/iam/resources/v1/service_account"
	logging_bucket "github.com/cloudwan/edgelq-sdk/logging/resources/v1/bucket"
	monitoring_bucket "github.com/cloudwan/edgelq-sdk/monitoring/resources/v4/bucket"
	meta "github.com/cloudwan/goten-sdk/types/meta"
	latlng "google.golang.org/genproto/googleapis/type/latlng"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &project.Project{}
	_ = &iam_attestation_domain.AttestationDomain{}
	_ = &iam_iam_common.PCR{}
	_ = &iam_service_account.ServiceAccount{}
	_ = &logging_bucket.Bucket{}
	_ = &monitoring_bucket.Bucket{}
	_ = &durationpb.Duration{}
	_ = &fieldmaskpb.FieldMask{}
	_ = &timestamppb.Timestamp{}
	_ = &latlng.LatLng{}
	_ = &meta.Meta{}
)

type Device_FieldMask struct {
	Paths []Device_FieldPath
}

func FullDevice_FieldMask() *Device_FieldMask {
	res := &Device_FieldMask{}
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorName})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorDisplayName})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorSpec})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &Device_FieldTerminalPath{selector: Device_FieldPathSelectorPublicListingSpec})
	return res
}

func (fieldMask *Device_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDevice_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Device_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDevice_FieldPath(raw)
	})
}

func (fieldMask *Device_FieldMask) ProtoMessage() {}

func (fieldMask *Device_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_FieldMask) Subtract(other *Device_FieldMask) *Device_FieldMask {
	result := &Device_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[Device_FieldPathSelector]gotenobject.FieldMask{
		Device_FieldPathSelectorMetadata:          &meta.Meta_FieldMask{},
		Device_FieldPathSelectorSpec:              &Device_Spec_FieldMask{},
		Device_FieldPathSelectorStatus:            &Device_Status_FieldMask{},
		Device_FieldPathSelectorPublicListingSpec: &Device_PublicListingSpec_FieldMask{},
	}
	mySubMasks := map[Device_FieldPathSelector]gotenobject.FieldMask{
		Device_FieldPathSelectorMetadata:          &meta.Meta_FieldMask{},
		Device_FieldPathSelectorSpec:              &Device_Spec_FieldMask{},
		Device_FieldPathSelectorStatus:            &Device_Status_FieldMask{},
		Device_FieldPathSelectorPublicListingSpec: &Device_PublicListingSpec_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Device_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *Device_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*Device_FieldTerminalPath); ok {
					switch tp.selector {
					case Device_FieldPathSelectorMetadata:
						mySubMasks[Device_FieldPathSelectorMetadata] = meta.FullMeta_FieldMask()
					case Device_FieldPathSelectorSpec:
						mySubMasks[Device_FieldPathSelectorSpec] = FullDevice_Spec_FieldMask()
					case Device_FieldPathSelectorStatus:
						mySubMasks[Device_FieldPathSelectorStatus] = FullDevice_Status_FieldMask()
					case Device_FieldPathSelectorPublicListingSpec:
						mySubMasks[Device_FieldPathSelectorPublicListingSpec] = FullDevice_PublicListingSpec_FieldMask()
					}
				} else if tp, ok := path.(*Device_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &Device_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_FieldMask) FilterInputFields() *Device_FieldMask {
	result := &Device_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case Device_FieldPathSelectorMetadata:
			if _, ok := path.(*Device_FieldTerminalPath); ok {
				for _, subpath := range meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Device_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Device_FieldSubPath); ok {
				selectedMask := &meta.Meta_FieldMask{
					Paths: []meta.Meta_FieldPath{sub.subPath.(meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Device_FieldSubPath{selector: Device_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		case Device_FieldPathSelectorSpec:
			if _, ok := path.(*Device_FieldTerminalPath); ok {
				for _, subpath := range FullDevice_Spec_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Device_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*Device_FieldSubPath); ok {
				selectedMask := &Device_Spec_FieldMask{
					Paths: []DeviceSpec_FieldPath{sub.subPath.(DeviceSpec_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &Device_FieldSubPath{selector: Device_FieldPathSelectorSpec, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Device_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDevice_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_FieldMask) AppendPath(path Device_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Device_FieldPath))
}

func (fieldMask *Device_FieldMask) GetPaths() []Device_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDevice_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_FieldMask) Set(target, source *Device) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device), source.(*Device))
}

func (fieldMask *Device_FieldMask) Project(source *Device) *Device {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device{}
	metadataMask := &meta.Meta_FieldMask{}
	wholeMetadataAccepted := false
	specMask := &Device_Spec_FieldMask{}
	wholeSpecAccepted := false
	statusMask := &Device_Status_FieldMask{}
	wholeStatusAccepted := false
	publicListingSpecMask := &Device_PublicListingSpec_FieldMask{}
	wholePublicListingSpecAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Device_FieldTerminalPath:
			switch tp.selector {
			case Device_FieldPathSelectorName:
				result.Name = source.Name
			case Device_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case Device_FieldPathSelectorDisplayName:
				result.DisplayName = source.DisplayName
			case Device_FieldPathSelectorDescription:
				result.Description = source.Description
			case Device_FieldPathSelectorSpec:
				result.Spec = source.Spec
				wholeSpecAccepted = true
			case Device_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			case Device_FieldPathSelectorPublicListingSpec:
				result.PublicListingSpec = source.PublicListingSpec
				wholePublicListingSpecAccepted = true
			}
		case *Device_FieldSubPath:
			switch tp.selector {
			case Device_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(meta.Meta_FieldPath))
			case Device_FieldPathSelectorSpec:
				specMask.AppendPath(tp.subPath.(DeviceSpec_FieldPath))
			case Device_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(DeviceStatus_FieldPath))
			case Device_FieldPathSelectorPublicListingSpec:
				publicListingSpecMask.AppendPath(tp.subPath.(DevicePublicListingSpec_FieldPath))
			}
		}
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	if wholeSpecAccepted == false && len(specMask.Paths) > 0 {
		result.Spec = specMask.Project(source.GetSpec())
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	if wholePublicListingSpecAccepted == false && len(publicListingSpecMask.Paths) > 0 {
		result.PublicListingSpec = publicListingSpecMask.Project(source.GetPublicListingSpec())
	}
	return result
}

func (fieldMask *Device_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device))
}

func (fieldMask *Device_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_FieldMask struct {
	Paths []DeviceSpec_FieldPath
}

func FullDevice_Spec_FieldMask() *Device_Spec_FieldMask {
	res := &Device_Spec_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorServiceAccount})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorLogBucket})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorMetricsBucket})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorOsVersion})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorNetplanYamlConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorNetplanApiConfigMode})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorOsImageUrl})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorSshConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorAttestationConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorDisableDeviceDiscovery})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorLoggingConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorProxyConfig})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorLocation})
	res.Paths = append(res.Paths, &DeviceSpec_FieldTerminalPath{selector: DeviceSpec_FieldPathSelectorUsbGuard})
	return res
}

func (fieldMask *Device_Spec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 14)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpec_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_FieldMask) Subtract(other *Device_Spec_FieldMask) *Device_Spec_FieldMask {
	result := &Device_Spec_FieldMask{}
	removedSelectors := make([]bool, 14)
	otherSubMasks := map[DeviceSpec_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpec_FieldPathSelectorSshConfig:         &Device_Spec_SSHConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorAttestationConfig: &Device_Spec_AttestationConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLoggingConfig:     &Device_Spec_LoggingConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorProxyConfig:       &Device_Spec_ProxyConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLocation:          &Device_Spec_Location_FieldMask{},
		DeviceSpec_FieldPathSelectorUsbGuard:          &Device_Spec_USBGuard_FieldMask{},
	}
	mySubMasks := map[DeviceSpec_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpec_FieldPathSelectorSshConfig:         &Device_Spec_SSHConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorAttestationConfig: &Device_Spec_AttestationConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLoggingConfig:     &Device_Spec_LoggingConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorProxyConfig:       &Device_Spec_ProxyConfig_FieldMask{},
		DeviceSpec_FieldPathSelectorLocation:          &Device_Spec_Location_FieldMask{},
		DeviceSpec_FieldPathSelectorUsbGuard:          &Device_Spec_USBGuard_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpec_FieldPathSelectorSshConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorSshConfig] = FullDevice_Spec_SSHConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorAttestationConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorAttestationConfig] = FullDevice_Spec_AttestationConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorLoggingConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorLoggingConfig] = FullDevice_Spec_LoggingConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorProxyConfig:
						mySubMasks[DeviceSpec_FieldPathSelectorProxyConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					case DeviceSpec_FieldPathSelectorLocation:
						mySubMasks[DeviceSpec_FieldPathSelectorLocation] = FullDevice_Spec_Location_FieldMask()
					case DeviceSpec_FieldPathSelectorUsbGuard:
						mySubMasks[DeviceSpec_FieldPathSelectorUsbGuard] = FullDevice_Spec_USBGuard_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_FieldMask) FilterInputFields() *Device_Spec_FieldMask {
	result := &Device_Spec_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case DeviceSpec_FieldPathSelectorLogBucket:
		case DeviceSpec_FieldPathSelectorMetricsBucket:
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_FieldMask) AppendPath(path DeviceSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpec_FieldPath))
}

func (fieldMask *Device_Spec_FieldMask) GetPaths() []DeviceSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_FieldMask) Set(target, source *Device_Spec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec), source.(*Device_Spec))
}

func (fieldMask *Device_Spec_FieldMask) Project(source *Device_Spec) *Device_Spec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec{}
	sshConfigMask := &Device_Spec_SSHConfig_FieldMask{}
	wholeSshConfigAccepted := false
	attestationConfigMask := &Device_Spec_AttestationConfig_FieldMask{}
	wholeAttestationConfigAccepted := false
	loggingConfigMask := &Device_Spec_LoggingConfig_FieldMask{}
	wholeLoggingConfigAccepted := false
	proxyConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeProxyConfigAccepted := false
	locationMask := &Device_Spec_Location_FieldMask{}
	wholeLocationAccepted := false
	usbGuardMask := &Device_Spec_USBGuard_FieldMask{}
	wholeUsbGuardAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpec_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpec_FieldPathSelectorServiceAccount:
				result.ServiceAccount = source.ServiceAccount
			case DeviceSpec_FieldPathSelectorLogBucket:
				result.LogBucket = source.LogBucket
			case DeviceSpec_FieldPathSelectorMetricsBucket:
				result.MetricsBucket = source.MetricsBucket
			case DeviceSpec_FieldPathSelectorOsVersion:
				result.OsVersion = source.OsVersion
			case DeviceSpec_FieldPathSelectorNetplanYamlConfig:
				result.NetplanYamlConfig = source.NetplanYamlConfig
			case DeviceSpec_FieldPathSelectorNetplanApiConfigMode:
				result.NetplanApiConfigMode = source.NetplanApiConfigMode
			case DeviceSpec_FieldPathSelectorOsImageUrl:
				result.OsImageUrl = source.OsImageUrl
			case DeviceSpec_FieldPathSelectorSshConfig:
				result.SshConfig = source.SshConfig
				wholeSshConfigAccepted = true
			case DeviceSpec_FieldPathSelectorAttestationConfig:
				result.AttestationConfig = source.AttestationConfig
				wholeAttestationConfigAccepted = true
			case DeviceSpec_FieldPathSelectorDisableDeviceDiscovery:
				result.DisableDeviceDiscovery = source.DisableDeviceDiscovery
			case DeviceSpec_FieldPathSelectorLoggingConfig:
				result.LoggingConfig = source.LoggingConfig
				wholeLoggingConfigAccepted = true
			case DeviceSpec_FieldPathSelectorProxyConfig:
				result.ProxyConfig = source.ProxyConfig
				wholeProxyConfigAccepted = true
			case DeviceSpec_FieldPathSelectorLocation:
				result.Location = source.Location
				wholeLocationAccepted = true
			case DeviceSpec_FieldPathSelectorUsbGuard:
				result.UsbGuard = source.UsbGuard
				wholeUsbGuardAccepted = true
			}
		case *DeviceSpec_FieldSubPath:
			switch tp.selector {
			case DeviceSpec_FieldPathSelectorSshConfig:
				sshConfigMask.AppendPath(tp.subPath.(DeviceSpecSSHConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorAttestationConfig:
				attestationConfigMask.AppendPath(tp.subPath.(DeviceSpecAttestationConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorLoggingConfig:
				loggingConfigMask.AppendPath(tp.subPath.(DeviceSpecLoggingConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorProxyConfig:
				proxyConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			case DeviceSpec_FieldPathSelectorLocation:
				locationMask.AppendPath(tp.subPath.(DeviceSpecLocation_FieldPath))
			case DeviceSpec_FieldPathSelectorUsbGuard:
				usbGuardMask.AppendPath(tp.subPath.(DeviceSpecUSBGuard_FieldPath))
			}
		}
	}
	if wholeSshConfigAccepted == false && len(sshConfigMask.Paths) > 0 {
		result.SshConfig = sshConfigMask.Project(source.GetSshConfig())
	}
	if wholeAttestationConfigAccepted == false && len(attestationConfigMask.Paths) > 0 {
		result.AttestationConfig = attestationConfigMask.Project(source.GetAttestationConfig())
	}
	if wholeLoggingConfigAccepted == false && len(loggingConfigMask.Paths) > 0 {
		result.LoggingConfig = loggingConfigMask.Project(source.GetLoggingConfig())
	}
	if wholeProxyConfigAccepted == false && len(proxyConfigMask.Paths) > 0 {
		result.ProxyConfig = proxyConfigMask.Project(source.GetProxyConfig())
	}
	if wholeLocationAccepted == false && len(locationMask.Paths) > 0 {
		result.Location = locationMask.Project(source.GetLocation())
	}
	if wholeUsbGuardAccepted == false && len(usbGuardMask.Paths) > 0 {
		result.UsbGuard = usbGuardMask.Project(source.GetUsbGuard())
	}
	return result
}

func (fieldMask *Device_Spec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec))
}

func (fieldMask *Device_Spec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_FieldMask struct {
	Paths []DeviceStatus_FieldPath
}

func FullDevice_Status_FieldMask() *Device_Status_FieldMask {
	res := &Device_Status_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorAddresses})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorConditions})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorNetworkConfigState})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorProxyConfigStatus})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorDeviceInfo})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorAttestationStatus})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorNormalizedAddress})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorConnectionStatus})
	res.Paths = append(res.Paths, &DeviceStatus_FieldTerminalPath{selector: DeviceStatus_FieldPathSelectorConnectionStatusChangeTime})
	return res
}

func (fieldMask *Device_Status_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_FieldMask) Subtract(other *Device_Status_FieldMask) *Device_Status_FieldMask {
	result := &Device_Status_FieldMask{}
	removedSelectors := make([]bool, 9)
	otherSubMasks := map[DeviceStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatus_FieldPathSelectorAddresses:          &Device_Status_Address_FieldMask{},
		DeviceStatus_FieldPathSelectorConditions:         &Device_Status_Condition_FieldMask{},
		DeviceStatus_FieldPathSelectorNetworkConfigState: &Device_Status_NetworkConfigState_FieldMask{},
		DeviceStatus_FieldPathSelectorProxyConfigStatus:  &Device_Status_ProxyConfigStatus_FieldMask{},
		DeviceStatus_FieldPathSelectorDeviceInfo:         &Device_Status_DeviceInfo_FieldMask{},
		DeviceStatus_FieldPathSelectorAttestationStatus:  &iam_iam_common.PCR_FieldMask{},
		DeviceStatus_FieldPathSelectorNormalizedAddress:  &Device_Status_NormalizedAddress_FieldMask{},
	}
	mySubMasks := map[DeviceStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatus_FieldPathSelectorAddresses:          &Device_Status_Address_FieldMask{},
		DeviceStatus_FieldPathSelectorConditions:         &Device_Status_Condition_FieldMask{},
		DeviceStatus_FieldPathSelectorNetworkConfigState: &Device_Status_NetworkConfigState_FieldMask{},
		DeviceStatus_FieldPathSelectorProxyConfigStatus:  &Device_Status_ProxyConfigStatus_FieldMask{},
		DeviceStatus_FieldPathSelectorDeviceInfo:         &Device_Status_DeviceInfo_FieldMask{},
		DeviceStatus_FieldPathSelectorAttestationStatus:  &iam_iam_common.PCR_FieldMask{},
		DeviceStatus_FieldPathSelectorNormalizedAddress:  &Device_Status_NormalizedAddress_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatus_FieldPathSelectorAddresses:
						mySubMasks[DeviceStatus_FieldPathSelectorAddresses] = FullDevice_Status_Address_FieldMask()
					case DeviceStatus_FieldPathSelectorConditions:
						mySubMasks[DeviceStatus_FieldPathSelectorConditions] = FullDevice_Status_Condition_FieldMask()
					case DeviceStatus_FieldPathSelectorNetworkConfigState:
						mySubMasks[DeviceStatus_FieldPathSelectorNetworkConfigState] = FullDevice_Status_NetworkConfigState_FieldMask()
					case DeviceStatus_FieldPathSelectorProxyConfigStatus:
						mySubMasks[DeviceStatus_FieldPathSelectorProxyConfigStatus] = FullDevice_Status_ProxyConfigStatus_FieldMask()
					case DeviceStatus_FieldPathSelectorDeviceInfo:
						mySubMasks[DeviceStatus_FieldPathSelectorDeviceInfo] = FullDevice_Status_DeviceInfo_FieldMask()
					case DeviceStatus_FieldPathSelectorAttestationStatus:
						mySubMasks[DeviceStatus_FieldPathSelectorAttestationStatus] = iam_iam_common.FullPCR_FieldMask()
					case DeviceStatus_FieldPathSelectorNormalizedAddress:
						mySubMasks[DeviceStatus_FieldPathSelectorNormalizedAddress] = FullDevice_Status_NormalizedAddress_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_FieldMask) FilterInputFields() *Device_Status_FieldMask {
	result := &Device_Status_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_FieldMask) AppendPath(path DeviceStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatus_FieldPath))
}

func (fieldMask *Device_Status_FieldMask) GetPaths() []DeviceStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_FieldMask) Set(target, source *Device_Status) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status), source.(*Device_Status))
}

func (fieldMask *Device_Status_FieldMask) Project(source *Device_Status) *Device_Status {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status{}
	addressesMask := &Device_Status_Address_FieldMask{}
	wholeAddressesAccepted := false
	conditionsMask := &Device_Status_Condition_FieldMask{}
	wholeConditionsAccepted := false
	networkConfigStateMask := &Device_Status_NetworkConfigState_FieldMask{}
	wholeNetworkConfigStateAccepted := false
	proxyConfigStatusMask := &Device_Status_ProxyConfigStatus_FieldMask{}
	wholeProxyConfigStatusAccepted := false
	deviceInfoMask := &Device_Status_DeviceInfo_FieldMask{}
	wholeDeviceInfoAccepted := false
	attestationStatusMask := &iam_iam_common.PCR_FieldMask{}
	wholeAttestationStatusAccepted := false
	normalizedAddressMask := &Device_Status_NormalizedAddress_FieldMask{}
	wholeNormalizedAddressAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatus_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
				wholeAddressesAccepted = true
			case DeviceStatus_FieldPathSelectorConditions:
				result.Conditions = source.Conditions
				wholeConditionsAccepted = true
			case DeviceStatus_FieldPathSelectorNetworkConfigState:
				result.NetworkConfigState = source.NetworkConfigState
				wholeNetworkConfigStateAccepted = true
			case DeviceStatus_FieldPathSelectorProxyConfigStatus:
				result.ProxyConfigStatus = source.ProxyConfigStatus
				wholeProxyConfigStatusAccepted = true
			case DeviceStatus_FieldPathSelectorDeviceInfo:
				result.DeviceInfo = source.DeviceInfo
				wholeDeviceInfoAccepted = true
			case DeviceStatus_FieldPathSelectorAttestationStatus:
				result.AttestationStatus = source.AttestationStatus
				wholeAttestationStatusAccepted = true
			case DeviceStatus_FieldPathSelectorNormalizedAddress:
				result.NormalizedAddress = source.NormalizedAddress
				wholeNormalizedAddressAccepted = true
			case DeviceStatus_FieldPathSelectorConnectionStatus:
				result.ConnectionStatus = source.ConnectionStatus
			case DeviceStatus_FieldPathSelectorConnectionStatusChangeTime:
				result.ConnectionStatusChangeTime = source.ConnectionStatusChangeTime
			}
		case *DeviceStatus_FieldSubPath:
			switch tp.selector {
			case DeviceStatus_FieldPathSelectorAddresses:
				addressesMask.AppendPath(tp.subPath.(DeviceStatusAddress_FieldPath))
			case DeviceStatus_FieldPathSelectorConditions:
				conditionsMask.AppendPath(tp.subPath.(DeviceStatusCondition_FieldPath))
			case DeviceStatus_FieldPathSelectorNetworkConfigState:
				networkConfigStateMask.AppendPath(tp.subPath.(DeviceStatusNetworkConfigState_FieldPath))
			case DeviceStatus_FieldPathSelectorProxyConfigStatus:
				proxyConfigStatusMask.AppendPath(tp.subPath.(DeviceStatusProxyConfigStatus_FieldPath))
			case DeviceStatus_FieldPathSelectorDeviceInfo:
				deviceInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfo_FieldPath))
			case DeviceStatus_FieldPathSelectorAttestationStatus:
				attestationStatusMask.AppendPath(tp.subPath.(iam_iam_common.PCR_FieldPath))
			case DeviceStatus_FieldPathSelectorNormalizedAddress:
				normalizedAddressMask.AppendPath(tp.subPath.(DeviceStatusNormalizedAddress_FieldPath))
			}
		}
	}
	if wholeAddressesAccepted == false && len(addressesMask.Paths) > 0 {
		for _, sourceItem := range source.GetAddresses() {
			result.Addresses = append(result.Addresses, addressesMask.Project(sourceItem))
		}
	}
	if wholeConditionsAccepted == false && len(conditionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetConditions() {
			result.Conditions = append(result.Conditions, conditionsMask.Project(sourceItem))
		}
	}
	if wholeNetworkConfigStateAccepted == false && len(networkConfigStateMask.Paths) > 0 {
		result.NetworkConfigState = networkConfigStateMask.Project(source.GetNetworkConfigState())
	}
	if wholeProxyConfigStatusAccepted == false && len(proxyConfigStatusMask.Paths) > 0 {
		result.ProxyConfigStatus = proxyConfigStatusMask.Project(source.GetProxyConfigStatus())
	}
	if wholeDeviceInfoAccepted == false && len(deviceInfoMask.Paths) > 0 {
		result.DeviceInfo = deviceInfoMask.Project(source.GetDeviceInfo())
	}
	if wholeAttestationStatusAccepted == false && len(attestationStatusMask.Paths) > 0 {
		for _, sourceItem := range source.GetAttestationStatus() {
			result.AttestationStatus = append(result.AttestationStatus, attestationStatusMask.Project(sourceItem))
		}
	}
	if wholeNormalizedAddressAccepted == false && len(normalizedAddressMask.Paths) > 0 {
		result.NormalizedAddress = normalizedAddressMask.Project(source.GetNormalizedAddress())
	}
	return result
}

func (fieldMask *Device_Status_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status))
}

func (fieldMask *Device_Status_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_PublicListingSpec_FieldMask struct {
	Paths []DevicePublicListingSpec_FieldPath
}

func FullDevice_PublicListingSpec_FieldMask() *Device_PublicListingSpec_FieldMask {
	res := &Device_PublicListingSpec_FieldMask{}
	res.Paths = append(res.Paths, &DevicePublicListingSpec_FieldTerminalPath{selector: DevicePublicListingSpec_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &DevicePublicListingSpec_FieldTerminalPath{selector: DevicePublicListingSpec_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *Device_PublicListingSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_PublicListingSpec_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDevicePublicListingSpec_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DevicePublicListingSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDevicePublicListingSpec_FieldPath(raw)
	})
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProtoMessage() {}

func (fieldMask *Device_PublicListingSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Subtract(other *Device_PublicListingSpec_FieldMask) *Device_PublicListingSpec_FieldMask {
	result := &Device_PublicListingSpec_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DevicePublicListingSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_PublicListingSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_PublicListingSpec_FieldMask) FilterInputFields() *Device_PublicListingSpec_FieldMask {
	result := &Device_PublicListingSpec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_PublicListingSpec_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_PublicListingSpec_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DevicePublicListingSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDevicePublicListingSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_PublicListingSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_PublicListingSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_PublicListingSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) AppendPath(path DevicePublicListingSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_PublicListingSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DevicePublicListingSpec_FieldPath))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) GetPaths() []DevicePublicListingSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_PublicListingSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDevicePublicListingSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Set(target, source *Device_PublicListingSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_PublicListingSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_PublicListingSpec), source.(*Device_PublicListingSpec))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) Project(source *Device_PublicListingSpec) *Device_PublicListingSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_PublicListingSpec{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DevicePublicListingSpec_FieldTerminalPath:
			switch tp.selector {
			case DevicePublicListingSpec_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case DevicePublicListingSpec_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		}
	}
	return result
}

func (fieldMask *Device_PublicListingSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_PublicListingSpec))
}

func (fieldMask *Device_PublicListingSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_SSHConfig_FieldMask struct {
	Paths []DeviceSpecSSHConfig_FieldPath
}

func FullDevice_Spec_SSHConfig_FieldMask() *Device_Spec_SSHConfig_FieldMask {
	res := &Device_Spec_SSHConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshServer})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshPassword})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorIpAllowList})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorIpDenyList})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorRejectPeriod})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfig_FieldTerminalPath{selector: DeviceSpecSSHConfig_FieldPathSelectorDisableSshAuthkey})
	return res
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_SSHConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecSSHConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecSSHConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecSSHConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Subtract(other *Device_Spec_SSHConfig_FieldMask) *Device_Spec_SSHConfig_FieldMask {
	result := &Device_Spec_SSHConfig_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[DeviceSpecSSHConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized: &Device_Spec_SSHConfig_AuthKey_FieldMask{},
	}
	mySubMasks := map[DeviceSpecSSHConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized: &Device_Spec_SSHConfig_AuthKey_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecSSHConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecSSHConfig_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecSSHConfig_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
						mySubMasks[DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized] = FullDevice_Spec_SSHConfig_AuthKey_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecSSHConfig_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecSSHConfig_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_SSHConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_SSHConfig_FieldMask) FilterInputFields() *Device_Spec_SSHConfig_FieldMask {
	result := &Device_Spec_SSHConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_SSHConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecSSHConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecSSHConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_SSHConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_SSHConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) AppendPath(path DeviceSpecSSHConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecSSHConfig_FieldPath))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) GetPaths() []DeviceSpecSSHConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecSSHConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Set(target, source *Device_Spec_SSHConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_SSHConfig), source.(*Device_Spec_SSHConfig))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) Project(source *Device_Spec_SSHConfig) *Device_Spec_SSHConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_SSHConfig{}
	sshAuthorizedMask := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	wholeSshAuthorizedAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecSSHConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshServer:
				result.DisableSshServer = source.DisableSshServer
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshPassword:
				result.DisableSshPassword = source.DisableSshPassword
			case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
				result.SshAuthorized = source.SshAuthorized
				wholeSshAuthorizedAccepted = true
			case DeviceSpecSSHConfig_FieldPathSelectorIpAllowList:
				result.IpAllowList = source.IpAllowList
			case DeviceSpecSSHConfig_FieldPathSelectorIpDenyList:
				result.IpDenyList = source.IpDenyList
			case DeviceSpecSSHConfig_FieldPathSelectorRejectPeriod:
				result.RejectPeriod = source.RejectPeriod
			case DeviceSpecSSHConfig_FieldPathSelectorDisableSshAuthkey:
				result.DisableSshAuthkey = source.DisableSshAuthkey
			}
		case *DeviceSpecSSHConfig_FieldSubPath:
			switch tp.selector {
			case DeviceSpecSSHConfig_FieldPathSelectorSshAuthorized:
				sshAuthorizedMask.AppendPath(tp.subPath.(DeviceSpecSSHConfigAuthKey_FieldPath))
			}
		}
	}
	if wholeSshAuthorizedAccepted == false && len(sshAuthorizedMask.Paths) > 0 {
		for _, sourceItem := range source.GetSshAuthorized() {
			result.SshAuthorized = append(result.SshAuthorized, sshAuthorizedMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_SSHConfig))
}

func (fieldMask *Device_Spec_SSHConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_AttestationConfig_FieldMask struct {
	Paths []DeviceSpecAttestationConfig_FieldPath
}

func FullDevice_Spec_AttestationConfig_FieldMask() *Device_Spec_AttestationConfig_FieldMask {
	res := &Device_Spec_AttestationConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecAttestationConfig_FieldTerminalPath{selector: DeviceSpecAttestationConfig_FieldPathSelectorAttestationExpected})
	res.Paths = append(res.Paths, &DeviceSpecAttestationConfig_FieldTerminalPath{selector: DeviceSpecAttestationConfig_FieldPathSelectorAttestationDomain})
	return res
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecAttestationConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecAttestationConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecAttestationConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Subtract(other *Device_Spec_AttestationConfig_FieldMask) *Device_Spec_AttestationConfig_FieldMask {
	result := &Device_Spec_AttestationConfig_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecAttestationConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_AttestationConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) FilterInputFields() *Device_Spec_AttestationConfig_FieldMask {
	result := &Device_Spec_AttestationConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecAttestationConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecAttestationConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_AttestationConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_AttestationConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) AppendPath(path DeviceSpecAttestationConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecAttestationConfig_FieldPath))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) GetPaths() []DeviceSpecAttestationConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecAttestationConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Set(target, source *Device_Spec_AttestationConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_AttestationConfig), source.(*Device_Spec_AttestationConfig))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) Project(source *Device_Spec_AttestationConfig) *Device_Spec_AttestationConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_AttestationConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecAttestationConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecAttestationConfig_FieldPathSelectorAttestationExpected:
				result.AttestationExpected = source.AttestationExpected
			case DeviceSpecAttestationConfig_FieldPathSelectorAttestationDomain:
				result.AttestationDomain = source.AttestationDomain
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_AttestationConfig))
}

func (fieldMask *Device_Spec_AttestationConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_LoggingConfig_FieldMask struct {
	Paths []DeviceSpecLoggingConfig_FieldPath
}

func FullDevice_Spec_LoggingConfig_FieldMask() *Device_Spec_LoggingConfig_FieldMask {
	res := &Device_Spec_LoggingConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorPriority})
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorUnits})
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorEnableJournalExport})
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfig_FieldPathSelectorContainerLoggingConfig})
	return res
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecLoggingConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecLoggingConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecLoggingConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Subtract(other *Device_Spec_LoggingConfig_FieldMask) *Device_Spec_LoggingConfig_FieldMask {
	result := &Device_Spec_LoggingConfig_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DeviceSpecLoggingConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecLoggingConfig_FieldPathSelectorContainerLoggingConfig: &Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask{},
	}
	mySubMasks := map[DeviceSpecLoggingConfig_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecLoggingConfig_FieldPathSelectorContainerLoggingConfig: &Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecLoggingConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecLoggingConfig_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecLoggingConfig_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecLoggingConfig_FieldPathSelectorContainerLoggingConfig:
						mySubMasks[DeviceSpecLoggingConfig_FieldPathSelectorContainerLoggingConfig] = FullDevice_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecLoggingConfig_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecLoggingConfig_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_LoggingConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) FilterInputFields() *Device_Spec_LoggingConfig_FieldMask {
	result := &Device_Spec_LoggingConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecLoggingConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecLoggingConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_LoggingConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_LoggingConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) AppendPath(path DeviceSpecLoggingConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecLoggingConfig_FieldPath))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) GetPaths() []DeviceSpecLoggingConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecLoggingConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Set(target, source *Device_Spec_LoggingConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_LoggingConfig), source.(*Device_Spec_LoggingConfig))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) Project(source *Device_Spec_LoggingConfig) *Device_Spec_LoggingConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_LoggingConfig{}
	containerLoggingConfigMask := &Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask{}
	wholeContainerLoggingConfigAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecLoggingConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecLoggingConfig_FieldPathSelectorPriority:
				result.Priority = source.Priority
			case DeviceSpecLoggingConfig_FieldPathSelectorUnits:
				result.Units = source.Units
			case DeviceSpecLoggingConfig_FieldPathSelectorEnableJournalExport:
				result.EnableJournalExport = source.EnableJournalExport
			case DeviceSpecLoggingConfig_FieldPathSelectorContainerLoggingConfig:
				result.ContainerLoggingConfig = source.ContainerLoggingConfig
				wholeContainerLoggingConfigAccepted = true
			}
		case *DeviceSpecLoggingConfig_FieldSubPath:
			switch tp.selector {
			case DeviceSpecLoggingConfig_FieldPathSelectorContainerLoggingConfig:
				containerLoggingConfigMask.AppendPath(tp.subPath.(DeviceSpecLoggingConfigContainerLoggingConfig_FieldPath))
			}
		}
	}
	if wholeContainerLoggingConfigAccepted == false && len(containerLoggingConfigMask.Paths) > 0 {
		result.ContainerLoggingConfig = containerLoggingConfigMask.Project(source.GetContainerLoggingConfig())
	}
	return result
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_LoggingConfig))
}

func (fieldMask *Device_Spec_LoggingConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_ProxyConfig_FieldMask struct {
	Paths []DeviceSpecProxyConfig_FieldPath
}

func FullDevice_Spec_ProxyConfig_FieldMask() *Device_Spec_ProxyConfig_FieldMask {
	res := &Device_Spec_ProxyConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorHttpProxy})
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorHttpsProxy})
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorNoProxy})
	res.Paths = append(res.Paths, &DeviceSpecProxyConfig_FieldTerminalPath{selector: DeviceSpecProxyConfig_FieldPathSelectorProxyInterfaces})
	return res
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecProxyConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecProxyConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecProxyConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Subtract(other *Device_Spec_ProxyConfig_FieldMask) *Device_Spec_ProxyConfig_FieldMask {
	result := &Device_Spec_ProxyConfig_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecProxyConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_ProxyConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) FilterInputFields() *Device_Spec_ProxyConfig_FieldMask {
	result := &Device_Spec_ProxyConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecProxyConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecProxyConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_ProxyConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_ProxyConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) AppendPath(path DeviceSpecProxyConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecProxyConfig_FieldPath))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) GetPaths() []DeviceSpecProxyConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecProxyConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Set(target, source *Device_Spec_ProxyConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_ProxyConfig), source.(*Device_Spec_ProxyConfig))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) Project(source *Device_Spec_ProxyConfig) *Device_Spec_ProxyConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_ProxyConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecProxyConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecProxyConfig_FieldPathSelectorHttpProxy:
				result.HttpProxy = source.HttpProxy
			case DeviceSpecProxyConfig_FieldPathSelectorHttpsProxy:
				result.HttpsProxy = source.HttpsProxy
			case DeviceSpecProxyConfig_FieldPathSelectorNoProxy:
				result.NoProxy = source.NoProxy
			case DeviceSpecProxyConfig_FieldPathSelectorProxyInterfaces:
				result.ProxyInterfaces = source.ProxyInterfaces
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_ProxyConfig))
}

func (fieldMask *Device_Spec_ProxyConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_Location_FieldMask struct {
	Paths []DeviceSpecLocation_FieldPath
}

func FullDevice_Spec_Location_FieldMask() *Device_Spec_Location_FieldMask {
	res := &Device_Spec_Location_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecLocation_FieldTerminalPath{selector: DeviceSpecLocation_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceSpecLocation_FieldTerminalPath{selector: DeviceSpecLocation_FieldPathSelectorPlacement})
	return res
}

func (fieldMask *Device_Spec_Location_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_Location_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_Location_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecLocation_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_Location_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecLocation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_Location_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecLocation_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_Location_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_Location_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_Location_FieldMask) Subtract(other *Device_Spec_Location_FieldMask) *Device_Spec_Location_FieldMask {
	result := &Device_Spec_Location_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecLocation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_Location_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_Location_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_Location_FieldMask) FilterInputFields() *Device_Spec_Location_FieldMask {
	result := &Device_Spec_Location_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_Location_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_Location_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecLocation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecLocation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_Location_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_Location_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_Location_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_Location_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_Location_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_Location_FieldMask) AppendPath(path DeviceSpecLocation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_Location_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecLocation_FieldPath))
}

func (fieldMask *Device_Spec_Location_FieldMask) GetPaths() []DeviceSpecLocation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_Location_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_Location_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecLocation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_Location_FieldMask) Set(target, source *Device_Spec_Location) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_Location_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_Location), source.(*Device_Spec_Location))
}

func (fieldMask *Device_Spec_Location_FieldMask) Project(source *Device_Spec_Location) *Device_Spec_Location {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_Location{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecLocation_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecLocation_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceSpecLocation_FieldPathSelectorPlacement:
				result.Placement = source.Placement
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_Location_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_Location))
}

func (fieldMask *Device_Spec_Location_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_USBGuard_FieldMask struct {
	Paths []DeviceSpecUSBGuard_FieldPath
}

func FullDevice_Spec_USBGuard_FieldMask() *Device_Spec_USBGuard_FieldMask {
	res := &Device_Spec_USBGuard_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecUSBGuard_FieldTerminalPath{selector: DeviceSpecUSBGuard_FieldPathSelectorEnable})
	res.Paths = append(res.Paths, &DeviceSpecUSBGuard_FieldTerminalPath{selector: DeviceSpecUSBGuard_FieldPathSelectorWhiteList})
	return res
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_USBGuard_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecUSBGuard_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecUSBGuard_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecUSBGuard_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_USBGuard_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) Subtract(other *Device_Spec_USBGuard_FieldMask) *Device_Spec_USBGuard_FieldMask {
	result := &Device_Spec_USBGuard_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[DeviceSpecUSBGuard_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecUSBGuard_FieldPathSelectorWhiteList: &Device_Spec_USBGuard_WhiteList_FieldMask{},
	}
	mySubMasks := map[DeviceSpecUSBGuard_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecUSBGuard_FieldPathSelectorWhiteList: &Device_Spec_USBGuard_WhiteList_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecUSBGuard_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecUSBGuard_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecUSBGuard_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecUSBGuard_FieldPathSelectorWhiteList:
						mySubMasks[DeviceSpecUSBGuard_FieldPathSelectorWhiteList] = FullDevice_Spec_USBGuard_WhiteList_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecUSBGuard_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecUSBGuard_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_USBGuard_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_USBGuard_FieldMask) FilterInputFields() *Device_Spec_USBGuard_FieldMask {
	result := &Device_Spec_USBGuard_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_USBGuard_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecUSBGuard_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecUSBGuard_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_USBGuard_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_USBGuard_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) AppendPath(path DeviceSpecUSBGuard_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecUSBGuard_FieldPath))
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) GetPaths() []DeviceSpecUSBGuard_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecUSBGuard_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) Set(target, source *Device_Spec_USBGuard) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_USBGuard), source.(*Device_Spec_USBGuard))
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) Project(source *Device_Spec_USBGuard) *Device_Spec_USBGuard {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_USBGuard{}
	whiteListMask := &Device_Spec_USBGuard_WhiteList_FieldMask{}
	wholeWhiteListAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecUSBGuard_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecUSBGuard_FieldPathSelectorEnable:
				result.Enable = source.Enable
			case DeviceSpecUSBGuard_FieldPathSelectorWhiteList:
				result.WhiteList = source.WhiteList
				wholeWhiteListAccepted = true
			}
		case *DeviceSpecUSBGuard_FieldSubPath:
			switch tp.selector {
			case DeviceSpecUSBGuard_FieldPathSelectorWhiteList:
				whiteListMask.AppendPath(tp.subPath.(DeviceSpecUSBGuardWhiteList_FieldPath))
			}
		}
	}
	if wholeWhiteListAccepted == false && len(whiteListMask.Paths) > 0 {
		for _, sourceItem := range source.GetWhiteList() {
			result.WhiteList = append(result.WhiteList, whiteListMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_USBGuard))
}

func (fieldMask *Device_Spec_USBGuard_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_SSHConfig_AuthKey_FieldMask struct {
	Paths []DeviceSpecSSHConfigAuthKey_FieldPath
}

func FullDevice_Spec_SSHConfig_AuthKey_FieldMask() *Device_Spec_SSHConfig_AuthKey_FieldMask {
	res := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorSshaKey})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorCertAuthority})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorCommand})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorEnvironment})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorFrom})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoAgentForwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPortForwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPty})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoUserRc})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoX11Forwarding})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorPermitopen})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorPrincipals})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorTunnel})
	res.Paths = append(res.Paths, &DeviceSpecSSHConfigAuthKey_FieldTerminalPath{selector: DeviceSpecSSHConfigAuthKey_FieldPathSelectorRestrict})
	return res
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 14)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecSSHConfigAuthKey_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecSSHConfigAuthKey_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Subtract(other *Device_Spec_SSHConfig_AuthKey_FieldMask) *Device_Spec_SSHConfig_AuthKey_FieldMask {
	result := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	removedSelectors := make([]bool, 14)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecSSHConfigAuthKey_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_SSHConfig_AuthKey_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) FilterInputFields() *Device_Spec_SSHConfig_AuthKey_FieldMask {
	result := &Device_Spec_SSHConfig_AuthKey_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecSSHConfigAuthKey_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_SSHConfig_AuthKey_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_SSHConfig_AuthKey_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) AppendPath(path DeviceSpecSSHConfigAuthKey_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecSSHConfigAuthKey_FieldPath))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) GetPaths() []DeviceSpecSSHConfigAuthKey_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecSSHConfigAuthKey_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Set(target, source *Device_Spec_SSHConfig_AuthKey) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_SSHConfig_AuthKey), source.(*Device_Spec_SSHConfig_AuthKey))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) Project(source *Device_Spec_SSHConfig_AuthKey) *Device_Spec_SSHConfig_AuthKey {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_SSHConfig_AuthKey{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecSSHConfigAuthKey_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorSshaKey:
				result.SshaKey = source.SshaKey
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorCertAuthority:
				result.CertAuthority = source.CertAuthority
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorCommand:
				result.Command = source.Command
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorEnvironment:
				result.Environment = source.Environment
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorFrom:
				result.From = source.From
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoAgentForwarding:
				result.NoAgentForwarding = source.NoAgentForwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPortForwarding:
				result.NoPortForwarding = source.NoPortForwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoPty:
				result.NoPty = source.NoPty
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoUserRc:
				result.NoUserRc = source.NoUserRc
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorNoX11Forwarding:
				result.NoX11Forwarding = source.NoX11Forwarding
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorPermitopen:
				result.Permitopen = source.Permitopen
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorPrincipals:
				result.Principals = source.Principals
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorTunnel:
				result.Tunnel = source.Tunnel
			case DeviceSpecSSHConfigAuthKey_FieldPathSelectorRestrict:
				result.Restrict = source.Restrict
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_SSHConfig_AuthKey))
}

func (fieldMask *Device_Spec_SSHConfig_AuthKey_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask struct {
	Paths []DeviceSpecLoggingConfigContainerLoggingConfig_FieldPath
}

func FullDevice_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask() *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask {
	res := &Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecLoggingConfigContainerLoggingConfig_FieldTerminalPath{selector: DeviceSpecLoggingConfigContainerLoggingConfig_FieldPathSelectorEnableContainerLogExport})
	return res
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecLoggingConfigContainerLoggingConfig_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecLoggingConfigContainerLoggingConfig_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecLoggingConfigContainerLoggingConfig_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) Subtract(other *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask {
	result := &Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecLoggingConfigContainerLoggingConfig_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) FilterInputFields() *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask {
	result := &Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecLoggingConfigContainerLoggingConfig_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecLoggingConfigContainerLoggingConfig_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) AppendPath(path DeviceSpecLoggingConfigContainerLoggingConfig_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecLoggingConfigContainerLoggingConfig_FieldPath))
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) GetPaths() []DeviceSpecLoggingConfigContainerLoggingConfig_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecLoggingConfigContainerLoggingConfig_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) Set(target, source *Device_Spec_LoggingConfig_ContainerLoggingConfig) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_LoggingConfig_ContainerLoggingConfig), source.(*Device_Spec_LoggingConfig_ContainerLoggingConfig))
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) Project(source *Device_Spec_LoggingConfig_ContainerLoggingConfig) *Device_Spec_LoggingConfig_ContainerLoggingConfig {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_LoggingConfig_ContainerLoggingConfig{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecLoggingConfigContainerLoggingConfig_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecLoggingConfigContainerLoggingConfig_FieldPathSelectorEnableContainerLogExport:
				result.EnableContainerLogExport = source.EnableContainerLogExport
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_LoggingConfig_ContainerLoggingConfig))
}

func (fieldMask *Device_Spec_LoggingConfig_ContainerLoggingConfig_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_USBGuard_Port_FieldMask struct {
	Paths []DeviceSpecUSBGuardPort_FieldPath
}

func FullDevice_Spec_USBGuard_Port_FieldMask() *Device_Spec_USBGuard_Port_FieldMask {
	res := &Device_Spec_USBGuard_Port_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardPort_FieldTerminalPath{selector: DeviceSpecUSBGuardPort_FieldPathSelectorEquals})
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardPort_FieldTerminalPath{selector: DeviceSpecUSBGuardPort_FieldPathSelectorOneOf})
	return res
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecUSBGuardPort_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecUSBGuardPort_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecUSBGuardPort_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) Subtract(other *Device_Spec_USBGuard_Port_FieldMask) *Device_Spec_USBGuard_Port_FieldMask {
	result := &Device_Spec_USBGuard_Port_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecUSBGuardPort_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_USBGuard_Port_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) FilterInputFields() *Device_Spec_USBGuard_Port_FieldMask {
	result := &Device_Spec_USBGuard_Port_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecUSBGuardPort_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecUSBGuardPort_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_USBGuard_Port_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_USBGuard_Port_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) AppendPath(path DeviceSpecUSBGuardPort_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecUSBGuardPort_FieldPath))
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) GetPaths() []DeviceSpecUSBGuardPort_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecUSBGuardPort_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) Set(target, source *Device_Spec_USBGuard_Port) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_USBGuard_Port), source.(*Device_Spec_USBGuard_Port))
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) Project(source *Device_Spec_USBGuard_Port) *Device_Spec_USBGuard_Port {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_USBGuard_Port{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecUSBGuardPort_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecUSBGuardPort_FieldPathSelectorEquals:
				result.Equals = source.Equals
			case DeviceSpecUSBGuardPort_FieldPathSelectorOneOf:
				result.OneOf = source.OneOf
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_USBGuard_Port))
}

func (fieldMask *Device_Spec_USBGuard_Port_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_USBGuard_Interface_FieldMask struct {
	Paths []DeviceSpecUSBGuardInterface_FieldPath
}

func FullDevice_Spec_USBGuard_Interface_FieldMask() *Device_Spec_USBGuard_Interface_FieldMask {
	res := &Device_Spec_USBGuard_Interface_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardInterface_FieldTerminalPath{selector: DeviceSpecUSBGuardInterface_FieldPathSelectorEquals})
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardInterface_FieldTerminalPath{selector: DeviceSpecUSBGuardInterface_FieldPathSelectorOneOf})
	return res
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecUSBGuardInterface_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecUSBGuardInterface_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecUSBGuardInterface_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) Subtract(other *Device_Spec_USBGuard_Interface_FieldMask) *Device_Spec_USBGuard_Interface_FieldMask {
	result := &Device_Spec_USBGuard_Interface_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecUSBGuardInterface_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_USBGuard_Interface_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) FilterInputFields() *Device_Spec_USBGuard_Interface_FieldMask {
	result := &Device_Spec_USBGuard_Interface_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecUSBGuardInterface_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecUSBGuardInterface_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_USBGuard_Interface_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_USBGuard_Interface_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) AppendPath(path DeviceSpecUSBGuardInterface_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecUSBGuardInterface_FieldPath))
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) GetPaths() []DeviceSpecUSBGuardInterface_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecUSBGuardInterface_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) Set(target, source *Device_Spec_USBGuard_Interface) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_USBGuard_Interface), source.(*Device_Spec_USBGuard_Interface))
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) Project(source *Device_Spec_USBGuard_Interface) *Device_Spec_USBGuard_Interface {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_USBGuard_Interface{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecUSBGuardInterface_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecUSBGuardInterface_FieldPathSelectorEquals:
				result.Equals = source.Equals
			case DeviceSpecUSBGuardInterface_FieldPathSelectorOneOf:
				result.OneOf = source.OneOf
			}
		}
	}
	return result
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_USBGuard_Interface))
}

func (fieldMask *Device_Spec_USBGuard_Interface_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Spec_USBGuard_WhiteList_FieldMask struct {
	Paths []DeviceSpecUSBGuardWhiteList_FieldPath
}

func FullDevice_Spec_USBGuard_WhiteList_FieldMask() *Device_Spec_USBGuard_WhiteList_FieldMask {
	res := &Device_Spec_USBGuard_WhiteList_FieldMask{}
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardWhiteList_FieldTerminalPath{selector: DeviceSpecUSBGuardWhiteList_FieldPathSelectorDeviceName})
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardWhiteList_FieldTerminalPath{selector: DeviceSpecUSBGuardWhiteList_FieldPathSelectorDeviceId})
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardWhiteList_FieldTerminalPath{selector: DeviceSpecUSBGuardWhiteList_FieldPathSelectorViaPort})
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardWhiteList_FieldTerminalPath{selector: DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithInterface})
	res.Paths = append(res.Paths, &DeviceSpecUSBGuardWhiteList_FieldTerminalPath{selector: DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithConnectType})
	return res
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceSpecUSBGuardWhiteList_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceSpecUSBGuardWhiteList_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceSpecUSBGuardWhiteList_FieldPath(raw)
	})
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) Subtract(other *Device_Spec_USBGuard_WhiteList_FieldMask) *Device_Spec_USBGuard_WhiteList_FieldMask {
	result := &Device_Spec_USBGuard_WhiteList_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[DeviceSpecUSBGuardWhiteList_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecUSBGuardWhiteList_FieldPathSelectorViaPort:       &Device_Spec_USBGuard_Port_FieldMask{},
		DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithInterface: &Device_Spec_USBGuard_Interface_FieldMask{},
	}
	mySubMasks := map[DeviceSpecUSBGuardWhiteList_FieldPathSelector]gotenobject.FieldMask{
		DeviceSpecUSBGuardWhiteList_FieldPathSelectorViaPort:       &Device_Spec_USBGuard_Port_FieldMask{},
		DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithInterface: &Device_Spec_USBGuard_Interface_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceSpecUSBGuardWhiteList_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceSpecUSBGuardWhiteList_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceSpecUSBGuardWhiteList_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceSpecUSBGuardWhiteList_FieldPathSelectorViaPort:
						mySubMasks[DeviceSpecUSBGuardWhiteList_FieldPathSelectorViaPort] = FullDevice_Spec_USBGuard_Port_FieldMask()
					case DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithInterface:
						mySubMasks[DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithInterface] = FullDevice_Spec_USBGuard_Interface_FieldMask()
					}
				} else if tp, ok := path.(*DeviceSpecUSBGuardWhiteList_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceSpecUSBGuardWhiteList_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Spec_USBGuard_WhiteList_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) FilterInputFields() *Device_Spec_USBGuard_WhiteList_FieldMask {
	result := &Device_Spec_USBGuard_WhiteList_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceSpecUSBGuardWhiteList_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceSpecUSBGuardWhiteList_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Spec_USBGuard_WhiteList_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Spec_USBGuard_WhiteList_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) AppendPath(path DeviceSpecUSBGuardWhiteList_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceSpecUSBGuardWhiteList_FieldPath))
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) GetPaths() []DeviceSpecUSBGuardWhiteList_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceSpecUSBGuardWhiteList_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) Set(target, source *Device_Spec_USBGuard_WhiteList) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Spec_USBGuard_WhiteList), source.(*Device_Spec_USBGuard_WhiteList))
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) Project(source *Device_Spec_USBGuard_WhiteList) *Device_Spec_USBGuard_WhiteList {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Spec_USBGuard_WhiteList{}
	viaPortMask := &Device_Spec_USBGuard_Port_FieldMask{}
	wholeViaPortAccepted := false
	withInterfaceMask := &Device_Spec_USBGuard_Interface_FieldMask{}
	wholeWithInterfaceAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceSpecUSBGuardWhiteList_FieldTerminalPath:
			switch tp.selector {
			case DeviceSpecUSBGuardWhiteList_FieldPathSelectorDeviceName:
				result.DeviceName = source.DeviceName
			case DeviceSpecUSBGuardWhiteList_FieldPathSelectorDeviceId:
				result.DeviceId = source.DeviceId
			case DeviceSpecUSBGuardWhiteList_FieldPathSelectorViaPort:
				result.ViaPort = source.ViaPort
				wholeViaPortAccepted = true
			case DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithInterface:
				result.WithInterface = source.WithInterface
				wholeWithInterfaceAccepted = true
			case DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithConnectType:
				result.WithConnectType = source.WithConnectType
			}
		case *DeviceSpecUSBGuardWhiteList_FieldSubPath:
			switch tp.selector {
			case DeviceSpecUSBGuardWhiteList_FieldPathSelectorViaPort:
				viaPortMask.AppendPath(tp.subPath.(DeviceSpecUSBGuardPort_FieldPath))
			case DeviceSpecUSBGuardWhiteList_FieldPathSelectorWithInterface:
				withInterfaceMask.AppendPath(tp.subPath.(DeviceSpecUSBGuardInterface_FieldPath))
			}
		}
	}
	if wholeViaPortAccepted == false && len(viaPortMask.Paths) > 0 {
		result.ViaPort = viaPortMask.Project(source.GetViaPort())
	}
	if wholeWithInterfaceAccepted == false && len(withInterfaceMask.Paths) > 0 {
		result.WithInterface = withInterfaceMask.Project(source.GetWithInterface())
	}
	return result
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Spec_USBGuard_WhiteList))
}

func (fieldMask *Device_Spec_USBGuard_WhiteList_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_Address_FieldMask struct {
	Paths []DeviceStatusAddress_FieldPath
}

func FullDevice_Status_Address_FieldMask() *Device_Status_Address_FieldMask {
	res := &Device_Status_Address_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusAddress_FieldTerminalPath{selector: DeviceStatusAddress_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceStatusAddress_FieldTerminalPath{selector: DeviceStatusAddress_FieldPathSelectorType})
	return res
}

func (fieldMask *Device_Status_Address_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_Address_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_Address_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusAddress_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusAddress_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_Address_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusAddress_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_Address_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_Address_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_Address_FieldMask) Subtract(other *Device_Status_Address_FieldMask) *Device_Status_Address_FieldMask {
	result := &Device_Status_Address_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusAddress_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_Address_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_Address_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_Address_FieldMask) FilterInputFields() *Device_Status_Address_FieldMask {
	result := &Device_Status_Address_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_Address_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_Address_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusAddress_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusAddress_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_Address_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_Address_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_Address_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_Address_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) AppendPath(path DeviceStatusAddress_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_Address_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusAddress_FieldPath))
}

func (fieldMask *Device_Status_Address_FieldMask) GetPaths() []DeviceStatusAddress_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_Address_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_Address_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusAddress_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_Address_FieldMask) Set(target, source *Device_Status_Address) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_Address_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_Address), source.(*Device_Status_Address))
}

func (fieldMask *Device_Status_Address_FieldMask) Project(source *Device_Status_Address) *Device_Status_Address {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_Address{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusAddress_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusAddress_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceStatusAddress_FieldPathSelectorType:
				result.Type = source.Type
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_Address_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_Address))
}

func (fieldMask *Device_Status_Address_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_Condition_FieldMask struct {
	Paths []DeviceStatusCondition_FieldPath
}

func FullDevice_Status_Condition_FieldMask() *Device_Status_Condition_FieldMask {
	res := &Device_Status_Condition_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorMessage})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorReason})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorType})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorLastHeartBeatTime})
	res.Paths = append(res.Paths, &DeviceStatusCondition_FieldTerminalPath{selector: DeviceStatusCondition_FieldPathSelectorLastTransitionTime})
	return res
}

func (fieldMask *Device_Status_Condition_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_Condition_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_Condition_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusCondition_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusCondition_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_Condition_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusCondition_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_Condition_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_Condition_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_Condition_FieldMask) Subtract(other *Device_Status_Condition_FieldMask) *Device_Status_Condition_FieldMask {
	result := &Device_Status_Condition_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusCondition_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_Condition_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_Condition_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_Condition_FieldMask) FilterInputFields() *Device_Status_Condition_FieldMask {
	result := &Device_Status_Condition_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_Condition_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_Condition_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusCondition_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusCondition_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_Condition_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_Condition_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_Condition_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_Condition_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) AppendPath(path DeviceStatusCondition_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_Condition_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusCondition_FieldPath))
}

func (fieldMask *Device_Status_Condition_FieldMask) GetPaths() []DeviceStatusCondition_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_Condition_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_Condition_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusCondition_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_Condition_FieldMask) Set(target, source *Device_Status_Condition) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_Condition_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_Condition), source.(*Device_Status_Condition))
}

func (fieldMask *Device_Status_Condition_FieldMask) Project(source *Device_Status_Condition) *Device_Status_Condition {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_Condition{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusCondition_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusCondition_FieldPathSelectorMessage:
				result.Message = source.Message
			case DeviceStatusCondition_FieldPathSelectorReason:
				result.Reason = source.Reason
			case DeviceStatusCondition_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusCondition_FieldPathSelectorType:
				result.Type = source.Type
			case DeviceStatusCondition_FieldPathSelectorLastHeartBeatTime:
				result.LastHeartBeatTime = source.LastHeartBeatTime
			case DeviceStatusCondition_FieldPathSelectorLastTransitionTime:
				result.LastTransitionTime = source.LastTransitionTime
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_Condition_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_Condition))
}

func (fieldMask *Device_Status_Condition_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_NetworkConfigState_FieldMask struct {
	Paths []DeviceStatusNetworkConfigState_FieldPath
}

func FullDevice_Status_NetworkConfigState_FieldMask() *Device_Status_NetworkConfigState_FieldMask {
	res := &Device_Status_NetworkConfigState_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorActiveNetworkConfigSource})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetworkConfigSource})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetworkConfigError})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorDefaultNetplanConfig})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorActiveNetplanConfig})
	res.Paths = append(res.Paths, &DeviceStatusNetworkConfigState_FieldTerminalPath{selector: DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetplanConfig})
	return res
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_NetworkConfigState_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusNetworkConfigState_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusNetworkConfigState_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusNetworkConfigState_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Subtract(other *Device_Status_NetworkConfigState_FieldMask) *Device_Status_NetworkConfigState_FieldMask {
	result := &Device_Status_NetworkConfigState_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusNetworkConfigState_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_NetworkConfigState_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_NetworkConfigState_FieldMask) FilterInputFields() *Device_Status_NetworkConfigState_FieldMask {
	result := &Device_Status_NetworkConfigState_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_NetworkConfigState_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusNetworkConfigState_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusNetworkConfigState_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_NetworkConfigState_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_NetworkConfigState_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) AppendPath(path DeviceStatusNetworkConfigState_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusNetworkConfigState_FieldPath))
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) GetPaths() []DeviceStatusNetworkConfigState_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusNetworkConfigState_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Set(target, source *Device_Status_NetworkConfigState) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_NetworkConfigState), source.(*Device_Status_NetworkConfigState))
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) Project(source *Device_Status_NetworkConfigState) *Device_Status_NetworkConfigState {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_NetworkConfigState{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusNetworkConfigState_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusNetworkConfigState_FieldPathSelectorActiveNetworkConfigSource:
				result.ActiveNetworkConfigSource = source.ActiveNetworkConfigSource
			case DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetworkConfigSource:
				result.DesiredNetworkConfigSource = source.DesiredNetworkConfigSource
			case DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetworkConfigError:
				result.DesiredNetworkConfigError = source.DesiredNetworkConfigError
			case DeviceStatusNetworkConfigState_FieldPathSelectorDefaultNetplanConfig:
				result.DefaultNetplanConfig = source.DefaultNetplanConfig
			case DeviceStatusNetworkConfigState_FieldPathSelectorActiveNetplanConfig:
				result.ActiveNetplanConfig = source.ActiveNetplanConfig
			case DeviceStatusNetworkConfigState_FieldPathSelectorDesiredNetplanConfig:
				result.DesiredNetplanConfig = source.DesiredNetplanConfig
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_NetworkConfigState))
}

func (fieldMask *Device_Status_NetworkConfigState_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_ProxyConfigStatus_FieldMask struct {
	Paths []DeviceStatusProxyConfigStatus_FieldPath
}

func FullDevice_Status_ProxyConfigStatus_FieldMask() *Device_Status_ProxyConfigStatus_FieldMask {
	res := &Device_Status_ProxyConfigStatus_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfigSource})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorDesiredConfigSource})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorProxyConfigError})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig})
	res.Paths = append(res.Paths, &DeviceStatusProxyConfigStatus_FieldTerminalPath{selector: DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig})
	return res
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusProxyConfigStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusProxyConfigStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusProxyConfigStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Subtract(other *Device_Status_ProxyConfigStatus_FieldMask) *Device_Status_ProxyConfigStatus_FieldMask {
	result := &Device_Status_ProxyConfigStatus_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[DeviceStatusProxyConfigStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig: &Device_Spec_ProxyConfig_FieldMask{},
		DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:  &Device_Spec_ProxyConfig_FieldMask{},
		DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:     &Device_Spec_ProxyConfig_FieldMask{},
	}
	mySubMasks := map[DeviceStatusProxyConfigStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig: &Device_Spec_ProxyConfig_FieldMask{},
		DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:  &Device_Spec_ProxyConfig_FieldMask{},
		DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:     &Device_Spec_ProxyConfig_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusProxyConfigStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusProxyConfigStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusProxyConfigStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig:
						mySubMasks[DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					case DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:
						mySubMasks[DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					case DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:
						mySubMasks[DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig] = FullDevice_Spec_ProxyConfig_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusProxyConfigStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusProxyConfigStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_ProxyConfigStatus_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) FilterInputFields() *Device_Status_ProxyConfigStatus_FieldMask {
	result := &Device_Status_ProxyConfigStatus_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusProxyConfigStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusProxyConfigStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_ProxyConfigStatus_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_ProxyConfigStatus_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) AppendPath(path DeviceStatusProxyConfigStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusProxyConfigStatus_FieldPath))
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) GetPaths() []DeviceStatusProxyConfigStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusProxyConfigStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Set(target, source *Device_Status_ProxyConfigStatus) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_ProxyConfigStatus), source.(*Device_Status_ProxyConfigStatus))
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) Project(source *Device_Status_ProxyConfigStatus) *Device_Status_ProxyConfigStatus {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_ProxyConfigStatus{}
	defaultConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeDefaultConfigAccepted := false
	activeConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeActiveConfigAccepted := false
	apiConfigMask := &Device_Spec_ProxyConfig_FieldMask{}
	wholeApiConfigAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusProxyConfigStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfigSource:
				result.ActiveConfigSource = source.ActiveConfigSource
			case DeviceStatusProxyConfigStatus_FieldPathSelectorDesiredConfigSource:
				result.DesiredConfigSource = source.DesiredConfigSource
			case DeviceStatusProxyConfigStatus_FieldPathSelectorProxyConfigError:
				result.ProxyConfigError = source.ProxyConfigError
			case DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig:
				result.DefaultConfig = source.DefaultConfig
				wholeDefaultConfigAccepted = true
			case DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:
				result.ActiveConfig = source.ActiveConfig
				wholeActiveConfigAccepted = true
			case DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:
				result.ApiConfig = source.ApiConfig
				wholeApiConfigAccepted = true
			}
		case *DeviceStatusProxyConfigStatus_FieldSubPath:
			switch tp.selector {
			case DeviceStatusProxyConfigStatus_FieldPathSelectorDefaultConfig:
				defaultConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			case DeviceStatusProxyConfigStatus_FieldPathSelectorActiveConfig:
				activeConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			case DeviceStatusProxyConfigStatus_FieldPathSelectorApiConfig:
				apiConfigMask.AppendPath(tp.subPath.(DeviceSpecProxyConfig_FieldPath))
			}
		}
	}
	if wholeDefaultConfigAccepted == false && len(defaultConfigMask.Paths) > 0 {
		result.DefaultConfig = defaultConfigMask.Project(source.GetDefaultConfig())
	}
	if wholeActiveConfigAccepted == false && len(activeConfigMask.Paths) > 0 {
		result.ActiveConfig = activeConfigMask.Project(source.GetActiveConfig())
	}
	if wholeApiConfigAccepted == false && len(apiConfigMask.Paths) > 0 {
		result.ApiConfig = apiConfigMask.Project(source.GetApiConfig())
	}
	return result
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_ProxyConfigStatus))
}

func (fieldMask *Device_Status_ProxyConfigStatus_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_FieldMask() *Device_Status_DeviceInfo_FieldMask {
	res := &Device_Status_DeviceInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorArchitecture})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorHardware})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOperatingSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorKernelVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOsImage})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorContainerRuntimeVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorOsVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorDriver})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorNetworkInterfaces})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_FieldMask) *Device_Status_DeviceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_FieldMask{}
	removedSelectors := make([]bool, 11)
	otherSubMasks := map[DeviceStatusDeviceInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:       &Device_Status_DeviceInfo_HardwareInformation_FieldMask{},
		DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo: &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:       &Device_Status_DeviceInfo_HardwareInformation_FieldMask{},
		DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo: &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
						mySubMasks[DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation] = FullDevice_Status_DeviceInfo_HardwareInformation_FieldMask()
					case DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo:
						mySubMasks[DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo] = FullDevice_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo), source.(*Device_Status_DeviceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) Project(source *Device_Status_DeviceInfo) *Device_Status_DeviceInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo{}
	hardwareInformationMask := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	wholeHardwareInformationAccepted := false
	controlPlaneInterfaceInfoMask := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{}
	wholeControlPlaneInterfaceInfoAccepted := false
	var networkInterfacesMapKeys []string
	wholeNetworkInterfacesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfo_FieldPathSelectorArchitecture:
				result.Architecture = source.Architecture
			case DeviceStatusDeviceInfo_FieldPathSelectorHardware:
				result.Hardware = source.Hardware
			case DeviceStatusDeviceInfo_FieldPathSelectorOperatingSystem:
				result.OperatingSystem = source.OperatingSystem
			case DeviceStatusDeviceInfo_FieldPathSelectorKernelVersion:
				result.KernelVersion = source.KernelVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorOsImage:
				result.OsImage = source.OsImage
			case DeviceStatusDeviceInfo_FieldPathSelectorContainerRuntimeVersion:
				result.ContainerRuntimeVersion = source.ContainerRuntimeVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorOsVersion:
				result.OsVersion = source.OsVersion
			case DeviceStatusDeviceInfo_FieldPathSelectorDriver:
				result.Driver = source.Driver
			case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
				result.HardwareInformation = source.HardwareInformation
				wholeHardwareInformationAccepted = true
			case DeviceStatusDeviceInfo_FieldPathSelectorNetworkInterfaces:
				result.NetworkInterfaces = source.NetworkInterfaces
				wholeNetworkInterfacesAccepted = true
			case DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo:
				result.ControlPlaneInterfaceInfo = source.ControlPlaneInterfaceInfo
				wholeControlPlaneInterfaceInfoAccepted = true
			}
		case *DeviceStatusDeviceInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfo_FieldPathSelectorHardwareInformation:
				hardwareInformationMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformation_FieldPath))
			case DeviceStatusDeviceInfo_FieldPathSelectorControlPlaneInterfaceInfo:
				controlPlaneInterfaceInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath))
			}
		case *DeviceStatusDeviceInfo_FieldPathMap:
			switch tp.selector {
			case DeviceStatusDeviceInfo_FieldPathSelectorNetworkInterfaces:
				networkInterfacesMapKeys = append(networkInterfacesMapKeys, tp.key)
			}
		}
	}
	if wholeHardwareInformationAccepted == false && len(hardwareInformationMask.Paths) > 0 {
		result.HardwareInformation = hardwareInformationMask.Project(source.GetHardwareInformation())
	}
	if wholeNetworkInterfacesAccepted == false && len(networkInterfacesMapKeys) > 0 && source.GetNetworkInterfaces() != nil {
		copiedMap := map[string]*Device_Status_DeviceInfo_NetworkInterface{}
		sourceMap := source.GetNetworkInterfaces()
		for _, key := range networkInterfacesMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.NetworkInterfaces = copiedMap
	}
	if wholeControlPlaneInterfaceInfoAccepted == false && len(controlPlaneInterfaceInfoMask.Paths) > 0 {
		result.ControlPlaneInterfaceInfo = controlPlaneInterfaceInfoMask.Project(source.GetControlPlaneInterfaceInfo())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_NormalizedAddress_FieldMask struct {
	Paths []DeviceStatusNormalizedAddress_FieldPath
}

func FullDevice_Status_NormalizedAddress_FieldMask() *Device_Status_NormalizedAddress_FieldMask {
	res := &Device_Status_NormalizedAddress_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorPostalCode})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorCountryCode})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorContinent})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorContinentId})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorCountry})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorCountryId})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea1})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea1Id})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea2})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea2Id})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea3})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea3Id})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea4})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea4Id})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorCoordinates})
	res.Paths = append(res.Paths, &DeviceStatusNormalizedAddress_FieldTerminalPath{selector: DeviceStatusNormalizedAddress_FieldPathSelectorAccuracy})
	return res
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_NormalizedAddress_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusNormalizedAddress_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 17)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusNormalizedAddress_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusNormalizedAddress_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) Subtract(other *Device_Status_NormalizedAddress_FieldMask) *Device_Status_NormalizedAddress_FieldMask {
	result := &Device_Status_NormalizedAddress_FieldMask{}
	removedSelectors := make([]bool, 17)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusNormalizedAddress_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_NormalizedAddress_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_NormalizedAddress_FieldMask) FilterInputFields() *Device_Status_NormalizedAddress_FieldMask {
	result := &Device_Status_NormalizedAddress_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_NormalizedAddress_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusNormalizedAddress_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusNormalizedAddress_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_NormalizedAddress_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_NormalizedAddress_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) AppendPath(path DeviceStatusNormalizedAddress_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusNormalizedAddress_FieldPath))
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) GetPaths() []DeviceStatusNormalizedAddress_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusNormalizedAddress_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) Set(target, source *Device_Status_NormalizedAddress) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_NormalizedAddress), source.(*Device_Status_NormalizedAddress))
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) Project(source *Device_Status_NormalizedAddress) *Device_Status_NormalizedAddress {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_NormalizedAddress{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusNormalizedAddress_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusNormalizedAddress_FieldPathSelectorPostalCode:
				result.PostalCode = source.PostalCode
			case DeviceStatusNormalizedAddress_FieldPathSelectorCountryCode:
				result.CountryCode = source.CountryCode
			case DeviceStatusNormalizedAddress_FieldPathSelectorContinent:
				result.Continent = source.Continent
			case DeviceStatusNormalizedAddress_FieldPathSelectorContinentId:
				result.ContinentId = source.ContinentId
			case DeviceStatusNormalizedAddress_FieldPathSelectorCountry:
				result.Country = source.Country
			case DeviceStatusNormalizedAddress_FieldPathSelectorCountryId:
				result.CountryId = source.CountryId
			case DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea1:
				result.AdminArea1 = source.AdminArea1
			case DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea1Id:
				result.AdminArea1Id = source.AdminArea1Id
			case DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea2:
				result.AdminArea2 = source.AdminArea2
			case DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea2Id:
				result.AdminArea2Id = source.AdminArea2Id
			case DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea3:
				result.AdminArea3 = source.AdminArea3
			case DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea3Id:
				result.AdminArea3Id = source.AdminArea3Id
			case DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea4:
				result.AdminArea4 = source.AdminArea4
			case DeviceStatusNormalizedAddress_FieldPathSelectorAdminArea4Id:
				result.AdminArea4Id = source.AdminArea4Id
			case DeviceStatusNormalizedAddress_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceStatusNormalizedAddress_FieldPathSelectorCoordinates:
				result.Coordinates = source.Coordinates
			case DeviceStatusNormalizedAddress_FieldPathSelectorAccuracy:
				result.Accuracy = source.Accuracy
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_NormalizedAddress))
}

func (fieldMask *Device_Status_NormalizedAddress_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformation_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	removedSelectors := make([]bool, 11)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:          &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:        &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:      &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:         &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:       &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:     &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:         &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:  &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:   &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:  &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:          &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:        &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:      &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:         &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:       &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:     &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:         &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:  &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:   &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:  &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformation_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs] = FullDevice_Status_DeviceInfo_HardwareInformation_OS_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios] = FullDevice_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem] = FullDevice_Status_DeviceInfo_HardwareInformation_System_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork] = FullDevice_Status_DeviceInfo_HardwareInformation_Network_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu] = FullDevice_Status_DeviceInfo_HardwareInformation_GPU_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformation_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformation_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformation_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation), source.(*Device_Status_DeviceInfo_HardwareInformation))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation) *Device_Status_DeviceInfo_HardwareInformation {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation{}
	osMask := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	wholeOsAccepted := false
	biosMask := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	wholeBiosAccepted := false
	systemMask := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	wholeSystemAccepted := false
	cpuMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	wholeCpuAccepted := false
	blockMask := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	wholeBlockAccepted := false
	networkMask := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	wholeNetworkAccepted := false
	gpuMask := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	wholeGpuAccepted := false
	memoryInfoMask := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	wholeMemoryInfoAccepted := false
	hailoInfoMask := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	wholeHailoInfoAccepted := false
	nvidiaInfoMask := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	wholeNvidiaInfoAccepted := false
	modemStatusMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{}
	wholeModemStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformation_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
				result.Os = source.Os
				wholeOsAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
				result.Bios = source.Bios
				wholeBiosAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
				result.System = source.System
				wholeSystemAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
				result.Cpu = source.Cpu
				wholeCpuAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
				result.Block = source.Block
				wholeBlockAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
				result.Network = source.Network
				wholeNetworkAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
				result.Gpu = source.Gpu
				wholeGpuAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
				result.MemoryInfo = source.MemoryInfo
				wholeMemoryInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
				result.HailoInfo = source.HailoInfo
				wholeHailoInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
				result.NvidiaInfo = source.NvidiaInfo
				wholeNvidiaInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus:
				result.ModemStatus = source.ModemStatus
				wholeModemStatusAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformation_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorOs:
				osMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationOS_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBios:
				biosMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorSystem:
				systemMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorCpu:
				cpuMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorBlock:
				blockMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNetwork:
				networkMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorGpu:
				gpuMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorMemoryInfo:
				memoryInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorHailoInfo:
				hailoInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorNvidiaInfo:
				nvidiaInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformation_FieldPathSelectorModemStatus:
				modemStatusMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath))
			}
		}
	}
	if wholeOsAccepted == false && len(osMask.Paths) > 0 {
		result.Os = osMask.Project(source.GetOs())
	}
	if wholeBiosAccepted == false && len(biosMask.Paths) > 0 {
		result.Bios = biosMask.Project(source.GetBios())
	}
	if wholeSystemAccepted == false && len(systemMask.Paths) > 0 {
		result.System = systemMask.Project(source.GetSystem())
	}
	if wholeCpuAccepted == false && len(cpuMask.Paths) > 0 {
		result.Cpu = cpuMask.Project(source.GetCpu())
	}
	if wholeBlockAccepted == false && len(blockMask.Paths) > 0 {
		result.Block = blockMask.Project(source.GetBlock())
	}
	if wholeNetworkAccepted == false && len(networkMask.Paths) > 0 {
		result.Network = networkMask.Project(source.GetNetwork())
	}
	if wholeGpuAccepted == false && len(gpuMask.Paths) > 0 {
		result.Gpu = gpuMask.Project(source.GetGpu())
	}
	if wholeMemoryInfoAccepted == false && len(memoryInfoMask.Paths) > 0 {
		result.MemoryInfo = memoryInfoMask.Project(source.GetMemoryInfo())
	}
	if wholeHailoInfoAccepted == false && len(hailoInfoMask.Paths) > 0 {
		result.HailoInfo = hailoInfoMask.Project(source.GetHailoInfo())
	}
	if wholeNvidiaInfoAccepted == false && len(nvidiaInfoMask.Paths) > 0 {
		result.NvidiaInfo = nvidiaInfoMask.Project(source.GetNvidiaInfo())
	}
	if wholeModemStatusAccepted == false && len(modemStatusMask.Paths) > 0 {
		for _, sourceItem := range source.GetModemStatus() {
			result.ModemStatus = append(result.ModemStatus, modemStatusMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_NetworkInterface_FieldMask struct {
	Paths []DeviceStatusDeviceInfoNetworkInterface_FieldPath
}

func FullDevice_Status_DeviceInfo_NetworkInterface_FieldMask() *Device_Status_DeviceInfo_NetworkInterface_FieldMask {
	res := &Device_Status_DeviceInfo_NetworkInterface_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorInterfaceName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorIpAddressV4})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorExternalIpAddressV4})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorIpAddressV6})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorExternalIpAddressV6})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoNetworkInterface_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoNetworkInterface_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Subtract(other *Device_Status_DeviceInfo_NetworkInterface_FieldMask) *Device_Status_DeviceInfo_NetworkInterface_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[DeviceStatusDeviceInfoNetworkInterface_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:  &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{},
		DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier: &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoNetworkInterface_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:  &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{},
		DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier: &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoNetworkInterface_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:
						mySubMasks[DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo] = FullDevice_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask()
					case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier:
						mySubMasks[DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier] = FullDevice_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoNetworkInterface_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoNetworkInterface_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_NetworkInterface_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_NetworkInterface_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoNetworkInterface_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoNetworkInterface_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_NetworkInterface_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_NetworkInterface_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) AppendPath(path DeviceStatusDeviceInfoNetworkInterface_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoNetworkInterface_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) GetPaths() []DeviceStatusDeviceInfoNetworkInterface_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoNetworkInterface_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Set(target, source *Device_Status_DeviceInfo_NetworkInterface) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_NetworkInterface), source.(*Device_Status_DeviceInfo_NetworkInterface))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) Project(source *Device_Status_DeviceInfo_NetworkInterface) *Device_Status_DeviceInfo_NetworkInterface {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_NetworkInterface{}
	asInfoMask := &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{}
	wholeAsInfoAccepted := false
	carrierMask := &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{}
	wholeCarrierAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoNetworkInterface_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorInterfaceName:
				result.InterfaceName = source.InterfaceName
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorIpAddressV4:
				result.IpAddressV4 = source.IpAddressV4
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorExternalIpAddressV4:
				result.ExternalIpAddressV4 = source.ExternalIpAddressV4
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorIpAddressV6:
				result.IpAddressV6 = source.IpAddressV6
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorExternalIpAddressV6:
				result.ExternalIpAddressV6 = source.ExternalIpAddressV6
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:
				result.AsInfo = source.AsInfo
				wholeAsInfoAccepted = true
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier:
				result.Carrier = source.Carrier
				wholeCarrierAccepted = true
			}
		case *DeviceStatusDeviceInfoNetworkInterface_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorAsInfo:
				asInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath))
			case DeviceStatusDeviceInfoNetworkInterface_FieldPathSelectorCarrier:
				carrierMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath))
			}
		}
	}
	if wholeAsInfoAccepted == false && len(asInfoMask.Paths) > 0 {
		result.AsInfo = asInfoMask.Project(source.GetAsInfo())
	}
	if wholeCarrierAccepted == false && len(carrierMask.Paths) > 0 {
		result.Carrier = carrierMask.Project(source.GetCarrier())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_NetworkInterface))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask() *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask {
	res := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorActiveControlPlaneInterface})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorUsesProxy})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorIsFallback})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask {
	result := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_ControlPlaneInterfaceInfo), source.(*Device_Status_DeviceInfo_ControlPlaneInterfaceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) Project(source *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo) *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_ControlPlaneInterfaceInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorActiveControlPlaneInterface:
				result.ActiveControlPlaneInterface = source.ActiveControlPlaneInterface
			case DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorUsesProxy:
				result.UsesProxy = source.UsesProxy
			case DeviceStatusDeviceInfoControlPlaneInterfaceInfo_FieldPathSelectorIsFallback:
				result.IsFallback = source.IsFallback
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_ControlPlaneInterfaceInfo))
}

func (fieldMask *Device_Status_DeviceInfo_ControlPlaneInterfaceInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Capability_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorDescription})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCapability_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Capability) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Capability), source.(*Device_Status_DeviceInfo_HardwareInformation_Capability))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Capability) *Device_Status_DeviceInfo_HardwareInformation_Capability {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Capability{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCapability_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationCapability_FieldPathSelectorDescription:
				result.Description = source.Description
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Capability))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationOS_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_OS_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOperatingSystem})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorKernelVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOsImage})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorContainerRuntimeVersion})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationOS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationOS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationOS_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationOS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationOS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_OS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_OS), source.(*Device_Status_DeviceInfo_HardwareInformation_OS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_OS) *Device_Status_DeviceInfo_HardwareInformation_OS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_OS{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationOS_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOperatingSystem:
				result.OperatingSystem = source.OperatingSystem
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorKernelVersion:
				result.KernelVersion = source.KernelVersion
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorOsImage:
				result.OsImage = source.OsImage
			case DeviceStatusDeviceInfoHardwareInformationOS_FieldPathSelectorContainerRuntimeVersion:
				result.ContainerRuntimeVersion = source.ContainerRuntimeVersion
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_OS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_OS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorBiosVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorReleaseDate})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBIOS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_BIOS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_BIOS), source.(*Device_Status_DeviceInfo_HardwareInformation_BIOS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_BIOS) *Device_Status_DeviceInfo_HardwareInformation_BIOS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_BIOS{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBIOS_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorBiosVersion:
				result.BiosVersion = source.BiosVersion
			case DeviceStatusDeviceInfoHardwareInformationBIOS_FieldPathSelectorReleaseDate:
				result.ReleaseDate = source.ReleaseDate
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_BIOS))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_BIOS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_System_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_System_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorManufacturer})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration: &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration: &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration] = FullDevice_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_System_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationSystem_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystem_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_System) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_System), source.(*Device_Status_DeviceInfo_HardwareInformation_System))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_System) *Device_Status_DeviceInfo_HardwareInformation_System {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_System{}
	configurationMask := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	wholeConfigurationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorManufacturer:
				result.Manufacturer = source.Manufacturer
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorVersion:
				result.Version = source.Version
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
				result.Configuration = source.Configuration
				wholeConfigurationAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationSystem_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystem_FieldPathSelectorConfiguration:
				configurationMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath))
			}
		}
	}
	if wholeConfigurationAccepted == false && len(configurationMask.Paths) > 0 {
		result.Configuration = configurationMask.Project(source.GetConfiguration())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_System))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors: &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors: &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPU_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPU_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU) *Device_Status_DeviceInfo_HardwareInformation_CPU {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU{}
	processorsMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	wholeProcessorsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
				result.Processors = source.Processors
				wholeProcessorsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationCPU_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPU_FieldPathSelectorProcessors:
				processorsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath))
			}
		}
	}
	if wholeProcessorsAccepted == false && len(processorsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProcessors() {
			result.Processors = append(result.Processors, processorsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlock_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlock_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block), source.(*Device_Status_DeviceInfo_HardwareInformation_Block))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block) *Device_Status_DeviceInfo_HardwareInformation_Block {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block{}
	disksMask := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	wholeDisksAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
				result.Disks = source.Disks
				wholeDisksAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationBlock_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlock_FieldPathSelectorDisks:
				disksMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath))
			}
		}
	}
	if wholeDisksAccepted == false && len(disksMask.Paths) > 0 {
		for _, sourceItem := range source.GetDisks() {
			result.Disks = append(result.Disks, disksMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Network_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics: &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics: &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics] = FullDevice_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetwork_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Network) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Network), source.(*Device_Status_DeviceInfo_HardwareInformation_Network))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Network) *Device_Status_DeviceInfo_HardwareInformation_Network {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Network{}
	nicsMask := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	wholeNicsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
				result.Nics = source.Nics
				wholeNicsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNetwork_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetwork_FieldPathSelectorNics:
				nicsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath))
			}
		}
	}
	if wholeNicsAccepted == false && len(nicsMask.Paths) > 0 {
		for _, sourceItem := range source.GetNics() {
			result.Nics = append(result.Nics, nicsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Network))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_GPU_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards: &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards: &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards] = FullDevice_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationGPU_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPU_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_GPU) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_GPU), source.(*Device_Status_DeviceInfo_HardwareInformation_GPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_GPU) *Device_Status_DeviceInfo_HardwareInformation_GPU {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU{}
	graphicCardsMask := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	wholeGraphicCardsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
				result.GraphicCards = source.GraphicCards
				wholeGraphicCardsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationGPU_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPU_FieldPathSelectorGraphicCards:
				graphicCardsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath))
			}
		}
	}
	if wholeGraphicCardsAccepted == false && len(graphicCardsMask.Paths) > 0 {
		for _, sourceItem := range source.GetGraphicCards() {
			result.GraphicCards = append(result.GraphicCards, graphicCardsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_GPU))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorAddress})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorProduct})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorSubvendor})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_PCIDevice) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice), source.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_PCIDevice) *Device_Status_DeviceInfo_HardwareInformation_PCIDevice {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorAddress:
				result.Address = source.Address
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorProduct:
				result.Product = source.Product
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPathSelectorSubvendor:
				result.Subvendor = source.Subvendor
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_PCIDevice))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemoryBanks})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemoryBanks: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemoryBanks: &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemoryBanks:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemoryBanks] = FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo{}
	memoryBanksMask := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask{}
	wholeMemoryBanksAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemoryBanks:
				result.MemoryBanks = source.MemoryBanks
				wholeMemoryBanksAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfo_FieldPathSelectorMemoryBanks:
				memoryBanksMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath))
			}
		}
	}
	if wholeMemoryBanksAccepted == false && len(memoryBanksMask.Paths) > 0 {
		for _, sourceItem := range source.GetMemoryBanks() {
			result.MemoryBanks = append(result.MemoryBanks, memoryBanksMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorCliVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules: &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules: &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules] = FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo{}
	modulesMask := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	wholeModulesAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorCliVersion:
				result.CliVersion = source.CliVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
				result.Modules = source.Modules
				wholeModulesAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfo_FieldPathSelectorModules:
				modulesMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath))
			}
		}
	}
	if wholeModulesAccepted == false && len(modulesMask.Paths) > 0 {
		for _, sourceItem := range source.GetModules() {
			result.Modules = append(result.Modules, modulesMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorDriverVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorCudaVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus: &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus: &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus] = FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo{}
	gpusMask := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	wholeGpusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorStatus:
				result.Status = source.Status
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorDriverVersion:
				result.DriverVersion = source.DriverVersion
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorCudaVersion:
				result.CudaVersion = source.CudaVersion
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
				result.Gpus = source.Gpus
				wholeGpusAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfo_FieldPathSelectorGpus:
				gpusMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath))
			}
		}
	}
	if wholeGpusAccepted == false && len(gpusMask.Paths) > 0 {
		for _, sourceItem := range source.GetGpus() {
			result.Gpus = append(result.Gpus, gpusMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus{}
	modemMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{}
	wholeModemAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem:
				result.Modem = source.Modem
				wholeModemAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatus_FieldPathSelectorModem:
				modemMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath))
			}
		}
	}
	if wholeModemAccepted == false && len(modemMask.Paths) > 0 {
		result.Modem = modemMask.Project(source.GetModem())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorChassis})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorUuid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorSkuNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorFamily})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_System_Configuration) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration), source.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_System_Configuration) *Device_Status_DeviceInfo_HardwareInformation_System_Configuration {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_System_Configuration{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorChassis:
				result.Chassis = source.Chassis
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorUuid:
				result.Uuid = source.Uuid
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorSkuNumber:
				result.SkuNumber = source.SkuNumber
			case DeviceStatusDeviceInfoHardwareInformationSystemConfiguration_FieldPathSelectorFamily:
				result.Family = source.Family
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_System_Configuration))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_System_Configuration_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumThreads})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumCores})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumEnabledCores})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorSerial})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorFrequencyMhz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorMaxFrequencyMhz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorDriver})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorLatency})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorClock})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 14)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	removedSelectors := make([]bool, 14)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities: &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:    &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities: &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:    &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities] = FullDevice_Status_DeviceInfo_HardwareInformation_Capability_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo] = FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor{}
	capabilitiesMask := &Device_Status_DeviceInfo_HardwareInformation_Capability_FieldMask{}
	wholeCapabilitiesAccepted := false
	cacheInfoMask := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	wholeCacheInfoAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorModel:
				result.Model = source.Model
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
				result.Capabilities = source.Capabilities
				wholeCapabilitiesAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumThreads:
				result.NumThreads = source.NumThreads
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumCores:
				result.NumCores = source.NumCores
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorNumEnabledCores:
				result.NumEnabledCores = source.NumEnabledCores
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorSerial:
				result.Serial = source.Serial
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorFrequencyMhz:
				result.FrequencyMhz = source.FrequencyMhz
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorMaxFrequencyMhz:
				result.MaxFrequencyMhz = source.MaxFrequencyMhz
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
				result.CacheInfo = source.CacheInfo
				wholeCacheInfoAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorDriver:
				result.Driver = source.Driver
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorLatency:
				result.Latency = source.Latency
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorClock:
				result.Clock = source.Clock
			}
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCapabilities:
				capabilitiesMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCapability_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessor_FieldPathSelectorCacheInfo:
				cacheInfoMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath))
			}
		}
	}
	if wholeCapabilitiesAccepted == false && len(capabilitiesMask.Paths) > 0 {
		for _, sourceItem := range source.GetCapabilities() {
			result.Capabilities = append(result.Capabilities, capabilitiesMask.Project(sourceItem))
		}
	}
	if wholeCacheInfoAccepted == false && len(cacheInfoMask.Paths) > 0 {
		for _, sourceItem := range source.GetCacheInfo() {
			result.CacheInfo = append(result.CacheInfo, cacheInfoMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorType})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorSizeBytes})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache), source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache) *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorType:
				result.Type = source.Type
			case DeviceStatusDeviceInfoHardwareInformationCPUProcessorCache_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_CPU_Processor_Cache_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorDriveType})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorWwn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	removedSelectors := make([]bool, 8)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions: &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions] = FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk), source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk{}
	partitionsMask := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	wholePartitionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorDriveType:
				result.DriveType = source.DriveType
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorModel:
				result.Model = source.Model
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorWwn:
				result.Wwn = source.Wwn
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
				result.Partitions = source.Partitions
				wholePartitionsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDisk_FieldPathSelectorPartitions:
				partitionsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath))
			}
		}
	}
	if wholePartitionsAccepted == false && len(partitionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetPartitions() {
			result.Partitions = append(result.Partitions, partitionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorMountPoint})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorType})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition), source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition) *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorMountPoint:
				result.MountPoint = source.MountPoint
			case DeviceStatusDeviceInfoHardwareInformationBlockDiskPartition_FieldPathSelectorType:
				result.Type = source.Type
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Block_Disk_Partition_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorMacAddress})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVirtual})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSubvendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_Network_NIC) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC), source.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_Network_NIC) *Device_Status_DeviceInfo_HardwareInformation_Network_NIC {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_Network_NIC{}
	var settingMapKeys []string
	wholeSettingAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorMacAddress:
				result.MacAddress = source.MacAddress
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVirtual:
				result.Virtual = source.Virtual
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSubvendor:
				result.Subvendor = source.Subvendor
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting:
				result.Setting = source.Setting
				wholeSettingAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathMap:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNetworkNIC_FieldPathSelectorSetting:
				settingMapKeys = append(settingMapKeys, tp.key)
			}
		}
	}
	if wholeSettingAccepted == false && len(settingMapKeys) > 0 && source.GetSetting() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetSetting()
		for _, key := range settingMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.Setting = copiedMap
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_Network_NIC))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_Network_NIC_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorIndex})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice: &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice: &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice] = FullDevice_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard), source.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard) *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard{}
	deviceMask := &Device_Status_DeviceInfo_HardwareInformation_PCIDevice_FieldMask{}
	wholeDeviceAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorIndex:
				result.Index = source.Index
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
				result.Device = source.Device
				wholeDeviceAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationGPUGraphicCard_FieldPathSelectorDevice:
				deviceMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationPCIDevice_FieldPath))
			}
		}
	}
	if wholeDeviceAccepted == false && len(deviceMask.Paths) > 0 {
		result.Device = deviceMask.Project(source.GetDevice())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_GPU_GraphicCard_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorProduct})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorVendor})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorSerial})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorSlot})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorSizeBytes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorFrequencyHz})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorWidthBits})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank), source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank) *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorDescription:
				result.Description = source.Description
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorProduct:
				result.Product = source.Product
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorVendor:
				result.Vendor = source.Vendor
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorSerial:
				result.Serial = source.Serial
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorSlot:
				result.Slot = source.Slot
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorSizeBytes:
				result.SizeBytes = source.SizeBytes
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorFrequencyHz:
				result.FrequencyHz = source.FrequencyHz
			case DeviceStatusDeviceInfoHardwareInformationMemoryInfoMemoryBank_FieldPathSelectorWidthBits:
				result.WidthBits = source.WidthBits
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_MemoryInfo_MemoryBank_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorDevId})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorControlProtoVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorFirmwareVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorLoggerVersion})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorBoardName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorSerialNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorPartNumber})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorProductName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorNeuralNetworkCoreClockRate})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	removedSelectors := make([]bool, 9)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo) *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorDevId:
				result.DevId = source.DevId
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorControlProtoVersion:
				result.ControlProtoVersion = source.ControlProtoVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorFirmwareVersion:
				result.FirmwareVersion = source.FirmwareVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorLoggerVersion:
				result.LoggerVersion = source.LoggerVersion
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorBoardName:
				result.BoardName = source.BoardName
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorSerialNumber:
				result.SerialNumber = source.SerialNumber
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorPartNumber:
				result.PartNumber = source.PartNumber
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			case DeviceStatusDeviceInfoHardwareInformationHailoInfoHailoModuleInfo_FieldPathSelectorNeuralNetworkCoreClockRate:
				result.NeuralNetworkCoreClockRate = source.NeuralNetworkCoreClockRate
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_HailoInfo_HailoModuleInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorId})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorProductName})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo), source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo) *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorId:
				result.Id = source.Id
			case DeviceStatusDeviceInfoHardwareInformationNvidiaInfoGpuInfo_FieldPathSelectorProductName:
				result.ProductName = source.ProductName
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_NvidiaInfo_GpuInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPathSelectorDrxCycle})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPathSelectorMicoMode})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPathSelectorDrxCycle:
				result.DrxCycle = source.DrxCycle
			case DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPathSelectorMicoMode:
				result.MicoMode = source.MicoMode
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr{}
	registrationSettingsMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_RegistrationSettings_FieldMask{}
	wholeRegistrationSettingsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings:
				result.RegistrationSettings = source.RegistrationSettings
				wholeRegistrationSettingsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPathSelectorRegistrationSettings:
				registrationSettingsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusRegistrationSettings_FieldPath))
			}
		}
	}
	if wholeRegistrationSettingsAccepted == false && len(registrationSettingsMask.Paths) > 0 {
		result.RegistrationSettings = registrationSettingsMask.Project(source.GetRegistrationSettings())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorApn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorIpType})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorPassword})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorUser})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorApn:
				result.Apn = source.Apn
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorIpType:
				result.IpType = source.IpType
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorPassword:
				result.Password = source.Password
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPathSelectorUser:
				result.User = source.User
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorDbusPath})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer{}
	settingsMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Settings_FieldMask{}
	wholeSettingsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorDbusPath:
				result.DbusPath = source.DbusPath
			case DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings:
				result.Settings = source.Settings
				wholeSettingsAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPathSelectorSettings:
				settingsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSettings_FieldPath))
			}
		}
	}
	if wholeSettingsAccepted == false && len(settingsMask.Paths) > 0 {
		result.Settings = settingsMask.Project(source.GetSettings())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorUeModeOperation})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps{}
	initialBearerMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_InitialBearer_FieldMask{}
	wholeInitialBearerAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer:
				result.InitialBearer = source.InitialBearer
				wholeInitialBearerAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorUeModeOperation:
				result.UeModeOperation = source.UeModeOperation
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPathSelectorInitialBearer:
				initialBearerMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusInitialBearer_FieldPath))
			}
		}
	}
	if wholeInitialBearerAccepted == false && len(initialBearerMask.Paths) > 0 {
		result.InitialBearer = initialBearerMask.Project(source.GetInitialBearer())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEnabledLocks})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorImei})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorOperatorCode})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorOperatorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorPacketServiceState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorPco})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorRegistrationState})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{}
	removedSelectors := make([]bool, 9)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp{}
	fivegNrMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_FiveGNr_FieldMask{}
	wholeFivegNrAccepted := false
	epsMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Eps_FieldMask{}
	wholeEpsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr:
				result.FivegNr = source.FivegNr
				wholeFivegNrAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEnabledLocks:
				result.EnabledLocks = source.EnabledLocks
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:
				result.Eps = source.Eps
				wholeEpsAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorImei:
				result.Imei = source.Imei
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorOperatorCode:
				result.OperatorCode = source.OperatorCode
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorOperatorName:
				result.OperatorName = source.OperatorName
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorPacketServiceState:
				result.PacketServiceState = source.PacketServiceState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorPco:
				result.Pco = source.Pco
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorRegistrationState:
				result.RegistrationState = source.RegistrationState
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorFivegNr:
				fivegNrMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusFiveGNr_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPathSelectorEps:
				epsMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusEps_FieldPath))
			}
		}
	}
	if wholeFivegNrAccepted == false && len(fivegNrMask.Paths) > 0 {
		result.FivegNr = fivegNrMask.Project(source.GetFivegNr())
	}
	if wholeEpsAccepted == false && len(epsMask.Paths) > 0 {
		result.Eps = epsMask.Project(source.GetEps())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorActivationState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorCdma1xRegistrationState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorEsn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorEvdoRegistrationState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorMeid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorNid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorSid})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorActivationState:
				result.ActivationState = source.ActivationState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorCdma1xRegistrationState:
				result.Cdma1XRegistrationState = source.Cdma1XRegistrationState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorEsn:
				result.Esn = source.Esn
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorEvdoRegistrationState:
				result.EvdoRegistrationState = source.EvdoRegistrationState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorMeid:
				result.Meid = source.Meid
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorNid:
				result.Nid = source.Nid
			case DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPathSelectorSid:
				result.Sid = source.Sid
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPathSelectorRecent})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPathSelectorValue})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPathSelectorRecent:
				result.Recent = source.Recent
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPathSelectorValue:
				result.Value = source.Value
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorAccessTechnologies})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorBearers})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCarrierConfiguration})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCarrierConfigurationRevision})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentBands})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentCapabilities})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentModes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDevice})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDeviceIdentifier})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDrivers})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorEquipmentIdentifier})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorHardwareRevision})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorManufacturer})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorModel})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorOwnNumbers})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPlugin})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPorts})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPowerState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPrimaryPort})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPrimarySimSlot})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorRevision})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSim})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSimSlots})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorState})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorStateFailedReason})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedBands})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedCapabilities})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedIpFamilies})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedModes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorUnlockRequired})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorUnlockRetries})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 32)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{}
	removedSelectors := make([]bool, 32)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic{}
	signalQualityMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SignalQuality_FieldMask{}
	wholeSignalQualityAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorAccessTechnologies:
				result.AccessTechnologies = source.AccessTechnologies
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorBearers:
				result.Bearers = source.Bearers
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCarrierConfiguration:
				result.CarrierConfiguration = source.CarrierConfiguration
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCarrierConfigurationRevision:
				result.CarrierConfigurationRevision = source.CarrierConfigurationRevision
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentBands:
				result.CurrentBands = source.CurrentBands
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentCapabilities:
				result.CurrentCapabilities = source.CurrentCapabilities
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorCurrentModes:
				result.CurrentModes = source.CurrentModes
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDevice:
				result.Device = source.Device
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDeviceIdentifier:
				result.DeviceIdentifier = source.DeviceIdentifier
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorDrivers:
				result.Drivers = source.Drivers
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorEquipmentIdentifier:
				result.EquipmentIdentifier = source.EquipmentIdentifier
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorHardwareRevision:
				result.HardwareRevision = source.HardwareRevision
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorManufacturer:
				result.Manufacturer = source.Manufacturer
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorModel:
				result.Model = source.Model
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorOwnNumbers:
				result.OwnNumbers = source.OwnNumbers
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPlugin:
				result.Plugin = source.Plugin
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPorts:
				result.Ports = source.Ports
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPowerState:
				result.PowerState = source.PowerState
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPrimaryPort:
				result.PrimaryPort = source.PrimaryPort
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorPrimarySimSlot:
				result.PrimarySimSlot = source.PrimarySimSlot
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorRevision:
				result.Revision = source.Revision
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality:
				result.SignalQuality = source.SignalQuality
				wholeSignalQualityAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSim:
				result.Sim = source.Sim
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSimSlots:
				result.SimSlots = source.SimSlots
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorState:
				result.State = source.State
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorStateFailedReason:
				result.StateFailedReason = source.StateFailedReason
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedBands:
				result.SupportedBands = source.SupportedBands
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedCapabilities:
				result.SupportedCapabilities = source.SupportedCapabilities
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedIpFamilies:
				result.SupportedIpFamilies = source.SupportedIpFamilies
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSupportedModes:
				result.SupportedModes = source.SupportedModes
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorUnlockRequired:
				result.UnlockRequired = source.UnlockRequired
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorUnlockRetries:
				result.UnlockRetries = source.UnlockRetries
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPathSelectorSignalQuality:
				signalQualityMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusSignalQuality_FieldPath))
			}
		}
	}
	if wholeSignalQualityAccepted == false && len(signalQualityMask.Paths) > 0 {
		result.SignalQuality = signalQualityMask.Project(source.GetSignalQuality())
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorDbusPath})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorActive})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEmergencyNumbers})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEsimStatus})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorGid1})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorGid2})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorIccid})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorImsi})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorOperatorCode})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorOperatorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorRemovability})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorSimType})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 13)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask{}
	removedSelectors := make([]bool, 13)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorDbusPath:
				result.DbusPath = source.DbusPath
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorActive:
				result.Active = source.Active
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEid:
				result.Eid = source.Eid
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEmergencyNumbers:
				result.EmergencyNumbers = source.EmergencyNumbers
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorEsimStatus:
				result.EsimStatus = source.EsimStatus
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorGid1:
				result.Gid1 = source.Gid1
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorGid2:
				result.Gid2 = source.Gid2
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorIccid:
				result.Iccid = source.Iccid
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorImsi:
				result.Imsi = source.Imsi
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorOperatorCode:
				result.OperatorCode = source.OperatorCode
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorOperatorName:
				result.OperatorName = source.OperatorName
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorRemovability:
				result.Removability = source.Removability
			case DeviceStatusDeviceInfoHardwareInformationModemStatusSimStatus_FieldPathSelectorSimType:
				result.SimType = source.SimType
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask struct {
	Paths []DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath
}

func FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask {
	res := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorDbusPath})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath{selector: DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSimStatus})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) ProtoMessage() {
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Subtract(other *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:  &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{},
	}
	mySubMasks := map[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelector]gotenobject.FieldMask{
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp: &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:     &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{},
		DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:  &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath); ok {
					switch tp.selector {
					case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask()
					case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:
						mySubMasks[DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric] = FullDevice_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask()
					}
				} else if tp, ok := path.(*DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask {
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) AppendPath(path DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) GetPaths() []DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Set(target, source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem), source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) Project(source *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem) *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem{}
	threeGPpMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_ThreeGpp_FieldMask{}
	wholeThreeGPpAccepted := false
	cdmaMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Cdma_FieldMask{}
	wholeCdmaAccepted := false
	genericMask := &Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Generic_FieldMask{}
	wholeGenericAccepted := false
	var simStatusMapKeys []string
	wholeSimStatusAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp:
				result.ThreeGPp = source.ThreeGPp
				wholeThreeGPpAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:
				result.Cdma = source.Cdma
				wholeCdmaAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorDbusPath:
				result.DbusPath = source.DbusPath
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:
				result.Generic = source.Generic
				wholeGenericAccepted = true
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSimStatus:
				result.SimStatus = source.SimStatus
				wholeSimStatusAccepted = true
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldSubPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorThreeGPp:
				threeGPpMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusThreeGpp_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorCdma:
				cdmaMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusCdma_FieldPath))
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorGeneric:
				genericMask.AppendPath(tp.subPath.(DeviceStatusDeviceInfoHardwareInformationModemStatusGeneric_FieldPath))
			}
		case *DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathMap:
			switch tp.selector {
			case DeviceStatusDeviceInfoHardwareInformationModemStatusModem_FieldPathSelectorSimStatus:
				simStatusMapKeys = append(simStatusMapKeys, tp.key)
			}
		}
	}
	if wholeThreeGPpAccepted == false && len(threeGPpMask.Paths) > 0 {
		result.ThreeGPp = threeGPpMask.Project(source.GetThreeGPp())
	}
	if wholeCdmaAccepted == false && len(cdmaMask.Paths) > 0 {
		result.Cdma = cdmaMask.Project(source.GetCdma())
	}
	if wholeGenericAccepted == false && len(genericMask.Paths) > 0 {
		result.Generic = genericMask.Project(source.GetGeneric())
	}
	if wholeSimStatusAccepted == false && len(simStatusMapKeys) > 0 && source.GetSimStatus() != nil {
		copiedMap := map[string]*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_SimStatus{}
		sourceMap := source.GetSimStatus()
		for _, key := range simStatusMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.SimStatus = copiedMap
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem))
}

func (fieldMask *Device_Status_DeviceInfo_HardwareInformation_ModemStatus_Modem_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask struct {
	Paths []DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath
}

func FullDevice_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask() *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask {
	res := &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorAsn})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorDomain})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorRoutes})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorAsnType})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Subtract(other *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) AppendPath(path DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) GetPaths() []DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Set(target, source *Device_Status_DeviceInfo_NetworkInterface_ASInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_NetworkInterface_ASInfo), source.(*Device_Status_DeviceInfo_NetworkInterface_ASInfo))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) Project(source *Device_Status_DeviceInfo_NetworkInterface_ASInfo) *Device_Status_DeviceInfo_NetworkInterface_ASInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_NetworkInterface_ASInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorAsn:
				result.Asn = source.Asn
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorDomain:
				result.Domain = source.Domain
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorRoutes:
				result.Routes = source.Routes
			case DeviceStatusDeviceInfoNetworkInterfaceASInfo_FieldPathSelectorAsnType:
				result.AsnType = source.AsnType
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_NetworkInterface_ASInfo))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_ASInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask struct {
	Paths []DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath
}

func FullDevice_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask() *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask {
	res := &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{}
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorName})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorMobileCountryCode})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorMobileNetworkCode})
	res.Paths = append(res.Paths, &DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath{selector: DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorLocationAreaCode})
	return res
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath(raw)
	})
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) ProtoMessage() {}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Subtract(other *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) FilterInputFields() *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask {
	result := &Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) AppendPath(path DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) GetPaths() []DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Set(target, source *Device_Status_DeviceInfo_NetworkInterface_Carrier) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Device_Status_DeviceInfo_NetworkInterface_Carrier), source.(*Device_Status_DeviceInfo_NetworkInterface_Carrier))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) Project(source *Device_Status_DeviceInfo_NetworkInterface_Carrier) *Device_Status_DeviceInfo_NetworkInterface_Carrier {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Device_Status_DeviceInfo_NetworkInterface_Carrier{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldTerminalPath:
			switch tp.selector {
			case DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorName:
				result.Name = source.Name
			case DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorMobileCountryCode:
				result.MobileCountryCode = source.MobileCountryCode
			case DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorMobileNetworkCode:
				result.MobileNetworkCode = source.MobileNetworkCode
			case DeviceStatusDeviceInfoNetworkInterfaceCarrier_FieldPathSelectorLocationAreaCode:
				result.LocationAreaCode = source.LocationAreaCode
			}
		}
	}
	return result
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Device_Status_DeviceInfo_NetworkInterface_Carrier))
}

func (fieldMask *Device_Status_DeviceInfo_NetworkInterface_Carrier_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
