// Code generated by protoc-gen-goten-object
// File: edgelq/limits/proto/v1alpha2/limit_pool_service.proto
// DO NOT EDIT!!!

package limit_pool_client

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	iam_organization "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/organization"
	limit_pool "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/limit_pool"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &iam_organization.Organization{}
	_ = &limit_pool.LimitPool{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type GetLimitPoolRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() GetLimitPoolRequest_FieldPathSelector
	Get(source *GetLimitPoolRequest) []interface{}
	GetSingle(source *GetLimitPoolRequest) (interface{}, bool)
	ClearValue(item *GetLimitPoolRequest)

	// Those methods build corresponding GetLimitPoolRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) GetLimitPoolRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) GetLimitPoolRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) GetLimitPoolRequest_FieldPathArrayItemValue
}

type GetLimitPoolRequest_FieldPathSelector int32

const (
	GetLimitPoolRequest_FieldPathSelectorName      GetLimitPoolRequest_FieldPathSelector = 0
	GetLimitPoolRequest_FieldPathSelectorFieldMask GetLimitPoolRequest_FieldPathSelector = 1
	GetLimitPoolRequest_FieldPathSelectorView      GetLimitPoolRequest_FieldPathSelector = 2
)

func (s GetLimitPoolRequest_FieldPathSelector) String() string {
	switch s {
	case GetLimitPoolRequest_FieldPathSelectorName:
		return "name"
	case GetLimitPoolRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case GetLimitPoolRequest_FieldPathSelectorView:
		return "view"
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", s))
	}
}

func BuildGetLimitPoolRequest_FieldPath(fp gotenobject.RawFieldPath) (GetLimitPoolRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object GetLimitPoolRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &GetLimitPoolRequest_FieldTerminalPath{selector: GetLimitPoolRequest_FieldPathSelectorName}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &GetLimitPoolRequest_FieldTerminalPath{selector: GetLimitPoolRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &GetLimitPoolRequest_FieldTerminalPath{selector: GetLimitPoolRequest_FieldPathSelectorView}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object GetLimitPoolRequest", fp)
}

func ParseGetLimitPoolRequest_FieldPath(rawField string) (GetLimitPoolRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildGetLimitPoolRequest_FieldPath(fp)
}

func MustParseGetLimitPoolRequest_FieldPath(rawField string) GetLimitPoolRequest_FieldPath {
	fp, err := ParseGetLimitPoolRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type GetLimitPoolRequest_FieldTerminalPath struct {
	selector GetLimitPoolRequest_FieldPathSelector
}

var _ GetLimitPoolRequest_FieldPath = (*GetLimitPoolRequest_FieldTerminalPath)(nil)

func (fp *GetLimitPoolRequest_FieldTerminalPath) Selector() GetLimitPoolRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *GetLimitPoolRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *GetLimitPoolRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source GetLimitPoolRequest
func (fp *GetLimitPoolRequest_FieldTerminalPath) Get(source *GetLimitPoolRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case GetLimitPoolRequest_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		case GetLimitPoolRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case GetLimitPoolRequest_FieldPathSelectorView:
			values = append(values, source.View)
		default:
			panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*GetLimitPoolRequest))
}

// GetSingle returns value pointed by specific field of from source GetLimitPoolRequest
func (fp *GetLimitPoolRequest_FieldTerminalPath) GetSingle(source *GetLimitPoolRequest) (interface{}, bool) {
	switch fp.selector {
	case GetLimitPoolRequest_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	case GetLimitPoolRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case GetLimitPoolRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*GetLimitPoolRequest))
}

// GetDefault returns a default value of the field type
func (fp *GetLimitPoolRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case GetLimitPoolRequest_FieldPathSelectorName:
		return (*limit_pool.Reference)(nil)
	case GetLimitPoolRequest_FieldPathSelectorFieldMask:
		return (*limit_pool.LimitPool_FieldMask)(nil)
	case GetLimitPoolRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) ClearValue(item *GetLimitPoolRequest) {
	if item != nil {
		switch fp.selector {
		case GetLimitPoolRequest_FieldPathSelectorName:
			item.Name = nil
		case GetLimitPoolRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case GetLimitPoolRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fp.selector))
		}
	}
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*GetLimitPoolRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *GetLimitPoolRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == GetLimitPoolRequest_FieldPathSelectorName ||
		fp.selector == GetLimitPoolRequest_FieldPathSelectorFieldMask ||
		fp.selector == GetLimitPoolRequest_FieldPathSelectorView
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) WithIValue(value interface{}) GetLimitPoolRequest_FieldPathValue {
	switch fp.selector {
	case GetLimitPoolRequest_FieldPathSelectorName:
		return &GetLimitPoolRequest_FieldTerminalPathValue{GetLimitPoolRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.Reference)}
	case GetLimitPoolRequest_FieldPathSelectorFieldMask:
		return &GetLimitPoolRequest_FieldTerminalPathValue{GetLimitPoolRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool_FieldMask)}
	case GetLimitPoolRequest_FieldPathSelectorView:
		return &GetLimitPoolRequest_FieldTerminalPathValue{GetLimitPoolRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) GetLimitPoolRequest_FieldPathArrayOfValues {
	fpaov := &GetLimitPoolRequest_FieldTerminalPathArrayOfValues{GetLimitPoolRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case GetLimitPoolRequest_FieldPathSelectorName:
		return &GetLimitPoolRequest_FieldTerminalPathArrayOfValues{GetLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.Reference)}
	case GetLimitPoolRequest_FieldPathSelectorFieldMask:
		return &GetLimitPoolRequest_FieldTerminalPathArrayOfValues{GetLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool_FieldMask)}
	case GetLimitPoolRequest_FieldPathSelectorView:
		return &GetLimitPoolRequest_FieldTerminalPathArrayOfValues{GetLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) GetLimitPoolRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *GetLimitPoolRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// GetLimitPoolRequest_FieldPathValue allows storing values for GetLimitPoolRequest fields according to their type
type GetLimitPoolRequest_FieldPathValue interface {
	GetLimitPoolRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **GetLimitPoolRequest)
	CompareWith(*GetLimitPoolRequest) (cmp int, comparable bool)
}

func ParseGetLimitPoolRequest_FieldPathValue(pathStr, valueStr string) (GetLimitPoolRequest_FieldPathValue, error) {
	fp, err := ParseGetLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing GetLimitPoolRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(GetLimitPoolRequest_FieldPathValue), nil
}

func MustParseGetLimitPoolRequest_FieldPathValue(pathStr, valueStr string) GetLimitPoolRequest_FieldPathValue {
	fpv, err := ParseGetLimitPoolRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type GetLimitPoolRequest_FieldTerminalPathValue struct {
	GetLimitPoolRequest_FieldTerminalPath
	value interface{}
}

var _ GetLimitPoolRequest_FieldPathValue = (*GetLimitPoolRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'GetLimitPoolRequest' as interface{}
func (fpv *GetLimitPoolRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *GetLimitPoolRequest_FieldTerminalPathValue) AsNameValue() (*limit_pool.Reference, bool) {
	res, ok := fpv.value.(*limit_pool.Reference)
	return res, ok
}
func (fpv *GetLimitPoolRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpv *GetLimitPoolRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}

// SetTo stores value for selected field for object GetLimitPoolRequest
func (fpv *GetLimitPoolRequest_FieldTerminalPathValue) SetTo(target **GetLimitPoolRequest) {
	if *target == nil {
		*target = new(GetLimitPoolRequest)
	}
	switch fpv.selector {
	case GetLimitPoolRequest_FieldPathSelectorName:
		(*target).Name = fpv.value.(*limit_pool.Reference)
	case GetLimitPoolRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit_pool.LimitPool_FieldMask)
	case GetLimitPoolRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fpv.selector))
	}
}

func (fpv *GetLimitPoolRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*GetLimitPoolRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'GetLimitPoolRequest_FieldTerminalPathValue' with the value under path in 'GetLimitPoolRequest'.
func (fpv *GetLimitPoolRequest_FieldTerminalPathValue) CompareWith(source *GetLimitPoolRequest) (int, bool) {
	switch fpv.selector {
	case GetLimitPoolRequest_FieldPathSelectorName:
		leftValue := fpv.value.(*limit_pool.Reference)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case GetLimitPoolRequest_FieldPathSelectorFieldMask:
		return 0, false
	case GetLimitPoolRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitPoolRequest: %d", fpv.selector))
	}
}

func (fpv *GetLimitPoolRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*GetLimitPoolRequest))
}

// GetLimitPoolRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for GetLimitPoolRequest according to their type
// Present only for array (repeated) types.
type GetLimitPoolRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	GetLimitPoolRequest_FieldPath
	ContainsValue(*GetLimitPoolRequest) bool
}

// ParseGetLimitPoolRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseGetLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr string) (GetLimitPoolRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseGetLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing GetLimitPoolRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(GetLimitPoolRequest_FieldPathArrayItemValue), nil
}

func MustParseGetLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr string) GetLimitPoolRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseGetLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type GetLimitPoolRequest_FieldTerminalPathArrayItemValue struct {
	GetLimitPoolRequest_FieldTerminalPath
	value interface{}
}

var _ GetLimitPoolRequest_FieldPathArrayItemValue = (*GetLimitPoolRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object GetLimitPoolRequest as interface{}
func (fpaiv *GetLimitPoolRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *GetLimitPoolRequest_FieldTerminalPathArrayItemValue) GetSingle(source *GetLimitPoolRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *GetLimitPoolRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*GetLimitPoolRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'GetLimitPoolRequest'
func (fpaiv *GetLimitPoolRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *GetLimitPoolRequest) bool {
	slice := fpaiv.GetLimitPoolRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// GetLimitPoolRequest_FieldPathArrayOfValues allows storing slice of values for GetLimitPoolRequest fields according to their type
type GetLimitPoolRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	GetLimitPoolRequest_FieldPath
}

func ParseGetLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (GetLimitPoolRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseGetLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing GetLimitPoolRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(GetLimitPoolRequest_FieldPathArrayOfValues), nil
}

func MustParseGetLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr string) GetLimitPoolRequest_FieldPathArrayOfValues {
	fpaov, err := ParseGetLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type GetLimitPoolRequest_FieldTerminalPathArrayOfValues struct {
	GetLimitPoolRequest_FieldTerminalPath
	values interface{}
}

var _ GetLimitPoolRequest_FieldPathArrayOfValues = (*GetLimitPoolRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *GetLimitPoolRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case GetLimitPoolRequest_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*limit_pool.Reference) {
			values = append(values, v)
		}
	case GetLimitPoolRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool_FieldMask) {
			values = append(values, v)
		}
	case GetLimitPoolRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *GetLimitPoolRequest_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*limit_pool.Reference, bool) {
	res, ok := fpaov.values.([]*limit_pool.Reference)
	return res, ok
}
func (fpaov *GetLimitPoolRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpaov *GetLimitPoolRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BatchGetLimitPoolsRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() BatchGetLimitPoolsRequest_FieldPathSelector
	Get(source *BatchGetLimitPoolsRequest) []interface{}
	GetSingle(source *BatchGetLimitPoolsRequest) (interface{}, bool)
	ClearValue(item *BatchGetLimitPoolsRequest)

	// Those methods build corresponding BatchGetLimitPoolsRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BatchGetLimitPoolsRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) BatchGetLimitPoolsRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BatchGetLimitPoolsRequest_FieldPathArrayItemValue
}

type BatchGetLimitPoolsRequest_FieldPathSelector int32

const (
	BatchGetLimitPoolsRequest_FieldPathSelectorNames     BatchGetLimitPoolsRequest_FieldPathSelector = 0
	BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask BatchGetLimitPoolsRequest_FieldPathSelector = 1
	BatchGetLimitPoolsRequest_FieldPathSelectorView      BatchGetLimitPoolsRequest_FieldPathSelector = 2
)

func (s BatchGetLimitPoolsRequest_FieldPathSelector) String() string {
	switch s {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		return "names"
	case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case BatchGetLimitPoolsRequest_FieldPathSelectorView:
		return "view"
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", s))
	}
}

func BuildBatchGetLimitPoolsRequest_FieldPath(fp gotenobject.RawFieldPath) (BatchGetLimitPoolsRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object BatchGetLimitPoolsRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "names":
			return &BatchGetLimitPoolsRequest_FieldTerminalPath{selector: BatchGetLimitPoolsRequest_FieldPathSelectorNames}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &BatchGetLimitPoolsRequest_FieldTerminalPath{selector: BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &BatchGetLimitPoolsRequest_FieldTerminalPath{selector: BatchGetLimitPoolsRequest_FieldPathSelectorView}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object BatchGetLimitPoolsRequest", fp)
}

func ParseBatchGetLimitPoolsRequest_FieldPath(rawField string) (BatchGetLimitPoolsRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBatchGetLimitPoolsRequest_FieldPath(fp)
}

func MustParseBatchGetLimitPoolsRequest_FieldPath(rawField string) BatchGetLimitPoolsRequest_FieldPath {
	fp, err := ParseBatchGetLimitPoolsRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BatchGetLimitPoolsRequest_FieldTerminalPath struct {
	selector BatchGetLimitPoolsRequest_FieldPathSelector
}

var _ BatchGetLimitPoolsRequest_FieldPath = (*BatchGetLimitPoolsRequest_FieldTerminalPath)(nil)

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) Selector() BatchGetLimitPoolsRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source BatchGetLimitPoolsRequest
func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) Get(source *BatchGetLimitPoolsRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
			for _, value := range source.GetNames() {
				values = append(values, value)
			}
		case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case BatchGetLimitPoolsRequest_FieldPathSelectorView:
			values = append(values, source.View)
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*BatchGetLimitPoolsRequest))
}

// GetSingle returns value pointed by specific field of from source BatchGetLimitPoolsRequest
func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) GetSingle(source *BatchGetLimitPoolsRequest) (interface{}, bool) {
	switch fp.selector {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		res := source.GetNames()
		return res, res != nil
	case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case BatchGetLimitPoolsRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*BatchGetLimitPoolsRequest))
}

// GetDefault returns a default value of the field type
func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		return ([]*limit_pool.Reference)(nil)
	case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
		return (*limit_pool.LimitPool_FieldMask)(nil)
	case BatchGetLimitPoolsRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) ClearValue(item *BatchGetLimitPoolsRequest) {
	if item != nil {
		switch fp.selector {
		case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
			item.Names = nil
		case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case BatchGetLimitPoolsRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fp.selector))
		}
	}
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*BatchGetLimitPoolsRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == BatchGetLimitPoolsRequest_FieldPathSelectorNames ||
		fp.selector == BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask ||
		fp.selector == BatchGetLimitPoolsRequest_FieldPathSelectorView
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) WithIValue(value interface{}) BatchGetLimitPoolsRequest_FieldPathValue {
	switch fp.selector {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		return &BatchGetLimitPoolsRequest_FieldTerminalPathValue{BatchGetLimitPoolsRequest_FieldTerminalPath: *fp, value: value.([]*limit_pool.Reference)}
	case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
		return &BatchGetLimitPoolsRequest_FieldTerminalPathValue{BatchGetLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool_FieldMask)}
	case BatchGetLimitPoolsRequest_FieldPathSelectorView:
		return &BatchGetLimitPoolsRequest_FieldTerminalPathValue{BatchGetLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) BatchGetLimitPoolsRequest_FieldPathArrayOfValues {
	fpaov := &BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues{BatchGetLimitPoolsRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		return &BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues{BatchGetLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([][]*limit_pool.Reference)}
	case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
		return &BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues{BatchGetLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool_FieldMask)}
	case BatchGetLimitPoolsRequest_FieldPathSelectorView:
		return &BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues{BatchGetLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) BatchGetLimitPoolsRequest_FieldPathArrayItemValue {
	switch fp.selector {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		return &BatchGetLimitPoolsRequest_FieldTerminalPathArrayItemValue{BatchGetLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *BatchGetLimitPoolsRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// BatchGetLimitPoolsRequest_FieldPathValue allows storing values for BatchGetLimitPoolsRequest fields according to their type
type BatchGetLimitPoolsRequest_FieldPathValue interface {
	BatchGetLimitPoolsRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **BatchGetLimitPoolsRequest)
	CompareWith(*BatchGetLimitPoolsRequest) (cmp int, comparable bool)
}

func ParseBatchGetLimitPoolsRequest_FieldPathValue(pathStr, valueStr string) (BatchGetLimitPoolsRequest_FieldPathValue, error) {
	fp, err := ParseBatchGetLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitPoolsRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(BatchGetLimitPoolsRequest_FieldPathValue), nil
}

func MustParseBatchGetLimitPoolsRequest_FieldPathValue(pathStr, valueStr string) BatchGetLimitPoolsRequest_FieldPathValue {
	fpv, err := ParseBatchGetLimitPoolsRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BatchGetLimitPoolsRequest_FieldTerminalPathValue struct {
	BatchGetLimitPoolsRequest_FieldTerminalPath
	value interface{}
}

var _ BatchGetLimitPoolsRequest_FieldPathValue = (*BatchGetLimitPoolsRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'BatchGetLimitPoolsRequest' as interface{}
func (fpv *BatchGetLimitPoolsRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BatchGetLimitPoolsRequest_FieldTerminalPathValue) AsNamesValue() ([]*limit_pool.Reference, bool) {
	res, ok := fpv.value.([]*limit_pool.Reference)
	return res, ok
}
func (fpv *BatchGetLimitPoolsRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpv *BatchGetLimitPoolsRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}

// SetTo stores value for selected field for object BatchGetLimitPoolsRequest
func (fpv *BatchGetLimitPoolsRequest_FieldTerminalPathValue) SetTo(target **BatchGetLimitPoolsRequest) {
	if *target == nil {
		*target = new(BatchGetLimitPoolsRequest)
	}
	switch fpv.selector {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		(*target).Names = fpv.value.([]*limit_pool.Reference)
	case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit_pool.LimitPool_FieldMask)
	case BatchGetLimitPoolsRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fpv.selector))
	}
}

func (fpv *BatchGetLimitPoolsRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*BatchGetLimitPoolsRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BatchGetLimitPoolsRequest_FieldTerminalPathValue' with the value under path in 'BatchGetLimitPoolsRequest'.
func (fpv *BatchGetLimitPoolsRequest_FieldTerminalPathValue) CompareWith(source *BatchGetLimitPoolsRequest) (int, bool) {
	switch fpv.selector {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		return 0, false
	case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
		return 0, false
	case BatchGetLimitPoolsRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsRequest: %d", fpv.selector))
	}
}

func (fpv *BatchGetLimitPoolsRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*BatchGetLimitPoolsRequest))
}

// BatchGetLimitPoolsRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for BatchGetLimitPoolsRequest according to their type
// Present only for array (repeated) types.
type BatchGetLimitPoolsRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BatchGetLimitPoolsRequest_FieldPath
	ContainsValue(*BatchGetLimitPoolsRequest) bool
}

// ParseBatchGetLimitPoolsRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBatchGetLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr string) (BatchGetLimitPoolsRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseBatchGetLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitPoolsRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BatchGetLimitPoolsRequest_FieldPathArrayItemValue), nil
}

func MustParseBatchGetLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr string) BatchGetLimitPoolsRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseBatchGetLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BatchGetLimitPoolsRequest_FieldTerminalPathArrayItemValue struct {
	BatchGetLimitPoolsRequest_FieldTerminalPath
	value interface{}
}

var _ BatchGetLimitPoolsRequest_FieldPathArrayItemValue = (*BatchGetLimitPoolsRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object BatchGetLimitPoolsRequest as interface{}
func (fpaiv *BatchGetLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *BatchGetLimitPoolsRequest_FieldTerminalPathArrayItemValue) AsNamesItemValue() (*limit_pool.Reference, bool) {
	res, ok := fpaiv.value.(*limit_pool.Reference)
	return res, ok
}

func (fpaiv *BatchGetLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetSingle(source *BatchGetLimitPoolsRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BatchGetLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*BatchGetLimitPoolsRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'BatchGetLimitPoolsRequest'
func (fpaiv *BatchGetLimitPoolsRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *BatchGetLimitPoolsRequest) bool {
	slice := fpaiv.BatchGetLimitPoolsRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// BatchGetLimitPoolsRequest_FieldPathArrayOfValues allows storing slice of values for BatchGetLimitPoolsRequest fields according to their type
type BatchGetLimitPoolsRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BatchGetLimitPoolsRequest_FieldPath
}

func ParseBatchGetLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (BatchGetLimitPoolsRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseBatchGetLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitPoolsRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BatchGetLimitPoolsRequest_FieldPathArrayOfValues), nil
}

func MustParseBatchGetLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) BatchGetLimitPoolsRequest_FieldPathArrayOfValues {
	fpaov, err := ParseBatchGetLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues struct {
	BatchGetLimitPoolsRequest_FieldTerminalPath
	values interface{}
}

var _ BatchGetLimitPoolsRequest_FieldPathArrayOfValues = (*BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
		for _, v := range fpaov.values.([][]*limit_pool.Reference) {
			values = append(values, v)
		}
	case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool_FieldMask) {
			values = append(values, v)
		}
	case BatchGetLimitPoolsRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsNamesArrayOfValues() ([][]*limit_pool.Reference, bool) {
	res, ok := fpaov.values.([][]*limit_pool.Reference)
	return res, ok
}
func (fpaov *BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpaov *BatchGetLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BatchGetLimitPoolsResponse_FieldPath interface {
	gotenobject.FieldPath
	Selector() BatchGetLimitPoolsResponse_FieldPathSelector
	Get(source *BatchGetLimitPoolsResponse) []interface{}
	GetSingle(source *BatchGetLimitPoolsResponse) (interface{}, bool)
	ClearValue(item *BatchGetLimitPoolsResponse)

	// Those methods build corresponding BatchGetLimitPoolsResponse_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BatchGetLimitPoolsResponse_FieldPathValue
	WithIArrayOfValues(values interface{}) BatchGetLimitPoolsResponse_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BatchGetLimitPoolsResponse_FieldPathArrayItemValue
}

type BatchGetLimitPoolsResponse_FieldPathSelector int32

const (
	BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools BatchGetLimitPoolsResponse_FieldPathSelector = 0
	BatchGetLimitPoolsResponse_FieldPathSelectorMissing    BatchGetLimitPoolsResponse_FieldPathSelector = 1
)

func (s BatchGetLimitPoolsResponse_FieldPathSelector) String() string {
	switch s {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		return "limit_pools"
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		return "missing"
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", s))
	}
}

func BuildBatchGetLimitPoolsResponse_FieldPath(fp gotenobject.RawFieldPath) (BatchGetLimitPoolsResponse_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object BatchGetLimitPoolsResponse")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limit_pools", "limitPools", "limit-pools":
			return &BatchGetLimitPoolsResponse_FieldTerminalPath{selector: BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools}, nil
		case "missing":
			return &BatchGetLimitPoolsResponse_FieldTerminalPath{selector: BatchGetLimitPoolsResponse_FieldPathSelectorMissing}, nil
		}
	} else {
		switch fp[0] {
		case "limit_pools", "limitPools", "limit-pools":
			if subpath, err := limit_pool.BuildLimitPool_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &BatchGetLimitPoolsResponse_FieldSubPath{selector: BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object BatchGetLimitPoolsResponse", fp)
}

func ParseBatchGetLimitPoolsResponse_FieldPath(rawField string) (BatchGetLimitPoolsResponse_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBatchGetLimitPoolsResponse_FieldPath(fp)
}

func MustParseBatchGetLimitPoolsResponse_FieldPath(rawField string) BatchGetLimitPoolsResponse_FieldPath {
	fp, err := ParseBatchGetLimitPoolsResponse_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BatchGetLimitPoolsResponse_FieldTerminalPath struct {
	selector BatchGetLimitPoolsResponse_FieldPathSelector
}

var _ BatchGetLimitPoolsResponse_FieldPath = (*BatchGetLimitPoolsResponse_FieldTerminalPath)(nil)

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) Selector() BatchGetLimitPoolsResponse_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source BatchGetLimitPoolsResponse
func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) Get(source *BatchGetLimitPoolsResponse) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
			for _, value := range source.GetLimitPools() {
				values = append(values, value)
			}
		case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
			for _, value := range source.GetMissing() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fp.selector))
		}
	}
	return
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*BatchGetLimitPoolsResponse))
}

// GetSingle returns value pointed by specific field of from source BatchGetLimitPoolsResponse
func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) GetSingle(source *BatchGetLimitPoolsResponse) (interface{}, bool) {
	switch fp.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		res := source.GetLimitPools()
		return res, res != nil
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		res := source.GetMissing()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*BatchGetLimitPoolsResponse))
}

// GetDefault returns a default value of the field type
func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		return ([]*limit_pool.LimitPool)(nil)
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		return ([]*limit_pool.Reference)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) ClearValue(item *BatchGetLimitPoolsResponse) {
	if item != nil {
		switch fp.selector {
		case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
			item.LimitPools = nil
		case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
			item.Missing = nil
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fp.selector))
		}
	}
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*BatchGetLimitPoolsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == BatchGetLimitPoolsResponse_FieldPathSelectorMissing
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) WithIValue(value interface{}) BatchGetLimitPoolsResponse_FieldPathValue {
	switch fp.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		return &BatchGetLimitPoolsResponse_FieldTerminalPathValue{BatchGetLimitPoolsResponse_FieldTerminalPath: *fp, value: value.([]*limit_pool.LimitPool)}
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		return &BatchGetLimitPoolsResponse_FieldTerminalPathValue{BatchGetLimitPoolsResponse_FieldTerminalPath: *fp, value: value.([]*limit_pool.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) WithIArrayOfValues(values interface{}) BatchGetLimitPoolsResponse_FieldPathArrayOfValues {
	fpaov := &BatchGetLimitPoolsResponse_FieldTerminalPathArrayOfValues{BatchGetLimitPoolsResponse_FieldTerminalPath: *fp}
	switch fp.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		return &BatchGetLimitPoolsResponse_FieldTerminalPathArrayOfValues{BatchGetLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([][]*limit_pool.LimitPool)}
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		return &BatchGetLimitPoolsResponse_FieldTerminalPathArrayOfValues{BatchGetLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([][]*limit_pool.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fp.selector))
	}
	return fpaov
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) WithIArrayItemValue(value interface{}) BatchGetLimitPoolsResponse_FieldPathArrayItemValue {
	switch fp.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		return &BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue{BatchGetLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool)}
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		return &BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue{BatchGetLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(*limit_pool.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *BatchGetLimitPoolsResponse_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type BatchGetLimitPoolsResponse_FieldSubPath struct {
	selector BatchGetLimitPoolsResponse_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ BatchGetLimitPoolsResponse_FieldPath = (*BatchGetLimitPoolsResponse_FieldSubPath)(nil)

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) Selector() BatchGetLimitPoolsResponse_FieldPathSelector {
	return fps.selector
}
func (fps *BatchGetLimitPoolsResponse_FieldSubPath) AsLimitPoolsSubPath() (limit_pool.LimitPool_FieldPath, bool) {
	res, ok := fps.subPath.(limit_pool.LimitPool_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *BatchGetLimitPoolsResponse_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *BatchGetLimitPoolsResponse_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source BatchGetLimitPoolsResponse
func (fps *BatchGetLimitPoolsResponse_FieldSubPath) Get(source *BatchGetLimitPoolsResponse) (values []interface{}) {
	switch fps.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		for _, item := range source.GetLimitPools() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fps.selector))
	}
	return
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*BatchGetLimitPoolsResponse))
}

// GetSingle returns value of selected field from source BatchGetLimitPoolsResponse
func (fps *BatchGetLimitPoolsResponse_FieldSubPath) GetSingle(source *BatchGetLimitPoolsResponse) (interface{}, bool) {
	switch fps.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		if len(source.GetLimitPools()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetLimitPools()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fps.selector))
	}
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*BatchGetLimitPoolsResponse))
}

// GetDefault returns a default value of the field type
func (fps *BatchGetLimitPoolsResponse_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) ClearValue(item *BatchGetLimitPoolsResponse) {
	if item != nil {
		switch fps.selector {
		case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
			for _, subItem := range item.LimitPools {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fps.selector))
		}
	}
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*BatchGetLimitPoolsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fps *BatchGetLimitPoolsResponse_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&BatchGetLimitPoolsResponse_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) WithIValue(value interface{}) BatchGetLimitPoolsResponse_FieldPathValue {
	return &BatchGetLimitPoolsResponse_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) WithIArrayOfValues(values interface{}) BatchGetLimitPoolsResponse_FieldPathArrayOfValues {
	return &BatchGetLimitPoolsResponse_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) WithIArrayItemValue(value interface{}) BatchGetLimitPoolsResponse_FieldPathArrayItemValue {
	return &BatchGetLimitPoolsResponse_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *BatchGetLimitPoolsResponse_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// BatchGetLimitPoolsResponse_FieldPathValue allows storing values for BatchGetLimitPoolsResponse fields according to their type
type BatchGetLimitPoolsResponse_FieldPathValue interface {
	BatchGetLimitPoolsResponse_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **BatchGetLimitPoolsResponse)
	CompareWith(*BatchGetLimitPoolsResponse) (cmp int, comparable bool)
}

func ParseBatchGetLimitPoolsResponse_FieldPathValue(pathStr, valueStr string) (BatchGetLimitPoolsResponse_FieldPathValue, error) {
	fp, err := ParseBatchGetLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitPoolsResponse field path value from %s: %v", valueStr, err)
	}
	return fpv.(BatchGetLimitPoolsResponse_FieldPathValue), nil
}

func MustParseBatchGetLimitPoolsResponse_FieldPathValue(pathStr, valueStr string) BatchGetLimitPoolsResponse_FieldPathValue {
	fpv, err := ParseBatchGetLimitPoolsResponse_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BatchGetLimitPoolsResponse_FieldTerminalPathValue struct {
	BatchGetLimitPoolsResponse_FieldTerminalPath
	value interface{}
}

var _ BatchGetLimitPoolsResponse_FieldPathValue = (*BatchGetLimitPoolsResponse_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'BatchGetLimitPoolsResponse' as interface{}
func (fpv *BatchGetLimitPoolsResponse_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BatchGetLimitPoolsResponse_FieldTerminalPathValue) AsLimitPoolsValue() ([]*limit_pool.LimitPool, bool) {
	res, ok := fpv.value.([]*limit_pool.LimitPool)
	return res, ok
}
func (fpv *BatchGetLimitPoolsResponse_FieldTerminalPathValue) AsMissingValue() ([]*limit_pool.Reference, bool) {
	res, ok := fpv.value.([]*limit_pool.Reference)
	return res, ok
}

// SetTo stores value for selected field for object BatchGetLimitPoolsResponse
func (fpv *BatchGetLimitPoolsResponse_FieldTerminalPathValue) SetTo(target **BatchGetLimitPoolsResponse) {
	if *target == nil {
		*target = new(BatchGetLimitPoolsResponse)
	}
	switch fpv.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		(*target).LimitPools = fpv.value.([]*limit_pool.LimitPool)
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		(*target).Missing = fpv.value.([]*limit_pool.Reference)
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fpv.selector))
	}
}

func (fpv *BatchGetLimitPoolsResponse_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*BatchGetLimitPoolsResponse)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BatchGetLimitPoolsResponse_FieldTerminalPathValue' with the value under path in 'BatchGetLimitPoolsResponse'.
func (fpv *BatchGetLimitPoolsResponse_FieldTerminalPathValue) CompareWith(source *BatchGetLimitPoolsResponse) (int, bool) {
	switch fpv.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		return 0, false
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fpv.selector))
	}
}

func (fpv *BatchGetLimitPoolsResponse_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*BatchGetLimitPoolsResponse))
}

type BatchGetLimitPoolsResponse_FieldSubPathValue struct {
	BatchGetLimitPoolsResponse_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ BatchGetLimitPoolsResponse_FieldPathValue = (*BatchGetLimitPoolsResponse_FieldSubPathValue)(nil)

func (fpvs *BatchGetLimitPoolsResponse_FieldSubPathValue) AsLimitPoolsPathValue() (limit_pool.LimitPool_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(limit_pool.LimitPool_FieldPathValue)
	return res, ok
}

func (fpvs *BatchGetLimitPoolsResponse_FieldSubPathValue) SetTo(target **BatchGetLimitPoolsResponse) {
	if *target == nil {
		*target = new(BatchGetLimitPoolsResponse)
	}
	switch fpvs.Selector() {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *BatchGetLimitPoolsResponse_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*BatchGetLimitPoolsResponse)
	fpvs.SetTo(&typedObject)
}

func (fpvs *BatchGetLimitPoolsResponse_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *BatchGetLimitPoolsResponse_FieldSubPathValue) CompareWith(source *BatchGetLimitPoolsResponse) (int, bool) {
	switch fpvs.Selector() {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *BatchGetLimitPoolsResponse_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*BatchGetLimitPoolsResponse))
}

// BatchGetLimitPoolsResponse_FieldPathArrayItemValue allows storing single item in Path-specific values for BatchGetLimitPoolsResponse according to their type
// Present only for array (repeated) types.
type BatchGetLimitPoolsResponse_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BatchGetLimitPoolsResponse_FieldPath
	ContainsValue(*BatchGetLimitPoolsResponse) bool
}

// ParseBatchGetLimitPoolsResponse_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBatchGetLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr string) (BatchGetLimitPoolsResponse_FieldPathArrayItemValue, error) {
	fp, err := ParseBatchGetLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitPoolsResponse field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BatchGetLimitPoolsResponse_FieldPathArrayItemValue), nil
}

func MustParseBatchGetLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr string) BatchGetLimitPoolsResponse_FieldPathArrayItemValue {
	fpaiv, err := ParseBatchGetLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue struct {
	BatchGetLimitPoolsResponse_FieldTerminalPath
	value interface{}
}

var _ BatchGetLimitPoolsResponse_FieldPathArrayItemValue = (*BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object BatchGetLimitPoolsResponse as interface{}
func (fpaiv *BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue) AsLimitPoolsItemValue() (*limit_pool.LimitPool, bool) {
	res, ok := fpaiv.value.(*limit_pool.LimitPool)
	return res, ok
}
func (fpaiv *BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue) AsMissingItemValue() (*limit_pool.Reference, bool) {
	res, ok := fpaiv.value.(*limit_pool.Reference)
	return res, ok
}

func (fpaiv *BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetSingle(source *BatchGetLimitPoolsResponse) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*BatchGetLimitPoolsResponse))
}

// Contains returns a boolean indicating if value that is being held is present in given 'BatchGetLimitPoolsResponse'
func (fpaiv *BatchGetLimitPoolsResponse_FieldTerminalPathArrayItemValue) ContainsValue(source *BatchGetLimitPoolsResponse) bool {
	slice := fpaiv.BatchGetLimitPoolsResponse_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type BatchGetLimitPoolsResponse_FieldSubPathArrayItemValue struct {
	BatchGetLimitPoolsResponse_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *BatchGetLimitPoolsResponse_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *BatchGetLimitPoolsResponse_FieldSubPathArrayItemValue) AsLimitPoolsPathItemValue() (limit_pool.LimitPool_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(limit_pool.LimitPool_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'BatchGetLimitPoolsResponse'
func (fpaivs *BatchGetLimitPoolsResponse_FieldSubPathArrayItemValue) ContainsValue(source *BatchGetLimitPoolsResponse) bool {
	switch fpaivs.Selector() {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitPoolsResponse: %d", fpaivs.Selector()))
	}
}

// BatchGetLimitPoolsResponse_FieldPathArrayOfValues allows storing slice of values for BatchGetLimitPoolsResponse fields according to their type
type BatchGetLimitPoolsResponse_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BatchGetLimitPoolsResponse_FieldPath
}

func ParseBatchGetLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) (BatchGetLimitPoolsResponse_FieldPathArrayOfValues, error) {
	fp, err := ParseBatchGetLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitPoolsResponse field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BatchGetLimitPoolsResponse_FieldPathArrayOfValues), nil
}

func MustParseBatchGetLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) BatchGetLimitPoolsResponse_FieldPathArrayOfValues {
	fpaov, err := ParseBatchGetLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BatchGetLimitPoolsResponse_FieldTerminalPathArrayOfValues struct {
	BatchGetLimitPoolsResponse_FieldTerminalPath
	values interface{}
}

var _ BatchGetLimitPoolsResponse_FieldPathArrayOfValues = (*BatchGetLimitPoolsResponse_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BatchGetLimitPoolsResponse_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
		for _, v := range fpaov.values.([][]*limit_pool.LimitPool) {
			values = append(values, v)
		}
	case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
		for _, v := range fpaov.values.([][]*limit_pool.Reference) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BatchGetLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsLimitPoolsArrayOfValues() ([][]*limit_pool.LimitPool, bool) {
	res, ok := fpaov.values.([][]*limit_pool.LimitPool)
	return res, ok
}
func (fpaov *BatchGetLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsMissingArrayOfValues() ([][]*limit_pool.Reference, bool) {
	res, ok := fpaov.values.([][]*limit_pool.Reference)
	return res, ok
}

type BatchGetLimitPoolsResponse_FieldSubPathArrayOfValues struct {
	BatchGetLimitPoolsResponse_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ BatchGetLimitPoolsResponse_FieldPathArrayOfValues = (*BatchGetLimitPoolsResponse_FieldSubPathArrayOfValues)(nil)

func (fpsaov *BatchGetLimitPoolsResponse_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *BatchGetLimitPoolsResponse_FieldSubPathArrayOfValues) AsLimitPoolsPathArrayOfValues() (limit_pool.LimitPool_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(limit_pool.LimitPool_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ListLimitPoolsRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() ListLimitPoolsRequest_FieldPathSelector
	Get(source *ListLimitPoolsRequest) []interface{}
	GetSingle(source *ListLimitPoolsRequest) (interface{}, bool)
	ClearValue(item *ListLimitPoolsRequest)

	// Those methods build corresponding ListLimitPoolsRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ListLimitPoolsRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) ListLimitPoolsRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ListLimitPoolsRequest_FieldPathArrayItemValue
}

type ListLimitPoolsRequest_FieldPathSelector int32

const (
	ListLimitPoolsRequest_FieldPathSelectorParent            ListLimitPoolsRequest_FieldPathSelector = 0
	ListLimitPoolsRequest_FieldPathSelectorPageSize          ListLimitPoolsRequest_FieldPathSelector = 1
	ListLimitPoolsRequest_FieldPathSelectorPageToken         ListLimitPoolsRequest_FieldPathSelector = 2
	ListLimitPoolsRequest_FieldPathSelectorOrderBy           ListLimitPoolsRequest_FieldPathSelector = 3
	ListLimitPoolsRequest_FieldPathSelectorFilter            ListLimitPoolsRequest_FieldPathSelector = 4
	ListLimitPoolsRequest_FieldPathSelectorFieldMask         ListLimitPoolsRequest_FieldPathSelector = 5
	ListLimitPoolsRequest_FieldPathSelectorView              ListLimitPoolsRequest_FieldPathSelector = 6
	ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo ListLimitPoolsRequest_FieldPathSelector = 7
)

func (s ListLimitPoolsRequest_FieldPathSelector) String() string {
	switch s {
	case ListLimitPoolsRequest_FieldPathSelectorParent:
		return "parent"
	case ListLimitPoolsRequest_FieldPathSelectorPageSize:
		return "page_size"
	case ListLimitPoolsRequest_FieldPathSelectorPageToken:
		return "page_token"
	case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
		return "order_by"
	case ListLimitPoolsRequest_FieldPathSelectorFilter:
		return "filter"
	case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case ListLimitPoolsRequest_FieldPathSelectorView:
		return "view"
	case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
		return "include_paging_info"
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", s))
	}
}

func BuildListLimitPoolsRequest_FieldPath(fp gotenobject.RawFieldPath) (ListLimitPoolsRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ListLimitPoolsRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "parent":
			return &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorParent}, nil
		case "page_size", "pageSize", "page-size":
			return &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorPageSize}, nil
		case "page_token", "pageToken", "page-token":
			return &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorPageToken}, nil
		case "order_by", "orderBy", "order-by":
			return &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorOrderBy}, nil
		case "filter":
			return &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorFilter}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorView}, nil
		case "include_paging_info", "includePagingInfo", "include-paging-info":
			return &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ListLimitPoolsRequest", fp)
}

func ParseListLimitPoolsRequest_FieldPath(rawField string) (ListLimitPoolsRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildListLimitPoolsRequest_FieldPath(fp)
}

func MustParseListLimitPoolsRequest_FieldPath(rawField string) ListLimitPoolsRequest_FieldPath {
	fp, err := ParseListLimitPoolsRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ListLimitPoolsRequest_FieldTerminalPath struct {
	selector ListLimitPoolsRequest_FieldPathSelector
}

var _ ListLimitPoolsRequest_FieldPath = (*ListLimitPoolsRequest_FieldTerminalPath)(nil)

func (fp *ListLimitPoolsRequest_FieldTerminalPath) Selector() ListLimitPoolsRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ListLimitPoolsRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ListLimitPoolsRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ListLimitPoolsRequest
func (fp *ListLimitPoolsRequest_FieldTerminalPath) Get(source *ListLimitPoolsRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ListLimitPoolsRequest_FieldPathSelectorParent:
			if source.Parent != nil {
				values = append(values, source.Parent)
			}
		case ListLimitPoolsRequest_FieldPathSelectorPageSize:
			values = append(values, source.PageSize)
		case ListLimitPoolsRequest_FieldPathSelectorPageToken:
			if source.PageToken != nil {
				values = append(values, source.PageToken)
			}
		case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
			if source.OrderBy != nil {
				values = append(values, source.OrderBy)
			}
		case ListLimitPoolsRequest_FieldPathSelectorFilter:
			if source.Filter != nil {
				values = append(values, source.Filter)
			}
		case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case ListLimitPoolsRequest_FieldPathSelectorView:
			values = append(values, source.View)
		case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
			values = append(values, source.IncludePagingInfo)
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ListLimitPoolsRequest))
}

// GetSingle returns value pointed by specific field of from source ListLimitPoolsRequest
func (fp *ListLimitPoolsRequest_FieldTerminalPath) GetSingle(source *ListLimitPoolsRequest) (interface{}, bool) {
	switch fp.selector {
	case ListLimitPoolsRequest_FieldPathSelectorParent:
		res := source.GetParent()
		return res, res != nil
	case ListLimitPoolsRequest_FieldPathSelectorPageSize:
		return source.GetPageSize(), source != nil
	case ListLimitPoolsRequest_FieldPathSelectorPageToken:
		res := source.GetPageToken()
		return res, res != nil
	case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
		res := source.GetOrderBy()
		return res, res != nil
	case ListLimitPoolsRequest_FieldPathSelectorFilter:
		res := source.GetFilter()
		return res, res != nil
	case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case ListLimitPoolsRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
		return source.GetIncludePagingInfo(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ListLimitPoolsRequest))
}

// GetDefault returns a default value of the field type
func (fp *ListLimitPoolsRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ListLimitPoolsRequest_FieldPathSelectorParent:
		return (*limit_pool.ParentName)(nil)
	case ListLimitPoolsRequest_FieldPathSelectorPageSize:
		return int32(0)
	case ListLimitPoolsRequest_FieldPathSelectorPageToken:
		return (*limit_pool.PagerCursor)(nil)
	case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
		return (*limit_pool.OrderBy)(nil)
	case ListLimitPoolsRequest_FieldPathSelectorFilter:
		return (*limit_pool.Filter)(nil)
	case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
		return (*limit_pool.LimitPool_FieldMask)(nil)
	case ListLimitPoolsRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) ClearValue(item *ListLimitPoolsRequest) {
	if item != nil {
		switch fp.selector {
		case ListLimitPoolsRequest_FieldPathSelectorParent:
			item.Parent = nil
		case ListLimitPoolsRequest_FieldPathSelectorPageSize:
			item.PageSize = int32(0)
		case ListLimitPoolsRequest_FieldPathSelectorPageToken:
			item.PageToken = nil
		case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
			item.OrderBy = nil
		case ListLimitPoolsRequest_FieldPathSelectorFilter:
			item.Filter = nil
		case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case ListLimitPoolsRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
			item.IncludePagingInfo = false
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fp.selector))
		}
	}
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ListLimitPoolsRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *ListLimitPoolsRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ListLimitPoolsRequest_FieldPathSelectorParent ||
		fp.selector == ListLimitPoolsRequest_FieldPathSelectorPageSize ||
		fp.selector == ListLimitPoolsRequest_FieldPathSelectorPageToken ||
		fp.selector == ListLimitPoolsRequest_FieldPathSelectorOrderBy ||
		fp.selector == ListLimitPoolsRequest_FieldPathSelectorFilter ||
		fp.selector == ListLimitPoolsRequest_FieldPathSelectorFieldMask ||
		fp.selector == ListLimitPoolsRequest_FieldPathSelectorView ||
		fp.selector == ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) WithIValue(value interface{}) ListLimitPoolsRequest_FieldPathValue {
	switch fp.selector {
	case ListLimitPoolsRequest_FieldPathSelectorParent:
		return &ListLimitPoolsRequest_FieldTerminalPathValue{ListLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.ParentName)}
	case ListLimitPoolsRequest_FieldPathSelectorPageSize:
		return &ListLimitPoolsRequest_FieldTerminalPathValue{ListLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(int32)}
	case ListLimitPoolsRequest_FieldPathSelectorPageToken:
		return &ListLimitPoolsRequest_FieldTerminalPathValue{ListLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.PagerCursor)}
	case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
		return &ListLimitPoolsRequest_FieldTerminalPathValue{ListLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.OrderBy)}
	case ListLimitPoolsRequest_FieldPathSelectorFilter:
		return &ListLimitPoolsRequest_FieldTerminalPathValue{ListLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.Filter)}
	case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
		return &ListLimitPoolsRequest_FieldTerminalPathValue{ListLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool_FieldMask)}
	case ListLimitPoolsRequest_FieldPathSelectorView:
		return &ListLimitPoolsRequest_FieldTerminalPathValue{ListLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
		return &ListLimitPoolsRequest_FieldTerminalPathValue{ListLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) ListLimitPoolsRequest_FieldPathArrayOfValues {
	fpaov := &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case ListLimitPoolsRequest_FieldPathSelectorParent:
		return &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.ParentName)}
	case ListLimitPoolsRequest_FieldPathSelectorPageSize:
		return &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]int32)}
	case ListLimitPoolsRequest_FieldPathSelectorPageToken:
		return &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.PagerCursor)}
	case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
		return &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.OrderBy)}
	case ListLimitPoolsRequest_FieldPathSelectorFilter:
		return &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.Filter)}
	case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
		return &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool_FieldMask)}
	case ListLimitPoolsRequest_FieldPathSelectorView:
		return &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
		return &ListLimitPoolsRequest_FieldTerminalPathArrayOfValues{ListLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) ListLimitPoolsRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *ListLimitPoolsRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ListLimitPoolsRequest_FieldPathValue allows storing values for ListLimitPoolsRequest fields according to their type
type ListLimitPoolsRequest_FieldPathValue interface {
	ListLimitPoolsRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ListLimitPoolsRequest)
	CompareWith(*ListLimitPoolsRequest) (cmp int, comparable bool)
}

func ParseListLimitPoolsRequest_FieldPathValue(pathStr, valueStr string) (ListLimitPoolsRequest_FieldPathValue, error) {
	fp, err := ParseListLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitPoolsRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(ListLimitPoolsRequest_FieldPathValue), nil
}

func MustParseListLimitPoolsRequest_FieldPathValue(pathStr, valueStr string) ListLimitPoolsRequest_FieldPathValue {
	fpv, err := ParseListLimitPoolsRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ListLimitPoolsRequest_FieldTerminalPathValue struct {
	ListLimitPoolsRequest_FieldTerminalPath
	value interface{}
}

var _ ListLimitPoolsRequest_FieldPathValue = (*ListLimitPoolsRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ListLimitPoolsRequest' as interface{}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) AsParentValue() (*limit_pool.ParentName, bool) {
	res, ok := fpv.value.(*limit_pool.ParentName)
	return res, ok
}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) AsPageSizeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) AsPageTokenValue() (*limit_pool.PagerCursor, bool) {
	res, ok := fpv.value.(*limit_pool.PagerCursor)
	return res, ok
}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) AsOrderByValue() (*limit_pool.OrderBy, bool) {
	res, ok := fpv.value.(*limit_pool.OrderBy)
	return res, ok
}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) AsFilterValue() (*limit_pool.Filter, bool) {
	res, ok := fpv.value.(*limit_pool.Filter)
	return res, ok
}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) AsIncludePagingInfoValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object ListLimitPoolsRequest
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) SetTo(target **ListLimitPoolsRequest) {
	if *target == nil {
		*target = new(ListLimitPoolsRequest)
	}
	switch fpv.selector {
	case ListLimitPoolsRequest_FieldPathSelectorParent:
		(*target).Parent = fpv.value.(*limit_pool.ParentName)
	case ListLimitPoolsRequest_FieldPathSelectorPageSize:
		(*target).PageSize = fpv.value.(int32)
	case ListLimitPoolsRequest_FieldPathSelectorPageToken:
		(*target).PageToken = fpv.value.(*limit_pool.PagerCursor)
	case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
		(*target).OrderBy = fpv.value.(*limit_pool.OrderBy)
	case ListLimitPoolsRequest_FieldPathSelectorFilter:
		(*target).Filter = fpv.value.(*limit_pool.Filter)
	case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit_pool.LimitPool_FieldMask)
	case ListLimitPoolsRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
		(*target).IncludePagingInfo = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fpv.selector))
	}
}

func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ListLimitPoolsRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ListLimitPoolsRequest_FieldTerminalPathValue' with the value under path in 'ListLimitPoolsRequest'.
func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) CompareWith(source *ListLimitPoolsRequest) (int, bool) {
	switch fpv.selector {
	case ListLimitPoolsRequest_FieldPathSelectorParent:
		leftValue := fpv.value.(*limit_pool.ParentName)
		rightValue := source.GetParent()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case ListLimitPoolsRequest_FieldPathSelectorPageSize:
		leftValue := fpv.value.(int32)
		rightValue := source.GetPageSize()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ListLimitPoolsRequest_FieldPathSelectorPageToken:
		return 0, false
	case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
		return 0, false
	case ListLimitPoolsRequest_FieldPathSelectorFilter:
		return 0, false
	case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
		return 0, false
	case ListLimitPoolsRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
		leftValue := fpv.value.(bool)
		rightValue := source.GetIncludePagingInfo()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsRequest: %d", fpv.selector))
	}
}

func (fpv *ListLimitPoolsRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ListLimitPoolsRequest))
}

// ListLimitPoolsRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for ListLimitPoolsRequest according to their type
// Present only for array (repeated) types.
type ListLimitPoolsRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ListLimitPoolsRequest_FieldPath
	ContainsValue(*ListLimitPoolsRequest) bool
}

// ParseListLimitPoolsRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseListLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr string) (ListLimitPoolsRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseListLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitPoolsRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ListLimitPoolsRequest_FieldPathArrayItemValue), nil
}

func MustParseListLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr string) ListLimitPoolsRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseListLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ListLimitPoolsRequest_FieldTerminalPathArrayItemValue struct {
	ListLimitPoolsRequest_FieldTerminalPath
	value interface{}
}

var _ ListLimitPoolsRequest_FieldPathArrayItemValue = (*ListLimitPoolsRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ListLimitPoolsRequest as interface{}
func (fpaiv *ListLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ListLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetSingle(source *ListLimitPoolsRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ListLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ListLimitPoolsRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ListLimitPoolsRequest'
func (fpaiv *ListLimitPoolsRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *ListLimitPoolsRequest) bool {
	slice := fpaiv.ListLimitPoolsRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ListLimitPoolsRequest_FieldPathArrayOfValues allows storing slice of values for ListLimitPoolsRequest fields according to their type
type ListLimitPoolsRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ListLimitPoolsRequest_FieldPath
}

func ParseListLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (ListLimitPoolsRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseListLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitPoolsRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ListLimitPoolsRequest_FieldPathArrayOfValues), nil
}

func MustParseListLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) ListLimitPoolsRequest_FieldPathArrayOfValues {
	fpaov, err := ParseListLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ListLimitPoolsRequest_FieldTerminalPathArrayOfValues struct {
	ListLimitPoolsRequest_FieldTerminalPath
	values interface{}
}

var _ ListLimitPoolsRequest_FieldPathArrayOfValues = (*ListLimitPoolsRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ListLimitPoolsRequest_FieldPathSelectorParent:
		for _, v := range fpaov.values.([]*limit_pool.ParentName) {
			values = append(values, v)
		}
	case ListLimitPoolsRequest_FieldPathSelectorPageSize:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ListLimitPoolsRequest_FieldPathSelectorPageToken:
		for _, v := range fpaov.values.([]*limit_pool.PagerCursor) {
			values = append(values, v)
		}
	case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
		for _, v := range fpaov.values.([]*limit_pool.OrderBy) {
			values = append(values, v)
		}
	case ListLimitPoolsRequest_FieldPathSelectorFilter:
		for _, v := range fpaov.values.([]*limit_pool.Filter) {
			values = append(values, v)
		}
	case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool_FieldMask) {
			values = append(values, v)
		}
	case ListLimitPoolsRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	case ListLimitPoolsRequest_FieldPathSelectorIncludePagingInfo:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsParentArrayOfValues() ([]*limit_pool.ParentName, bool) {
	res, ok := fpaov.values.([]*limit_pool.ParentName)
	return res, ok
}
func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsPageSizeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsPageTokenArrayOfValues() ([]*limit_pool.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit_pool.PagerCursor)
	return res, ok
}
func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsOrderByArrayOfValues() ([]*limit_pool.OrderBy, bool) {
	res, ok := fpaov.values.([]*limit_pool.OrderBy)
	return res, ok
}
func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsFilterArrayOfValues() ([]*limit_pool.Filter, bool) {
	res, ok := fpaov.values.([]*limit_pool.Filter)
	return res, ok
}
func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}
func (fpaov *ListLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsIncludePagingInfoArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ListLimitPoolsResponse_FieldPath interface {
	gotenobject.FieldPath
	Selector() ListLimitPoolsResponse_FieldPathSelector
	Get(source *ListLimitPoolsResponse) []interface{}
	GetSingle(source *ListLimitPoolsResponse) (interface{}, bool)
	ClearValue(item *ListLimitPoolsResponse)

	// Those methods build corresponding ListLimitPoolsResponse_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ListLimitPoolsResponse_FieldPathValue
	WithIArrayOfValues(values interface{}) ListLimitPoolsResponse_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ListLimitPoolsResponse_FieldPathArrayItemValue
}

type ListLimitPoolsResponse_FieldPathSelector int32

const (
	ListLimitPoolsResponse_FieldPathSelectorLimitPools        ListLimitPoolsResponse_FieldPathSelector = 0
	ListLimitPoolsResponse_FieldPathSelectorPrevPageToken     ListLimitPoolsResponse_FieldPathSelector = 1
	ListLimitPoolsResponse_FieldPathSelectorNextPageToken     ListLimitPoolsResponse_FieldPathSelector = 2
	ListLimitPoolsResponse_FieldPathSelectorCurrentOffset     ListLimitPoolsResponse_FieldPathSelector = 3
	ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount ListLimitPoolsResponse_FieldPathSelector = 4
)

func (s ListLimitPoolsResponse_FieldPathSelector) String() string {
	switch s {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		return "limit_pools"
	case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
		return "prev_page_token"
	case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
		return "next_page_token"
	case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
		return "current_offset"
	case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
		return "total_results_count"
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", s))
	}
}

func BuildListLimitPoolsResponse_FieldPath(fp gotenobject.RawFieldPath) (ListLimitPoolsResponse_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ListLimitPoolsResponse")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limit_pools", "limitPools", "limit-pools":
			return &ListLimitPoolsResponse_FieldTerminalPath{selector: ListLimitPoolsResponse_FieldPathSelectorLimitPools}, nil
		case "prev_page_token", "prevPageToken", "prev-page-token":
			return &ListLimitPoolsResponse_FieldTerminalPath{selector: ListLimitPoolsResponse_FieldPathSelectorPrevPageToken}, nil
		case "next_page_token", "nextPageToken", "next-page-token":
			return &ListLimitPoolsResponse_FieldTerminalPath{selector: ListLimitPoolsResponse_FieldPathSelectorNextPageToken}, nil
		case "current_offset", "currentOffset", "current-offset":
			return &ListLimitPoolsResponse_FieldTerminalPath{selector: ListLimitPoolsResponse_FieldPathSelectorCurrentOffset}, nil
		case "total_results_count", "totalResultsCount", "total-results-count":
			return &ListLimitPoolsResponse_FieldTerminalPath{selector: ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount}, nil
		}
	} else {
		switch fp[0] {
		case "limit_pools", "limitPools", "limit-pools":
			if subpath, err := limit_pool.BuildLimitPool_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ListLimitPoolsResponse_FieldSubPath{selector: ListLimitPoolsResponse_FieldPathSelectorLimitPools, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ListLimitPoolsResponse", fp)
}

func ParseListLimitPoolsResponse_FieldPath(rawField string) (ListLimitPoolsResponse_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildListLimitPoolsResponse_FieldPath(fp)
}

func MustParseListLimitPoolsResponse_FieldPath(rawField string) ListLimitPoolsResponse_FieldPath {
	fp, err := ParseListLimitPoolsResponse_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ListLimitPoolsResponse_FieldTerminalPath struct {
	selector ListLimitPoolsResponse_FieldPathSelector
}

var _ ListLimitPoolsResponse_FieldPath = (*ListLimitPoolsResponse_FieldTerminalPath)(nil)

func (fp *ListLimitPoolsResponse_FieldTerminalPath) Selector() ListLimitPoolsResponse_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ListLimitPoolsResponse_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ListLimitPoolsResponse_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ListLimitPoolsResponse
func (fp *ListLimitPoolsResponse_FieldTerminalPath) Get(source *ListLimitPoolsResponse) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
			for _, value := range source.GetLimitPools() {
				values = append(values, value)
			}
		case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
			if source.PrevPageToken != nil {
				values = append(values, source.PrevPageToken)
			}
		case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
			if source.NextPageToken != nil {
				values = append(values, source.NextPageToken)
			}
		case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
			values = append(values, source.CurrentOffset)
		case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
			values = append(values, source.TotalResultsCount)
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fp.selector))
		}
	}
	return
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ListLimitPoolsResponse))
}

// GetSingle returns value pointed by specific field of from source ListLimitPoolsResponse
func (fp *ListLimitPoolsResponse_FieldTerminalPath) GetSingle(source *ListLimitPoolsResponse) (interface{}, bool) {
	switch fp.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		res := source.GetLimitPools()
		return res, res != nil
	case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
		res := source.GetPrevPageToken()
		return res, res != nil
	case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
		res := source.GetNextPageToken()
		return res, res != nil
	case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
		return source.GetCurrentOffset(), source != nil
	case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
		return source.GetTotalResultsCount(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ListLimitPoolsResponse))
}

// GetDefault returns a default value of the field type
func (fp *ListLimitPoolsResponse_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		return ([]*limit_pool.LimitPool)(nil)
	case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
		return (*limit_pool.PagerCursor)(nil)
	case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
		return (*limit_pool.PagerCursor)(nil)
	case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
		return int32(0)
	case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) ClearValue(item *ListLimitPoolsResponse) {
	if item != nil {
		switch fp.selector {
		case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
			item.LimitPools = nil
		case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
			item.PrevPageToken = nil
		case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
			item.NextPageToken = nil
		case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
			item.CurrentOffset = int32(0)
		case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
			item.TotalResultsCount = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fp.selector))
		}
	}
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ListLimitPoolsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fp *ListLimitPoolsResponse_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ListLimitPoolsResponse_FieldPathSelectorPrevPageToken ||
		fp.selector == ListLimitPoolsResponse_FieldPathSelectorNextPageToken ||
		fp.selector == ListLimitPoolsResponse_FieldPathSelectorCurrentOffset ||
		fp.selector == ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) WithIValue(value interface{}) ListLimitPoolsResponse_FieldPathValue {
	switch fp.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		return &ListLimitPoolsResponse_FieldTerminalPathValue{ListLimitPoolsResponse_FieldTerminalPath: *fp, value: value.([]*limit_pool.LimitPool)}
	case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
		return &ListLimitPoolsResponse_FieldTerminalPathValue{ListLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(*limit_pool.PagerCursor)}
	case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
		return &ListLimitPoolsResponse_FieldTerminalPathValue{ListLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(*limit_pool.PagerCursor)}
	case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
		return &ListLimitPoolsResponse_FieldTerminalPathValue{ListLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(int32)}
	case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
		return &ListLimitPoolsResponse_FieldTerminalPathValue{ListLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) WithIArrayOfValues(values interface{}) ListLimitPoolsResponse_FieldPathArrayOfValues {
	fpaov := &ListLimitPoolsResponse_FieldTerminalPathArrayOfValues{ListLimitPoolsResponse_FieldTerminalPath: *fp}
	switch fp.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		return &ListLimitPoolsResponse_FieldTerminalPathArrayOfValues{ListLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([][]*limit_pool.LimitPool)}
	case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
		return &ListLimitPoolsResponse_FieldTerminalPathArrayOfValues{ListLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]*limit_pool.PagerCursor)}
	case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
		return &ListLimitPoolsResponse_FieldTerminalPathArrayOfValues{ListLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]*limit_pool.PagerCursor)}
	case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
		return &ListLimitPoolsResponse_FieldTerminalPathArrayOfValues{ListLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]int32)}
	case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
		return &ListLimitPoolsResponse_FieldTerminalPathArrayOfValues{ListLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fp.selector))
	}
	return fpaov
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) WithIArrayItemValue(value interface{}) ListLimitPoolsResponse_FieldPathArrayItemValue {
	switch fp.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		return &ListLimitPoolsResponse_FieldTerminalPathArrayItemValue{ListLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *ListLimitPoolsResponse_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ListLimitPoolsResponse_FieldSubPath struct {
	selector ListLimitPoolsResponse_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ListLimitPoolsResponse_FieldPath = (*ListLimitPoolsResponse_FieldSubPath)(nil)

func (fps *ListLimitPoolsResponse_FieldSubPath) Selector() ListLimitPoolsResponse_FieldPathSelector {
	return fps.selector
}
func (fps *ListLimitPoolsResponse_FieldSubPath) AsLimitPoolsSubPath() (limit_pool.LimitPool_FieldPath, bool) {
	res, ok := fps.subPath.(limit_pool.LimitPool_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ListLimitPoolsResponse_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ListLimitPoolsResponse_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ListLimitPoolsResponse
func (fps *ListLimitPoolsResponse_FieldSubPath) Get(source *ListLimitPoolsResponse) (values []interface{}) {
	switch fps.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		for _, item := range source.GetLimitPools() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fps.selector))
	}
	return
}

func (fps *ListLimitPoolsResponse_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ListLimitPoolsResponse))
}

// GetSingle returns value of selected field from source ListLimitPoolsResponse
func (fps *ListLimitPoolsResponse_FieldSubPath) GetSingle(source *ListLimitPoolsResponse) (interface{}, bool) {
	switch fps.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		if len(source.GetLimitPools()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetLimitPools()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fps.selector))
	}
}

func (fps *ListLimitPoolsResponse_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ListLimitPoolsResponse))
}

// GetDefault returns a default value of the field type
func (fps *ListLimitPoolsResponse_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ListLimitPoolsResponse_FieldSubPath) ClearValue(item *ListLimitPoolsResponse) {
	if item != nil {
		switch fps.selector {
		case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
			for _, subItem := range item.LimitPools {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fps.selector))
		}
	}
}

func (fps *ListLimitPoolsResponse_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ListLimitPoolsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fps *ListLimitPoolsResponse_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ListLimitPoolsResponse_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&ListLimitPoolsResponse_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *ListLimitPoolsResponse_FieldSubPath) WithIValue(value interface{}) ListLimitPoolsResponse_FieldPathValue {
	return &ListLimitPoolsResponse_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ListLimitPoolsResponse_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ListLimitPoolsResponse_FieldSubPath) WithIArrayOfValues(values interface{}) ListLimitPoolsResponse_FieldPathArrayOfValues {
	return &ListLimitPoolsResponse_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ListLimitPoolsResponse_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ListLimitPoolsResponse_FieldSubPath) WithIArrayItemValue(value interface{}) ListLimitPoolsResponse_FieldPathArrayItemValue {
	return &ListLimitPoolsResponse_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ListLimitPoolsResponse_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ListLimitPoolsResponse_FieldPathValue allows storing values for ListLimitPoolsResponse fields according to their type
type ListLimitPoolsResponse_FieldPathValue interface {
	ListLimitPoolsResponse_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ListLimitPoolsResponse)
	CompareWith(*ListLimitPoolsResponse) (cmp int, comparable bool)
}

func ParseListLimitPoolsResponse_FieldPathValue(pathStr, valueStr string) (ListLimitPoolsResponse_FieldPathValue, error) {
	fp, err := ParseListLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitPoolsResponse field path value from %s: %v", valueStr, err)
	}
	return fpv.(ListLimitPoolsResponse_FieldPathValue), nil
}

func MustParseListLimitPoolsResponse_FieldPathValue(pathStr, valueStr string) ListLimitPoolsResponse_FieldPathValue {
	fpv, err := ParseListLimitPoolsResponse_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ListLimitPoolsResponse_FieldTerminalPathValue struct {
	ListLimitPoolsResponse_FieldTerminalPath
	value interface{}
}

var _ ListLimitPoolsResponse_FieldPathValue = (*ListLimitPoolsResponse_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ListLimitPoolsResponse' as interface{}
func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) AsLimitPoolsValue() ([]*limit_pool.LimitPool, bool) {
	res, ok := fpv.value.([]*limit_pool.LimitPool)
	return res, ok
}
func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) AsPrevPageTokenValue() (*limit_pool.PagerCursor, bool) {
	res, ok := fpv.value.(*limit_pool.PagerCursor)
	return res, ok
}
func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) AsNextPageTokenValue() (*limit_pool.PagerCursor, bool) {
	res, ok := fpv.value.(*limit_pool.PagerCursor)
	return res, ok
}
func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) AsCurrentOffsetValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) AsTotalResultsCountValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object ListLimitPoolsResponse
func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) SetTo(target **ListLimitPoolsResponse) {
	if *target == nil {
		*target = new(ListLimitPoolsResponse)
	}
	switch fpv.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		(*target).LimitPools = fpv.value.([]*limit_pool.LimitPool)
	case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
		(*target).PrevPageToken = fpv.value.(*limit_pool.PagerCursor)
	case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
		(*target).NextPageToken = fpv.value.(*limit_pool.PagerCursor)
	case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
		(*target).CurrentOffset = fpv.value.(int32)
	case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
		(*target).TotalResultsCount = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fpv.selector))
	}
}

func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ListLimitPoolsResponse)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ListLimitPoolsResponse_FieldTerminalPathValue' with the value under path in 'ListLimitPoolsResponse'.
func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) CompareWith(source *ListLimitPoolsResponse) (int, bool) {
	switch fpv.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		return 0, false
	case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
		return 0, false
	case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
		return 0, false
	case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
		leftValue := fpv.value.(int32)
		rightValue := source.GetCurrentOffset()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
		leftValue := fpv.value.(int32)
		rightValue := source.GetTotalResultsCount()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fpv.selector))
	}
}

func (fpv *ListLimitPoolsResponse_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ListLimitPoolsResponse))
}

type ListLimitPoolsResponse_FieldSubPathValue struct {
	ListLimitPoolsResponse_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ListLimitPoolsResponse_FieldPathValue = (*ListLimitPoolsResponse_FieldSubPathValue)(nil)

func (fpvs *ListLimitPoolsResponse_FieldSubPathValue) AsLimitPoolsPathValue() (limit_pool.LimitPool_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(limit_pool.LimitPool_FieldPathValue)
	return res, ok
}

func (fpvs *ListLimitPoolsResponse_FieldSubPathValue) SetTo(target **ListLimitPoolsResponse) {
	if *target == nil {
		*target = new(ListLimitPoolsResponse)
	}
	switch fpvs.Selector() {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *ListLimitPoolsResponse_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ListLimitPoolsResponse)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ListLimitPoolsResponse_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ListLimitPoolsResponse_FieldSubPathValue) CompareWith(source *ListLimitPoolsResponse) (int, bool) {
	switch fpvs.Selector() {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *ListLimitPoolsResponse_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ListLimitPoolsResponse))
}

// ListLimitPoolsResponse_FieldPathArrayItemValue allows storing single item in Path-specific values for ListLimitPoolsResponse according to their type
// Present only for array (repeated) types.
type ListLimitPoolsResponse_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ListLimitPoolsResponse_FieldPath
	ContainsValue(*ListLimitPoolsResponse) bool
}

// ParseListLimitPoolsResponse_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseListLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr string) (ListLimitPoolsResponse_FieldPathArrayItemValue, error) {
	fp, err := ParseListLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitPoolsResponse field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ListLimitPoolsResponse_FieldPathArrayItemValue), nil
}

func MustParseListLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr string) ListLimitPoolsResponse_FieldPathArrayItemValue {
	fpaiv, err := ParseListLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ListLimitPoolsResponse_FieldTerminalPathArrayItemValue struct {
	ListLimitPoolsResponse_FieldTerminalPath
	value interface{}
}

var _ ListLimitPoolsResponse_FieldPathArrayItemValue = (*ListLimitPoolsResponse_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ListLimitPoolsResponse as interface{}
func (fpaiv *ListLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *ListLimitPoolsResponse_FieldTerminalPathArrayItemValue) AsLimitPoolsItemValue() (*limit_pool.LimitPool, bool) {
	res, ok := fpaiv.value.(*limit_pool.LimitPool)
	return res, ok
}

func (fpaiv *ListLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetSingle(source *ListLimitPoolsResponse) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ListLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ListLimitPoolsResponse))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ListLimitPoolsResponse'
func (fpaiv *ListLimitPoolsResponse_FieldTerminalPathArrayItemValue) ContainsValue(source *ListLimitPoolsResponse) bool {
	slice := fpaiv.ListLimitPoolsResponse_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ListLimitPoolsResponse_FieldSubPathArrayItemValue struct {
	ListLimitPoolsResponse_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ListLimitPoolsResponse_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ListLimitPoolsResponse_FieldSubPathArrayItemValue) AsLimitPoolsPathItemValue() (limit_pool.LimitPool_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(limit_pool.LimitPool_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ListLimitPoolsResponse'
func (fpaivs *ListLimitPoolsResponse_FieldSubPathArrayItemValue) ContainsValue(source *ListLimitPoolsResponse) bool {
	switch fpaivs.Selector() {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitPoolsResponse: %d", fpaivs.Selector()))
	}
}

// ListLimitPoolsResponse_FieldPathArrayOfValues allows storing slice of values for ListLimitPoolsResponse fields according to their type
type ListLimitPoolsResponse_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ListLimitPoolsResponse_FieldPath
}

func ParseListLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) (ListLimitPoolsResponse_FieldPathArrayOfValues, error) {
	fp, err := ParseListLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitPoolsResponse field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ListLimitPoolsResponse_FieldPathArrayOfValues), nil
}

func MustParseListLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) ListLimitPoolsResponse_FieldPathArrayOfValues {
	fpaov, err := ParseListLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ListLimitPoolsResponse_FieldTerminalPathArrayOfValues struct {
	ListLimitPoolsResponse_FieldTerminalPath
	values interface{}
}

var _ ListLimitPoolsResponse_FieldPathArrayOfValues = (*ListLimitPoolsResponse_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ListLimitPoolsResponse_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
		for _, v := range fpaov.values.([][]*limit_pool.LimitPool) {
			values = append(values, v)
		}
	case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
		for _, v := range fpaov.values.([]*limit_pool.PagerCursor) {
			values = append(values, v)
		}
	case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
		for _, v := range fpaov.values.([]*limit_pool.PagerCursor) {
			values = append(values, v)
		}
	case ListLimitPoolsResponse_FieldPathSelectorCurrentOffset:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ListLimitPoolsResponse_FieldPathSelectorTotalResultsCount:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ListLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsLimitPoolsArrayOfValues() ([][]*limit_pool.LimitPool, bool) {
	res, ok := fpaov.values.([][]*limit_pool.LimitPool)
	return res, ok
}
func (fpaov *ListLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsPrevPageTokenArrayOfValues() ([]*limit_pool.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit_pool.PagerCursor)
	return res, ok
}
func (fpaov *ListLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsNextPageTokenArrayOfValues() ([]*limit_pool.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit_pool.PagerCursor)
	return res, ok
}
func (fpaov *ListLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsCurrentOffsetArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ListLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsTotalResultsCountArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

type ListLimitPoolsResponse_FieldSubPathArrayOfValues struct {
	ListLimitPoolsResponse_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ListLimitPoolsResponse_FieldPathArrayOfValues = (*ListLimitPoolsResponse_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ListLimitPoolsResponse_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ListLimitPoolsResponse_FieldSubPathArrayOfValues) AsLimitPoolsPathArrayOfValues() (limit_pool.LimitPool_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(limit_pool.LimitPool_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitPoolRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitPoolRequest_FieldPathSelector
	Get(source *WatchLimitPoolRequest) []interface{}
	GetSingle(source *WatchLimitPoolRequest) (interface{}, bool)
	ClearValue(item *WatchLimitPoolRequest)

	// Those methods build corresponding WatchLimitPoolRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitPoolRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitPoolRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitPoolRequest_FieldPathArrayItemValue
}

type WatchLimitPoolRequest_FieldPathSelector int32

const (
	WatchLimitPoolRequest_FieldPathSelectorName      WatchLimitPoolRequest_FieldPathSelector = 0
	WatchLimitPoolRequest_FieldPathSelectorFieldMask WatchLimitPoolRequest_FieldPathSelector = 1
	WatchLimitPoolRequest_FieldPathSelectorView      WatchLimitPoolRequest_FieldPathSelector = 2
)

func (s WatchLimitPoolRequest_FieldPathSelector) String() string {
	switch s {
	case WatchLimitPoolRequest_FieldPathSelectorName:
		return "name"
	case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case WatchLimitPoolRequest_FieldPathSelectorView:
		return "view"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", s))
	}
}

func BuildWatchLimitPoolRequest_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitPoolRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitPoolRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &WatchLimitPoolRequest_FieldTerminalPath{selector: WatchLimitPoolRequest_FieldPathSelectorName}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &WatchLimitPoolRequest_FieldTerminalPath{selector: WatchLimitPoolRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &WatchLimitPoolRequest_FieldTerminalPath{selector: WatchLimitPoolRequest_FieldPathSelectorView}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitPoolRequest", fp)
}

func ParseWatchLimitPoolRequest_FieldPath(rawField string) (WatchLimitPoolRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitPoolRequest_FieldPath(fp)
}

func MustParseWatchLimitPoolRequest_FieldPath(rawField string) WatchLimitPoolRequest_FieldPath {
	fp, err := ParseWatchLimitPoolRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitPoolRequest_FieldTerminalPath struct {
	selector WatchLimitPoolRequest_FieldPathSelector
}

var _ WatchLimitPoolRequest_FieldPath = (*WatchLimitPoolRequest_FieldTerminalPath)(nil)

func (fp *WatchLimitPoolRequest_FieldTerminalPath) Selector() WatchLimitPoolRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitPoolRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitPoolRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitPoolRequest
func (fp *WatchLimitPoolRequest_FieldTerminalPath) Get(source *WatchLimitPoolRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitPoolRequest_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case WatchLimitPoolRequest_FieldPathSelectorView:
			values = append(values, source.View)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitPoolRequest))
}

// GetSingle returns value pointed by specific field of from source WatchLimitPoolRequest
func (fp *WatchLimitPoolRequest_FieldTerminalPath) GetSingle(source *WatchLimitPoolRequest) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitPoolRequest_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case WatchLimitPoolRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitPoolRequest))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitPoolRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitPoolRequest_FieldPathSelectorName:
		return (*limit_pool.Reference)(nil)
	case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
		return (*limit_pool.LimitPool_FieldMask)(nil)
	case WatchLimitPoolRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) ClearValue(item *WatchLimitPoolRequest) {
	if item != nil {
		switch fp.selector {
		case WatchLimitPoolRequest_FieldPathSelectorName:
			item.Name = nil
		case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case WatchLimitPoolRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitPoolRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitPoolRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitPoolRequest_FieldPathSelectorName ||
		fp.selector == WatchLimitPoolRequest_FieldPathSelectorFieldMask ||
		fp.selector == WatchLimitPoolRequest_FieldPathSelectorView
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) WithIValue(value interface{}) WatchLimitPoolRequest_FieldPathValue {
	switch fp.selector {
	case WatchLimitPoolRequest_FieldPathSelectorName:
		return &WatchLimitPoolRequest_FieldTerminalPathValue{WatchLimitPoolRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.Reference)}
	case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
		return &WatchLimitPoolRequest_FieldTerminalPathValue{WatchLimitPoolRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool_FieldMask)}
	case WatchLimitPoolRequest_FieldPathSelectorView:
		return &WatchLimitPoolRequest_FieldTerminalPathValue{WatchLimitPoolRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitPoolRequest_FieldPathArrayOfValues {
	fpaov := &WatchLimitPoolRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitPoolRequest_FieldPathSelectorName:
		return &WatchLimitPoolRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.Reference)}
	case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
		return &WatchLimitPoolRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool_FieldMask)}
	case WatchLimitPoolRequest_FieldPathSelectorView:
		return &WatchLimitPoolRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitPoolRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WatchLimitPoolRequest_FieldPathValue allows storing values for WatchLimitPoolRequest fields according to their type
type WatchLimitPoolRequest_FieldPathValue interface {
	WatchLimitPoolRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitPoolRequest)
	CompareWith(*WatchLimitPoolRequest) (cmp int, comparable bool)
}

func ParseWatchLimitPoolRequest_FieldPathValue(pathStr, valueStr string) (WatchLimitPoolRequest_FieldPathValue, error) {
	fp, err := ParseWatchLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitPoolRequest_FieldPathValue), nil
}

func MustParseWatchLimitPoolRequest_FieldPathValue(pathStr, valueStr string) WatchLimitPoolRequest_FieldPathValue {
	fpv, err := ParseWatchLimitPoolRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitPoolRequest_FieldTerminalPathValue struct {
	WatchLimitPoolRequest_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolRequest_FieldPathValue = (*WatchLimitPoolRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WatchLimitPoolRequest' as interface{}
func (fpv *WatchLimitPoolRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitPoolRequest_FieldTerminalPathValue) AsNameValue() (*limit_pool.Reference, bool) {
	res, ok := fpv.value.(*limit_pool.Reference)
	return res, ok
}
func (fpv *WatchLimitPoolRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpv *WatchLimitPoolRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}

// SetTo stores value for selected field for object WatchLimitPoolRequest
func (fpv *WatchLimitPoolRequest_FieldTerminalPathValue) SetTo(target **WatchLimitPoolRequest) {
	if *target == nil {
		*target = new(WatchLimitPoolRequest)
	}
	switch fpv.selector {
	case WatchLimitPoolRequest_FieldPathSelectorName:
		(*target).Name = fpv.value.(*limit_pool.Reference)
	case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit_pool.LimitPool_FieldMask)
	case WatchLimitPoolRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitPoolRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitPoolRequest_FieldTerminalPathValue' with the value under path in 'WatchLimitPoolRequest'.
func (fpv *WatchLimitPoolRequest_FieldTerminalPathValue) CompareWith(source *WatchLimitPoolRequest) (int, bool) {
	switch fpv.selector {
	case WatchLimitPoolRequest_FieldPathSelectorName:
		leftValue := fpv.value.(*limit_pool.Reference)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
		return 0, false
	case WatchLimitPoolRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolRequest: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitPoolRequest))
}

// WatchLimitPoolRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for WatchLimitPoolRequest according to their type
// Present only for array (repeated) types.
type WatchLimitPoolRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitPoolRequest_FieldPath
	ContainsValue(*WatchLimitPoolRequest) bool
}

// ParseWatchLimitPoolRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitPoolRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitPoolRequest_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitPoolRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitPoolRequest_FieldTerminalPathArrayItemValue struct {
	WatchLimitPoolRequest_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolRequest_FieldPathArrayItemValue = (*WatchLimitPoolRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitPoolRequest as interface{}
func (fpaiv *WatchLimitPoolRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WatchLimitPoolRequest_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitPoolRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitPoolRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitPoolRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitPoolRequest'
func (fpaiv *WatchLimitPoolRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitPoolRequest) bool {
	slice := fpaiv.WatchLimitPoolRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WatchLimitPoolRequest_FieldPathArrayOfValues allows storing slice of values for WatchLimitPoolRequest fields according to their type
type WatchLimitPoolRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitPoolRequest_FieldPath
}

func ParseWatchLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitPoolRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitPoolRequest_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitPoolRequest_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitPoolRequest_FieldTerminalPathArrayOfValues struct {
	WatchLimitPoolRequest_FieldTerminalPath
	values interface{}
}

var _ WatchLimitPoolRequest_FieldPathArrayOfValues = (*WatchLimitPoolRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitPoolRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitPoolRequest_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*limit_pool.Reference) {
			values = append(values, v)
		}
	case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool_FieldMask) {
			values = append(values, v)
		}
	case WatchLimitPoolRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitPoolRequest_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*limit_pool.Reference, bool) {
	res, ok := fpaov.values.([]*limit_pool.Reference)
	return res, ok
}
func (fpaov *WatchLimitPoolRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpaov *WatchLimitPoolRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitPoolResponse_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitPoolResponse_FieldPathSelector
	Get(source *WatchLimitPoolResponse) []interface{}
	GetSingle(source *WatchLimitPoolResponse) (interface{}, bool)
	ClearValue(item *WatchLimitPoolResponse)

	// Those methods build corresponding WatchLimitPoolResponse_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitPoolResponse_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitPoolResponse_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitPoolResponse_FieldPathArrayItemValue
}

type WatchLimitPoolResponse_FieldPathSelector int32

const (
	WatchLimitPoolResponse_FieldPathSelectorChange WatchLimitPoolResponse_FieldPathSelector = 0
)

func (s WatchLimitPoolResponse_FieldPathSelector) String() string {
	switch s {
	case WatchLimitPoolResponse_FieldPathSelectorChange:
		return "change"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", s))
	}
}

func BuildWatchLimitPoolResponse_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitPoolResponse_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitPoolResponse")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "change":
			return &WatchLimitPoolResponse_FieldTerminalPath{selector: WatchLimitPoolResponse_FieldPathSelectorChange}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitPoolResponse", fp)
}

func ParseWatchLimitPoolResponse_FieldPath(rawField string) (WatchLimitPoolResponse_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitPoolResponse_FieldPath(fp)
}

func MustParseWatchLimitPoolResponse_FieldPath(rawField string) WatchLimitPoolResponse_FieldPath {
	fp, err := ParseWatchLimitPoolResponse_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitPoolResponse_FieldTerminalPath struct {
	selector WatchLimitPoolResponse_FieldPathSelector
}

var _ WatchLimitPoolResponse_FieldPath = (*WatchLimitPoolResponse_FieldTerminalPath)(nil)

func (fp *WatchLimitPoolResponse_FieldTerminalPath) Selector() WatchLimitPoolResponse_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitPoolResponse_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitPoolResponse_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitPoolResponse
func (fp *WatchLimitPoolResponse_FieldTerminalPath) Get(source *WatchLimitPoolResponse) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitPoolResponse_FieldPathSelectorChange:
			if source.Change != nil {
				values = append(values, source.Change)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitPoolResponse))
}

// GetSingle returns value pointed by specific field of from source WatchLimitPoolResponse
func (fp *WatchLimitPoolResponse_FieldTerminalPath) GetSingle(source *WatchLimitPoolResponse) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitPoolResponse_FieldPathSelectorChange:
		res := source.GetChange()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitPoolResponse))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitPoolResponse_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitPoolResponse_FieldPathSelectorChange:
		return (*limit_pool.LimitPoolChange)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) ClearValue(item *WatchLimitPoolResponse) {
	if item != nil {
		switch fp.selector {
		case WatchLimitPoolResponse_FieldPathSelectorChange:
			item.Change = nil
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitPoolResponse))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitPoolResponse_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitPoolResponse_FieldPathSelectorChange
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) WithIValue(value interface{}) WatchLimitPoolResponse_FieldPathValue {
	switch fp.selector {
	case WatchLimitPoolResponse_FieldPathSelectorChange:
		return &WatchLimitPoolResponse_FieldTerminalPathValue{WatchLimitPoolResponse_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPoolChange)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitPoolResponse_FieldPathArrayOfValues {
	fpaov := &WatchLimitPoolResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolResponse_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitPoolResponse_FieldPathSelectorChange:
		return &WatchLimitPoolResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolResponse_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPoolChange)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitPoolResponse_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolResponse_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WatchLimitPoolResponse_FieldPathValue allows storing values for WatchLimitPoolResponse fields according to their type
type WatchLimitPoolResponse_FieldPathValue interface {
	WatchLimitPoolResponse_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitPoolResponse)
	CompareWith(*WatchLimitPoolResponse) (cmp int, comparable bool)
}

func ParseWatchLimitPoolResponse_FieldPathValue(pathStr, valueStr string) (WatchLimitPoolResponse_FieldPathValue, error) {
	fp, err := ParseWatchLimitPoolResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolResponse field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitPoolResponse_FieldPathValue), nil
}

func MustParseWatchLimitPoolResponse_FieldPathValue(pathStr, valueStr string) WatchLimitPoolResponse_FieldPathValue {
	fpv, err := ParseWatchLimitPoolResponse_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitPoolResponse_FieldTerminalPathValue struct {
	WatchLimitPoolResponse_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolResponse_FieldPathValue = (*WatchLimitPoolResponse_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WatchLimitPoolResponse' as interface{}
func (fpv *WatchLimitPoolResponse_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitPoolResponse_FieldTerminalPathValue) AsChangeValue() (*limit_pool.LimitPoolChange, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPoolChange)
	return res, ok
}

// SetTo stores value for selected field for object WatchLimitPoolResponse
func (fpv *WatchLimitPoolResponse_FieldTerminalPathValue) SetTo(target **WatchLimitPoolResponse) {
	if *target == nil {
		*target = new(WatchLimitPoolResponse)
	}
	switch fpv.selector {
	case WatchLimitPoolResponse_FieldPathSelectorChange:
		(*target).Change = fpv.value.(*limit_pool.LimitPoolChange)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolResponse_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitPoolResponse)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitPoolResponse_FieldTerminalPathValue' with the value under path in 'WatchLimitPoolResponse'.
func (fpv *WatchLimitPoolResponse_FieldTerminalPathValue) CompareWith(source *WatchLimitPoolResponse) (int, bool) {
	switch fpv.selector {
	case WatchLimitPoolResponse_FieldPathSelectorChange:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolResponse: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolResponse_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitPoolResponse))
}

// WatchLimitPoolResponse_FieldPathArrayItemValue allows storing single item in Path-specific values for WatchLimitPoolResponse according to their type
// Present only for array (repeated) types.
type WatchLimitPoolResponse_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitPoolResponse_FieldPath
	ContainsValue(*WatchLimitPoolResponse) bool
}

// ParseWatchLimitPoolResponse_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitPoolResponse_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitPoolResponse_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitPoolResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolResponse field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitPoolResponse_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitPoolResponse_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitPoolResponse_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitPoolResponse_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitPoolResponse_FieldTerminalPathArrayItemValue struct {
	WatchLimitPoolResponse_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolResponse_FieldPathArrayItemValue = (*WatchLimitPoolResponse_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitPoolResponse as interface{}
func (fpaiv *WatchLimitPoolResponse_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WatchLimitPoolResponse_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitPoolResponse) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitPoolResponse_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitPoolResponse))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitPoolResponse'
func (fpaiv *WatchLimitPoolResponse_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitPoolResponse) bool {
	slice := fpaiv.WatchLimitPoolResponse_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WatchLimitPoolResponse_FieldPathArrayOfValues allows storing slice of values for WatchLimitPoolResponse fields according to their type
type WatchLimitPoolResponse_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitPoolResponse_FieldPath
}

func ParseWatchLimitPoolResponse_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitPoolResponse_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitPoolResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolResponse field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitPoolResponse_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitPoolResponse_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitPoolResponse_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitPoolResponse_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitPoolResponse_FieldTerminalPathArrayOfValues struct {
	WatchLimitPoolResponse_FieldTerminalPath
	values interface{}
}

var _ WatchLimitPoolResponse_FieldPathArrayOfValues = (*WatchLimitPoolResponse_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitPoolResponse_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitPoolResponse_FieldPathSelectorChange:
		for _, v := range fpaov.values.([]*limit_pool.LimitPoolChange) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitPoolResponse_FieldTerminalPathArrayOfValues) AsChangeArrayOfValues() ([]*limit_pool.LimitPoolChange, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPoolChange)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitPoolsRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitPoolsRequest_FieldPathSelector
	Get(source *WatchLimitPoolsRequest) []interface{}
	GetSingle(source *WatchLimitPoolsRequest) (interface{}, bool)
	ClearValue(item *WatchLimitPoolsRequest)

	// Those methods build corresponding WatchLimitPoolsRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitPoolsRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitPoolsRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitPoolsRequest_FieldPathArrayItemValue
}

type WatchLimitPoolsRequest_FieldPathSelector int32

const (
	WatchLimitPoolsRequest_FieldPathSelectorType         WatchLimitPoolsRequest_FieldPathSelector = 0
	WatchLimitPoolsRequest_FieldPathSelectorParent       WatchLimitPoolsRequest_FieldPathSelector = 1
	WatchLimitPoolsRequest_FieldPathSelectorPageSize     WatchLimitPoolsRequest_FieldPathSelector = 2
	WatchLimitPoolsRequest_FieldPathSelectorPageToken    WatchLimitPoolsRequest_FieldPathSelector = 3
	WatchLimitPoolsRequest_FieldPathSelectorOrderBy      WatchLimitPoolsRequest_FieldPathSelector = 4
	WatchLimitPoolsRequest_FieldPathSelectorResumeToken  WatchLimitPoolsRequest_FieldPathSelector = 5
	WatchLimitPoolsRequest_FieldPathSelectorStartingTime WatchLimitPoolsRequest_FieldPathSelector = 6
	WatchLimitPoolsRequest_FieldPathSelectorFilter       WatchLimitPoolsRequest_FieldPathSelector = 7
	WatchLimitPoolsRequest_FieldPathSelectorFieldMask    WatchLimitPoolsRequest_FieldPathSelector = 8
	WatchLimitPoolsRequest_FieldPathSelectorView         WatchLimitPoolsRequest_FieldPathSelector = 9
	WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize WatchLimitPoolsRequest_FieldPathSelector = 10
)

func (s WatchLimitPoolsRequest_FieldPathSelector) String() string {
	switch s {
	case WatchLimitPoolsRequest_FieldPathSelectorType:
		return "type"
	case WatchLimitPoolsRequest_FieldPathSelectorParent:
		return "parent"
	case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
		return "page_size"
	case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
		return "page_token"
	case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
		return "order_by"
	case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
		return "resume_token"
	case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
		return "starting_time"
	case WatchLimitPoolsRequest_FieldPathSelectorFilter:
		return "filter"
	case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case WatchLimitPoolsRequest_FieldPathSelectorView:
		return "view"
	case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
		return "max_chunk_size"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", s))
	}
}

func BuildWatchLimitPoolsRequest_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitPoolsRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitPoolsRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "type":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorType}, nil
		case "parent":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorParent}, nil
		case "page_size", "pageSize", "page-size":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorPageSize}, nil
		case "page_token", "pageToken", "page-token":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorPageToken}, nil
		case "order_by", "orderBy", "order-by":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorOrderBy}, nil
		case "resume_token", "resumeToken", "resume-token":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorResumeToken}, nil
		case "starting_time", "startingTime", "starting-time":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorStartingTime}, nil
		case "filter":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorFilter}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorView}, nil
		case "max_chunk_size", "maxChunkSize", "max-chunk-size":
			return &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitPoolsRequest", fp)
}

func ParseWatchLimitPoolsRequest_FieldPath(rawField string) (WatchLimitPoolsRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitPoolsRequest_FieldPath(fp)
}

func MustParseWatchLimitPoolsRequest_FieldPath(rawField string) WatchLimitPoolsRequest_FieldPath {
	fp, err := ParseWatchLimitPoolsRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitPoolsRequest_FieldTerminalPath struct {
	selector WatchLimitPoolsRequest_FieldPathSelector
}

var _ WatchLimitPoolsRequest_FieldPath = (*WatchLimitPoolsRequest_FieldTerminalPath)(nil)

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) Selector() WatchLimitPoolsRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitPoolsRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitPoolsRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitPoolsRequest
func (fp *WatchLimitPoolsRequest_FieldTerminalPath) Get(source *WatchLimitPoolsRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitPoolsRequest_FieldPathSelectorType:
			values = append(values, source.Type)
		case WatchLimitPoolsRequest_FieldPathSelectorParent:
			if source.Parent != nil {
				values = append(values, source.Parent)
			}
		case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
			values = append(values, source.PageSize)
		case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
			if source.PageToken != nil {
				values = append(values, source.PageToken)
			}
		case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
			if source.OrderBy != nil {
				values = append(values, source.OrderBy)
			}
		case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
			values = append(values, source.ResumeToken)
		case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
			if source.StartingTime != nil {
				values = append(values, source.StartingTime)
			}
		case WatchLimitPoolsRequest_FieldPathSelectorFilter:
			if source.Filter != nil {
				values = append(values, source.Filter)
			}
		case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case WatchLimitPoolsRequest_FieldPathSelectorView:
			values = append(values, source.View)
		case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
			values = append(values, source.MaxChunkSize)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitPoolsRequest))
}

// GetSingle returns value pointed by specific field of from source WatchLimitPoolsRequest
func (fp *WatchLimitPoolsRequest_FieldTerminalPath) GetSingle(source *WatchLimitPoolsRequest) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitPoolsRequest_FieldPathSelectorType:
		return source.GetType(), source != nil
	case WatchLimitPoolsRequest_FieldPathSelectorParent:
		res := source.GetParent()
		return res, res != nil
	case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
		return source.GetPageSize(), source != nil
	case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
		res := source.GetPageToken()
		return res, res != nil
	case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
		res := source.GetOrderBy()
		return res, res != nil
	case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
		return source.GetResumeToken(), source != nil
	case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
		res := source.GetStartingTime()
		return res, res != nil
	case WatchLimitPoolsRequest_FieldPathSelectorFilter:
		res := source.GetFilter()
		return res, res != nil
	case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case WatchLimitPoolsRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
		return source.GetMaxChunkSize(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitPoolsRequest))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitPoolsRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitPoolsRequest_FieldPathSelectorType:
		return watch_type.WatchType_STATEFUL
	case WatchLimitPoolsRequest_FieldPathSelectorParent:
		return (*limit_pool.ParentReference)(nil)
	case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
		return int32(0)
	case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
		return (*limit_pool.PagerCursor)(nil)
	case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
		return (*limit_pool.OrderBy)(nil)
	case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
		return ""
	case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
		return (*timestamp.Timestamp)(nil)
	case WatchLimitPoolsRequest_FieldPathSelectorFilter:
		return (*limit_pool.Filter)(nil)
	case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
		return (*limit_pool.LimitPool_FieldMask)(nil)
	case WatchLimitPoolsRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) ClearValue(item *WatchLimitPoolsRequest) {
	if item != nil {
		switch fp.selector {
		case WatchLimitPoolsRequest_FieldPathSelectorType:
			item.Type = watch_type.WatchType_STATEFUL
		case WatchLimitPoolsRequest_FieldPathSelectorParent:
			item.Parent = nil
		case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
			item.PageSize = int32(0)
		case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
			item.PageToken = nil
		case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
			item.OrderBy = nil
		case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
			item.ResumeToken = ""
		case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
			item.StartingTime = nil
		case WatchLimitPoolsRequest_FieldPathSelectorFilter:
			item.Filter = nil
		case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case WatchLimitPoolsRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
			item.MaxChunkSize = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitPoolsRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitPoolsRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitPoolsRequest_FieldPathSelectorType ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorParent ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorPageSize ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorPageToken ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorOrderBy ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorResumeToken ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorStartingTime ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorFilter ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorFieldMask ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorView ||
		fp.selector == WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) WithIValue(value interface{}) WatchLimitPoolsRequest_FieldPathValue {
	switch fp.selector {
	case WatchLimitPoolsRequest_FieldPathSelectorType:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(watch_type.WatchType)}
	case WatchLimitPoolsRequest_FieldPathSelectorParent:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.ParentReference)}
	case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(int32)}
	case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.PagerCursor)}
	case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.OrderBy)}
	case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(string)}
	case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*timestamp.Timestamp)}
	case WatchLimitPoolsRequest_FieldPathSelectorFilter:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.Filter)}
	case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool_FieldMask)}
	case WatchLimitPoolsRequest_FieldPathSelectorView:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
		return &WatchLimitPoolsRequest_FieldTerminalPathValue{WatchLimitPoolsRequest_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitPoolsRequest_FieldPathArrayOfValues {
	fpaov := &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitPoolsRequest_FieldPathSelectorType:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]watch_type.WatchType)}
	case WatchLimitPoolsRequest_FieldPathSelectorParent:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.ParentReference)}
	case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]int32)}
	case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.PagerCursor)}
	case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.OrderBy)}
	case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]string)}
	case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*timestamp.Timestamp)}
	case WatchLimitPoolsRequest_FieldPathSelectorFilter:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.Filter)}
	case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool_FieldMask)}
	case WatchLimitPoolsRequest_FieldPathSelectorView:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
		return &WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues{WatchLimitPoolsRequest_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitPoolsRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WatchLimitPoolsRequest_FieldPathValue allows storing values for WatchLimitPoolsRequest fields according to their type
type WatchLimitPoolsRequest_FieldPathValue interface {
	WatchLimitPoolsRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitPoolsRequest)
	CompareWith(*WatchLimitPoolsRequest) (cmp int, comparable bool)
}

func ParseWatchLimitPoolsRequest_FieldPathValue(pathStr, valueStr string) (WatchLimitPoolsRequest_FieldPathValue, error) {
	fp, err := ParseWatchLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolsRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitPoolsRequest_FieldPathValue), nil
}

func MustParseWatchLimitPoolsRequest_FieldPathValue(pathStr, valueStr string) WatchLimitPoolsRequest_FieldPathValue {
	fpv, err := ParseWatchLimitPoolsRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitPoolsRequest_FieldTerminalPathValue struct {
	WatchLimitPoolsRequest_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolsRequest_FieldPathValue = (*WatchLimitPoolsRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WatchLimitPoolsRequest' as interface{}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsTypeValue() (watch_type.WatchType, bool) {
	res, ok := fpv.value.(watch_type.WatchType)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsParentValue() (*limit_pool.ParentReference, bool) {
	res, ok := fpv.value.(*limit_pool.ParentReference)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsPageSizeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsPageTokenValue() (*limit_pool.PagerCursor, bool) {
	res, ok := fpv.value.(*limit_pool.PagerCursor)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsOrderByValue() (*limit_pool.OrderBy, bool) {
	res, ok := fpv.value.(*limit_pool.OrderBy)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsResumeTokenValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsStartingTimeValue() (*timestamp.Timestamp, bool) {
	res, ok := fpv.value.(*timestamp.Timestamp)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsFilterValue() (*limit_pool.Filter, bool) {
	res, ok := fpv.value.(*limit_pool.Filter)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) AsMaxChunkSizeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object WatchLimitPoolsRequest
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) SetTo(target **WatchLimitPoolsRequest) {
	if *target == nil {
		*target = new(WatchLimitPoolsRequest)
	}
	switch fpv.selector {
	case WatchLimitPoolsRequest_FieldPathSelectorType:
		(*target).Type = fpv.value.(watch_type.WatchType)
	case WatchLimitPoolsRequest_FieldPathSelectorParent:
		(*target).Parent = fpv.value.(*limit_pool.ParentReference)
	case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
		(*target).PageSize = fpv.value.(int32)
	case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
		(*target).PageToken = fpv.value.(*limit_pool.PagerCursor)
	case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
		(*target).OrderBy = fpv.value.(*limit_pool.OrderBy)
	case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
		(*target).ResumeToken = fpv.value.(string)
	case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
		(*target).StartingTime = fpv.value.(*timestamp.Timestamp)
	case WatchLimitPoolsRequest_FieldPathSelectorFilter:
		(*target).Filter = fpv.value.(*limit_pool.Filter)
	case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit_pool.LimitPool_FieldMask)
	case WatchLimitPoolsRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
		(*target).MaxChunkSize = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitPoolsRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitPoolsRequest_FieldTerminalPathValue' with the value under path in 'WatchLimitPoolsRequest'.
func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) CompareWith(source *WatchLimitPoolsRequest) (int, bool) {
	switch fpv.selector {
	case WatchLimitPoolsRequest_FieldPathSelectorType:
		leftValue := fpv.value.(watch_type.WatchType)
		rightValue := source.GetType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsRequest_FieldPathSelectorParent:
		leftValue := fpv.value.(*limit_pool.ParentReference)
		rightValue := source.GetParent()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
		leftValue := fpv.value.(int32)
		rightValue := source.GetPageSize()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
		return 0, false
	case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
		return 0, false
	case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
		leftValue := fpv.value.(string)
		rightValue := source.GetResumeToken()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
		leftValue := fpv.value.(*timestamp.Timestamp)
		rightValue := source.GetStartingTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsRequest_FieldPathSelectorFilter:
		return 0, false
	case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
		return 0, false
	case WatchLimitPoolsRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
		leftValue := fpv.value.(int32)
		rightValue := source.GetMaxChunkSize()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsRequest: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolsRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitPoolsRequest))
}

// WatchLimitPoolsRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for WatchLimitPoolsRequest according to their type
// Present only for array (repeated) types.
type WatchLimitPoolsRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitPoolsRequest_FieldPath
	ContainsValue(*WatchLimitPoolsRequest) bool
}

// ParseWatchLimitPoolsRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitPoolsRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolsRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitPoolsRequest_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitPoolsRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitPoolsRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitPoolsRequest_FieldTerminalPathArrayItemValue struct {
	WatchLimitPoolsRequest_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolsRequest_FieldPathArrayItemValue = (*WatchLimitPoolsRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitPoolsRequest as interface{}
func (fpaiv *WatchLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WatchLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitPoolsRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitPoolsRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitPoolsRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitPoolsRequest'
func (fpaiv *WatchLimitPoolsRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitPoolsRequest) bool {
	slice := fpaiv.WatchLimitPoolsRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WatchLimitPoolsRequest_FieldPathArrayOfValues allows storing slice of values for WatchLimitPoolsRequest fields according to their type
type WatchLimitPoolsRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitPoolsRequest_FieldPath
}

func ParseWatchLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitPoolsRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitPoolsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolsRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitPoolsRequest_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitPoolsRequest_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitPoolsRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues struct {
	WatchLimitPoolsRequest_FieldTerminalPath
	values interface{}
}

var _ WatchLimitPoolsRequest_FieldPathArrayOfValues = (*WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitPoolsRequest_FieldPathSelectorType:
		for _, v := range fpaov.values.([]watch_type.WatchType) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorParent:
		for _, v := range fpaov.values.([]*limit_pool.ParentReference) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
		for _, v := range fpaov.values.([]*limit_pool.PagerCursor) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
		for _, v := range fpaov.values.([]*limit_pool.OrderBy) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorStartingTime:
		for _, v := range fpaov.values.([]*timestamp.Timestamp) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorFilter:
		for _, v := range fpaov.values.([]*limit_pool.Filter) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool_FieldMask) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsTypeArrayOfValues() ([]watch_type.WatchType, bool) {
	res, ok := fpaov.values.([]watch_type.WatchType)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsParentArrayOfValues() ([]*limit_pool.ParentReference, bool) {
	res, ok := fpaov.values.([]*limit_pool.ParentReference)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsPageSizeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsPageTokenArrayOfValues() ([]*limit_pool.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit_pool.PagerCursor)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsOrderByArrayOfValues() ([]*limit_pool.OrderBy, bool) {
	res, ok := fpaov.values.([]*limit_pool.OrderBy)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsResumeTokenArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsStartingTimeArrayOfValues() ([]*timestamp.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamp.Timestamp)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsFilterArrayOfValues() ([]*limit_pool.Filter, bool) {
	res, ok := fpaov.values.([]*limit_pool.Filter)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}
func (fpaov *WatchLimitPoolsRequest_FieldTerminalPathArrayOfValues) AsMaxChunkSizeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitPoolsResponse_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitPoolsResponse_FieldPathSelector
	Get(source *WatchLimitPoolsResponse) []interface{}
	GetSingle(source *WatchLimitPoolsResponse) (interface{}, bool)
	ClearValue(item *WatchLimitPoolsResponse)

	// Those methods build corresponding WatchLimitPoolsResponse_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitPoolsResponse_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitPoolsResponse_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitPoolsResponse_FieldPathArrayItemValue
}

type WatchLimitPoolsResponse_FieldPathSelector int32

const (
	WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges WatchLimitPoolsResponse_FieldPathSelector = 0
	WatchLimitPoolsResponse_FieldPathSelectorIsCurrent        WatchLimitPoolsResponse_FieldPathSelector = 1
	WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange  WatchLimitPoolsResponse_FieldPathSelector = 2
	WatchLimitPoolsResponse_FieldPathSelectorResumeToken      WatchLimitPoolsResponse_FieldPathSelector = 3
	WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize     WatchLimitPoolsResponse_FieldPathSelector = 4
	WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset      WatchLimitPoolsResponse_FieldPathSelector = 5
	WatchLimitPoolsResponse_FieldPathSelectorIsHardReset      WatchLimitPoolsResponse_FieldPathSelector = 6
)

func (s WatchLimitPoolsResponse_FieldPathSelector) String() string {
	switch s {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		return "limit_pool_changes"
	case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
		return "is_current"
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		return "page_token_change"
	case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
		return "resume_token"
	case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
		return "snapshot_size"
	case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
		return "is_soft_reset"
	case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
		return "is_hard_reset"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", s))
	}
}

func BuildWatchLimitPoolsResponse_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitPoolsResponse_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitPoolsResponse")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limit_pool_changes", "limitPoolChanges", "limit-pool-changes":
			return &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges}, nil
		case "is_current", "isCurrent", "is-current":
			return &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorIsCurrent}, nil
		case "page_token_change", "pageTokenChange", "page-token-change":
			return &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange}, nil
		case "resume_token", "resumeToken", "resume-token":
			return &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorResumeToken}, nil
		case "snapshot_size", "snapshotSize", "snapshot-size":
			return &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize}, nil
		case "is_soft_reset", "isSoftReset", "is-soft-reset":
			return &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset}, nil
		case "is_hard_reset", "isHardReset", "is-hard-reset":
			return &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorIsHardReset}, nil
		}
	} else {
		switch fp[0] {
		case "page_token_change", "pageTokenChange", "page-token-change":
			if subpath, err := BuildWatchLimitPoolsResponsePageTokenChange_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &WatchLimitPoolsResponse_FieldSubPath{selector: WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitPoolsResponse", fp)
}

func ParseWatchLimitPoolsResponse_FieldPath(rawField string) (WatchLimitPoolsResponse_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitPoolsResponse_FieldPath(fp)
}

func MustParseWatchLimitPoolsResponse_FieldPath(rawField string) WatchLimitPoolsResponse_FieldPath {
	fp, err := ParseWatchLimitPoolsResponse_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitPoolsResponse_FieldTerminalPath struct {
	selector WatchLimitPoolsResponse_FieldPathSelector
}

var _ WatchLimitPoolsResponse_FieldPath = (*WatchLimitPoolsResponse_FieldTerminalPath)(nil)

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) Selector() WatchLimitPoolsResponse_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitPoolsResponse_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitPoolsResponse_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitPoolsResponse
func (fp *WatchLimitPoolsResponse_FieldTerminalPath) Get(source *WatchLimitPoolsResponse) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
			for _, value := range source.GetLimitPoolChanges() {
				values = append(values, value)
			}
		case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
			values = append(values, source.IsCurrent)
		case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
			if source.PageTokenChange != nil {
				values = append(values, source.PageTokenChange)
			}
		case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
			values = append(values, source.ResumeToken)
		case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
			values = append(values, source.SnapshotSize)
		case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
			values = append(values, source.IsSoftReset)
		case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
			values = append(values, source.IsHardReset)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitPoolsResponse))
}

// GetSingle returns value pointed by specific field of from source WatchLimitPoolsResponse
func (fp *WatchLimitPoolsResponse_FieldTerminalPath) GetSingle(source *WatchLimitPoolsResponse) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		res := source.GetLimitPoolChanges()
		return res, res != nil
	case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
		return source.GetIsCurrent(), source != nil
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		res := source.GetPageTokenChange()
		return res, res != nil
	case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
		return source.GetResumeToken(), source != nil
	case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
		return source.GetSnapshotSize(), source != nil
	case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
		return source.GetIsSoftReset(), source != nil
	case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
		return source.GetIsHardReset(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitPoolsResponse))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitPoolsResponse_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		return ([]*limit_pool.LimitPoolChange)(nil)
	case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
		return false
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		return (*WatchLimitPoolsResponse_PageTokenChange)(nil)
	case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
		return ""
	case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
		return int64(0)
	case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
		return false
	case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) ClearValue(item *WatchLimitPoolsResponse) {
	if item != nil {
		switch fp.selector {
		case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
			item.LimitPoolChanges = nil
		case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
			item.IsCurrent = false
		case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
			item.PageTokenChange = nil
		case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
			item.ResumeToken = ""
		case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
			item.SnapshotSize = int64(0)
		case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
			item.IsSoftReset = false
		case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
			item.IsHardReset = false
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitPoolsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitPoolsResponse_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges ||
		fp.selector == WatchLimitPoolsResponse_FieldPathSelectorIsCurrent ||
		fp.selector == WatchLimitPoolsResponse_FieldPathSelectorResumeToken ||
		fp.selector == WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize ||
		fp.selector == WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset ||
		fp.selector == WatchLimitPoolsResponse_FieldPathSelectorIsHardReset
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) WithIValue(value interface{}) WatchLimitPoolsResponse_FieldPathValue {
	switch fp.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		return &WatchLimitPoolsResponse_FieldTerminalPathValue{WatchLimitPoolsResponse_FieldTerminalPath: *fp, value: value.([]*limit_pool.LimitPoolChange)}
	case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
		return &WatchLimitPoolsResponse_FieldTerminalPathValue{WatchLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(bool)}
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		return &WatchLimitPoolsResponse_FieldTerminalPathValue{WatchLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(*WatchLimitPoolsResponse_PageTokenChange)}
	case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
		return &WatchLimitPoolsResponse_FieldTerminalPathValue{WatchLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(string)}
	case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
		return &WatchLimitPoolsResponse_FieldTerminalPathValue{WatchLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(int64)}
	case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
		return &WatchLimitPoolsResponse_FieldTerminalPathValue{WatchLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(bool)}
	case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
		return &WatchLimitPoolsResponse_FieldTerminalPathValue{WatchLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitPoolsResponse_FieldPathArrayOfValues {
	fpaov := &WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponse_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		return &WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([][]*limit_pool.LimitPoolChange)}
	case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
		return &WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]bool)}
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		return &WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]*WatchLimitPoolsResponse_PageTokenChange)}
	case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
		return &WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]string)}
	case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
		return &WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]int64)}
	case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
		return &WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]bool)}
	case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
		return &WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponse_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitPoolsResponse_FieldPathArrayItemValue {
	switch fp.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		return &WatchLimitPoolsResponse_FieldTerminalPathArrayItemValue{WatchLimitPoolsResponse_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPoolChange)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsResponse_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type WatchLimitPoolsResponse_FieldSubPath struct {
	selector WatchLimitPoolsResponse_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ WatchLimitPoolsResponse_FieldPath = (*WatchLimitPoolsResponse_FieldSubPath)(nil)

func (fps *WatchLimitPoolsResponse_FieldSubPath) Selector() WatchLimitPoolsResponse_FieldPathSelector {
	return fps.selector
}
func (fps *WatchLimitPoolsResponse_FieldSubPath) AsPageTokenChangeSubPath() (WatchLimitPoolsResponsePageTokenChange_FieldPath, bool) {
	res, ok := fps.subPath.(WatchLimitPoolsResponsePageTokenChange_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *WatchLimitPoolsResponse_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *WatchLimitPoolsResponse_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source WatchLimitPoolsResponse
func (fps *WatchLimitPoolsResponse_FieldSubPath) Get(source *WatchLimitPoolsResponse) (values []interface{}) {
	switch fps.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		values = append(values, fps.subPath.GetRaw(source.GetPageTokenChange())...)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fps.selector))
	}
	return
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*WatchLimitPoolsResponse))
}

// GetSingle returns value of selected field from source WatchLimitPoolsResponse
func (fps *WatchLimitPoolsResponse_FieldSubPath) GetSingle(source *WatchLimitPoolsResponse) (interface{}, bool) {
	switch fps.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		if source.GetPageTokenChange() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetPageTokenChange())
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fps.selector))
	}
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*WatchLimitPoolsResponse))
}

// GetDefault returns a default value of the field type
func (fps *WatchLimitPoolsResponse_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) ClearValue(item *WatchLimitPoolsResponse) {
	if item != nil {
		switch fps.selector {
		case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
			fps.subPath.ClearValueRaw(item.PageTokenChange)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fps.selector))
		}
	}
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*WatchLimitPoolsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fps *WatchLimitPoolsResponse_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&WatchLimitPoolsResponse_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) WithIValue(value interface{}) WatchLimitPoolsResponse_FieldPathValue {
	return &WatchLimitPoolsResponse_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) WithIArrayOfValues(values interface{}) WatchLimitPoolsResponse_FieldPathArrayOfValues {
	return &WatchLimitPoolsResponse_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) WithIArrayItemValue(value interface{}) WatchLimitPoolsResponse_FieldPathArrayItemValue {
	return &WatchLimitPoolsResponse_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *WatchLimitPoolsResponse_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// WatchLimitPoolsResponse_FieldPathValue allows storing values for WatchLimitPoolsResponse fields according to their type
type WatchLimitPoolsResponse_FieldPathValue interface {
	WatchLimitPoolsResponse_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitPoolsResponse)
	CompareWith(*WatchLimitPoolsResponse) (cmp int, comparable bool)
}

func ParseWatchLimitPoolsResponse_FieldPathValue(pathStr, valueStr string) (WatchLimitPoolsResponse_FieldPathValue, error) {
	fp, err := ParseWatchLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolsResponse field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitPoolsResponse_FieldPathValue), nil
}

func MustParseWatchLimitPoolsResponse_FieldPathValue(pathStr, valueStr string) WatchLimitPoolsResponse_FieldPathValue {
	fpv, err := ParseWatchLimitPoolsResponse_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitPoolsResponse_FieldTerminalPathValue struct {
	WatchLimitPoolsResponse_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolsResponse_FieldPathValue = (*WatchLimitPoolsResponse_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WatchLimitPoolsResponse' as interface{}
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) AsLimitPoolChangesValue() ([]*limit_pool.LimitPoolChange, bool) {
	res, ok := fpv.value.([]*limit_pool.LimitPoolChange)
	return res, ok
}
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) AsIsCurrentValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) AsPageTokenChangeValue() (*WatchLimitPoolsResponse_PageTokenChange, bool) {
	res, ok := fpv.value.(*WatchLimitPoolsResponse_PageTokenChange)
	return res, ok
}
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) AsResumeTokenValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) AsSnapshotSizeValue() (int64, bool) {
	res, ok := fpv.value.(int64)
	return res, ok
}
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) AsIsSoftResetValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) AsIsHardResetValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object WatchLimitPoolsResponse
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) SetTo(target **WatchLimitPoolsResponse) {
	if *target == nil {
		*target = new(WatchLimitPoolsResponse)
	}
	switch fpv.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		(*target).LimitPoolChanges = fpv.value.([]*limit_pool.LimitPoolChange)
	case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
		(*target).IsCurrent = fpv.value.(bool)
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		(*target).PageTokenChange = fpv.value.(*WatchLimitPoolsResponse_PageTokenChange)
	case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
		(*target).ResumeToken = fpv.value.(string)
	case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
		(*target).SnapshotSize = fpv.value.(int64)
	case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
		(*target).IsSoftReset = fpv.value.(bool)
	case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
		(*target).IsHardReset = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitPoolsResponse)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitPoolsResponse_FieldTerminalPathValue' with the value under path in 'WatchLimitPoolsResponse'.
func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) CompareWith(source *WatchLimitPoolsResponse) (int, bool) {
	switch fpv.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		return 0, false
	case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
		leftValue := fpv.value.(bool)
		rightValue := source.GetIsCurrent()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		return 0, false
	case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
		leftValue := fpv.value.(string)
		rightValue := source.GetResumeToken()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
		leftValue := fpv.value.(int64)
		rightValue := source.GetSnapshotSize()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
		leftValue := fpv.value.(bool)
		rightValue := source.GetIsSoftReset()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
		leftValue := fpv.value.(bool)
		rightValue := source.GetIsHardReset()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolsResponse_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitPoolsResponse))
}

type WatchLimitPoolsResponse_FieldSubPathValue struct {
	WatchLimitPoolsResponse_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ WatchLimitPoolsResponse_FieldPathValue = (*WatchLimitPoolsResponse_FieldSubPathValue)(nil)

func (fpvs *WatchLimitPoolsResponse_FieldSubPathValue) AsPageTokenChangePathValue() (WatchLimitPoolsResponsePageTokenChange_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(WatchLimitPoolsResponsePageTokenChange_FieldPathValue)
	return res, ok
}

func (fpvs *WatchLimitPoolsResponse_FieldSubPathValue) SetTo(target **WatchLimitPoolsResponse) {
	if *target == nil {
		*target = new(WatchLimitPoolsResponse)
	}
	switch fpvs.Selector() {
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		fpvs.subPathValue.(WatchLimitPoolsResponsePageTokenChange_FieldPathValue).SetTo(&(*target).PageTokenChange)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *WatchLimitPoolsResponse_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitPoolsResponse)
	fpvs.SetTo(&typedObject)
}

func (fpvs *WatchLimitPoolsResponse_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *WatchLimitPoolsResponse_FieldSubPathValue) CompareWith(source *WatchLimitPoolsResponse) (int, bool) {
	switch fpvs.Selector() {
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		return fpvs.subPathValue.(WatchLimitPoolsResponsePageTokenChange_FieldPathValue).CompareWith(source.GetPageTokenChange())
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *WatchLimitPoolsResponse_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*WatchLimitPoolsResponse))
}

// WatchLimitPoolsResponse_FieldPathArrayItemValue allows storing single item in Path-specific values for WatchLimitPoolsResponse according to their type
// Present only for array (repeated) types.
type WatchLimitPoolsResponse_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitPoolsResponse_FieldPath
	ContainsValue(*WatchLimitPoolsResponse) bool
}

// ParseWatchLimitPoolsResponse_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitPoolsResponse_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolsResponse field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitPoolsResponse_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitPoolsResponse_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitPoolsResponse_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitPoolsResponse_FieldTerminalPathArrayItemValue struct {
	WatchLimitPoolsResponse_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolsResponse_FieldPathArrayItemValue = (*WatchLimitPoolsResponse_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitPoolsResponse as interface{}
func (fpaiv *WatchLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *WatchLimitPoolsResponse_FieldTerminalPathArrayItemValue) AsLimitPoolChangesItemValue() (*limit_pool.LimitPoolChange, bool) {
	res, ok := fpaiv.value.(*limit_pool.LimitPoolChange)
	return res, ok
}

func (fpaiv *WatchLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitPoolsResponse) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitPoolsResponse_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitPoolsResponse))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitPoolsResponse'
func (fpaiv *WatchLimitPoolsResponse_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitPoolsResponse) bool {
	slice := fpaiv.WatchLimitPoolsResponse_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type WatchLimitPoolsResponse_FieldSubPathArrayItemValue struct {
	WatchLimitPoolsResponse_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *WatchLimitPoolsResponse_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *WatchLimitPoolsResponse_FieldSubPathArrayItemValue) AsPageTokenChangePathItemValue() (WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitPoolsResponse'
func (fpaivs *WatchLimitPoolsResponse_FieldSubPathArrayItemValue) ContainsValue(source *WatchLimitPoolsResponse) bool {
	switch fpaivs.Selector() {
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		return fpaivs.subPathItemValue.(WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue).ContainsValue(source.GetPageTokenChange())
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse: %d", fpaivs.Selector()))
	}
}

// WatchLimitPoolsResponse_FieldPathArrayOfValues allows storing slice of values for WatchLimitPoolsResponse fields according to their type
type WatchLimitPoolsResponse_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitPoolsResponse_FieldPath
}

func ParseWatchLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitPoolsResponse_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitPoolsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitPoolsResponse field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitPoolsResponse_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitPoolsResponse_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitPoolsResponse_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues struct {
	WatchLimitPoolsResponse_FieldTerminalPath
	values interface{}
}

var _ WatchLimitPoolsResponse_FieldPathArrayOfValues = (*WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
		for _, v := range fpaov.values.([][]*limit_pool.LimitPoolChange) {
			values = append(values, v)
		}
	case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
		for _, v := range fpaov.values.([]*WatchLimitPoolsResponse_PageTokenChange) {
			values = append(values, v)
		}
	case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
		for _, v := range fpaov.values.([]int64) {
			values = append(values, v)
		}
	case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsLimitPoolChangesArrayOfValues() ([][]*limit_pool.LimitPoolChange, bool) {
	res, ok := fpaov.values.([][]*limit_pool.LimitPoolChange)
	return res, ok
}
func (fpaov *WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsIsCurrentArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsPageTokenChangeArrayOfValues() ([]*WatchLimitPoolsResponse_PageTokenChange, bool) {
	res, ok := fpaov.values.([]*WatchLimitPoolsResponse_PageTokenChange)
	return res, ok
}
func (fpaov *WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsResumeTokenArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsSnapshotSizeArrayOfValues() ([]int64, bool) {
	res, ok := fpaov.values.([]int64)
	return res, ok
}
func (fpaov *WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsIsSoftResetArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *WatchLimitPoolsResponse_FieldTerminalPathArrayOfValues) AsIsHardResetArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

type WatchLimitPoolsResponse_FieldSubPathArrayOfValues struct {
	WatchLimitPoolsResponse_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ WatchLimitPoolsResponse_FieldPathArrayOfValues = (*WatchLimitPoolsResponse_FieldSubPathArrayOfValues)(nil)

func (fpsaov *WatchLimitPoolsResponse_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *WatchLimitPoolsResponse_FieldSubPathArrayOfValues) AsPageTokenChangePathArrayOfValues() (WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitPoolsResponsePageTokenChange_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitPoolsResponsePageTokenChange_FieldPathSelector
	Get(source *WatchLimitPoolsResponse_PageTokenChange) []interface{}
	GetSingle(source *WatchLimitPoolsResponse_PageTokenChange) (interface{}, bool)
	ClearValue(item *WatchLimitPoolsResponse_PageTokenChange)

	// Those methods build corresponding WatchLimitPoolsResponsePageTokenChange_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitPoolsResponsePageTokenChange_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue
}

type WatchLimitPoolsResponsePageTokenChange_FieldPathSelector int32

const (
	WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken WatchLimitPoolsResponsePageTokenChange_FieldPathSelector = 0
	WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken WatchLimitPoolsResponsePageTokenChange_FieldPathSelector = 1
)

func (s WatchLimitPoolsResponsePageTokenChange_FieldPathSelector) String() string {
	switch s {
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return "prev_page_token"
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return "next_page_token"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", s))
	}
}

func BuildWatchLimitPoolsResponsePageTokenChange_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitPoolsResponsePageTokenChange_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitPoolsResponse_PageTokenChange")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "prev_page_token", "prevPageToken", "prev-page-token":
			return &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath{selector: WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken}, nil
		case "next_page_token", "nextPageToken", "next-page-token":
			return &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath{selector: WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitPoolsResponse_PageTokenChange", fp)
}

func ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(rawField string) (WatchLimitPoolsResponsePageTokenChange_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitPoolsResponsePageTokenChange_FieldPath(fp)
}

func MustParseWatchLimitPoolsResponsePageTokenChange_FieldPath(rawField string) WatchLimitPoolsResponsePageTokenChange_FieldPath {
	fp, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath struct {
	selector WatchLimitPoolsResponsePageTokenChange_FieldPathSelector
}

var _ WatchLimitPoolsResponsePageTokenChange_FieldPath = (*WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath)(nil)

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) Selector() WatchLimitPoolsResponsePageTokenChange_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitPoolsResponse_PageTokenChange
func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) Get(source *WatchLimitPoolsResponse_PageTokenChange) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
			if source.PrevPageToken != nil {
				values = append(values, source.PrevPageToken)
			}
		case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
			if source.NextPageToken != nil {
				values = append(values, source.NextPageToken)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitPoolsResponse_PageTokenChange))
}

// GetSingle returns value pointed by specific field of from source WatchLimitPoolsResponse_PageTokenChange
func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) GetSingle(source *WatchLimitPoolsResponse_PageTokenChange) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		res := source.GetPrevPageToken()
		return res, res != nil
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		res := source.GetNextPageToken()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitPoolsResponse_PageTokenChange))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return (*limit_pool.PagerCursor)(nil)
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return (*limit_pool.PagerCursor)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) ClearValue(item *WatchLimitPoolsResponse_PageTokenChange) {
	if item != nil {
		switch fp.selector {
		case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
			item.PrevPageToken = nil
		case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
			item.NextPageToken = nil
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitPoolsResponse_PageTokenChange))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken ||
		fp.selector == WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) WithIValue(value interface{}) WatchLimitPoolsResponsePageTokenChange_FieldPathValue {
	switch fp.selector {
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue{WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath: *fp, value: value.(*limit_pool.PagerCursor)}
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue{WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath: *fp, value: value.(*limit_pool.PagerCursor)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues {
	fpaov := &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath: *fp, values: values.([]*limit_pool.PagerCursor)}
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayOfValues{WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath: *fp, values: values.([]*limit_pool.PagerCursor)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fp.selector))
	}
}

func (fp *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WatchLimitPoolsResponsePageTokenChange_FieldPathValue allows storing values for PageTokenChange fields according to their type
type WatchLimitPoolsResponsePageTokenChange_FieldPathValue interface {
	WatchLimitPoolsResponsePageTokenChange_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitPoolsResponse_PageTokenChange)
	CompareWith(*WatchLimitPoolsResponse_PageTokenChange) (cmp int, comparable bool)
}

func ParseWatchLimitPoolsResponsePageTokenChange_FieldPathValue(pathStr, valueStr string) (WatchLimitPoolsResponsePageTokenChange_FieldPathValue, error) {
	fp, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PageTokenChange field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitPoolsResponsePageTokenChange_FieldPathValue), nil
}

func MustParseWatchLimitPoolsResponsePageTokenChange_FieldPathValue(pathStr, valueStr string) WatchLimitPoolsResponsePageTokenChange_FieldPathValue {
	fpv, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue struct {
	WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolsResponsePageTokenChange_FieldPathValue = (*WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'PageTokenChange' as interface{}
func (fpv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue) AsPrevPageTokenValue() (*limit_pool.PagerCursor, bool) {
	res, ok := fpv.value.(*limit_pool.PagerCursor)
	return res, ok
}
func (fpv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue) AsNextPageTokenValue() (*limit_pool.PagerCursor, bool) {
	res, ok := fpv.value.(*limit_pool.PagerCursor)
	return res, ok
}

// SetTo stores value for selected field for object PageTokenChange
func (fpv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue) SetTo(target **WatchLimitPoolsResponse_PageTokenChange) {
	if *target == nil {
		*target = new(WatchLimitPoolsResponse_PageTokenChange)
	}
	switch fpv.selector {
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		(*target).PrevPageToken = fpv.value.(*limit_pool.PagerCursor)
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		(*target).NextPageToken = fpv.value.(*limit_pool.PagerCursor)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitPoolsResponse_PageTokenChange)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue' with the value under path in 'WatchLimitPoolsResponse_PageTokenChange'.
func (fpv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue) CompareWith(source *WatchLimitPoolsResponse_PageTokenChange) (int, bool) {
	switch fpv.selector {
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return 0, false
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitPoolsResponse_PageTokenChange: %d", fpv.selector))
	}
}

func (fpv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitPoolsResponse_PageTokenChange))
}

// WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue allows storing single item in Path-specific values for PageTokenChange according to their type
// Present only for array (repeated) types.
type WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitPoolsResponsePageTokenChange_FieldPath
	ContainsValue(*WatchLimitPoolsResponse_PageTokenChange) bool
}

// ParseWatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PageTokenChange field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayItemValue struct {
	WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath
	value interface{}
}

var _ WatchLimitPoolsResponsePageTokenChange_FieldPathArrayItemValue = (*WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitPoolsResponse_PageTokenChange as interface{}
func (fpaiv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitPoolsResponse_PageTokenChange) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitPoolsResponse_PageTokenChange))
}

// Contains returns a boolean indicating if value that is being held is present in given 'PageTokenChange'
func (fpaiv *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitPoolsResponse_PageTokenChange) bool {
	slice := fpaiv.WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues allows storing slice of values for PageTokenChange fields according to their type
type WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitPoolsResponsePageTokenChange_FieldPath
}

func ParseWatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PageTokenChange field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayOfValues struct {
	WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath
	values interface{}
}

var _ WatchLimitPoolsResponsePageTokenChange_FieldPathArrayOfValues = (*WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		for _, v := range fpaov.values.([]*limit_pool.PagerCursor) {
			values = append(values, v)
		}
	case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		for _, v := range fpaov.values.([]*limit_pool.PagerCursor) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayOfValues) AsPrevPageTokenArrayOfValues() ([]*limit_pool.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit_pool.PagerCursor)
	return res, ok
}
func (fpaov *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPathArrayOfValues) AsNextPageTokenArrayOfValues() ([]*limit_pool.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit_pool.PagerCursor)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type UpdateLimitPoolRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() UpdateLimitPoolRequest_FieldPathSelector
	Get(source *UpdateLimitPoolRequest) []interface{}
	GetSingle(source *UpdateLimitPoolRequest) (interface{}, bool)
	ClearValue(item *UpdateLimitPoolRequest)

	// Those methods build corresponding UpdateLimitPoolRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) UpdateLimitPoolRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) UpdateLimitPoolRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) UpdateLimitPoolRequest_FieldPathArrayItemValue
}

type UpdateLimitPoolRequest_FieldPathSelector int32

const (
	UpdateLimitPoolRequest_FieldPathSelectorLimitPool  UpdateLimitPoolRequest_FieldPathSelector = 0
	UpdateLimitPoolRequest_FieldPathSelectorUpdateMask UpdateLimitPoolRequest_FieldPathSelector = 1
	UpdateLimitPoolRequest_FieldPathSelectorCas        UpdateLimitPoolRequest_FieldPathSelector = 2
)

func (s UpdateLimitPoolRequest_FieldPathSelector) String() string {
	switch s {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		return "limit_pool"
	case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
		return "update_mask"
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		return "cas"
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", s))
	}
}

func BuildUpdateLimitPoolRequest_FieldPath(fp gotenobject.RawFieldPath) (UpdateLimitPoolRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object UpdateLimitPoolRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limit_pool", "limitPool", "limit-pool":
			return &UpdateLimitPoolRequest_FieldTerminalPath{selector: UpdateLimitPoolRequest_FieldPathSelectorLimitPool}, nil
		case "update_mask", "updateMask", "update-mask":
			return &UpdateLimitPoolRequest_FieldTerminalPath{selector: UpdateLimitPoolRequest_FieldPathSelectorUpdateMask}, nil
		case "cas":
			return &UpdateLimitPoolRequest_FieldTerminalPath{selector: UpdateLimitPoolRequest_FieldPathSelectorCas}, nil
		}
	} else {
		switch fp[0] {
		case "limit_pool", "limitPool", "limit-pool":
			if subpath, err := limit_pool.BuildLimitPool_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &UpdateLimitPoolRequest_FieldSubPath{selector: UpdateLimitPoolRequest_FieldPathSelectorLimitPool, subPath: subpath}, nil
			}
		case "cas":
			if subpath, err := BuildUpdateLimitPoolRequestCAS_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &UpdateLimitPoolRequest_FieldSubPath{selector: UpdateLimitPoolRequest_FieldPathSelectorCas, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object UpdateLimitPoolRequest", fp)
}

func ParseUpdateLimitPoolRequest_FieldPath(rawField string) (UpdateLimitPoolRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildUpdateLimitPoolRequest_FieldPath(fp)
}

func MustParseUpdateLimitPoolRequest_FieldPath(rawField string) UpdateLimitPoolRequest_FieldPath {
	fp, err := ParseUpdateLimitPoolRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type UpdateLimitPoolRequest_FieldTerminalPath struct {
	selector UpdateLimitPoolRequest_FieldPathSelector
}

var _ UpdateLimitPoolRequest_FieldPath = (*UpdateLimitPoolRequest_FieldTerminalPath)(nil)

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) Selector() UpdateLimitPoolRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *UpdateLimitPoolRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *UpdateLimitPoolRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source UpdateLimitPoolRequest
func (fp *UpdateLimitPoolRequest_FieldTerminalPath) Get(source *UpdateLimitPoolRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
			if source.LimitPool != nil {
				values = append(values, source.LimitPool)
			}
		case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
			if source.UpdateMask != nil {
				values = append(values, source.UpdateMask)
			}
		case UpdateLimitPoolRequest_FieldPathSelectorCas:
			if source.Cas != nil {
				values = append(values, source.Cas)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*UpdateLimitPoolRequest))
}

// GetSingle returns value pointed by specific field of from source UpdateLimitPoolRequest
func (fp *UpdateLimitPoolRequest_FieldTerminalPath) GetSingle(source *UpdateLimitPoolRequest) (interface{}, bool) {
	switch fp.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		res := source.GetLimitPool()
		return res, res != nil
	case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
		res := source.GetUpdateMask()
		return res, res != nil
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		res := source.GetCas()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*UpdateLimitPoolRequest))
}

// GetDefault returns a default value of the field type
func (fp *UpdateLimitPoolRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		return (*limit_pool.LimitPool)(nil)
	case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
		return (*limit_pool.LimitPool_FieldMask)(nil)
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		return (*UpdateLimitPoolRequest_CAS)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) ClearValue(item *UpdateLimitPoolRequest) {
	if item != nil {
		switch fp.selector {
		case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
			item.LimitPool = nil
		case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
			item.UpdateMask = nil
		case UpdateLimitPoolRequest_FieldPathSelectorCas:
			item.Cas = nil
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fp.selector))
		}
	}
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*UpdateLimitPoolRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *UpdateLimitPoolRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == UpdateLimitPoolRequest_FieldPathSelectorUpdateMask
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) WithIValue(value interface{}) UpdateLimitPoolRequest_FieldPathValue {
	switch fp.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		return &UpdateLimitPoolRequest_FieldTerminalPathValue{UpdateLimitPoolRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool)}
	case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
		return &UpdateLimitPoolRequest_FieldTerminalPathValue{UpdateLimitPoolRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool_FieldMask)}
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		return &UpdateLimitPoolRequest_FieldTerminalPathValue{UpdateLimitPoolRequest_FieldTerminalPath: *fp, value: value.(*UpdateLimitPoolRequest_CAS)}
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) UpdateLimitPoolRequest_FieldPathArrayOfValues {
	fpaov := &UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues{UpdateLimitPoolRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		return &UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues{UpdateLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool)}
	case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
		return &UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues{UpdateLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool_FieldMask)}
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		return &UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues{UpdateLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]*UpdateLimitPoolRequest_CAS)}
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) UpdateLimitPoolRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *UpdateLimitPoolRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type UpdateLimitPoolRequest_FieldSubPath struct {
	selector UpdateLimitPoolRequest_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ UpdateLimitPoolRequest_FieldPath = (*UpdateLimitPoolRequest_FieldSubPath)(nil)

func (fps *UpdateLimitPoolRequest_FieldSubPath) Selector() UpdateLimitPoolRequest_FieldPathSelector {
	return fps.selector
}
func (fps *UpdateLimitPoolRequest_FieldSubPath) AsLimitPoolSubPath() (limit_pool.LimitPool_FieldPath, bool) {
	res, ok := fps.subPath.(limit_pool.LimitPool_FieldPath)
	return res, ok
}
func (fps *UpdateLimitPoolRequest_FieldSubPath) AsCasSubPath() (UpdateLimitPoolRequestCAS_FieldPath, bool) {
	res, ok := fps.subPath.(UpdateLimitPoolRequestCAS_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *UpdateLimitPoolRequest_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *UpdateLimitPoolRequest_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source UpdateLimitPoolRequest
func (fps *UpdateLimitPoolRequest_FieldSubPath) Get(source *UpdateLimitPoolRequest) (values []interface{}) {
	switch fps.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		values = append(values, fps.subPath.GetRaw(source.GetLimitPool())...)
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		values = append(values, fps.subPath.GetRaw(source.GetCas())...)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fps.selector))
	}
	return
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*UpdateLimitPoolRequest))
}

// GetSingle returns value of selected field from source UpdateLimitPoolRequest
func (fps *UpdateLimitPoolRequest_FieldSubPath) GetSingle(source *UpdateLimitPoolRequest) (interface{}, bool) {
	switch fps.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		if source.GetLimitPool() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetLimitPool())
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		if source.GetCas() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetCas())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fps.selector))
	}
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*UpdateLimitPoolRequest))
}

// GetDefault returns a default value of the field type
func (fps *UpdateLimitPoolRequest_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) ClearValue(item *UpdateLimitPoolRequest) {
	if item != nil {
		switch fps.selector {
		case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
			fps.subPath.ClearValueRaw(item.LimitPool)
		case UpdateLimitPoolRequest_FieldPathSelectorCas:
			fps.subPath.ClearValueRaw(item.Cas)
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fps.selector))
		}
	}
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*UpdateLimitPoolRequest))
}

// IsLeaf - whether field path is holds simple value
func (fps *UpdateLimitPoolRequest_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&UpdateLimitPoolRequest_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) WithIValue(value interface{}) UpdateLimitPoolRequest_FieldPathValue {
	return &UpdateLimitPoolRequest_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) WithIArrayOfValues(values interface{}) UpdateLimitPoolRequest_FieldPathArrayOfValues {
	return &UpdateLimitPoolRequest_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) WithIArrayItemValue(value interface{}) UpdateLimitPoolRequest_FieldPathArrayItemValue {
	return &UpdateLimitPoolRequest_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *UpdateLimitPoolRequest_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// UpdateLimitPoolRequest_FieldPathValue allows storing values for UpdateLimitPoolRequest fields according to their type
type UpdateLimitPoolRequest_FieldPathValue interface {
	UpdateLimitPoolRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **UpdateLimitPoolRequest)
	CompareWith(*UpdateLimitPoolRequest) (cmp int, comparable bool)
}

func ParseUpdateLimitPoolRequest_FieldPathValue(pathStr, valueStr string) (UpdateLimitPoolRequest_FieldPathValue, error) {
	fp, err := ParseUpdateLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing UpdateLimitPoolRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(UpdateLimitPoolRequest_FieldPathValue), nil
}

func MustParseUpdateLimitPoolRequest_FieldPathValue(pathStr, valueStr string) UpdateLimitPoolRequest_FieldPathValue {
	fpv, err := ParseUpdateLimitPoolRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type UpdateLimitPoolRequest_FieldTerminalPathValue struct {
	UpdateLimitPoolRequest_FieldTerminalPath
	value interface{}
}

var _ UpdateLimitPoolRequest_FieldPathValue = (*UpdateLimitPoolRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'UpdateLimitPoolRequest' as interface{}
func (fpv *UpdateLimitPoolRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *UpdateLimitPoolRequest_FieldTerminalPathValue) AsLimitPoolValue() (*limit_pool.LimitPool, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool)
	return res, ok
}
func (fpv *UpdateLimitPoolRequest_FieldTerminalPathValue) AsUpdateMaskValue() (*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpv *UpdateLimitPoolRequest_FieldTerminalPathValue) AsCasValue() (*UpdateLimitPoolRequest_CAS, bool) {
	res, ok := fpv.value.(*UpdateLimitPoolRequest_CAS)
	return res, ok
}

// SetTo stores value for selected field for object UpdateLimitPoolRequest
func (fpv *UpdateLimitPoolRequest_FieldTerminalPathValue) SetTo(target **UpdateLimitPoolRequest) {
	if *target == nil {
		*target = new(UpdateLimitPoolRequest)
	}
	switch fpv.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		(*target).LimitPool = fpv.value.(*limit_pool.LimitPool)
	case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
		(*target).UpdateMask = fpv.value.(*limit_pool.LimitPool_FieldMask)
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		(*target).Cas = fpv.value.(*UpdateLimitPoolRequest_CAS)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fpv.selector))
	}
}

func (fpv *UpdateLimitPoolRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*UpdateLimitPoolRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'UpdateLimitPoolRequest_FieldTerminalPathValue' with the value under path in 'UpdateLimitPoolRequest'.
func (fpv *UpdateLimitPoolRequest_FieldTerminalPathValue) CompareWith(source *UpdateLimitPoolRequest) (int, bool) {
	switch fpv.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		return 0, false
	case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
		return 0, false
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fpv.selector))
	}
}

func (fpv *UpdateLimitPoolRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*UpdateLimitPoolRequest))
}

type UpdateLimitPoolRequest_FieldSubPathValue struct {
	UpdateLimitPoolRequest_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ UpdateLimitPoolRequest_FieldPathValue = (*UpdateLimitPoolRequest_FieldSubPathValue)(nil)

func (fpvs *UpdateLimitPoolRequest_FieldSubPathValue) AsLimitPoolPathValue() (limit_pool.LimitPool_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(limit_pool.LimitPool_FieldPathValue)
	return res, ok
}
func (fpvs *UpdateLimitPoolRequest_FieldSubPathValue) AsCasPathValue() (UpdateLimitPoolRequestCAS_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(UpdateLimitPoolRequestCAS_FieldPathValue)
	return res, ok
}

func (fpvs *UpdateLimitPoolRequest_FieldSubPathValue) SetTo(target **UpdateLimitPoolRequest) {
	if *target == nil {
		*target = new(UpdateLimitPoolRequest)
	}
	switch fpvs.Selector() {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		fpvs.subPathValue.(limit_pool.LimitPool_FieldPathValue).SetTo(&(*target).LimitPool)
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		fpvs.subPathValue.(UpdateLimitPoolRequestCAS_FieldPathValue).SetTo(&(*target).Cas)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fpvs.Selector()))
	}
}

func (fpvs *UpdateLimitPoolRequest_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*UpdateLimitPoolRequest)
	fpvs.SetTo(&typedObject)
}

func (fpvs *UpdateLimitPoolRequest_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *UpdateLimitPoolRequest_FieldSubPathValue) CompareWith(source *UpdateLimitPoolRequest) (int, bool) {
	switch fpvs.Selector() {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		return fpvs.subPathValue.(limit_pool.LimitPool_FieldPathValue).CompareWith(source.GetLimitPool())
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		return fpvs.subPathValue.(UpdateLimitPoolRequestCAS_FieldPathValue).CompareWith(source.GetCas())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fpvs.Selector()))
	}
}

func (fpvs *UpdateLimitPoolRequest_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*UpdateLimitPoolRequest))
}

// UpdateLimitPoolRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for UpdateLimitPoolRequest according to their type
// Present only for array (repeated) types.
type UpdateLimitPoolRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	UpdateLimitPoolRequest_FieldPath
	ContainsValue(*UpdateLimitPoolRequest) bool
}

// ParseUpdateLimitPoolRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseUpdateLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr string) (UpdateLimitPoolRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseUpdateLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing UpdateLimitPoolRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(UpdateLimitPoolRequest_FieldPathArrayItemValue), nil
}

func MustParseUpdateLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr string) UpdateLimitPoolRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseUpdateLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type UpdateLimitPoolRequest_FieldTerminalPathArrayItemValue struct {
	UpdateLimitPoolRequest_FieldTerminalPath
	value interface{}
}

var _ UpdateLimitPoolRequest_FieldPathArrayItemValue = (*UpdateLimitPoolRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object UpdateLimitPoolRequest as interface{}
func (fpaiv *UpdateLimitPoolRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *UpdateLimitPoolRequest_FieldTerminalPathArrayItemValue) GetSingle(source *UpdateLimitPoolRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *UpdateLimitPoolRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*UpdateLimitPoolRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'UpdateLimitPoolRequest'
func (fpaiv *UpdateLimitPoolRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *UpdateLimitPoolRequest) bool {
	slice := fpaiv.UpdateLimitPoolRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type UpdateLimitPoolRequest_FieldSubPathArrayItemValue struct {
	UpdateLimitPoolRequest_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *UpdateLimitPoolRequest_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *UpdateLimitPoolRequest_FieldSubPathArrayItemValue) AsLimitPoolPathItemValue() (limit_pool.LimitPool_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(limit_pool.LimitPool_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *UpdateLimitPoolRequest_FieldSubPathArrayItemValue) AsCasPathItemValue() (UpdateLimitPoolRequestCAS_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(UpdateLimitPoolRequestCAS_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'UpdateLimitPoolRequest'
func (fpaivs *UpdateLimitPoolRequest_FieldSubPathArrayItemValue) ContainsValue(source *UpdateLimitPoolRequest) bool {
	switch fpaivs.Selector() {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		return fpaivs.subPathItemValue.(limit_pool.LimitPool_FieldPathArrayItemValue).ContainsValue(source.GetLimitPool())
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		return fpaivs.subPathItemValue.(UpdateLimitPoolRequestCAS_FieldPathArrayItemValue).ContainsValue(source.GetCas())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest: %d", fpaivs.Selector()))
	}
}

// UpdateLimitPoolRequest_FieldPathArrayOfValues allows storing slice of values for UpdateLimitPoolRequest fields according to their type
type UpdateLimitPoolRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	UpdateLimitPoolRequest_FieldPath
}

func ParseUpdateLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (UpdateLimitPoolRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseUpdateLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing UpdateLimitPoolRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(UpdateLimitPoolRequest_FieldPathArrayOfValues), nil
}

func MustParseUpdateLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr string) UpdateLimitPoolRequest_FieldPathArrayOfValues {
	fpaov, err := ParseUpdateLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues struct {
	UpdateLimitPoolRequest_FieldTerminalPath
	values interface{}
}

var _ UpdateLimitPoolRequest_FieldPathArrayOfValues = (*UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool) {
			values = append(values, v)
		}
	case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool_FieldMask) {
			values = append(values, v)
		}
	case UpdateLimitPoolRequest_FieldPathSelectorCas:
		for _, v := range fpaov.values.([]*UpdateLimitPoolRequest_CAS) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues) AsLimitPoolArrayOfValues() ([]*limit_pool.LimitPool, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool)
	return res, ok
}
func (fpaov *UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues) AsUpdateMaskArrayOfValues() ([]*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool_FieldMask)
	return res, ok
}
func (fpaov *UpdateLimitPoolRequest_FieldTerminalPathArrayOfValues) AsCasArrayOfValues() ([]*UpdateLimitPoolRequest_CAS, bool) {
	res, ok := fpaov.values.([]*UpdateLimitPoolRequest_CAS)
	return res, ok
}

type UpdateLimitPoolRequest_FieldSubPathArrayOfValues struct {
	UpdateLimitPoolRequest_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ UpdateLimitPoolRequest_FieldPathArrayOfValues = (*UpdateLimitPoolRequest_FieldSubPathArrayOfValues)(nil)

func (fpsaov *UpdateLimitPoolRequest_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *UpdateLimitPoolRequest_FieldSubPathArrayOfValues) AsLimitPoolPathArrayOfValues() (limit_pool.LimitPool_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(limit_pool.LimitPool_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *UpdateLimitPoolRequest_FieldSubPathArrayOfValues) AsCasPathArrayOfValues() (UpdateLimitPoolRequestCAS_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(UpdateLimitPoolRequestCAS_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type UpdateLimitPoolRequestCAS_FieldPath interface {
	gotenobject.FieldPath
	Selector() UpdateLimitPoolRequestCAS_FieldPathSelector
	Get(source *UpdateLimitPoolRequest_CAS) []interface{}
	GetSingle(source *UpdateLimitPoolRequest_CAS) (interface{}, bool)
	ClearValue(item *UpdateLimitPoolRequest_CAS)

	// Those methods build corresponding UpdateLimitPoolRequestCAS_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) UpdateLimitPoolRequestCAS_FieldPathValue
	WithIArrayOfValues(values interface{}) UpdateLimitPoolRequestCAS_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) UpdateLimitPoolRequestCAS_FieldPathArrayItemValue
}

type UpdateLimitPoolRequestCAS_FieldPathSelector int32

const (
	UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState UpdateLimitPoolRequestCAS_FieldPathSelector = 0
	UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask        UpdateLimitPoolRequestCAS_FieldPathSelector = 1
)

func (s UpdateLimitPoolRequestCAS_FieldPathSelector) String() string {
	switch s {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		return "conditional_state"
	case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
		return "field_mask"
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", s))
	}
}

func BuildUpdateLimitPoolRequestCAS_FieldPath(fp gotenobject.RawFieldPath) (UpdateLimitPoolRequestCAS_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object UpdateLimitPoolRequest_CAS")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "conditional_state", "conditionalState", "conditional-state":
			return &UpdateLimitPoolRequestCAS_FieldTerminalPath{selector: UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &UpdateLimitPoolRequestCAS_FieldTerminalPath{selector: UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask}, nil
		}
	} else {
		switch fp[0] {
		case "conditional_state", "conditionalState", "conditional-state":
			if subpath, err := limit_pool.BuildLimitPool_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &UpdateLimitPoolRequestCAS_FieldSubPath{selector: UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object UpdateLimitPoolRequest_CAS", fp)
}

func ParseUpdateLimitPoolRequestCAS_FieldPath(rawField string) (UpdateLimitPoolRequestCAS_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildUpdateLimitPoolRequestCAS_FieldPath(fp)
}

func MustParseUpdateLimitPoolRequestCAS_FieldPath(rawField string) UpdateLimitPoolRequestCAS_FieldPath {
	fp, err := ParseUpdateLimitPoolRequestCAS_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type UpdateLimitPoolRequestCAS_FieldTerminalPath struct {
	selector UpdateLimitPoolRequestCAS_FieldPathSelector
}

var _ UpdateLimitPoolRequestCAS_FieldPath = (*UpdateLimitPoolRequestCAS_FieldTerminalPath)(nil)

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) Selector() UpdateLimitPoolRequestCAS_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source UpdateLimitPoolRequest_CAS
func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) Get(source *UpdateLimitPoolRequest_CAS) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
			if source.ConditionalState != nil {
				values = append(values, source.ConditionalState)
			}
		case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fp.selector))
		}
	}
	return
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*UpdateLimitPoolRequest_CAS))
}

// GetSingle returns value pointed by specific field of from source UpdateLimitPoolRequest_CAS
func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) GetSingle(source *UpdateLimitPoolRequest_CAS) (interface{}, bool) {
	switch fp.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		res := source.GetConditionalState()
		return res, res != nil
	case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fp.selector))
	}
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*UpdateLimitPoolRequest_CAS))
}

// GetDefault returns a default value of the field type
func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		return (*limit_pool.LimitPool)(nil)
	case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
		return (*limit_pool.LimitPool_FieldMask)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fp.selector))
	}
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) ClearValue(item *UpdateLimitPoolRequest_CAS) {
	if item != nil {
		switch fp.selector {
		case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
			item.ConditionalState = nil
		case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fp.selector))
		}
	}
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*UpdateLimitPoolRequest_CAS))
}

// IsLeaf - whether field path is holds simple value
func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) WithIValue(value interface{}) UpdateLimitPoolRequestCAS_FieldPathValue {
	switch fp.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		return &UpdateLimitPoolRequestCAS_FieldTerminalPathValue{UpdateLimitPoolRequestCAS_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool)}
	case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
		return &UpdateLimitPoolRequestCAS_FieldTerminalPathValue{UpdateLimitPoolRequestCAS_FieldTerminalPath: *fp, value: value.(*limit_pool.LimitPool_FieldMask)}
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fp.selector))
	}
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) WithIArrayOfValues(values interface{}) UpdateLimitPoolRequestCAS_FieldPathArrayOfValues {
	fpaov := &UpdateLimitPoolRequestCAS_FieldTerminalPathArrayOfValues{UpdateLimitPoolRequestCAS_FieldTerminalPath: *fp}
	switch fp.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		return &UpdateLimitPoolRequestCAS_FieldTerminalPathArrayOfValues{UpdateLimitPoolRequestCAS_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool)}
	case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
		return &UpdateLimitPoolRequestCAS_FieldTerminalPathArrayOfValues{UpdateLimitPoolRequestCAS_FieldTerminalPath: *fp, values: values.([]*limit_pool.LimitPool_FieldMask)}
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fp.selector))
	}
	return fpaov
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) WithIArrayItemValue(value interface{}) UpdateLimitPoolRequestCAS_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fp.selector))
	}
}

func (fp *UpdateLimitPoolRequestCAS_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type UpdateLimitPoolRequestCAS_FieldSubPath struct {
	selector UpdateLimitPoolRequestCAS_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ UpdateLimitPoolRequestCAS_FieldPath = (*UpdateLimitPoolRequestCAS_FieldSubPath)(nil)

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) Selector() UpdateLimitPoolRequestCAS_FieldPathSelector {
	return fps.selector
}
func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) AsConditionalStateSubPath() (limit_pool.LimitPool_FieldPath, bool) {
	res, ok := fps.subPath.(limit_pool.LimitPool_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source UpdateLimitPoolRequest_CAS
func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) Get(source *UpdateLimitPoolRequest_CAS) (values []interface{}) {
	switch fps.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		values = append(values, fps.subPath.GetRaw(source.GetConditionalState())...)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fps.selector))
	}
	return
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*UpdateLimitPoolRequest_CAS))
}

// GetSingle returns value of selected field from source UpdateLimitPoolRequest_CAS
func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) GetSingle(source *UpdateLimitPoolRequest_CAS) (interface{}, bool) {
	switch fps.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		if source.GetConditionalState() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetConditionalState())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fps.selector))
	}
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*UpdateLimitPoolRequest_CAS))
}

// GetDefault returns a default value of the field type
func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) ClearValue(item *UpdateLimitPoolRequest_CAS) {
	if item != nil {
		switch fps.selector {
		case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
			fps.subPath.ClearValueRaw(item.ConditionalState)
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fps.selector))
		}
	}
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*UpdateLimitPoolRequest_CAS))
}

// IsLeaf - whether field path is holds simple value
func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&UpdateLimitPoolRequestCAS_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) WithIValue(value interface{}) UpdateLimitPoolRequestCAS_FieldPathValue {
	return &UpdateLimitPoolRequestCAS_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) WithIArrayOfValues(values interface{}) UpdateLimitPoolRequestCAS_FieldPathArrayOfValues {
	return &UpdateLimitPoolRequestCAS_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) WithIArrayItemValue(value interface{}) UpdateLimitPoolRequestCAS_FieldPathArrayItemValue {
	return &UpdateLimitPoolRequestCAS_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *UpdateLimitPoolRequestCAS_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// UpdateLimitPoolRequestCAS_FieldPathValue allows storing values for CAS fields according to their type
type UpdateLimitPoolRequestCAS_FieldPathValue interface {
	UpdateLimitPoolRequestCAS_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **UpdateLimitPoolRequest_CAS)
	CompareWith(*UpdateLimitPoolRequest_CAS) (cmp int, comparable bool)
}

func ParseUpdateLimitPoolRequestCAS_FieldPathValue(pathStr, valueStr string) (UpdateLimitPoolRequestCAS_FieldPathValue, error) {
	fp, err := ParseUpdateLimitPoolRequestCAS_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CAS field path value from %s: %v", valueStr, err)
	}
	return fpv.(UpdateLimitPoolRequestCAS_FieldPathValue), nil
}

func MustParseUpdateLimitPoolRequestCAS_FieldPathValue(pathStr, valueStr string) UpdateLimitPoolRequestCAS_FieldPathValue {
	fpv, err := ParseUpdateLimitPoolRequestCAS_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type UpdateLimitPoolRequestCAS_FieldTerminalPathValue struct {
	UpdateLimitPoolRequestCAS_FieldTerminalPath
	value interface{}
}

var _ UpdateLimitPoolRequestCAS_FieldPathValue = (*UpdateLimitPoolRequestCAS_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'CAS' as interface{}
func (fpv *UpdateLimitPoolRequestCAS_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *UpdateLimitPoolRequestCAS_FieldTerminalPathValue) AsConditionalStateValue() (*limit_pool.LimitPool, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool)
	return res, ok
}
func (fpv *UpdateLimitPoolRequestCAS_FieldTerminalPathValue) AsFieldMaskValue() (*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpv.value.(*limit_pool.LimitPool_FieldMask)
	return res, ok
}

// SetTo stores value for selected field for object CAS
func (fpv *UpdateLimitPoolRequestCAS_FieldTerminalPathValue) SetTo(target **UpdateLimitPoolRequest_CAS) {
	if *target == nil {
		*target = new(UpdateLimitPoolRequest_CAS)
	}
	switch fpv.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		(*target).ConditionalState = fpv.value.(*limit_pool.LimitPool)
	case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit_pool.LimitPool_FieldMask)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fpv.selector))
	}
}

func (fpv *UpdateLimitPoolRequestCAS_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*UpdateLimitPoolRequest_CAS)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'UpdateLimitPoolRequestCAS_FieldTerminalPathValue' with the value under path in 'UpdateLimitPoolRequest_CAS'.
func (fpv *UpdateLimitPoolRequestCAS_FieldTerminalPathValue) CompareWith(source *UpdateLimitPoolRequest_CAS) (int, bool) {
	switch fpv.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		return 0, false
	case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fpv.selector))
	}
}

func (fpv *UpdateLimitPoolRequestCAS_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*UpdateLimitPoolRequest_CAS))
}

type UpdateLimitPoolRequestCAS_FieldSubPathValue struct {
	UpdateLimitPoolRequestCAS_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ UpdateLimitPoolRequestCAS_FieldPathValue = (*UpdateLimitPoolRequestCAS_FieldSubPathValue)(nil)

func (fpvs *UpdateLimitPoolRequestCAS_FieldSubPathValue) AsConditionalStatePathValue() (limit_pool.LimitPool_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(limit_pool.LimitPool_FieldPathValue)
	return res, ok
}

func (fpvs *UpdateLimitPoolRequestCAS_FieldSubPathValue) SetTo(target **UpdateLimitPoolRequest_CAS) {
	if *target == nil {
		*target = new(UpdateLimitPoolRequest_CAS)
	}
	switch fpvs.Selector() {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		fpvs.subPathValue.(limit_pool.LimitPool_FieldPathValue).SetTo(&(*target).ConditionalState)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fpvs.Selector()))
	}
}

func (fpvs *UpdateLimitPoolRequestCAS_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*UpdateLimitPoolRequest_CAS)
	fpvs.SetTo(&typedObject)
}

func (fpvs *UpdateLimitPoolRequestCAS_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *UpdateLimitPoolRequestCAS_FieldSubPathValue) CompareWith(source *UpdateLimitPoolRequest_CAS) (int, bool) {
	switch fpvs.Selector() {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		return fpvs.subPathValue.(limit_pool.LimitPool_FieldPathValue).CompareWith(source.GetConditionalState())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fpvs.Selector()))
	}
}

func (fpvs *UpdateLimitPoolRequestCAS_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*UpdateLimitPoolRequest_CAS))
}

// UpdateLimitPoolRequestCAS_FieldPathArrayItemValue allows storing single item in Path-specific values for CAS according to their type
// Present only for array (repeated) types.
type UpdateLimitPoolRequestCAS_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	UpdateLimitPoolRequestCAS_FieldPath
	ContainsValue(*UpdateLimitPoolRequest_CAS) bool
}

// ParseUpdateLimitPoolRequestCAS_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseUpdateLimitPoolRequestCAS_FieldPathArrayItemValue(pathStr, valueStr string) (UpdateLimitPoolRequestCAS_FieldPathArrayItemValue, error) {
	fp, err := ParseUpdateLimitPoolRequestCAS_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CAS field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(UpdateLimitPoolRequestCAS_FieldPathArrayItemValue), nil
}

func MustParseUpdateLimitPoolRequestCAS_FieldPathArrayItemValue(pathStr, valueStr string) UpdateLimitPoolRequestCAS_FieldPathArrayItemValue {
	fpaiv, err := ParseUpdateLimitPoolRequestCAS_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type UpdateLimitPoolRequestCAS_FieldTerminalPathArrayItemValue struct {
	UpdateLimitPoolRequestCAS_FieldTerminalPath
	value interface{}
}

var _ UpdateLimitPoolRequestCAS_FieldPathArrayItemValue = (*UpdateLimitPoolRequestCAS_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object UpdateLimitPoolRequest_CAS as interface{}
func (fpaiv *UpdateLimitPoolRequestCAS_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *UpdateLimitPoolRequestCAS_FieldTerminalPathArrayItemValue) GetSingle(source *UpdateLimitPoolRequest_CAS) (interface{}, bool) {
	return nil, false
}

func (fpaiv *UpdateLimitPoolRequestCAS_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*UpdateLimitPoolRequest_CAS))
}

// Contains returns a boolean indicating if value that is being held is present in given 'CAS'
func (fpaiv *UpdateLimitPoolRequestCAS_FieldTerminalPathArrayItemValue) ContainsValue(source *UpdateLimitPoolRequest_CAS) bool {
	slice := fpaiv.UpdateLimitPoolRequestCAS_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type UpdateLimitPoolRequestCAS_FieldSubPathArrayItemValue struct {
	UpdateLimitPoolRequestCAS_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *UpdateLimitPoolRequestCAS_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *UpdateLimitPoolRequestCAS_FieldSubPathArrayItemValue) AsConditionalStatePathItemValue() (limit_pool.LimitPool_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(limit_pool.LimitPool_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'CAS'
func (fpaivs *UpdateLimitPoolRequestCAS_FieldSubPathArrayItemValue) ContainsValue(source *UpdateLimitPoolRequest_CAS) bool {
	switch fpaivs.Selector() {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		return fpaivs.subPathItemValue.(limit_pool.LimitPool_FieldPathArrayItemValue).ContainsValue(source.GetConditionalState())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitPoolRequest_CAS: %d", fpaivs.Selector()))
	}
}

// UpdateLimitPoolRequestCAS_FieldPathArrayOfValues allows storing slice of values for CAS fields according to their type
type UpdateLimitPoolRequestCAS_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	UpdateLimitPoolRequestCAS_FieldPath
}

func ParseUpdateLimitPoolRequestCAS_FieldPathArrayOfValues(pathStr, valuesStr string) (UpdateLimitPoolRequestCAS_FieldPathArrayOfValues, error) {
	fp, err := ParseUpdateLimitPoolRequestCAS_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CAS field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(UpdateLimitPoolRequestCAS_FieldPathArrayOfValues), nil
}

func MustParseUpdateLimitPoolRequestCAS_FieldPathArrayOfValues(pathStr, valuesStr string) UpdateLimitPoolRequestCAS_FieldPathArrayOfValues {
	fpaov, err := ParseUpdateLimitPoolRequestCAS_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type UpdateLimitPoolRequestCAS_FieldTerminalPathArrayOfValues struct {
	UpdateLimitPoolRequestCAS_FieldTerminalPath
	values interface{}
}

var _ UpdateLimitPoolRequestCAS_FieldPathArrayOfValues = (*UpdateLimitPoolRequestCAS_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *UpdateLimitPoolRequestCAS_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool) {
			values = append(values, v)
		}
	case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit_pool.LimitPool_FieldMask) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *UpdateLimitPoolRequestCAS_FieldTerminalPathArrayOfValues) AsConditionalStateArrayOfValues() ([]*limit_pool.LimitPool, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool)
	return res, ok
}
func (fpaov *UpdateLimitPoolRequestCAS_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit_pool.LimitPool_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit_pool.LimitPool_FieldMask)
	return res, ok
}

type UpdateLimitPoolRequestCAS_FieldSubPathArrayOfValues struct {
	UpdateLimitPoolRequestCAS_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ UpdateLimitPoolRequestCAS_FieldPathArrayOfValues = (*UpdateLimitPoolRequestCAS_FieldSubPathArrayOfValues)(nil)

func (fpsaov *UpdateLimitPoolRequestCAS_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *UpdateLimitPoolRequestCAS_FieldSubPathArrayOfValues) AsConditionalStatePathArrayOfValues() (limit_pool.LimitPool_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(limit_pool.LimitPool_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DeleteLimitPoolRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() DeleteLimitPoolRequest_FieldPathSelector
	Get(source *DeleteLimitPoolRequest) []interface{}
	GetSingle(source *DeleteLimitPoolRequest) (interface{}, bool)
	ClearValue(item *DeleteLimitPoolRequest)

	// Those methods build corresponding DeleteLimitPoolRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DeleteLimitPoolRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) DeleteLimitPoolRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DeleteLimitPoolRequest_FieldPathArrayItemValue
}

type DeleteLimitPoolRequest_FieldPathSelector int32

const (
	DeleteLimitPoolRequest_FieldPathSelectorName DeleteLimitPoolRequest_FieldPathSelector = 0
)

func (s DeleteLimitPoolRequest_FieldPathSelector) String() string {
	switch s {
	case DeleteLimitPoolRequest_FieldPathSelectorName:
		return "name"
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", s))
	}
}

func BuildDeleteLimitPoolRequest_FieldPath(fp gotenobject.RawFieldPath) (DeleteLimitPoolRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object DeleteLimitPoolRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &DeleteLimitPoolRequest_FieldTerminalPath{selector: DeleteLimitPoolRequest_FieldPathSelectorName}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object DeleteLimitPoolRequest", fp)
}

func ParseDeleteLimitPoolRequest_FieldPath(rawField string) (DeleteLimitPoolRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDeleteLimitPoolRequest_FieldPath(fp)
}

func MustParseDeleteLimitPoolRequest_FieldPath(rawField string) DeleteLimitPoolRequest_FieldPath {
	fp, err := ParseDeleteLimitPoolRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DeleteLimitPoolRequest_FieldTerminalPath struct {
	selector DeleteLimitPoolRequest_FieldPathSelector
}

var _ DeleteLimitPoolRequest_FieldPath = (*DeleteLimitPoolRequest_FieldTerminalPath)(nil)

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) Selector() DeleteLimitPoolRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DeleteLimitPoolRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DeleteLimitPoolRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source DeleteLimitPoolRequest
func (fp *DeleteLimitPoolRequest_FieldTerminalPath) Get(source *DeleteLimitPoolRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DeleteLimitPoolRequest_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*DeleteLimitPoolRequest))
}

// GetSingle returns value pointed by specific field of from source DeleteLimitPoolRequest
func (fp *DeleteLimitPoolRequest_FieldTerminalPath) GetSingle(source *DeleteLimitPoolRequest) (interface{}, bool) {
	switch fp.selector {
	case DeleteLimitPoolRequest_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*DeleteLimitPoolRequest))
}

// GetDefault returns a default value of the field type
func (fp *DeleteLimitPoolRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DeleteLimitPoolRequest_FieldPathSelectorName:
		return (*limit_pool.Reference)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) ClearValue(item *DeleteLimitPoolRequest) {
	if item != nil {
		switch fp.selector {
		case DeleteLimitPoolRequest_FieldPathSelectorName:
			item.Name = nil
		default:
			panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fp.selector))
		}
	}
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*DeleteLimitPoolRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *DeleteLimitPoolRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DeleteLimitPoolRequest_FieldPathSelectorName
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) WithIValue(value interface{}) DeleteLimitPoolRequest_FieldPathValue {
	switch fp.selector {
	case DeleteLimitPoolRequest_FieldPathSelectorName:
		return &DeleteLimitPoolRequest_FieldTerminalPathValue{DeleteLimitPoolRequest_FieldTerminalPath: *fp, value: value.(*limit_pool.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) DeleteLimitPoolRequest_FieldPathArrayOfValues {
	fpaov := &DeleteLimitPoolRequest_FieldTerminalPathArrayOfValues{DeleteLimitPoolRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case DeleteLimitPoolRequest_FieldPathSelectorName:
		return &DeleteLimitPoolRequest_FieldTerminalPathArrayOfValues{DeleteLimitPoolRequest_FieldTerminalPath: *fp, values: values.([]*limit_pool.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) DeleteLimitPoolRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fp.selector))
	}
}

func (fp *DeleteLimitPoolRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DeleteLimitPoolRequest_FieldPathValue allows storing values for DeleteLimitPoolRequest fields according to their type
type DeleteLimitPoolRequest_FieldPathValue interface {
	DeleteLimitPoolRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **DeleteLimitPoolRequest)
	CompareWith(*DeleteLimitPoolRequest) (cmp int, comparable bool)
}

func ParseDeleteLimitPoolRequest_FieldPathValue(pathStr, valueStr string) (DeleteLimitPoolRequest_FieldPathValue, error) {
	fp, err := ParseDeleteLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DeleteLimitPoolRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(DeleteLimitPoolRequest_FieldPathValue), nil
}

func MustParseDeleteLimitPoolRequest_FieldPathValue(pathStr, valueStr string) DeleteLimitPoolRequest_FieldPathValue {
	fpv, err := ParseDeleteLimitPoolRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DeleteLimitPoolRequest_FieldTerminalPathValue struct {
	DeleteLimitPoolRequest_FieldTerminalPath
	value interface{}
}

var _ DeleteLimitPoolRequest_FieldPathValue = (*DeleteLimitPoolRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'DeleteLimitPoolRequest' as interface{}
func (fpv *DeleteLimitPoolRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DeleteLimitPoolRequest_FieldTerminalPathValue) AsNameValue() (*limit_pool.Reference, bool) {
	res, ok := fpv.value.(*limit_pool.Reference)
	return res, ok
}

// SetTo stores value for selected field for object DeleteLimitPoolRequest
func (fpv *DeleteLimitPoolRequest_FieldTerminalPathValue) SetTo(target **DeleteLimitPoolRequest) {
	if *target == nil {
		*target = new(DeleteLimitPoolRequest)
	}
	switch fpv.selector {
	case DeleteLimitPoolRequest_FieldPathSelectorName:
		(*target).Name = fpv.value.(*limit_pool.Reference)
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fpv.selector))
	}
}

func (fpv *DeleteLimitPoolRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*DeleteLimitPoolRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DeleteLimitPoolRequest_FieldTerminalPathValue' with the value under path in 'DeleteLimitPoolRequest'.
func (fpv *DeleteLimitPoolRequest_FieldTerminalPathValue) CompareWith(source *DeleteLimitPoolRequest) (int, bool) {
	switch fpv.selector {
	case DeleteLimitPoolRequest_FieldPathSelectorName:
		leftValue := fpv.value.(*limit_pool.Reference)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitPoolRequest: %d", fpv.selector))
	}
}

func (fpv *DeleteLimitPoolRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*DeleteLimitPoolRequest))
}

// DeleteLimitPoolRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for DeleteLimitPoolRequest according to their type
// Present only for array (repeated) types.
type DeleteLimitPoolRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DeleteLimitPoolRequest_FieldPath
	ContainsValue(*DeleteLimitPoolRequest) bool
}

// ParseDeleteLimitPoolRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDeleteLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr string) (DeleteLimitPoolRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseDeleteLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DeleteLimitPoolRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DeleteLimitPoolRequest_FieldPathArrayItemValue), nil
}

func MustParseDeleteLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr string) DeleteLimitPoolRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseDeleteLimitPoolRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DeleteLimitPoolRequest_FieldTerminalPathArrayItemValue struct {
	DeleteLimitPoolRequest_FieldTerminalPath
	value interface{}
}

var _ DeleteLimitPoolRequest_FieldPathArrayItemValue = (*DeleteLimitPoolRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object DeleteLimitPoolRequest as interface{}
func (fpaiv *DeleteLimitPoolRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *DeleteLimitPoolRequest_FieldTerminalPathArrayItemValue) GetSingle(source *DeleteLimitPoolRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DeleteLimitPoolRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*DeleteLimitPoolRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'DeleteLimitPoolRequest'
func (fpaiv *DeleteLimitPoolRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *DeleteLimitPoolRequest) bool {
	slice := fpaiv.DeleteLimitPoolRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DeleteLimitPoolRequest_FieldPathArrayOfValues allows storing slice of values for DeleteLimitPoolRequest fields according to their type
type DeleteLimitPoolRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DeleteLimitPoolRequest_FieldPath
}

func ParseDeleteLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (DeleteLimitPoolRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseDeleteLimitPoolRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DeleteLimitPoolRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DeleteLimitPoolRequest_FieldPathArrayOfValues), nil
}

func MustParseDeleteLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr string) DeleteLimitPoolRequest_FieldPathArrayOfValues {
	fpaov, err := ParseDeleteLimitPoolRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DeleteLimitPoolRequest_FieldTerminalPathArrayOfValues struct {
	DeleteLimitPoolRequest_FieldTerminalPath
	values interface{}
}

var _ DeleteLimitPoolRequest_FieldPathArrayOfValues = (*DeleteLimitPoolRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DeleteLimitPoolRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DeleteLimitPoolRequest_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*limit_pool.Reference) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DeleteLimitPoolRequest_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*limit_pool.Reference, bool) {
	res, ok := fpaov.values.([]*limit_pool.Reference)
	return res, ok
}
