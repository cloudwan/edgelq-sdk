// Code generated by protoc-gen-goten-client
// API: LimitPoolService
// DO NOT EDIT!!!

package limit_pool_client

import (
	"google.golang.org/protobuf/proto"

	gotenclient "github.com/cloudwan/goten-sdk/runtime/client"
	gotenresource "github.com/cloudwan/goten-sdk/runtime/resource"
)

// proto imports
import (
	limit_pool "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/limit_pool"
	empty "github.com/golang/protobuf/ptypes/empty"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = new(proto.Message)
	_ = new(gotenclient.MethodDescriptor)
	_ = gotenresource.WildcardId
)

// make sure we're using proto imports
var (
	_ = &limit_pool.LimitPool{}
	_ = &empty.Empty{}
)

var (
	descriptorsInitialized           bool
	limitPoolServiceDescriptor       *LimitPoolServiceDescriptor
	getLimitPoolDescriptor           *GetLimitPoolDescriptor
	batchGetLimitPoolsDescriptor     *BatchGetLimitPoolsDescriptor
	listLimitPoolsDescriptor         *ListLimitPoolsDescriptor
	watchLimitPoolDescriptor         *WatchLimitPoolDescriptor
	watchLimitPoolsDescriptor        *WatchLimitPoolsDescriptor
	updateLimitPoolDescriptor        *UpdateLimitPoolDescriptor
	deleteLimitPoolDescriptor        *DeleteLimitPoolDescriptor
	migrateLimitPoolSourceDescriptor *MigrateLimitPoolSourceDescriptor
)

type GetLimitPoolDescriptor struct{}

type GetLimitPoolDescriptorClientMsgHandle struct{}

type GetLimitPoolDescriptorServerMsgHandle struct{}

func (d *GetLimitPoolDescriptor) NewEmptyClientMsg() proto.Message {
	return &GetLimitPoolRequest{}
}

func (d *GetLimitPoolDescriptor) NewEmptyServerMsg() proto.Message {
	return &limit_pool.LimitPool{}
}

func (d *GetLimitPoolDescriptor) IsUnary() bool {
	return true
}

func (d *GetLimitPoolDescriptor) IsClientStream() bool {
	return false
}

func (d *GetLimitPoolDescriptor) IsServerStream() bool {
	return false
}

func (d *GetLimitPoolDescriptor) IsCollection() bool {
	return false
}

func (d *GetLimitPoolDescriptor) IsPlural() bool {
	return false
}

func (d *GetLimitPoolDescriptor) HasResource() bool {
	return true
}

func (d *GetLimitPoolDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *GetLimitPoolDescriptor) GetVerb() string {
	return "get"
}

func (d *GetLimitPoolDescriptor) GetMethodName() string {
	return "GetLimitPool"
}

func (d *GetLimitPoolDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService/GetLimitPool"
}

func (d *GetLimitPoolDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *GetLimitPoolDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *GetLimitPoolDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *GetLimitPoolDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *GetLimitPoolDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitPoolServiceDescriptor
}

func (d *GetLimitPoolDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit_pool.GetDescriptor()
}

func (d *GetLimitPoolDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetLimitPoolDescriptorClientMsgHandle{}
}

func (d *GetLimitPoolDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetLimitPoolDescriptorServerMsgHandle{}
}

func (h *GetLimitPoolDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*GetLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*GetLimitPoolRequest) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *GetLimitPoolDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*GetLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*GetLimitPoolRequest) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetLimitPoolDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*GetLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*GetLimitPoolRequest) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *GetLimitPoolDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*limit_pool.LimitPool) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if name := typedMsg.GetName(); name != nil {
			return name
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *GetLimitPoolDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*limit_pool.LimitPool) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetLimitPoolDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*limit_pool.LimitPool) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetGetLimitPoolDescriptor() *GetLimitPoolDescriptor {
	return getLimitPoolDescriptor
}

type BatchGetLimitPoolsDescriptor struct{}

type BatchGetLimitPoolsDescriptorClientMsgHandle struct{}

type BatchGetLimitPoolsDescriptorServerMsgHandle struct{}

func (d *BatchGetLimitPoolsDescriptor) NewEmptyClientMsg() proto.Message {
	return &BatchGetLimitPoolsRequest{}
}

func (d *BatchGetLimitPoolsDescriptor) NewEmptyServerMsg() proto.Message {
	return &BatchGetLimitPoolsResponse{}
}

func (d *BatchGetLimitPoolsDescriptor) IsUnary() bool {
	return true
}

func (d *BatchGetLimitPoolsDescriptor) IsClientStream() bool {
	return false
}

func (d *BatchGetLimitPoolsDescriptor) IsServerStream() bool {
	return false
}

func (d *BatchGetLimitPoolsDescriptor) IsCollection() bool {
	return false
}

func (d *BatchGetLimitPoolsDescriptor) IsPlural() bool {
	return true
}

func (d *BatchGetLimitPoolsDescriptor) HasResource() bool {
	return true
}

func (d *BatchGetLimitPoolsDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *BatchGetLimitPoolsDescriptor) GetVerb() string {
	return "batchGet"
}

func (d *BatchGetLimitPoolsDescriptor) GetMethodName() string {
	return "BatchGetLimitPools"
}

func (d *BatchGetLimitPoolsDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService/BatchGetLimitPools"
}

func (d *BatchGetLimitPoolsDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *BatchGetLimitPoolsDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *BatchGetLimitPoolsDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *BatchGetLimitPoolsDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *BatchGetLimitPoolsDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitPoolServiceDescriptor
}

func (d *BatchGetLimitPoolsDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit_pool.GetDescriptor()
}

func (d *BatchGetLimitPoolsDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &BatchGetLimitPoolsDescriptorClientMsgHandle{}
}

func (d *BatchGetLimitPoolsDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &BatchGetLimitPoolsDescriptorServerMsgHandle{}
}

func (h *BatchGetLimitPoolsDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*BatchGetLimitPoolsRequest) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *BatchGetLimitPoolsDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*BatchGetLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*BatchGetLimitPoolsRequest) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if refs := typedMsg.GetNames(); len(refs) > 0 {
			list := make(limit_pool.LimitPoolNameList, 0, len(refs))
			for _, ref := range refs {
				list = append(list, &ref.Name)
			}
			return list
		}
	}
	return (limit_pool.LimitPoolNameList)(nil)
}

func (h *BatchGetLimitPoolsDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*BatchGetLimitPoolsRequest) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *BatchGetLimitPoolsDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*BatchGetLimitPoolsResponse) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *BatchGetLimitPoolsDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*BatchGetLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*BatchGetLimitPoolsResponse) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resources := typedMsg.GetLimitPools(); len(resources) > 0 {
			list := make(limit_pool.LimitPoolNameList, 0, len(resources))
			for _, res := range resources {
				list = append(list, res.GetName())
			}
			return list
		}
	}
	return (limit_pool.LimitPoolNameList)(nil)
}

func (h *BatchGetLimitPoolsDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*BatchGetLimitPoolsResponse) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetBatchGetLimitPoolsDescriptor() *BatchGetLimitPoolsDescriptor {
	return batchGetLimitPoolsDescriptor
}

type ListLimitPoolsDescriptor struct{}

type ListLimitPoolsDescriptorClientMsgHandle struct{}

type ListLimitPoolsDescriptorServerMsgHandle struct{}

func (d *ListLimitPoolsDescriptor) NewEmptyClientMsg() proto.Message {
	return &ListLimitPoolsRequest{}
}

func (d *ListLimitPoolsDescriptor) NewEmptyServerMsg() proto.Message {
	return &ListLimitPoolsResponse{}
}

func (d *ListLimitPoolsDescriptor) IsUnary() bool {
	return true
}

func (d *ListLimitPoolsDescriptor) IsClientStream() bool {
	return false
}

func (d *ListLimitPoolsDescriptor) IsServerStream() bool {
	return false
}

func (d *ListLimitPoolsDescriptor) IsCollection() bool {
	return true
}

func (d *ListLimitPoolsDescriptor) IsPlural() bool {
	return true
}

func (d *ListLimitPoolsDescriptor) HasResource() bool {
	return true
}

func (d *ListLimitPoolsDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *ListLimitPoolsDescriptor) GetVerb() string {
	return "list"
}

func (d *ListLimitPoolsDescriptor) GetMethodName() string {
	return "ListLimitPools"
}

func (d *ListLimitPoolsDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService/ListLimitPools"
}

func (d *ListLimitPoolsDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *ListLimitPoolsDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *ListLimitPoolsDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *ListLimitPoolsDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *ListLimitPoolsDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitPoolServiceDescriptor
}

func (d *ListLimitPoolsDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit_pool.GetDescriptor()
}

func (d *ListLimitPoolsDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &ListLimitPoolsDescriptorClientMsgHandle{}
}

func (d *ListLimitPoolsDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &ListLimitPoolsDescriptorServerMsgHandle{}
}

func (h *ListLimitPoolsDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*ListLimitPoolsRequest) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *ListLimitPoolsDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*ListLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*ListLimitPoolsRequest) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *ListLimitPoolsDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*ListLimitPoolsRequest) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	{
		if parentName := typedMsg.GetParent(); parentName != nil {
			return parentName
		}
	}
	return (*limit_pool.ParentName)(nil)
}

func (h *ListLimitPoolsDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*ListLimitPoolsResponse) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *ListLimitPoolsDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*ListLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*ListLimitPoolsResponse) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resources := typedMsg.GetLimitPools(); len(resources) > 0 {
			list := make(limit_pool.LimitPoolNameList, 0, len(resources))
			for _, res := range resources {
				list = append(list, res.GetName())
			}
			return list
		}
	}
	return (limit_pool.LimitPoolNameList)(nil)
}

func (h *ListLimitPoolsDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*ListLimitPoolsResponse) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetListLimitPoolsDescriptor() *ListLimitPoolsDescriptor {
	return listLimitPoolsDescriptor
}

type WatchLimitPoolDescriptor struct{}

type WatchLimitPoolDescriptorClientMsgHandle struct{}

type WatchLimitPoolDescriptorServerMsgHandle struct{}

func (d *WatchLimitPoolDescriptor) NewEmptyClientMsg() proto.Message {
	return &WatchLimitPoolRequest{}
}

func (d *WatchLimitPoolDescriptor) NewEmptyServerMsg() proto.Message {
	return &WatchLimitPoolResponse{}
}

func (d *WatchLimitPoolDescriptor) IsUnary() bool {
	return false
}

func (d *WatchLimitPoolDescriptor) IsClientStream() bool {
	return false
}

func (d *WatchLimitPoolDescriptor) IsServerStream() bool {
	return true
}

func (d *WatchLimitPoolDescriptor) IsCollection() bool {
	return false
}

func (d *WatchLimitPoolDescriptor) IsPlural() bool {
	return false
}

func (d *WatchLimitPoolDescriptor) HasResource() bool {
	return true
}

func (d *WatchLimitPoolDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *WatchLimitPoolDescriptor) GetVerb() string {
	return "watch"
}

func (d *WatchLimitPoolDescriptor) GetMethodName() string {
	return "WatchLimitPool"
}

func (d *WatchLimitPoolDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService/WatchLimitPool"
}

func (d *WatchLimitPoolDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *WatchLimitPoolDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *WatchLimitPoolDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *WatchLimitPoolDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *WatchLimitPoolDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitPoolServiceDescriptor
}

func (d *WatchLimitPoolDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit_pool.GetDescriptor()
}

func (d *WatchLimitPoolDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchLimitPoolDescriptorClientMsgHandle{}
}

func (d *WatchLimitPoolDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchLimitPoolDescriptorServerMsgHandle{}
}

func (h *WatchLimitPoolDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchLimitPoolRequest) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *WatchLimitPoolDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchLimitPoolRequest) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchLimitPoolDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*WatchLimitPoolRequest) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *WatchLimitPoolDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitPoolResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchLimitPoolResponse) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if resChange := typedMsg.GetChange(); resChange != nil {
			switch tResChange := resChange.ChangeType.(type) {
			case *limit_pool.LimitPoolChange_Added_:
				return tResChange.Added.GetLimitPool().GetName()
			case *limit_pool.LimitPoolChange_Modified_:
				return tResChange.Modified.GetName()
			case *limit_pool.LimitPoolChange_Removed_:
				return tResChange.Removed.GetName()
			case *limit_pool.LimitPoolChange_Current_:
				return tResChange.Current.GetLimitPool().GetName()
			}
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *WatchLimitPoolDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchLimitPoolResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchLimitPoolResponse) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchLimitPoolDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitPoolResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*WatchLimitPoolResponse) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetWatchLimitPoolDescriptor() *WatchLimitPoolDescriptor {
	return watchLimitPoolDescriptor
}

type WatchLimitPoolsDescriptor struct{}

type WatchLimitPoolsDescriptorClientMsgHandle struct{}

type WatchLimitPoolsDescriptorServerMsgHandle struct{}

func (d *WatchLimitPoolsDescriptor) NewEmptyClientMsg() proto.Message {
	return &WatchLimitPoolsRequest{}
}

func (d *WatchLimitPoolsDescriptor) NewEmptyServerMsg() proto.Message {
	return &WatchLimitPoolsResponse{}
}

func (d *WatchLimitPoolsDescriptor) IsUnary() bool {
	return false
}

func (d *WatchLimitPoolsDescriptor) IsClientStream() bool {
	return false
}

func (d *WatchLimitPoolsDescriptor) IsServerStream() bool {
	return true
}

func (d *WatchLimitPoolsDescriptor) IsCollection() bool {
	return true
}

func (d *WatchLimitPoolsDescriptor) IsPlural() bool {
	return true
}

func (d *WatchLimitPoolsDescriptor) HasResource() bool {
	return true
}

func (d *WatchLimitPoolsDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *WatchLimitPoolsDescriptor) GetVerb() string {
	return "watch"
}

func (d *WatchLimitPoolsDescriptor) GetMethodName() string {
	return "WatchLimitPools"
}

func (d *WatchLimitPoolsDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService/WatchLimitPools"
}

func (d *WatchLimitPoolsDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *WatchLimitPoolsDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *WatchLimitPoolsDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *WatchLimitPoolsDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *WatchLimitPoolsDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitPoolServiceDescriptor
}

func (d *WatchLimitPoolsDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit_pool.GetDescriptor()
}

func (d *WatchLimitPoolsDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchLimitPoolsDescriptorClientMsgHandle{}
}

func (d *WatchLimitPoolsDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchLimitPoolsDescriptorServerMsgHandle{}
}

func (h *WatchLimitPoolsDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchLimitPoolsRequest) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *WatchLimitPoolsDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchLimitPoolsRequest) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchLimitPoolsDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitPoolsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*WatchLimitPoolsRequest) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	{
		if ref := typedMsg.GetParent(); ref != nil {
			return &ref.ParentName
		}
	}
	return (*limit_pool.ParentName)(nil)
}

func (h *WatchLimitPoolsDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchLimitPoolsResponse) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *WatchLimitPoolsDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchLimitPoolsResponse) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resChanges := typedMsg.GetLimitPoolChanges(); len(resChanges) > 0 {
			list := make(limit_pool.LimitPoolNameList, 0, len(resChanges))
			for _, resChange := range resChanges {
				switch tResChange := resChange.ChangeType.(type) {
				case *limit_pool.LimitPoolChange_Added_:
					list = append(list, tResChange.Added.GetLimitPool().GetName())
				case *limit_pool.LimitPoolChange_Modified_:
					list = append(list, tResChange.Modified.GetName())
				case *limit_pool.LimitPoolChange_Removed_:
					list = append(list, tResChange.Removed.GetName())
				case *limit_pool.LimitPoolChange_Current_:
					list = append(list, tResChange.Current.GetLimitPool().GetName())
				}
			}
			return list
		}
	}
	return (limit_pool.LimitPoolNameList)(nil)
}

func (h *WatchLimitPoolsDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitPoolsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*WatchLimitPoolsResponse) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetWatchLimitPoolsDescriptor() *WatchLimitPoolsDescriptor {
	return watchLimitPoolsDescriptor
}

type UpdateLimitPoolDescriptor struct{}

type UpdateLimitPoolDescriptorClientMsgHandle struct{}

type UpdateLimitPoolDescriptorServerMsgHandle struct{}

func (d *UpdateLimitPoolDescriptor) NewEmptyClientMsg() proto.Message {
	return &UpdateLimitPoolRequest{}
}

func (d *UpdateLimitPoolDescriptor) NewEmptyServerMsg() proto.Message {
	return &limit_pool.LimitPool{}
}

func (d *UpdateLimitPoolDescriptor) IsUnary() bool {
	return true
}

func (d *UpdateLimitPoolDescriptor) IsClientStream() bool {
	return false
}

func (d *UpdateLimitPoolDescriptor) IsServerStream() bool {
	return false
}

func (d *UpdateLimitPoolDescriptor) IsCollection() bool {
	return false
}

func (d *UpdateLimitPoolDescriptor) IsPlural() bool {
	return false
}

func (d *UpdateLimitPoolDescriptor) HasResource() bool {
	return true
}

func (d *UpdateLimitPoolDescriptor) RequestHasResourceBody() bool {
	return true
}

func (d *UpdateLimitPoolDescriptor) GetVerb() string {
	return "update"
}

func (d *UpdateLimitPoolDescriptor) GetMethodName() string {
	return "UpdateLimitPool"
}

func (d *UpdateLimitPoolDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService/UpdateLimitPool"
}

func (d *UpdateLimitPoolDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *UpdateLimitPoolDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *UpdateLimitPoolDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *UpdateLimitPoolDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *UpdateLimitPoolDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitPoolServiceDescriptor
}

func (d *UpdateLimitPoolDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit_pool.GetDescriptor()
}

func (d *UpdateLimitPoolDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &UpdateLimitPoolDescriptorClientMsgHandle{}
}

func (d *UpdateLimitPoolDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &UpdateLimitPoolDescriptorServerMsgHandle{}
}

func (h *UpdateLimitPoolDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*UpdateLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*UpdateLimitPoolRequest) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		res := typedMsg.GetLimitPool()
		if name := res.GetName(); name != nil {
			return name
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *UpdateLimitPoolDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*UpdateLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*UpdateLimitPoolRequest) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *UpdateLimitPoolDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*UpdateLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*UpdateLimitPoolRequest) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *UpdateLimitPoolDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*limit_pool.LimitPool) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if name := typedMsg.GetName(); name != nil {
			return name
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *UpdateLimitPoolDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*limit_pool.LimitPool) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *UpdateLimitPoolDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*limit_pool.LimitPool) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetUpdateLimitPoolDescriptor() *UpdateLimitPoolDescriptor {
	return updateLimitPoolDescriptor
}

type DeleteLimitPoolDescriptor struct{}

type DeleteLimitPoolDescriptorClientMsgHandle struct{}

type DeleteLimitPoolDescriptorServerMsgHandle struct{}

func (d *DeleteLimitPoolDescriptor) NewEmptyClientMsg() proto.Message {
	return &DeleteLimitPoolRequest{}
}

func (d *DeleteLimitPoolDescriptor) NewEmptyServerMsg() proto.Message {
	return &empty.Empty{}
}

func (d *DeleteLimitPoolDescriptor) IsUnary() bool {
	return true
}

func (d *DeleteLimitPoolDescriptor) IsClientStream() bool {
	return false
}

func (d *DeleteLimitPoolDescriptor) IsServerStream() bool {
	return false
}

func (d *DeleteLimitPoolDescriptor) IsCollection() bool {
	return false
}

func (d *DeleteLimitPoolDescriptor) IsPlural() bool {
	return false
}

func (d *DeleteLimitPoolDescriptor) HasResource() bool {
	return true
}

func (d *DeleteLimitPoolDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *DeleteLimitPoolDescriptor) GetVerb() string {
	return "delete"
}

func (d *DeleteLimitPoolDescriptor) GetMethodName() string {
	return "DeleteLimitPool"
}

func (d *DeleteLimitPoolDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService/DeleteLimitPool"
}

func (d *DeleteLimitPoolDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *DeleteLimitPoolDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *DeleteLimitPoolDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *DeleteLimitPoolDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *DeleteLimitPoolDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitPoolServiceDescriptor
}

func (d *DeleteLimitPoolDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit_pool.GetDescriptor()
}

func (d *DeleteLimitPoolDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &DeleteLimitPoolDescriptorClientMsgHandle{}
}

func (d *DeleteLimitPoolDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &DeleteLimitPoolDescriptorServerMsgHandle{}
}

func (h *DeleteLimitPoolDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*DeleteLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*DeleteLimitPoolRequest) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *DeleteLimitPoolDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*DeleteLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*DeleteLimitPoolRequest) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *DeleteLimitPoolDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*DeleteLimitPoolRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*DeleteLimitPoolRequest) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *DeleteLimitPoolDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*empty.Empty) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *DeleteLimitPoolDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*empty.Empty) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *DeleteLimitPoolDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*empty.Empty) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetDeleteLimitPoolDescriptor() *DeleteLimitPoolDescriptor {
	return deleteLimitPoolDescriptor
}

type MigrateLimitPoolSourceDescriptor struct{}

type MigrateLimitPoolSourceDescriptorClientMsgHandle struct{}

type MigrateLimitPoolSourceDescriptorServerMsgHandle struct{}

func (d *MigrateLimitPoolSourceDescriptor) NewEmptyClientMsg() proto.Message {
	return &MigrateLimitPoolSourceRequest{}
}

func (d *MigrateLimitPoolSourceDescriptor) NewEmptyServerMsg() proto.Message {
	return &limit_pool.LimitPool{}
}

func (d *MigrateLimitPoolSourceDescriptor) IsUnary() bool {
	return true
}

func (d *MigrateLimitPoolSourceDescriptor) IsClientStream() bool {
	return false
}

func (d *MigrateLimitPoolSourceDescriptor) IsServerStream() bool {
	return false
}

func (d *MigrateLimitPoolSourceDescriptor) IsCollection() bool {
	return false
}

func (d *MigrateLimitPoolSourceDescriptor) IsPlural() bool {
	return false
}

func (d *MigrateLimitPoolSourceDescriptor) HasResource() bool {
	return true
}

func (d *MigrateLimitPoolSourceDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *MigrateLimitPoolSourceDescriptor) GetVerb() string {
	return "migrate"
}

func (d *MigrateLimitPoolSourceDescriptor) GetMethodName() string {
	return "MigrateLimitPoolSource"
}

func (d *MigrateLimitPoolSourceDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService/MigrateLimitPoolSource"
}

func (d *MigrateLimitPoolSourceDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *MigrateLimitPoolSourceDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *MigrateLimitPoolSourceDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *MigrateLimitPoolSourceDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *MigrateLimitPoolSourceDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitPoolServiceDescriptor
}

func (d *MigrateLimitPoolSourceDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit_pool.GetDescriptor()
}

func (d *MigrateLimitPoolSourceDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &MigrateLimitPoolSourceDescriptorClientMsgHandle{}
}

func (d *MigrateLimitPoolSourceDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &MigrateLimitPoolSourceDescriptorServerMsgHandle{}
}

func (h *MigrateLimitPoolSourceDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*MigrateLimitPoolSourceRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*MigrateLimitPoolSourceRequest) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *MigrateLimitPoolSourceDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*MigrateLimitPoolSourceRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*MigrateLimitPoolSourceRequest) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *MigrateLimitPoolSourceDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*MigrateLimitPoolSourceRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*MigrateLimitPoolSourceRequest) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *MigrateLimitPoolSourceDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*limit_pool.LimitPool) *limit_pool.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if name := typedMsg.GetName(); name != nil {
			return name
		}
	}
	return (*limit_pool.Name)(nil)
}

func (h *MigrateLimitPoolSourceDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*limit_pool.LimitPool) []*limit_pool.Name
	})
	if ok {
		return limit_pool.LimitPoolNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *MigrateLimitPoolSourceDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit_pool.LimitPool)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*limit_pool.LimitPool) *limit_pool.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetMigrateLimitPoolSourceDescriptor() *MigrateLimitPoolSourceDescriptor {
	return migrateLimitPoolSourceDescriptor
}

type LimitPoolServiceDescriptor struct{}

func (d *LimitPoolServiceDescriptor) AllMethodDescriptors() []gotenclient.MethodDescriptor {
	return []gotenclient.MethodDescriptor{
		getLimitPoolDescriptor,
		batchGetLimitPoolsDescriptor,
		listLimitPoolsDescriptor,
		watchLimitPoolDescriptor,
		watchLimitPoolsDescriptor,
		updateLimitPoolDescriptor,
		deleteLimitPoolDescriptor,
		migrateLimitPoolSourceDescriptor,
	}
}

func (d *LimitPoolServiceDescriptor) GetFullAPIName() string {
	return "/ntt.limits.v1alpha2.LimitPoolService"
}

func (d *LimitPoolServiceDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *LimitPoolServiceDescriptor) GetApiName() string {
	return "LimitPoolService"
}

func (d *LimitPoolServiceDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *LimitPoolServiceDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func GetLimitPoolServiceDescriptor() *LimitPoolServiceDescriptor {
	return limitPoolServiceDescriptor
}

func initDescriptors() {
	limitPoolServiceDescriptor = &LimitPoolServiceDescriptor{}
	getLimitPoolDescriptor = &GetLimitPoolDescriptor{}
	batchGetLimitPoolsDescriptor = &BatchGetLimitPoolsDescriptor{}
	listLimitPoolsDescriptor = &ListLimitPoolsDescriptor{}
	watchLimitPoolDescriptor = &WatchLimitPoolDescriptor{}
	watchLimitPoolsDescriptor = &WatchLimitPoolsDescriptor{}
	updateLimitPoolDescriptor = &UpdateLimitPoolDescriptor{}
	deleteLimitPoolDescriptor = &DeleteLimitPoolDescriptor{}
	migrateLimitPoolSourceDescriptor = &MigrateLimitPoolSourceDescriptor{}
	gotenclient.GetRegistry().RegisterApiDescriptor(limitPoolServiceDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(getLimitPoolDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(batchGetLimitPoolsDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(listLimitPoolsDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(watchLimitPoolDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(watchLimitPoolsDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(updateLimitPoolDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(deleteLimitPoolDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(migrateLimitPoolSourceDescriptor)
}

func init() {
	if !descriptorsInitialized {
		initDescriptors()
		descriptorsInitialized = true
	}
}
