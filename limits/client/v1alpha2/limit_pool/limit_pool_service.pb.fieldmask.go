// Code generated by protoc-gen-goten-object
// File: edgelq/limits/proto/v1alpha2/limit_pool_service.proto
// DO NOT EDIT!!!

package limit_pool_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	iam_organization "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/organization"
	limit_pool "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/limit_pool"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &iam_organization.Organization{}
	_ = &limit_pool.LimitPool{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetLimitPoolRequest_FieldMask struct {
	Paths []GetLimitPoolRequest_FieldPath
}

func FullGetLimitPoolRequest_FieldMask() *GetLimitPoolRequest_FieldMask {
	res := &GetLimitPoolRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetLimitPoolRequest_FieldTerminalPath{selector: GetLimitPoolRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetLimitPoolRequest_FieldTerminalPath{selector: GetLimitPoolRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetLimitPoolRequest_FieldTerminalPath{selector: GetLimitPoolRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetLimitPoolRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetLimitPoolRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetLimitPoolRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetLimitPoolRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetLimitPoolRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetLimitPoolRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetLimitPoolRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetLimitPoolRequest_FieldPath(raw)
	})
}

func (fieldMask *GetLimitPoolRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetLimitPoolRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetLimitPoolRequest_FieldMask) Subtract(other *GetLimitPoolRequest_FieldMask) *GetLimitPoolRequest_FieldMask {
	result := &GetLimitPoolRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetLimitPoolRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetLimitPoolRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetLimitPoolRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetLimitPoolRequest_FieldMask) FilterInputFields() *GetLimitPoolRequest_FieldMask {
	result := &GetLimitPoolRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetLimitPoolRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetLimitPoolRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetLimitPoolRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetLimitPoolRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetLimitPoolRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetLimitPoolRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetLimitPoolRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetLimitPoolRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetLimitPoolRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetLimitPoolRequest_FieldMask) AppendPath(path GetLimitPoolRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetLimitPoolRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetLimitPoolRequest_FieldPath))
}

func (fieldMask *GetLimitPoolRequest_FieldMask) GetPaths() []GetLimitPoolRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetLimitPoolRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetLimitPoolRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetLimitPoolRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetLimitPoolRequest_FieldMask) Set(target, source *GetLimitPoolRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetLimitPoolRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetLimitPoolRequest), source.(*GetLimitPoolRequest))
}

func (fieldMask *GetLimitPoolRequest_FieldMask) Project(source *GetLimitPoolRequest) *GetLimitPoolRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetLimitPoolRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetLimitPoolRequest_FieldTerminalPath:
			switch tp.selector {
			case GetLimitPoolRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetLimitPoolRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetLimitPoolRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetLimitPoolRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetLimitPoolRequest))
}

func (fieldMask *GetLimitPoolRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetLimitPoolsRequest_FieldMask struct {
	Paths []BatchGetLimitPoolsRequest_FieldPath
}

func FullBatchGetLimitPoolsRequest_FieldMask() *BatchGetLimitPoolsRequest_FieldMask {
	res := &BatchGetLimitPoolsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetLimitPoolsRequest_FieldTerminalPath{selector: BatchGetLimitPoolsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetLimitPoolsRequest_FieldTerminalPath{selector: BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetLimitPoolsRequest_FieldTerminalPath{selector: BatchGetLimitPoolsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetLimitPoolsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetLimitPoolsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetLimitPoolsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) Subtract(other *BatchGetLimitPoolsRequest_FieldMask) *BatchGetLimitPoolsRequest_FieldMask {
	result := &BatchGetLimitPoolsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetLimitPoolsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetLimitPoolsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) FilterInputFields() *BatchGetLimitPoolsRequest_FieldMask {
	result := &BatchGetLimitPoolsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetLimitPoolsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetLimitPoolsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetLimitPoolsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetLimitPoolsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) AppendPath(path BatchGetLimitPoolsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetLimitPoolsRequest_FieldPath))
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) GetPaths() []BatchGetLimitPoolsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetLimitPoolsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) Set(target, source *BatchGetLimitPoolsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetLimitPoolsRequest), source.(*BatchGetLimitPoolsRequest))
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) Project(source *BatchGetLimitPoolsRequest) *BatchGetLimitPoolsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetLimitPoolsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetLimitPoolsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetLimitPoolsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetLimitPoolsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetLimitPoolsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetLimitPoolsRequest))
}

func (fieldMask *BatchGetLimitPoolsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetLimitPoolsResponse_FieldMask struct {
	Paths []BatchGetLimitPoolsResponse_FieldPath
}

func FullBatchGetLimitPoolsResponse_FieldMask() *BatchGetLimitPoolsResponse_FieldMask {
	res := &BatchGetLimitPoolsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetLimitPoolsResponse_FieldTerminalPath{selector: BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools})
	res.Paths = append(res.Paths, &BatchGetLimitPoolsResponse_FieldTerminalPath{selector: BatchGetLimitPoolsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetLimitPoolsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetLimitPoolsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetLimitPoolsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) Subtract(other *BatchGetLimitPoolsResponse_FieldMask) *BatchGetLimitPoolsResponse_FieldMask {
	result := &BatchGetLimitPoolsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetLimitPoolsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools: &limit_pool.LimitPool_FieldMask{},
	}
	mySubMasks := map[BatchGetLimitPoolsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools: &limit_pool.LimitPool_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetLimitPoolsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetLimitPoolsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetLimitPoolsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
						mySubMasks[BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools] = limit_pool.FullLimitPool_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetLimitPoolsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetLimitPoolsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetLimitPoolsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) FilterInputFields() *BatchGetLimitPoolsResponse_FieldMask {
	result := &BatchGetLimitPoolsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
			if _, ok := path.(*BatchGetLimitPoolsResponse_FieldTerminalPath); ok {
				for _, subpath := range limit_pool.FullLimitPool_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetLimitPoolsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetLimitPoolsResponse_FieldSubPath); ok {
				selectedMask := &limit_pool.LimitPool_FieldMask{
					Paths: []limit_pool.LimitPool_FieldPath{sub.subPath.(limit_pool.LimitPool_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetLimitPoolsResponse_FieldSubPath{selector: BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetLimitPoolsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetLimitPoolsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetLimitPoolsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetLimitPoolsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) AppendPath(path BatchGetLimitPoolsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetLimitPoolsResponse_FieldPath))
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) GetPaths() []BatchGetLimitPoolsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetLimitPoolsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) Set(target, source *BatchGetLimitPoolsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetLimitPoolsResponse), source.(*BatchGetLimitPoolsResponse))
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) Project(source *BatchGetLimitPoolsResponse) *BatchGetLimitPoolsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetLimitPoolsResponse{}
	limitPoolsMask := &limit_pool.LimitPool_FieldMask{}
	wholeLimitPoolsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetLimitPoolsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
				result.LimitPools = source.LimitPools
				wholeLimitPoolsAccepted = true
			case BatchGetLimitPoolsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetLimitPoolsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetLimitPoolsResponse_FieldPathSelectorLimitPools:
				limitPoolsMask.AppendPath(tp.subPath.(limit_pool.LimitPool_FieldPath))
			}
		}
	}
	if wholeLimitPoolsAccepted == false && len(limitPoolsMask.Paths) > 0 {
		for _, sourceItem := range source.GetLimitPools() {
			result.LimitPools = append(result.LimitPools, limitPoolsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetLimitPoolsResponse))
}

func (fieldMask *BatchGetLimitPoolsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListLimitPoolsRequest_FieldMask struct {
	Paths []ListLimitPoolsRequest_FieldPath
}

func FullListLimitPoolsRequest_FieldMask() *ListLimitPoolsRequest_FieldMask {
	res := &ListLimitPoolsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListLimitPoolsRequest_FieldTerminalPath{selector: ListLimitPoolsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListLimitPoolsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListLimitPoolsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListLimitPoolsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListLimitPoolsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListLimitPoolsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) Subtract(other *ListLimitPoolsRequest_FieldMask) *ListLimitPoolsRequest_FieldMask {
	result := &ListLimitPoolsRequest_FieldMask{}
	removedSelectors := make([]bool, 7)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListLimitPoolsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListLimitPoolsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListLimitPoolsRequest_FieldMask) FilterInputFields() *ListLimitPoolsRequest_FieldMask {
	result := &ListLimitPoolsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListLimitPoolsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListLimitPoolsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListLimitPoolsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListLimitPoolsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListLimitPoolsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) AppendPath(path ListLimitPoolsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListLimitPoolsRequest_FieldPath))
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) GetPaths() []ListLimitPoolsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListLimitPoolsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) Set(target, source *ListLimitPoolsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListLimitPoolsRequest), source.(*ListLimitPoolsRequest))
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) Project(source *ListLimitPoolsRequest) *ListLimitPoolsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListLimitPoolsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListLimitPoolsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListLimitPoolsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListLimitPoolsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListLimitPoolsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListLimitPoolsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListLimitPoolsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListLimitPoolsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListLimitPoolsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListLimitPoolsRequest))
}

func (fieldMask *ListLimitPoolsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListLimitPoolsResponse_FieldMask struct {
	Paths []ListLimitPoolsResponse_FieldPath
}

func FullListLimitPoolsResponse_FieldMask() *ListLimitPoolsResponse_FieldMask {
	res := &ListLimitPoolsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListLimitPoolsResponse_FieldTerminalPath{selector: ListLimitPoolsResponse_FieldPathSelectorLimitPools})
	res.Paths = append(res.Paths, &ListLimitPoolsResponse_FieldTerminalPath{selector: ListLimitPoolsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListLimitPoolsResponse_FieldTerminalPath{selector: ListLimitPoolsResponse_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListLimitPoolsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListLimitPoolsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListLimitPoolsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListLimitPoolsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListLimitPoolsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) Subtract(other *ListLimitPoolsResponse_FieldMask) *ListLimitPoolsResponse_FieldMask {
	result := &ListLimitPoolsResponse_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[ListLimitPoolsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListLimitPoolsResponse_FieldPathSelectorLimitPools: &limit_pool.LimitPool_FieldMask{},
	}
	mySubMasks := map[ListLimitPoolsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListLimitPoolsResponse_FieldPathSelectorLimitPools: &limit_pool.LimitPool_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListLimitPoolsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListLimitPoolsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListLimitPoolsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
						mySubMasks[ListLimitPoolsResponse_FieldPathSelectorLimitPools] = limit_pool.FullLimitPool_FieldMask()
					}
				} else if tp, ok := path.(*ListLimitPoolsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListLimitPoolsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListLimitPoolsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListLimitPoolsResponse_FieldMask) FilterInputFields() *ListLimitPoolsResponse_FieldMask {
	result := &ListLimitPoolsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
			if _, ok := path.(*ListLimitPoolsResponse_FieldTerminalPath); ok {
				for _, subpath := range limit_pool.FullLimitPool_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListLimitPoolsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListLimitPoolsResponse_FieldSubPath); ok {
				selectedMask := &limit_pool.LimitPool_FieldMask{
					Paths: []limit_pool.LimitPool_FieldPath{sub.subPath.(limit_pool.LimitPool_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListLimitPoolsResponse_FieldSubPath{selector: ListLimitPoolsResponse_FieldPathSelectorLimitPools, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListLimitPoolsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListLimitPoolsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListLimitPoolsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListLimitPoolsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListLimitPoolsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) AppendPath(path ListLimitPoolsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListLimitPoolsResponse_FieldPath))
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) GetPaths() []ListLimitPoolsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListLimitPoolsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) Set(target, source *ListLimitPoolsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListLimitPoolsResponse), source.(*ListLimitPoolsResponse))
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) Project(source *ListLimitPoolsResponse) *ListLimitPoolsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListLimitPoolsResponse{}
	limitPoolsMask := &limit_pool.LimitPool_FieldMask{}
	wholeLimitPoolsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListLimitPoolsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
				result.LimitPools = source.LimitPools
				wholeLimitPoolsAccepted = true
			case ListLimitPoolsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListLimitPoolsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		case *ListLimitPoolsResponse_FieldSubPath:
			switch tp.selector {
			case ListLimitPoolsResponse_FieldPathSelectorLimitPools:
				limitPoolsMask.AppendPath(tp.subPath.(limit_pool.LimitPool_FieldPath))
			}
		}
	}
	if wholeLimitPoolsAccepted == false && len(limitPoolsMask.Paths) > 0 {
		for _, sourceItem := range source.GetLimitPools() {
			result.LimitPools = append(result.LimitPools, limitPoolsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListLimitPoolsResponse))
}

func (fieldMask *ListLimitPoolsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLimitPoolRequest_FieldMask struct {
	Paths []WatchLimitPoolRequest_FieldPath
}

func FullWatchLimitPoolRequest_FieldMask() *WatchLimitPoolRequest_FieldMask {
	res := &WatchLimitPoolRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchLimitPoolRequest_FieldTerminalPath{selector: WatchLimitPoolRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchLimitPoolRequest_FieldTerminalPath{selector: WatchLimitPoolRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchLimitPoolRequest_FieldTerminalPath{selector: WatchLimitPoolRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLimitPoolRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLimitPoolRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLimitPoolRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLimitPoolRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLimitPoolRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) Subtract(other *WatchLimitPoolRequest_FieldMask) *WatchLimitPoolRequest_FieldMask {
	result := &WatchLimitPoolRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLimitPoolRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLimitPoolRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLimitPoolRequest_FieldMask) FilterInputFields() *WatchLimitPoolRequest_FieldMask {
	result := &WatchLimitPoolRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLimitPoolRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLimitPoolRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLimitPoolRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLimitPoolRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLimitPoolRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) AppendPath(path WatchLimitPoolRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLimitPoolRequest_FieldPath))
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) GetPaths() []WatchLimitPoolRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLimitPoolRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) Set(target, source *WatchLimitPoolRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLimitPoolRequest), source.(*WatchLimitPoolRequest))
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) Project(source *WatchLimitPoolRequest) *WatchLimitPoolRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLimitPoolRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLimitPoolRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchLimitPoolRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchLimitPoolRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchLimitPoolRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLimitPoolRequest))
}

func (fieldMask *WatchLimitPoolRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLimitPoolResponse_FieldMask struct {
	Paths []WatchLimitPoolResponse_FieldPath
}

func FullWatchLimitPoolResponse_FieldMask() *WatchLimitPoolResponse_FieldMask {
	res := &WatchLimitPoolResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchLimitPoolResponse_FieldTerminalPath{selector: WatchLimitPoolResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLimitPoolResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLimitPoolResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLimitPoolResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLimitPoolResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLimitPoolResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) Subtract(other *WatchLimitPoolResponse_FieldMask) *WatchLimitPoolResponse_FieldMask {
	result := &WatchLimitPoolResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLimitPoolResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLimitPoolResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLimitPoolResponse_FieldMask) FilterInputFields() *WatchLimitPoolResponse_FieldMask {
	result := &WatchLimitPoolResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLimitPoolResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLimitPoolResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLimitPoolResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLimitPoolResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLimitPoolResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) AppendPath(path WatchLimitPoolResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLimitPoolResponse_FieldPath))
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) GetPaths() []WatchLimitPoolResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLimitPoolResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) Set(target, source *WatchLimitPoolResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLimitPoolResponse), source.(*WatchLimitPoolResponse))
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) Project(source *WatchLimitPoolResponse) *WatchLimitPoolResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLimitPoolResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLimitPoolResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchLimitPoolResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLimitPoolResponse))
}

func (fieldMask *WatchLimitPoolResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLimitPoolsRequest_FieldMask struct {
	Paths []WatchLimitPoolsRequest_FieldPath
}

func FullWatchLimitPoolsRequest_FieldMask() *WatchLimitPoolsRequest_FieldMask {
	res := &WatchLimitPoolsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchLimitPoolsRequest_FieldTerminalPath{selector: WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLimitPoolsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLimitPoolsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLimitPoolsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLimitPoolsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) Subtract(other *WatchLimitPoolsRequest_FieldMask) *WatchLimitPoolsRequest_FieldMask {
	result := &WatchLimitPoolsRequest_FieldMask{}
	removedSelectors := make([]bool, 10)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLimitPoolsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLimitPoolsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLimitPoolsRequest_FieldMask) FilterInputFields() *WatchLimitPoolsRequest_FieldMask {
	result := &WatchLimitPoolsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLimitPoolsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLimitPoolsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLimitPoolsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLimitPoolsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLimitPoolsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) AppendPath(path WatchLimitPoolsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLimitPoolsRequest_FieldPath))
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) GetPaths() []WatchLimitPoolsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLimitPoolsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) Set(target, source *WatchLimitPoolsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLimitPoolsRequest), source.(*WatchLimitPoolsRequest))
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) Project(source *WatchLimitPoolsRequest) *WatchLimitPoolsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLimitPoolsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLimitPoolsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchLimitPoolsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchLimitPoolsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchLimitPoolsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchLimitPoolsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchLimitPoolsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchLimitPoolsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchLimitPoolsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchLimitPoolsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchLimitPoolsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchLimitPoolsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLimitPoolsRequest))
}

func (fieldMask *WatchLimitPoolsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLimitPoolsResponse_FieldMask struct {
	Paths []WatchLimitPoolsResponse_FieldPath
}

func FullWatchLimitPoolsResponse_FieldMask() *WatchLimitPoolsResponse_FieldMask {
	res := &WatchLimitPoolsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges})
	res.Paths = append(res.Paths, &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchLimitPoolsResponse_FieldTerminalPath{selector: WatchLimitPoolsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLimitPoolsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLimitPoolsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLimitPoolsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLimitPoolsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) Subtract(other *WatchLimitPoolsResponse_FieldMask) *WatchLimitPoolsResponse_FieldMask {
	result := &WatchLimitPoolsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchLimitPoolsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange: &WatchLimitPoolsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchLimitPoolsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange: &WatchLimitPoolsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLimitPoolsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchLimitPoolsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchLimitPoolsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange] = FullWatchLimitPoolsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchLimitPoolsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchLimitPoolsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLimitPoolsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLimitPoolsResponse_FieldMask) FilterInputFields() *WatchLimitPoolsResponse_FieldMask {
	result := &WatchLimitPoolsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLimitPoolsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLimitPoolsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLimitPoolsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLimitPoolsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLimitPoolsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) AppendPath(path WatchLimitPoolsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLimitPoolsResponse_FieldPath))
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) GetPaths() []WatchLimitPoolsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLimitPoolsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) Set(target, source *WatchLimitPoolsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLimitPoolsResponse), source.(*WatchLimitPoolsResponse))
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) Project(source *WatchLimitPoolsResponse) *WatchLimitPoolsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLimitPoolsResponse{}
	pageTokenChangeMask := &WatchLimitPoolsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLimitPoolsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchLimitPoolsResponse_FieldPathSelectorLimitPoolChanges:
				result.LimitPoolChanges = source.LimitPoolChanges
			case WatchLimitPoolsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchLimitPoolsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchLimitPoolsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchLimitPoolsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchLimitPoolsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchLimitPoolsResponse_FieldSubPath:
			switch tp.selector {
			case WatchLimitPoolsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchLimitPoolsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLimitPoolsResponse))
}

func (fieldMask *WatchLimitPoolsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchLimitPoolsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchLimitPoolsResponsePageTokenChange_FieldPath
}

func FullWatchLimitPoolsResponse_PageTokenChange_FieldMask() *WatchLimitPoolsResponse_PageTokenChange_FieldMask {
	res := &WatchLimitPoolsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath{selector: WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath{selector: WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) Subtract(other *WatchLimitPoolsResponse_PageTokenChange_FieldMask) *WatchLimitPoolsResponse_PageTokenChange_FieldMask {
	result := &WatchLimitPoolsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchLimitPoolsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchLimitPoolsResponse_PageTokenChange_FieldMask {
	result := &WatchLimitPoolsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchLimitPoolsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchLimitPoolsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchLimitPoolsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) AppendPath(path WatchLimitPoolsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchLimitPoolsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) GetPaths() []WatchLimitPoolsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchLimitPoolsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) Set(target, source *WatchLimitPoolsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchLimitPoolsResponse_PageTokenChange), source.(*WatchLimitPoolsResponse_PageTokenChange))
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) Project(source *WatchLimitPoolsResponse_PageTokenChange) *WatchLimitPoolsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchLimitPoolsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchLimitPoolsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchLimitPoolsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchLimitPoolsResponse_PageTokenChange))
}

func (fieldMask *WatchLimitPoolsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateLimitPoolRequest_FieldMask struct {
	Paths []UpdateLimitPoolRequest_FieldPath
}

func FullUpdateLimitPoolRequest_FieldMask() *UpdateLimitPoolRequest_FieldMask {
	res := &UpdateLimitPoolRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateLimitPoolRequest_FieldTerminalPath{selector: UpdateLimitPoolRequest_FieldPathSelectorLimitPool})
	res.Paths = append(res.Paths, &UpdateLimitPoolRequest_FieldTerminalPath{selector: UpdateLimitPoolRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateLimitPoolRequest_FieldTerminalPath{selector: UpdateLimitPoolRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateLimitPoolRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateLimitPoolRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateLimitPoolRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateLimitPoolRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) Subtract(other *UpdateLimitPoolRequest_FieldMask) *UpdateLimitPoolRequest_FieldMask {
	result := &UpdateLimitPoolRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateLimitPoolRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateLimitPoolRequest_FieldPathSelectorLimitPool: &limit_pool.LimitPool_FieldMask{},
		UpdateLimitPoolRequest_FieldPathSelectorCas:       &UpdateLimitPoolRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateLimitPoolRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateLimitPoolRequest_FieldPathSelectorLimitPool: &limit_pool.LimitPool_FieldMask{},
		UpdateLimitPoolRequest_FieldPathSelectorCas:       &UpdateLimitPoolRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateLimitPoolRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateLimitPoolRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateLimitPoolRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
						mySubMasks[UpdateLimitPoolRequest_FieldPathSelectorLimitPool] = limit_pool.FullLimitPool_FieldMask()
					case UpdateLimitPoolRequest_FieldPathSelectorCas:
						mySubMasks[UpdateLimitPoolRequest_FieldPathSelectorCas] = FullUpdateLimitPoolRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateLimitPoolRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateLimitPoolRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateLimitPoolRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateLimitPoolRequest_FieldMask) FilterInputFields() *UpdateLimitPoolRequest_FieldMask {
	result := &UpdateLimitPoolRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
			if _, ok := path.(*UpdateLimitPoolRequest_FieldTerminalPath); ok {
				for _, subpath := range limit_pool.FullLimitPool_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLimitPoolRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateLimitPoolRequest_FieldSubPath); ok {
				selectedMask := &limit_pool.LimitPool_FieldMask{
					Paths: []limit_pool.LimitPool_FieldPath{sub.subPath.(limit_pool.LimitPool_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLimitPoolRequest_FieldSubPath{selector: UpdateLimitPoolRequest_FieldPathSelectorLimitPool, subPath: allowedPath})
				}
			}
		case UpdateLimitPoolRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateLimitPoolRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateLimitPoolRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLimitPoolRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateLimitPoolRequest_FieldSubPath); ok {
				selectedMask := &UpdateLimitPoolRequest_CAS_FieldMask{
					Paths: []UpdateLimitPoolRequestCAS_FieldPath{sub.subPath.(UpdateLimitPoolRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLimitPoolRequest_FieldSubPath{selector: UpdateLimitPoolRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateLimitPoolRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateLimitPoolRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateLimitPoolRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateLimitPoolRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateLimitPoolRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) AppendPath(path UpdateLimitPoolRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateLimitPoolRequest_FieldPath))
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) GetPaths() []UpdateLimitPoolRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateLimitPoolRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) Set(target, source *UpdateLimitPoolRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateLimitPoolRequest), source.(*UpdateLimitPoolRequest))
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) Project(source *UpdateLimitPoolRequest) *UpdateLimitPoolRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateLimitPoolRequest{}
	limitPoolMask := &limit_pool.LimitPool_FieldMask{}
	wholeLimitPoolAccepted := false
	casMask := &UpdateLimitPoolRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateLimitPoolRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
				result.LimitPool = source.LimitPool
				wholeLimitPoolAccepted = true
			case UpdateLimitPoolRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateLimitPoolRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateLimitPoolRequest_FieldSubPath:
			switch tp.selector {
			case UpdateLimitPoolRequest_FieldPathSelectorLimitPool:
				limitPoolMask.AppendPath(tp.subPath.(limit_pool.LimitPool_FieldPath))
			case UpdateLimitPoolRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateLimitPoolRequestCAS_FieldPath))
			}
		}
	}
	if wholeLimitPoolAccepted == false && len(limitPoolMask.Paths) > 0 {
		result.LimitPool = limitPoolMask.Project(source.GetLimitPool())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateLimitPoolRequest))
}

func (fieldMask *UpdateLimitPoolRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateLimitPoolRequest_CAS_FieldMask struct {
	Paths []UpdateLimitPoolRequestCAS_FieldPath
}

func FullUpdateLimitPoolRequest_CAS_FieldMask() *UpdateLimitPoolRequest_CAS_FieldMask {
	res := &UpdateLimitPoolRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateLimitPoolRequestCAS_FieldTerminalPath{selector: UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateLimitPoolRequestCAS_FieldTerminalPath{selector: UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateLimitPoolRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateLimitPoolRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateLimitPoolRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) Subtract(other *UpdateLimitPoolRequest_CAS_FieldMask) *UpdateLimitPoolRequest_CAS_FieldMask {
	result := &UpdateLimitPoolRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateLimitPoolRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState: &limit_pool.LimitPool_FieldMask{},
	}
	mySubMasks := map[UpdateLimitPoolRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState: &limit_pool.LimitPool_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateLimitPoolRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateLimitPoolRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateLimitPoolRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState] = limit_pool.FullLimitPool_FieldMask()
					}
				} else if tp, ok := path.(*UpdateLimitPoolRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateLimitPoolRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateLimitPoolRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) FilterInputFields() *UpdateLimitPoolRequest_CAS_FieldMask {
	result := &UpdateLimitPoolRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateLimitPoolRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range limit_pool.FullLimitPool_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLimitPoolRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateLimitPoolRequestCAS_FieldSubPath); ok {
				selectedMask := &limit_pool.LimitPool_FieldMask{
					Paths: []limit_pool.LimitPool_FieldPath{sub.subPath.(limit_pool.LimitPool_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateLimitPoolRequestCAS_FieldSubPath{selector: UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateLimitPoolRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateLimitPoolRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateLimitPoolRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateLimitPoolRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) AppendPath(path UpdateLimitPoolRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateLimitPoolRequestCAS_FieldPath))
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) GetPaths() []UpdateLimitPoolRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateLimitPoolRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) Set(target, source *UpdateLimitPoolRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateLimitPoolRequest_CAS), source.(*UpdateLimitPoolRequest_CAS))
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) Project(source *UpdateLimitPoolRequest_CAS) *UpdateLimitPoolRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateLimitPoolRequest_CAS{}
	conditionalStateMask := &limit_pool.LimitPool_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateLimitPoolRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateLimitPoolRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateLimitPoolRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateLimitPoolRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(limit_pool.LimitPool_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateLimitPoolRequest_CAS))
}

func (fieldMask *UpdateLimitPoolRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteLimitPoolRequest_FieldMask struct {
	Paths []DeleteLimitPoolRequest_FieldPath
}

func FullDeleteLimitPoolRequest_FieldMask() *DeleteLimitPoolRequest_FieldMask {
	res := &DeleteLimitPoolRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteLimitPoolRequest_FieldTerminalPath{selector: DeleteLimitPoolRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteLimitPoolRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteLimitPoolRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteLimitPoolRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteLimitPoolRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) Subtract(other *DeleteLimitPoolRequest_FieldMask) *DeleteLimitPoolRequest_FieldMask {
	result := &DeleteLimitPoolRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteLimitPoolRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteLimitPoolRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteLimitPoolRequest_FieldMask) FilterInputFields() *DeleteLimitPoolRequest_FieldMask {
	result := &DeleteLimitPoolRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteLimitPoolRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteLimitPoolRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteLimitPoolRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteLimitPoolRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteLimitPoolRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) AppendPath(path DeleteLimitPoolRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteLimitPoolRequest_FieldPath))
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) GetPaths() []DeleteLimitPoolRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteLimitPoolRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) Set(target, source *DeleteLimitPoolRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteLimitPoolRequest), source.(*DeleteLimitPoolRequest))
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) Project(source *DeleteLimitPoolRequest) *DeleteLimitPoolRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteLimitPoolRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteLimitPoolRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteLimitPoolRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteLimitPoolRequest))
}

func (fieldMask *DeleteLimitPoolRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
