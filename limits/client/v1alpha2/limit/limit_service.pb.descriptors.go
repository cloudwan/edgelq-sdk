// Code generated by protoc-gen-goten-client
// API: LimitService
// DO NOT EDIT!!!

package limit_client

import (
	"google.golang.org/protobuf/proto"

	gotenclient "github.com/cloudwan/goten-sdk/runtime/client"
	gotenresource "github.com/cloudwan/goten-sdk/runtime/resource"
)

// proto imports
import (
	limit "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/limit"
	empty "github.com/golang/protobuf/ptypes/empty"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = proto.Message(nil)
	_ = gotenclient.MethodDescriptor(nil)
	_ = gotenresource.WildcardId
)

// make sure we're using proto imports
var (
	_ = &limit.Limit{}
	_ = &empty.Empty{}
)

var (
	descriptorsInitialized   bool
	limitServiceDescriptor   *LimitServiceDescriptor
	getLimitDescriptor       *GetLimitDescriptor
	batchGetLimitsDescriptor *BatchGetLimitsDescriptor
	listLimitsDescriptor     *ListLimitsDescriptor
	watchLimitDescriptor     *WatchLimitDescriptor
	watchLimitsDescriptor    *WatchLimitsDescriptor
	updateLimitDescriptor    *UpdateLimitDescriptor
	deleteLimitDescriptor    *DeleteLimitDescriptor
)

type GetLimitDescriptor struct{}

type GetLimitDescriptorClientMsgHandle struct{}

type GetLimitDescriptorServerMsgHandle struct{}

func (d *GetLimitDescriptor) NewEmptyClientMsg() proto.Message {
	return &GetLimitRequest{}
}

func (d *GetLimitDescriptor) NewEmptyServerMsg() proto.Message {
	return &limit.Limit{}
}

func (d *GetLimitDescriptor) IsUnary() bool {
	return true
}

func (d *GetLimitDescriptor) IsClientStream() bool {
	return false
}

func (d *GetLimitDescriptor) IsServerStream() bool {
	return false
}

func (d *GetLimitDescriptor) IsCollection() bool {
	return false
}

func (d *GetLimitDescriptor) IsPlural() bool {
	return false
}

func (d *GetLimitDescriptor) HasResource() bool {
	return true
}

func (d *GetLimitDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *GetLimitDescriptor) GetVerb() string {
	return "get"
}

func (d *GetLimitDescriptor) GetMethodName() string {
	return "GetLimit"
}

func (d *GetLimitDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitService/GetLimit"
}

func (d *GetLimitDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *GetLimitDescriptor) GetApiName() string {
	return "LimitService"
}

func (d *GetLimitDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *GetLimitDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *GetLimitDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitServiceDescriptor
}

func (d *GetLimitDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit.GetDescriptor()
}

func (d *GetLimitDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetLimitDescriptorClientMsgHandle{}
}

func (d *GetLimitDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetLimitDescriptorServerMsgHandle{}
}

func (h *GetLimitDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*GetLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*GetLimitRequest) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*limit.Name)(nil)
}

func (h *GetLimitDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*GetLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*GetLimitRequest) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetLimitDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*GetLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*GetLimitRequest) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *GetLimitDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit.Limit)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*limit.Limit) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if name := typedMsg.GetName(); name != nil {
			return name
		}
	}
	return (*limit.Name)(nil)
}

func (h *GetLimitDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*limit.Limit)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*limit.Limit) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetLimitDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit.Limit)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*limit.Limit) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetGetLimitDescriptor() *GetLimitDescriptor {
	return getLimitDescriptor
}

type BatchGetLimitsDescriptor struct{}

type BatchGetLimitsDescriptorClientMsgHandle struct{}

type BatchGetLimitsDescriptorServerMsgHandle struct{}

func (d *BatchGetLimitsDescriptor) NewEmptyClientMsg() proto.Message {
	return &BatchGetLimitsRequest{}
}

func (d *BatchGetLimitsDescriptor) NewEmptyServerMsg() proto.Message {
	return &BatchGetLimitsResponse{}
}

func (d *BatchGetLimitsDescriptor) IsUnary() bool {
	return true
}

func (d *BatchGetLimitsDescriptor) IsClientStream() bool {
	return false
}

func (d *BatchGetLimitsDescriptor) IsServerStream() bool {
	return false
}

func (d *BatchGetLimitsDescriptor) IsCollection() bool {
	return false
}

func (d *BatchGetLimitsDescriptor) IsPlural() bool {
	return true
}

func (d *BatchGetLimitsDescriptor) HasResource() bool {
	return true
}

func (d *BatchGetLimitsDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *BatchGetLimitsDescriptor) GetVerb() string {
	return "batchGet"
}

func (d *BatchGetLimitsDescriptor) GetMethodName() string {
	return "BatchGetLimits"
}

func (d *BatchGetLimitsDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitService/BatchGetLimits"
}

func (d *BatchGetLimitsDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *BatchGetLimitsDescriptor) GetApiName() string {
	return "LimitService"
}

func (d *BatchGetLimitsDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *BatchGetLimitsDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *BatchGetLimitsDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitServiceDescriptor
}

func (d *BatchGetLimitsDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit.GetDescriptor()
}

func (d *BatchGetLimitsDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &BatchGetLimitsDescriptorClientMsgHandle{}
}

func (d *BatchGetLimitsDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &BatchGetLimitsDescriptorServerMsgHandle{}
}

func (h *BatchGetLimitsDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*BatchGetLimitsRequest) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *BatchGetLimitsDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*BatchGetLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*BatchGetLimitsRequest) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if refs := typedMsg.GetNames(); len(refs) > 0 {
			list := make(limit.LimitNameList, 0, len(refs))
			for _, ref := range refs {
				list = append(list, &ref.Name)
			}
			return list
		}
	}
	return (limit.LimitNameList)(nil)
}

func (h *BatchGetLimitsDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*BatchGetLimitsRequest) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *BatchGetLimitsDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*BatchGetLimitsResponse) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *BatchGetLimitsDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*BatchGetLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*BatchGetLimitsResponse) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resources := typedMsg.GetLimits(); len(resources) > 0 {
			list := make(limit.LimitNameList, 0, len(resources))
			for _, res := range resources {
				list = append(list, res.GetName())
			}
			return list
		}
	}
	return (limit.LimitNameList)(nil)
}

func (h *BatchGetLimitsDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*BatchGetLimitsResponse) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetBatchGetLimitsDescriptor() *BatchGetLimitsDescriptor {
	return batchGetLimitsDescriptor
}

type ListLimitsDescriptor struct{}

type ListLimitsDescriptorClientMsgHandle struct{}

type ListLimitsDescriptorServerMsgHandle struct{}

func (d *ListLimitsDescriptor) NewEmptyClientMsg() proto.Message {
	return &ListLimitsRequest{}
}

func (d *ListLimitsDescriptor) NewEmptyServerMsg() proto.Message {
	return &ListLimitsResponse{}
}

func (d *ListLimitsDescriptor) IsUnary() bool {
	return true
}

func (d *ListLimitsDescriptor) IsClientStream() bool {
	return false
}

func (d *ListLimitsDescriptor) IsServerStream() bool {
	return false
}

func (d *ListLimitsDescriptor) IsCollection() bool {
	return true
}

func (d *ListLimitsDescriptor) IsPlural() bool {
	return true
}

func (d *ListLimitsDescriptor) HasResource() bool {
	return true
}

func (d *ListLimitsDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *ListLimitsDescriptor) GetVerb() string {
	return "list"
}

func (d *ListLimitsDescriptor) GetMethodName() string {
	return "ListLimits"
}

func (d *ListLimitsDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitService/ListLimits"
}

func (d *ListLimitsDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *ListLimitsDescriptor) GetApiName() string {
	return "LimitService"
}

func (d *ListLimitsDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *ListLimitsDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *ListLimitsDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitServiceDescriptor
}

func (d *ListLimitsDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit.GetDescriptor()
}

func (d *ListLimitsDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &ListLimitsDescriptorClientMsgHandle{}
}

func (d *ListLimitsDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &ListLimitsDescriptorServerMsgHandle{}
}

func (h *ListLimitsDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*ListLimitsRequest) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *ListLimitsDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*ListLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*ListLimitsRequest) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *ListLimitsDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*ListLimitsRequest) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	{
		if parentName := typedMsg.GetParent(); parentName != nil {
			return parentName
		}
	}
	return (*limit.ParentName)(nil)
}

func (h *ListLimitsDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*ListLimitsResponse) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *ListLimitsDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*ListLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*ListLimitsResponse) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resources := typedMsg.GetLimits(); len(resources) > 0 {
			list := make(limit.LimitNameList, 0, len(resources))
			for _, res := range resources {
				list = append(list, res.GetName())
			}
			return list
		}
	}
	return (limit.LimitNameList)(nil)
}

func (h *ListLimitsDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*ListLimitsResponse) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetListLimitsDescriptor() *ListLimitsDescriptor {
	return listLimitsDescriptor
}

type WatchLimitDescriptor struct{}

type WatchLimitDescriptorClientMsgHandle struct{}

type WatchLimitDescriptorServerMsgHandle struct{}

func (d *WatchLimitDescriptor) NewEmptyClientMsg() proto.Message {
	return &WatchLimitRequest{}
}

func (d *WatchLimitDescriptor) NewEmptyServerMsg() proto.Message {
	return &WatchLimitResponse{}
}

func (d *WatchLimitDescriptor) IsUnary() bool {
	return false
}

func (d *WatchLimitDescriptor) IsClientStream() bool {
	return false
}

func (d *WatchLimitDescriptor) IsServerStream() bool {
	return true
}

func (d *WatchLimitDescriptor) IsCollection() bool {
	return false
}

func (d *WatchLimitDescriptor) IsPlural() bool {
	return false
}

func (d *WatchLimitDescriptor) HasResource() bool {
	return true
}

func (d *WatchLimitDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *WatchLimitDescriptor) GetVerb() string {
	return "watch"
}

func (d *WatchLimitDescriptor) GetMethodName() string {
	return "WatchLimit"
}

func (d *WatchLimitDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitService/WatchLimit"
}

func (d *WatchLimitDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *WatchLimitDescriptor) GetApiName() string {
	return "LimitService"
}

func (d *WatchLimitDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *WatchLimitDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *WatchLimitDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitServiceDescriptor
}

func (d *WatchLimitDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit.GetDescriptor()
}

func (d *WatchLimitDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchLimitDescriptorClientMsgHandle{}
}

func (d *WatchLimitDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchLimitDescriptorServerMsgHandle{}
}

func (h *WatchLimitDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchLimitRequest) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*limit.Name)(nil)
}

func (h *WatchLimitDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchLimitRequest) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchLimitDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*WatchLimitRequest) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *WatchLimitDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchLimitResponse) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if resChange := typedMsg.GetChange(); resChange != nil {
			switch tResChange := resChange.ChangeType.(type) {
			case *limit.LimitChange_Added_:
				return tResChange.Added.GetLimit().GetName()
			case *limit.LimitChange_Modified_:
				return tResChange.Modified.GetName()
			case *limit.LimitChange_Removed_:
				return tResChange.Removed.GetName()
			case *limit.LimitChange_Current_:
				return tResChange.Current.GetLimit().GetName()
			}
		}
	}
	return (*limit.Name)(nil)
}

func (h *WatchLimitDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchLimitResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchLimitResponse) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchLimitDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*WatchLimitResponse) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetWatchLimitDescriptor() *WatchLimitDescriptor {
	return watchLimitDescriptor
}

type WatchLimitsDescriptor struct{}

type WatchLimitsDescriptorClientMsgHandle struct{}

type WatchLimitsDescriptorServerMsgHandle struct{}

func (d *WatchLimitsDescriptor) NewEmptyClientMsg() proto.Message {
	return &WatchLimitsRequest{}
}

func (d *WatchLimitsDescriptor) NewEmptyServerMsg() proto.Message {
	return &WatchLimitsResponse{}
}

func (d *WatchLimitsDescriptor) IsUnary() bool {
	return false
}

func (d *WatchLimitsDescriptor) IsClientStream() bool {
	return false
}

func (d *WatchLimitsDescriptor) IsServerStream() bool {
	return true
}

func (d *WatchLimitsDescriptor) IsCollection() bool {
	return true
}

func (d *WatchLimitsDescriptor) IsPlural() bool {
	return true
}

func (d *WatchLimitsDescriptor) HasResource() bool {
	return true
}

func (d *WatchLimitsDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *WatchLimitsDescriptor) GetVerb() string {
	return "watch"
}

func (d *WatchLimitsDescriptor) GetMethodName() string {
	return "WatchLimits"
}

func (d *WatchLimitsDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitService/WatchLimits"
}

func (d *WatchLimitsDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *WatchLimitsDescriptor) GetApiName() string {
	return "LimitService"
}

func (d *WatchLimitsDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *WatchLimitsDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *WatchLimitsDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitServiceDescriptor
}

func (d *WatchLimitsDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit.GetDescriptor()
}

func (d *WatchLimitsDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchLimitsDescriptorClientMsgHandle{}
}

func (d *WatchLimitsDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchLimitsDescriptorServerMsgHandle{}
}

func (h *WatchLimitsDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchLimitsRequest) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *WatchLimitsDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchLimitsRequest) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchLimitsDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*WatchLimitsRequest) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	{
		if ref := typedMsg.GetParent(); ref != nil {
			return &ref.ParentName
		}
	}
	return (*limit.ParentName)(nil)
}

func (h *WatchLimitsDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchLimitsResponse) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *WatchLimitsDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchLimitsResponse) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resChanges := typedMsg.GetLimitChanges(); len(resChanges) > 0 {
			list := make(limit.LimitNameList, 0, len(resChanges))
			for _, resChange := range resChanges {
				switch tResChange := resChange.ChangeType.(type) {
				case *limit.LimitChange_Added_:
					list = append(list, tResChange.Added.GetLimit().GetName())
				case *limit.LimitChange_Modified_:
					list = append(list, tResChange.Modified.GetName())
				case *limit.LimitChange_Removed_:
					list = append(list, tResChange.Removed.GetName())
				case *limit.LimitChange_Current_:
					list = append(list, tResChange.Current.GetLimit().GetName())
				}
			}
			return list
		}
	}
	return (limit.LimitNameList)(nil)
}

func (h *WatchLimitsDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchLimitsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*WatchLimitsResponse) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetWatchLimitsDescriptor() *WatchLimitsDescriptor {
	return watchLimitsDescriptor
}

type UpdateLimitDescriptor struct{}

type UpdateLimitDescriptorClientMsgHandle struct{}

type UpdateLimitDescriptorServerMsgHandle struct{}

func (d *UpdateLimitDescriptor) NewEmptyClientMsg() proto.Message {
	return &UpdateLimitRequest{}
}

func (d *UpdateLimitDescriptor) NewEmptyServerMsg() proto.Message {
	return &limit.Limit{}
}

func (d *UpdateLimitDescriptor) IsUnary() bool {
	return true
}

func (d *UpdateLimitDescriptor) IsClientStream() bool {
	return false
}

func (d *UpdateLimitDescriptor) IsServerStream() bool {
	return false
}

func (d *UpdateLimitDescriptor) IsCollection() bool {
	return false
}

func (d *UpdateLimitDescriptor) IsPlural() bool {
	return false
}

func (d *UpdateLimitDescriptor) HasResource() bool {
	return true
}

func (d *UpdateLimitDescriptor) RequestHasResourceBody() bool {
	return true
}

func (d *UpdateLimitDescriptor) GetVerb() string {
	return "update"
}

func (d *UpdateLimitDescriptor) GetMethodName() string {
	return "UpdateLimit"
}

func (d *UpdateLimitDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitService/UpdateLimit"
}

func (d *UpdateLimitDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *UpdateLimitDescriptor) GetApiName() string {
	return "LimitService"
}

func (d *UpdateLimitDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *UpdateLimitDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *UpdateLimitDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitServiceDescriptor
}

func (d *UpdateLimitDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit.GetDescriptor()
}

func (d *UpdateLimitDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &UpdateLimitDescriptorClientMsgHandle{}
}

func (d *UpdateLimitDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &UpdateLimitDescriptorServerMsgHandle{}
}

func (h *UpdateLimitDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*UpdateLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*UpdateLimitRequest) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		res := typedMsg.GetLimit()
		if name := res.GetName(); name != nil {
			return name
		}
	}
	return (*limit.Name)(nil)
}

func (h *UpdateLimitDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*UpdateLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*UpdateLimitRequest) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *UpdateLimitDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*UpdateLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*UpdateLimitRequest) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *UpdateLimitDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit.Limit)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*limit.Limit) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if name := typedMsg.GetName(); name != nil {
			return name
		}
	}
	return (*limit.Name)(nil)
}

func (h *UpdateLimitDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*limit.Limit)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*limit.Limit) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *UpdateLimitDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*limit.Limit)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*limit.Limit) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetUpdateLimitDescriptor() *UpdateLimitDescriptor {
	return updateLimitDescriptor
}

type DeleteLimitDescriptor struct{}

type DeleteLimitDescriptorClientMsgHandle struct{}

type DeleteLimitDescriptorServerMsgHandle struct{}

func (d *DeleteLimitDescriptor) NewEmptyClientMsg() proto.Message {
	return &DeleteLimitRequest{}
}

func (d *DeleteLimitDescriptor) NewEmptyServerMsg() proto.Message {
	return &empty.Empty{}
}

func (d *DeleteLimitDescriptor) IsUnary() bool {
	return true
}

func (d *DeleteLimitDescriptor) IsClientStream() bool {
	return false
}

func (d *DeleteLimitDescriptor) IsServerStream() bool {
	return false
}

func (d *DeleteLimitDescriptor) IsCollection() bool {
	return false
}

func (d *DeleteLimitDescriptor) IsPlural() bool {
	return false
}

func (d *DeleteLimitDescriptor) HasResource() bool {
	return true
}

func (d *DeleteLimitDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *DeleteLimitDescriptor) GetVerb() string {
	return "delete"
}

func (d *DeleteLimitDescriptor) GetMethodName() string {
	return "DeleteLimit"
}

func (d *DeleteLimitDescriptor) GetFullMethodName() string {
	return "/ntt.limits.v1alpha2.LimitService/DeleteLimit"
}

func (d *DeleteLimitDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *DeleteLimitDescriptor) GetApiName() string {
	return "LimitService"
}

func (d *DeleteLimitDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *DeleteLimitDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func (d *DeleteLimitDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return limitServiceDescriptor
}

func (d *DeleteLimitDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return limit.GetDescriptor()
}

func (d *DeleteLimitDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &DeleteLimitDescriptorClientMsgHandle{}
}

func (d *DeleteLimitDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &DeleteLimitDescriptorServerMsgHandle{}
}

func (h *DeleteLimitDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*DeleteLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*DeleteLimitRequest) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*limit.Name)(nil)
}

func (h *DeleteLimitDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*DeleteLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*DeleteLimitRequest) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *DeleteLimitDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*DeleteLimitRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*DeleteLimitRequest) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func (h *DeleteLimitDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*empty.Empty) *limit.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *DeleteLimitDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*empty.Empty) []*limit.Name
	})
	if ok {
		return limit.LimitNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *DeleteLimitDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractCollectionName(*empty.Empty) *limit.ParentName
	})
	if ok {
		return override.OverrideExtractCollectionName(typedMsg)
	}
	return nil
}

func GetDeleteLimitDescriptor() *DeleteLimitDescriptor {
	return deleteLimitDescriptor
}

type LimitServiceDescriptor struct{}

func (d *LimitServiceDescriptor) AllMethodDescriptors() []gotenclient.MethodDescriptor {
	return []gotenclient.MethodDescriptor{
		getLimitDescriptor,
		batchGetLimitsDescriptor,
		listLimitsDescriptor,
		watchLimitDescriptor,
		watchLimitsDescriptor,
		updateLimitDescriptor,
		deleteLimitDescriptor,
	}
}

func (d *LimitServiceDescriptor) GetFullAPIName() string {
	return "/ntt.limits.v1alpha2.LimitService"
}

func (d *LimitServiceDescriptor) GetProtoPkgName() string {
	return "ntt.limits.v1alpha2"
}

func (d *LimitServiceDescriptor) GetApiName() string {
	return "LimitService"
}

func (d *LimitServiceDescriptor) GetServiceDomain() string {
	return "limits.edgelq.com"
}

func (d *LimitServiceDescriptor) GetServiceVersion() string {
	return "v1alpha2"
}

func GetLimitServiceDescriptor() *LimitServiceDescriptor {
	return limitServiceDescriptor
}

func initDescriptors() {
	limitServiceDescriptor = &LimitServiceDescriptor{}
	getLimitDescriptor = &GetLimitDescriptor{}
	batchGetLimitsDescriptor = &BatchGetLimitsDescriptor{}
	listLimitsDescriptor = &ListLimitsDescriptor{}
	watchLimitDescriptor = &WatchLimitDescriptor{}
	watchLimitsDescriptor = &WatchLimitsDescriptor{}
	updateLimitDescriptor = &UpdateLimitDescriptor{}
	deleteLimitDescriptor = &DeleteLimitDescriptor{}
	gotenclient.GetRegistry().RegisterApiDescriptor(limitServiceDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(getLimitDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(batchGetLimitsDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(listLimitsDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(watchLimitDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(watchLimitsDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(updateLimitDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(deleteLimitDescriptor)
}

func init() {
	if !descriptorsInitialized {
		initDescriptors()
		descriptorsInitialized = true
	}
}
