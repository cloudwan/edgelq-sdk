// Code generated by protoc-gen-goten-object
// File: edgelq/limits/proto/v1alpha2/limit_service.proto
// DO NOT EDIT!!!

package limit_client

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/project"
	limit "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/limit"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &iam_project.Project{}
	_ = &limit.Limit{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type GetLimitRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() GetLimitRequest_FieldPathSelector
	Get(source *GetLimitRequest) []interface{}
	GetSingle(source *GetLimitRequest) (interface{}, bool)
	ClearValue(item *GetLimitRequest)

	// Those methods build corresponding GetLimitRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) GetLimitRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) GetLimitRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) GetLimitRequest_FieldPathArrayItemValue
}

type GetLimitRequest_FieldPathSelector int32

const (
	GetLimitRequest_FieldPathSelectorName      GetLimitRequest_FieldPathSelector = 0
	GetLimitRequest_FieldPathSelectorFieldMask GetLimitRequest_FieldPathSelector = 1
	GetLimitRequest_FieldPathSelectorView      GetLimitRequest_FieldPathSelector = 2
)

func (s GetLimitRequest_FieldPathSelector) String() string {
	switch s {
	case GetLimitRequest_FieldPathSelectorName:
		return "name"
	case GetLimitRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case GetLimitRequest_FieldPathSelectorView:
		return "view"
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", s))
	}
}

func BuildGetLimitRequest_FieldPath(fp gotenobject.RawFieldPath) (GetLimitRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object GetLimitRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &GetLimitRequest_FieldTerminalPath{selector: GetLimitRequest_FieldPathSelectorName}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &GetLimitRequest_FieldTerminalPath{selector: GetLimitRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &GetLimitRequest_FieldTerminalPath{selector: GetLimitRequest_FieldPathSelectorView}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object GetLimitRequest", fp)
}

func ParseGetLimitRequest_FieldPath(rawField string) (GetLimitRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildGetLimitRequest_FieldPath(fp)
}

func MustParseGetLimitRequest_FieldPath(rawField string) GetLimitRequest_FieldPath {
	fp, err := ParseGetLimitRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type GetLimitRequest_FieldTerminalPath struct {
	selector GetLimitRequest_FieldPathSelector
}

var _ GetLimitRequest_FieldPath = (*GetLimitRequest_FieldTerminalPath)(nil)

func (fp *GetLimitRequest_FieldTerminalPath) Selector() GetLimitRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *GetLimitRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *GetLimitRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source GetLimitRequest
func (fp *GetLimitRequest_FieldTerminalPath) Get(source *GetLimitRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case GetLimitRequest_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		case GetLimitRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case GetLimitRequest_FieldPathSelectorView:
			values = append(values, source.View)
		default:
			panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *GetLimitRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*GetLimitRequest))
}

// GetSingle returns value pointed by specific field of from source GetLimitRequest
func (fp *GetLimitRequest_FieldTerminalPath) GetSingle(source *GetLimitRequest) (interface{}, bool) {
	switch fp.selector {
	case GetLimitRequest_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	case GetLimitRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case GetLimitRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fp.selector))
	}
}

func (fp *GetLimitRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*GetLimitRequest))
}

// GetDefault returns a default value of the field type
func (fp *GetLimitRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case GetLimitRequest_FieldPathSelectorName:
		return (*limit.Reference)(nil)
	case GetLimitRequest_FieldPathSelectorFieldMask:
		return (*limit.Limit_FieldMask)(nil)
	case GetLimitRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fp.selector))
	}
}

func (fp *GetLimitRequest_FieldTerminalPath) ClearValue(item *GetLimitRequest) {
	if item != nil {
		switch fp.selector {
		case GetLimitRequest_FieldPathSelectorName:
			item.Name = nil
		case GetLimitRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case GetLimitRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fp.selector))
		}
	}
}

func (fp *GetLimitRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*GetLimitRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *GetLimitRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == GetLimitRequest_FieldPathSelectorName ||
		fp.selector == GetLimitRequest_FieldPathSelectorFieldMask ||
		fp.selector == GetLimitRequest_FieldPathSelectorView
}

func (fp *GetLimitRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *GetLimitRequest_FieldTerminalPath) WithIValue(value interface{}) GetLimitRequest_FieldPathValue {
	switch fp.selector {
	case GetLimitRequest_FieldPathSelectorName:
		return &GetLimitRequest_FieldTerminalPathValue{GetLimitRequest_FieldTerminalPath: *fp, value: value.(*limit.Reference)}
	case GetLimitRequest_FieldPathSelectorFieldMask:
		return &GetLimitRequest_FieldTerminalPathValue{GetLimitRequest_FieldTerminalPath: *fp, value: value.(*limit.Limit_FieldMask)}
	case GetLimitRequest_FieldPathSelectorView:
		return &GetLimitRequest_FieldTerminalPathValue{GetLimitRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fp.selector))
	}
}

func (fp *GetLimitRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *GetLimitRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) GetLimitRequest_FieldPathArrayOfValues {
	fpaov := &GetLimitRequest_FieldTerminalPathArrayOfValues{GetLimitRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case GetLimitRequest_FieldPathSelectorName:
		return &GetLimitRequest_FieldTerminalPathArrayOfValues{GetLimitRequest_FieldTerminalPath: *fp, values: values.([]*limit.Reference)}
	case GetLimitRequest_FieldPathSelectorFieldMask:
		return &GetLimitRequest_FieldTerminalPathArrayOfValues{GetLimitRequest_FieldTerminalPath: *fp, values: values.([]*limit.Limit_FieldMask)}
	case GetLimitRequest_FieldPathSelectorView:
		return &GetLimitRequest_FieldTerminalPathArrayOfValues{GetLimitRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *GetLimitRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *GetLimitRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) GetLimitRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fp.selector))
	}
}

func (fp *GetLimitRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// GetLimitRequest_FieldPathValue allows storing values for GetLimitRequest fields according to their type
type GetLimitRequest_FieldPathValue interface {
	GetLimitRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **GetLimitRequest)
	CompareWith(*GetLimitRequest) (cmp int, comparable bool)
}

func ParseGetLimitRequest_FieldPathValue(pathStr, valueStr string) (GetLimitRequest_FieldPathValue, error) {
	fp, err := ParseGetLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing GetLimitRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(GetLimitRequest_FieldPathValue), nil
}

func MustParseGetLimitRequest_FieldPathValue(pathStr, valueStr string) GetLimitRequest_FieldPathValue {
	fpv, err := ParseGetLimitRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type GetLimitRequest_FieldTerminalPathValue struct {
	GetLimitRequest_FieldTerminalPath
	value interface{}
}

var _ GetLimitRequest_FieldPathValue = (*GetLimitRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'GetLimitRequest' as interface{}
func (fpv *GetLimitRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *GetLimitRequest_FieldTerminalPathValue) AsNameValue() (*limit.Reference, bool) {
	res, ok := fpv.value.(*limit.Reference)
	return res, ok
}
func (fpv *GetLimitRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit.Limit_FieldMask, bool) {
	res, ok := fpv.value.(*limit.Limit_FieldMask)
	return res, ok
}
func (fpv *GetLimitRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}

// SetTo stores value for selected field for object GetLimitRequest
func (fpv *GetLimitRequest_FieldTerminalPathValue) SetTo(target **GetLimitRequest) {
	if *target == nil {
		*target = new(GetLimitRequest)
	}
	switch fpv.selector {
	case GetLimitRequest_FieldPathSelectorName:
		(*target).Name = fpv.value.(*limit.Reference)
	case GetLimitRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit.Limit_FieldMask)
	case GetLimitRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fpv.selector))
	}
}

func (fpv *GetLimitRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*GetLimitRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'GetLimitRequest_FieldTerminalPathValue' with the value under path in 'GetLimitRequest'.
func (fpv *GetLimitRequest_FieldTerminalPathValue) CompareWith(source *GetLimitRequest) (int, bool) {
	switch fpv.selector {
	case GetLimitRequest_FieldPathSelectorName:
		leftValue := fpv.value.(*limit.Reference)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case GetLimitRequest_FieldPathSelectorFieldMask:
		return 0, false
	case GetLimitRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for GetLimitRequest: %d", fpv.selector))
	}
}

func (fpv *GetLimitRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*GetLimitRequest))
}

// GetLimitRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for GetLimitRequest according to their type
// Present only for array (repeated) types.
type GetLimitRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	GetLimitRequest_FieldPath
	ContainsValue(*GetLimitRequest) bool
}

// ParseGetLimitRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseGetLimitRequest_FieldPathArrayItemValue(pathStr, valueStr string) (GetLimitRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseGetLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing GetLimitRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(GetLimitRequest_FieldPathArrayItemValue), nil
}

func MustParseGetLimitRequest_FieldPathArrayItemValue(pathStr, valueStr string) GetLimitRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseGetLimitRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type GetLimitRequest_FieldTerminalPathArrayItemValue struct {
	GetLimitRequest_FieldTerminalPath
	value interface{}
}

var _ GetLimitRequest_FieldPathArrayItemValue = (*GetLimitRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object GetLimitRequest as interface{}
func (fpaiv *GetLimitRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *GetLimitRequest_FieldTerminalPathArrayItemValue) GetSingle(source *GetLimitRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *GetLimitRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*GetLimitRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'GetLimitRequest'
func (fpaiv *GetLimitRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *GetLimitRequest) bool {
	slice := fpaiv.GetLimitRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// GetLimitRequest_FieldPathArrayOfValues allows storing slice of values for GetLimitRequest fields according to their type
type GetLimitRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	GetLimitRequest_FieldPath
}

func ParseGetLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (GetLimitRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseGetLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing GetLimitRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(GetLimitRequest_FieldPathArrayOfValues), nil
}

func MustParseGetLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr string) GetLimitRequest_FieldPathArrayOfValues {
	fpaov, err := ParseGetLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type GetLimitRequest_FieldTerminalPathArrayOfValues struct {
	GetLimitRequest_FieldTerminalPath
	values interface{}
}

var _ GetLimitRequest_FieldPathArrayOfValues = (*GetLimitRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *GetLimitRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case GetLimitRequest_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*limit.Reference) {
			values = append(values, v)
		}
	case GetLimitRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit.Limit_FieldMask) {
			values = append(values, v)
		}
	case GetLimitRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *GetLimitRequest_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*limit.Reference, bool) {
	res, ok := fpaov.values.([]*limit.Reference)
	return res, ok
}
func (fpaov *GetLimitRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit.Limit_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit.Limit_FieldMask)
	return res, ok
}
func (fpaov *GetLimitRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BatchGetLimitsRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() BatchGetLimitsRequest_FieldPathSelector
	Get(source *BatchGetLimitsRequest) []interface{}
	GetSingle(source *BatchGetLimitsRequest) (interface{}, bool)
	ClearValue(item *BatchGetLimitsRequest)

	// Those methods build corresponding BatchGetLimitsRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BatchGetLimitsRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) BatchGetLimitsRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BatchGetLimitsRequest_FieldPathArrayItemValue
}

type BatchGetLimitsRequest_FieldPathSelector int32

const (
	BatchGetLimitsRequest_FieldPathSelectorNames     BatchGetLimitsRequest_FieldPathSelector = 0
	BatchGetLimitsRequest_FieldPathSelectorFieldMask BatchGetLimitsRequest_FieldPathSelector = 1
	BatchGetLimitsRequest_FieldPathSelectorView      BatchGetLimitsRequest_FieldPathSelector = 2
)

func (s BatchGetLimitsRequest_FieldPathSelector) String() string {
	switch s {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		return "names"
	case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case BatchGetLimitsRequest_FieldPathSelectorView:
		return "view"
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", s))
	}
}

func BuildBatchGetLimitsRequest_FieldPath(fp gotenobject.RawFieldPath) (BatchGetLimitsRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object BatchGetLimitsRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "names":
			return &BatchGetLimitsRequest_FieldTerminalPath{selector: BatchGetLimitsRequest_FieldPathSelectorNames}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &BatchGetLimitsRequest_FieldTerminalPath{selector: BatchGetLimitsRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &BatchGetLimitsRequest_FieldTerminalPath{selector: BatchGetLimitsRequest_FieldPathSelectorView}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object BatchGetLimitsRequest", fp)
}

func ParseBatchGetLimitsRequest_FieldPath(rawField string) (BatchGetLimitsRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBatchGetLimitsRequest_FieldPath(fp)
}

func MustParseBatchGetLimitsRequest_FieldPath(rawField string) BatchGetLimitsRequest_FieldPath {
	fp, err := ParseBatchGetLimitsRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BatchGetLimitsRequest_FieldTerminalPath struct {
	selector BatchGetLimitsRequest_FieldPathSelector
}

var _ BatchGetLimitsRequest_FieldPath = (*BatchGetLimitsRequest_FieldTerminalPath)(nil)

func (fp *BatchGetLimitsRequest_FieldTerminalPath) Selector() BatchGetLimitsRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BatchGetLimitsRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BatchGetLimitsRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source BatchGetLimitsRequest
func (fp *BatchGetLimitsRequest_FieldTerminalPath) Get(source *BatchGetLimitsRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BatchGetLimitsRequest_FieldPathSelectorNames:
			for _, value := range source.GetNames() {
				values = append(values, value)
			}
		case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case BatchGetLimitsRequest_FieldPathSelectorView:
			values = append(values, source.View)
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*BatchGetLimitsRequest))
}

// GetSingle returns value pointed by specific field of from source BatchGetLimitsRequest
func (fp *BatchGetLimitsRequest_FieldTerminalPath) GetSingle(source *BatchGetLimitsRequest) (interface{}, bool) {
	switch fp.selector {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		res := source.GetNames()
		return res, res != nil
	case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case BatchGetLimitsRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fp.selector))
	}
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*BatchGetLimitsRequest))
}

// GetDefault returns a default value of the field type
func (fp *BatchGetLimitsRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		return ([]*limit.Reference)(nil)
	case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
		return (*limit.Limit_FieldMask)(nil)
	case BatchGetLimitsRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fp.selector))
	}
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) ClearValue(item *BatchGetLimitsRequest) {
	if item != nil {
		switch fp.selector {
		case BatchGetLimitsRequest_FieldPathSelectorNames:
			item.Names = nil
		case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case BatchGetLimitsRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fp.selector))
		}
	}
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*BatchGetLimitsRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *BatchGetLimitsRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == BatchGetLimitsRequest_FieldPathSelectorNames ||
		fp.selector == BatchGetLimitsRequest_FieldPathSelectorFieldMask ||
		fp.selector == BatchGetLimitsRequest_FieldPathSelectorView
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) WithIValue(value interface{}) BatchGetLimitsRequest_FieldPathValue {
	switch fp.selector {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		return &BatchGetLimitsRequest_FieldTerminalPathValue{BatchGetLimitsRequest_FieldTerminalPath: *fp, value: value.([]*limit.Reference)}
	case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
		return &BatchGetLimitsRequest_FieldTerminalPathValue{BatchGetLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.Limit_FieldMask)}
	case BatchGetLimitsRequest_FieldPathSelectorView:
		return &BatchGetLimitsRequest_FieldTerminalPathValue{BatchGetLimitsRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fp.selector))
	}
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) BatchGetLimitsRequest_FieldPathArrayOfValues {
	fpaov := &BatchGetLimitsRequest_FieldTerminalPathArrayOfValues{BatchGetLimitsRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		return &BatchGetLimitsRequest_FieldTerminalPathArrayOfValues{BatchGetLimitsRequest_FieldTerminalPath: *fp, values: values.([][]*limit.Reference)}
	case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
		return &BatchGetLimitsRequest_FieldTerminalPathArrayOfValues{BatchGetLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.Limit_FieldMask)}
	case BatchGetLimitsRequest_FieldPathSelectorView:
		return &BatchGetLimitsRequest_FieldTerminalPathArrayOfValues{BatchGetLimitsRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) BatchGetLimitsRequest_FieldPathArrayItemValue {
	switch fp.selector {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		return &BatchGetLimitsRequest_FieldTerminalPathArrayItemValue{BatchGetLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fp.selector))
	}
}

func (fp *BatchGetLimitsRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// BatchGetLimitsRequest_FieldPathValue allows storing values for BatchGetLimitsRequest fields according to their type
type BatchGetLimitsRequest_FieldPathValue interface {
	BatchGetLimitsRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **BatchGetLimitsRequest)
	CompareWith(*BatchGetLimitsRequest) (cmp int, comparable bool)
}

func ParseBatchGetLimitsRequest_FieldPathValue(pathStr, valueStr string) (BatchGetLimitsRequest_FieldPathValue, error) {
	fp, err := ParseBatchGetLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitsRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(BatchGetLimitsRequest_FieldPathValue), nil
}

func MustParseBatchGetLimitsRequest_FieldPathValue(pathStr, valueStr string) BatchGetLimitsRequest_FieldPathValue {
	fpv, err := ParseBatchGetLimitsRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BatchGetLimitsRequest_FieldTerminalPathValue struct {
	BatchGetLimitsRequest_FieldTerminalPath
	value interface{}
}

var _ BatchGetLimitsRequest_FieldPathValue = (*BatchGetLimitsRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'BatchGetLimitsRequest' as interface{}
func (fpv *BatchGetLimitsRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BatchGetLimitsRequest_FieldTerminalPathValue) AsNamesValue() ([]*limit.Reference, bool) {
	res, ok := fpv.value.([]*limit.Reference)
	return res, ok
}
func (fpv *BatchGetLimitsRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit.Limit_FieldMask, bool) {
	res, ok := fpv.value.(*limit.Limit_FieldMask)
	return res, ok
}
func (fpv *BatchGetLimitsRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}

// SetTo stores value for selected field for object BatchGetLimitsRequest
func (fpv *BatchGetLimitsRequest_FieldTerminalPathValue) SetTo(target **BatchGetLimitsRequest) {
	if *target == nil {
		*target = new(BatchGetLimitsRequest)
	}
	switch fpv.selector {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		(*target).Names = fpv.value.([]*limit.Reference)
	case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit.Limit_FieldMask)
	case BatchGetLimitsRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fpv.selector))
	}
}

func (fpv *BatchGetLimitsRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*BatchGetLimitsRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BatchGetLimitsRequest_FieldTerminalPathValue' with the value under path in 'BatchGetLimitsRequest'.
func (fpv *BatchGetLimitsRequest_FieldTerminalPathValue) CompareWith(source *BatchGetLimitsRequest) (int, bool) {
	switch fpv.selector {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		return 0, false
	case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
		return 0, false
	case BatchGetLimitsRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsRequest: %d", fpv.selector))
	}
}

func (fpv *BatchGetLimitsRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*BatchGetLimitsRequest))
}

// BatchGetLimitsRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for BatchGetLimitsRequest according to their type
// Present only for array (repeated) types.
type BatchGetLimitsRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BatchGetLimitsRequest_FieldPath
	ContainsValue(*BatchGetLimitsRequest) bool
}

// ParseBatchGetLimitsRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBatchGetLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr string) (BatchGetLimitsRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseBatchGetLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitsRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BatchGetLimitsRequest_FieldPathArrayItemValue), nil
}

func MustParseBatchGetLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr string) BatchGetLimitsRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseBatchGetLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BatchGetLimitsRequest_FieldTerminalPathArrayItemValue struct {
	BatchGetLimitsRequest_FieldTerminalPath
	value interface{}
}

var _ BatchGetLimitsRequest_FieldPathArrayItemValue = (*BatchGetLimitsRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object BatchGetLimitsRequest as interface{}
func (fpaiv *BatchGetLimitsRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *BatchGetLimitsRequest_FieldTerminalPathArrayItemValue) AsNamesItemValue() (*limit.Reference, bool) {
	res, ok := fpaiv.value.(*limit.Reference)
	return res, ok
}

func (fpaiv *BatchGetLimitsRequest_FieldTerminalPathArrayItemValue) GetSingle(source *BatchGetLimitsRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BatchGetLimitsRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*BatchGetLimitsRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'BatchGetLimitsRequest'
func (fpaiv *BatchGetLimitsRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *BatchGetLimitsRequest) bool {
	slice := fpaiv.BatchGetLimitsRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// BatchGetLimitsRequest_FieldPathArrayOfValues allows storing slice of values for BatchGetLimitsRequest fields according to their type
type BatchGetLimitsRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BatchGetLimitsRequest_FieldPath
}

func ParseBatchGetLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (BatchGetLimitsRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseBatchGetLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitsRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BatchGetLimitsRequest_FieldPathArrayOfValues), nil
}

func MustParseBatchGetLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) BatchGetLimitsRequest_FieldPathArrayOfValues {
	fpaov, err := ParseBatchGetLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BatchGetLimitsRequest_FieldTerminalPathArrayOfValues struct {
	BatchGetLimitsRequest_FieldTerminalPath
	values interface{}
}

var _ BatchGetLimitsRequest_FieldPathArrayOfValues = (*BatchGetLimitsRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BatchGetLimitsRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BatchGetLimitsRequest_FieldPathSelectorNames:
		for _, v := range fpaov.values.([][]*limit.Reference) {
			values = append(values, v)
		}
	case BatchGetLimitsRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit.Limit_FieldMask) {
			values = append(values, v)
		}
	case BatchGetLimitsRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BatchGetLimitsRequest_FieldTerminalPathArrayOfValues) AsNamesArrayOfValues() ([][]*limit.Reference, bool) {
	res, ok := fpaov.values.([][]*limit.Reference)
	return res, ok
}
func (fpaov *BatchGetLimitsRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit.Limit_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit.Limit_FieldMask)
	return res, ok
}
func (fpaov *BatchGetLimitsRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type BatchGetLimitsResponse_FieldPath interface {
	gotenobject.FieldPath
	Selector() BatchGetLimitsResponse_FieldPathSelector
	Get(source *BatchGetLimitsResponse) []interface{}
	GetSingle(source *BatchGetLimitsResponse) (interface{}, bool)
	ClearValue(item *BatchGetLimitsResponse)

	// Those methods build corresponding BatchGetLimitsResponse_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) BatchGetLimitsResponse_FieldPathValue
	WithIArrayOfValues(values interface{}) BatchGetLimitsResponse_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) BatchGetLimitsResponse_FieldPathArrayItemValue
}

type BatchGetLimitsResponse_FieldPathSelector int32

const (
	BatchGetLimitsResponse_FieldPathSelectorLimits  BatchGetLimitsResponse_FieldPathSelector = 0
	BatchGetLimitsResponse_FieldPathSelectorMissing BatchGetLimitsResponse_FieldPathSelector = 1
)

func (s BatchGetLimitsResponse_FieldPathSelector) String() string {
	switch s {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		return "limits"
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		return "missing"
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", s))
	}
}

func BuildBatchGetLimitsResponse_FieldPath(fp gotenobject.RawFieldPath) (BatchGetLimitsResponse_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object BatchGetLimitsResponse")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limits":
			return &BatchGetLimitsResponse_FieldTerminalPath{selector: BatchGetLimitsResponse_FieldPathSelectorLimits}, nil
		case "missing":
			return &BatchGetLimitsResponse_FieldTerminalPath{selector: BatchGetLimitsResponse_FieldPathSelectorMissing}, nil
		}
	} else {
		switch fp[0] {
		case "limits":
			if subpath, err := limit.BuildLimit_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &BatchGetLimitsResponse_FieldSubPath{selector: BatchGetLimitsResponse_FieldPathSelectorLimits, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object BatchGetLimitsResponse", fp)
}

func ParseBatchGetLimitsResponse_FieldPath(rawField string) (BatchGetLimitsResponse_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildBatchGetLimitsResponse_FieldPath(fp)
}

func MustParseBatchGetLimitsResponse_FieldPath(rawField string) BatchGetLimitsResponse_FieldPath {
	fp, err := ParseBatchGetLimitsResponse_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type BatchGetLimitsResponse_FieldTerminalPath struct {
	selector BatchGetLimitsResponse_FieldPathSelector
}

var _ BatchGetLimitsResponse_FieldPath = (*BatchGetLimitsResponse_FieldTerminalPath)(nil)

func (fp *BatchGetLimitsResponse_FieldTerminalPath) Selector() BatchGetLimitsResponse_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *BatchGetLimitsResponse_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *BatchGetLimitsResponse_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source BatchGetLimitsResponse
func (fp *BatchGetLimitsResponse_FieldTerminalPath) Get(source *BatchGetLimitsResponse) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case BatchGetLimitsResponse_FieldPathSelectorLimits:
			for _, value := range source.GetLimits() {
				values = append(values, value)
			}
		case BatchGetLimitsResponse_FieldPathSelectorMissing:
			for _, value := range source.GetMissing() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fp.selector))
		}
	}
	return
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*BatchGetLimitsResponse))
}

// GetSingle returns value pointed by specific field of from source BatchGetLimitsResponse
func (fp *BatchGetLimitsResponse_FieldTerminalPath) GetSingle(source *BatchGetLimitsResponse) (interface{}, bool) {
	switch fp.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		res := source.GetLimits()
		return res, res != nil
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		res := source.GetMissing()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fp.selector))
	}
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*BatchGetLimitsResponse))
}

// GetDefault returns a default value of the field type
func (fp *BatchGetLimitsResponse_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		return ([]*limit.Limit)(nil)
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		return ([]*limit.Reference)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fp.selector))
	}
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) ClearValue(item *BatchGetLimitsResponse) {
	if item != nil {
		switch fp.selector {
		case BatchGetLimitsResponse_FieldPathSelectorLimits:
			item.Limits = nil
		case BatchGetLimitsResponse_FieldPathSelectorMissing:
			item.Missing = nil
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fp.selector))
		}
	}
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*BatchGetLimitsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fp *BatchGetLimitsResponse_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == BatchGetLimitsResponse_FieldPathSelectorMissing
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) WithIValue(value interface{}) BatchGetLimitsResponse_FieldPathValue {
	switch fp.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		return &BatchGetLimitsResponse_FieldTerminalPathValue{BatchGetLimitsResponse_FieldTerminalPath: *fp, value: value.([]*limit.Limit)}
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		return &BatchGetLimitsResponse_FieldTerminalPathValue{BatchGetLimitsResponse_FieldTerminalPath: *fp, value: value.([]*limit.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fp.selector))
	}
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) WithIArrayOfValues(values interface{}) BatchGetLimitsResponse_FieldPathArrayOfValues {
	fpaov := &BatchGetLimitsResponse_FieldTerminalPathArrayOfValues{BatchGetLimitsResponse_FieldTerminalPath: *fp}
	switch fp.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		return &BatchGetLimitsResponse_FieldTerminalPathArrayOfValues{BatchGetLimitsResponse_FieldTerminalPath: *fp, values: values.([][]*limit.Limit)}
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		return &BatchGetLimitsResponse_FieldTerminalPathArrayOfValues{BatchGetLimitsResponse_FieldTerminalPath: *fp, values: values.([][]*limit.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fp.selector))
	}
	return fpaov
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) WithIArrayItemValue(value interface{}) BatchGetLimitsResponse_FieldPathArrayItemValue {
	switch fp.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		return &BatchGetLimitsResponse_FieldTerminalPathArrayItemValue{BatchGetLimitsResponse_FieldTerminalPath: *fp, value: value.(*limit.Limit)}
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		return &BatchGetLimitsResponse_FieldTerminalPathArrayItemValue{BatchGetLimitsResponse_FieldTerminalPath: *fp, value: value.(*limit.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fp.selector))
	}
}

func (fp *BatchGetLimitsResponse_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type BatchGetLimitsResponse_FieldSubPath struct {
	selector BatchGetLimitsResponse_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ BatchGetLimitsResponse_FieldPath = (*BatchGetLimitsResponse_FieldSubPath)(nil)

func (fps *BatchGetLimitsResponse_FieldSubPath) Selector() BatchGetLimitsResponse_FieldPathSelector {
	return fps.selector
}
func (fps *BatchGetLimitsResponse_FieldSubPath) AsLimitsSubPath() (limit.Limit_FieldPath, bool) {
	res, ok := fps.subPath.(limit.Limit_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *BatchGetLimitsResponse_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *BatchGetLimitsResponse_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source BatchGetLimitsResponse
func (fps *BatchGetLimitsResponse_FieldSubPath) Get(source *BatchGetLimitsResponse) (values []interface{}) {
	if asLimitFieldPath, ok := fps.AsLimitsSubPath(); ok {
		for _, item := range source.GetLimits() {
			values = append(values, asLimitFieldPath.Get(item)...)
		}
	} else {
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fps.selector))
	}
	return
}

func (fps *BatchGetLimitsResponse_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*BatchGetLimitsResponse))
}

// GetSingle returns value of selected field from source BatchGetLimitsResponse
func (fps *BatchGetLimitsResponse_FieldSubPath) GetSingle(source *BatchGetLimitsResponse) (interface{}, bool) {
	switch fps.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		if len(source.GetLimits()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetLimits()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fps.selector))
	}
}

func (fps *BatchGetLimitsResponse_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*BatchGetLimitsResponse))
}

// GetDefault returns a default value of the field type
func (fps *BatchGetLimitsResponse_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *BatchGetLimitsResponse_FieldSubPath) ClearValue(item *BatchGetLimitsResponse) {
	if item != nil {
		switch fps.selector {
		case BatchGetLimitsResponse_FieldPathSelectorLimits:
			for _, subItem := range item.Limits {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fps.selector))
		}
	}
}

func (fps *BatchGetLimitsResponse_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*BatchGetLimitsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fps *BatchGetLimitsResponse_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *BatchGetLimitsResponse_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&BatchGetLimitsResponse_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *BatchGetLimitsResponse_FieldSubPath) WithIValue(value interface{}) BatchGetLimitsResponse_FieldPathValue {
	return &BatchGetLimitsResponse_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *BatchGetLimitsResponse_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *BatchGetLimitsResponse_FieldSubPath) WithIArrayOfValues(values interface{}) BatchGetLimitsResponse_FieldPathArrayOfValues {
	return &BatchGetLimitsResponse_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *BatchGetLimitsResponse_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *BatchGetLimitsResponse_FieldSubPath) WithIArrayItemValue(value interface{}) BatchGetLimitsResponse_FieldPathArrayItemValue {
	return &BatchGetLimitsResponse_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *BatchGetLimitsResponse_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// BatchGetLimitsResponse_FieldPathValue allows storing values for BatchGetLimitsResponse fields according to their type
type BatchGetLimitsResponse_FieldPathValue interface {
	BatchGetLimitsResponse_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **BatchGetLimitsResponse)
	CompareWith(*BatchGetLimitsResponse) (cmp int, comparable bool)
}

func ParseBatchGetLimitsResponse_FieldPathValue(pathStr, valueStr string) (BatchGetLimitsResponse_FieldPathValue, error) {
	fp, err := ParseBatchGetLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitsResponse field path value from %s: %v", valueStr, err)
	}
	return fpv.(BatchGetLimitsResponse_FieldPathValue), nil
}

func MustParseBatchGetLimitsResponse_FieldPathValue(pathStr, valueStr string) BatchGetLimitsResponse_FieldPathValue {
	fpv, err := ParseBatchGetLimitsResponse_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type BatchGetLimitsResponse_FieldTerminalPathValue struct {
	BatchGetLimitsResponse_FieldTerminalPath
	value interface{}
}

var _ BatchGetLimitsResponse_FieldPathValue = (*BatchGetLimitsResponse_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'BatchGetLimitsResponse' as interface{}
func (fpv *BatchGetLimitsResponse_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *BatchGetLimitsResponse_FieldTerminalPathValue) AsLimitsValue() ([]*limit.Limit, bool) {
	res, ok := fpv.value.([]*limit.Limit)
	return res, ok
}
func (fpv *BatchGetLimitsResponse_FieldTerminalPathValue) AsMissingValue() ([]*limit.Reference, bool) {
	res, ok := fpv.value.([]*limit.Reference)
	return res, ok
}

// SetTo stores value for selected field for object BatchGetLimitsResponse
func (fpv *BatchGetLimitsResponse_FieldTerminalPathValue) SetTo(target **BatchGetLimitsResponse) {
	if *target == nil {
		*target = new(BatchGetLimitsResponse)
	}
	switch fpv.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		(*target).Limits = fpv.value.([]*limit.Limit)
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		(*target).Missing = fpv.value.([]*limit.Reference)
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fpv.selector))
	}
}

func (fpv *BatchGetLimitsResponse_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*BatchGetLimitsResponse)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'BatchGetLimitsResponse_FieldTerminalPathValue' with the value under path in 'BatchGetLimitsResponse'.
func (fpv *BatchGetLimitsResponse_FieldTerminalPathValue) CompareWith(source *BatchGetLimitsResponse) (int, bool) {
	switch fpv.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		return 0, false
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fpv.selector))
	}
}

func (fpv *BatchGetLimitsResponse_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*BatchGetLimitsResponse))
}

type BatchGetLimitsResponse_FieldSubPathValue struct {
	BatchGetLimitsResponse_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ BatchGetLimitsResponse_FieldPathValue = (*BatchGetLimitsResponse_FieldSubPathValue)(nil)

func (fpvs *BatchGetLimitsResponse_FieldSubPathValue) AsLimitsPathValue() (limit.Limit_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(limit.Limit_FieldPathValue)
	return res, ok
}

func (fpvs *BatchGetLimitsResponse_FieldSubPathValue) SetTo(target **BatchGetLimitsResponse) {
	if *target == nil {
		*target = new(BatchGetLimitsResponse)
	}
	switch fpvs.Selector() {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *BatchGetLimitsResponse_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*BatchGetLimitsResponse)
	fpvs.SetTo(&typedObject)
}

func (fpvs *BatchGetLimitsResponse_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *BatchGetLimitsResponse_FieldSubPathValue) CompareWith(source *BatchGetLimitsResponse) (int, bool) {
	switch fpvs.Selector() {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *BatchGetLimitsResponse_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*BatchGetLimitsResponse))
}

// BatchGetLimitsResponse_FieldPathArrayItemValue allows storing single item in Path-specific values for BatchGetLimitsResponse according to their type
// Present only for array (repeated) types.
type BatchGetLimitsResponse_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	BatchGetLimitsResponse_FieldPath
	ContainsValue(*BatchGetLimitsResponse) bool
}

// ParseBatchGetLimitsResponse_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseBatchGetLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr string) (BatchGetLimitsResponse_FieldPathArrayItemValue, error) {
	fp, err := ParseBatchGetLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitsResponse field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(BatchGetLimitsResponse_FieldPathArrayItemValue), nil
}

func MustParseBatchGetLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr string) BatchGetLimitsResponse_FieldPathArrayItemValue {
	fpaiv, err := ParseBatchGetLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type BatchGetLimitsResponse_FieldTerminalPathArrayItemValue struct {
	BatchGetLimitsResponse_FieldTerminalPath
	value interface{}
}

var _ BatchGetLimitsResponse_FieldPathArrayItemValue = (*BatchGetLimitsResponse_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object BatchGetLimitsResponse as interface{}
func (fpaiv *BatchGetLimitsResponse_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *BatchGetLimitsResponse_FieldTerminalPathArrayItemValue) AsLimitsItemValue() (*limit.Limit, bool) {
	res, ok := fpaiv.value.(*limit.Limit)
	return res, ok
}
func (fpaiv *BatchGetLimitsResponse_FieldTerminalPathArrayItemValue) AsMissingItemValue() (*limit.Reference, bool) {
	res, ok := fpaiv.value.(*limit.Reference)
	return res, ok
}

func (fpaiv *BatchGetLimitsResponse_FieldTerminalPathArrayItemValue) GetSingle(source *BatchGetLimitsResponse) (interface{}, bool) {
	return nil, false
}

func (fpaiv *BatchGetLimitsResponse_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*BatchGetLimitsResponse))
}

// Contains returns a boolean indicating if value that is being held is present in given 'BatchGetLimitsResponse'
func (fpaiv *BatchGetLimitsResponse_FieldTerminalPathArrayItemValue) ContainsValue(source *BatchGetLimitsResponse) bool {
	slice := fpaiv.BatchGetLimitsResponse_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type BatchGetLimitsResponse_FieldSubPathArrayItemValue struct {
	BatchGetLimitsResponse_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *BatchGetLimitsResponse_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *BatchGetLimitsResponse_FieldSubPathArrayItemValue) AsLimitsPathItemValue() (limit.Limit_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(limit.Limit_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'BatchGetLimitsResponse'
func (fpaivs *BatchGetLimitsResponse_FieldSubPathArrayItemValue) ContainsValue(source *BatchGetLimitsResponse) bool {
	switch fpaivs.Selector() {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for BatchGetLimitsResponse: %d", fpaivs.Selector()))
	}
}

// BatchGetLimitsResponse_FieldPathArrayOfValues allows storing slice of values for BatchGetLimitsResponse fields according to their type
type BatchGetLimitsResponse_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	BatchGetLimitsResponse_FieldPath
}

func ParseBatchGetLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) (BatchGetLimitsResponse_FieldPathArrayOfValues, error) {
	fp, err := ParseBatchGetLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing BatchGetLimitsResponse field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(BatchGetLimitsResponse_FieldPathArrayOfValues), nil
}

func MustParseBatchGetLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) BatchGetLimitsResponse_FieldPathArrayOfValues {
	fpaov, err := ParseBatchGetLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type BatchGetLimitsResponse_FieldTerminalPathArrayOfValues struct {
	BatchGetLimitsResponse_FieldTerminalPath
	values interface{}
}

var _ BatchGetLimitsResponse_FieldPathArrayOfValues = (*BatchGetLimitsResponse_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *BatchGetLimitsResponse_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case BatchGetLimitsResponse_FieldPathSelectorLimits:
		for _, v := range fpaov.values.([][]*limit.Limit) {
			values = append(values, v)
		}
	case BatchGetLimitsResponse_FieldPathSelectorMissing:
		for _, v := range fpaov.values.([][]*limit.Reference) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *BatchGetLimitsResponse_FieldTerminalPathArrayOfValues) AsLimitsArrayOfValues() ([][]*limit.Limit, bool) {
	res, ok := fpaov.values.([][]*limit.Limit)
	return res, ok
}
func (fpaov *BatchGetLimitsResponse_FieldTerminalPathArrayOfValues) AsMissingArrayOfValues() ([][]*limit.Reference, bool) {
	res, ok := fpaov.values.([][]*limit.Reference)
	return res, ok
}

type BatchGetLimitsResponse_FieldSubPathArrayOfValues struct {
	BatchGetLimitsResponse_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ BatchGetLimitsResponse_FieldPathArrayOfValues = (*BatchGetLimitsResponse_FieldSubPathArrayOfValues)(nil)

func (fpsaov *BatchGetLimitsResponse_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *BatchGetLimitsResponse_FieldSubPathArrayOfValues) AsLimitsPathArrayOfValues() (limit.Limit_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(limit.Limit_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ListLimitsRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() ListLimitsRequest_FieldPathSelector
	Get(source *ListLimitsRequest) []interface{}
	GetSingle(source *ListLimitsRequest) (interface{}, bool)
	ClearValue(item *ListLimitsRequest)

	// Those methods build corresponding ListLimitsRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ListLimitsRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) ListLimitsRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ListLimitsRequest_FieldPathArrayItemValue
}

type ListLimitsRequest_FieldPathSelector int32

const (
	ListLimitsRequest_FieldPathSelectorParent    ListLimitsRequest_FieldPathSelector = 0
	ListLimitsRequest_FieldPathSelectorPageSize  ListLimitsRequest_FieldPathSelector = 1
	ListLimitsRequest_FieldPathSelectorPageToken ListLimitsRequest_FieldPathSelector = 2
	ListLimitsRequest_FieldPathSelectorOrderBy   ListLimitsRequest_FieldPathSelector = 3
	ListLimitsRequest_FieldPathSelectorFilter    ListLimitsRequest_FieldPathSelector = 4
	ListLimitsRequest_FieldPathSelectorFieldMask ListLimitsRequest_FieldPathSelector = 5
	ListLimitsRequest_FieldPathSelectorView      ListLimitsRequest_FieldPathSelector = 6
)

func (s ListLimitsRequest_FieldPathSelector) String() string {
	switch s {
	case ListLimitsRequest_FieldPathSelectorParent:
		return "parent"
	case ListLimitsRequest_FieldPathSelectorPageSize:
		return "page_size"
	case ListLimitsRequest_FieldPathSelectorPageToken:
		return "page_token"
	case ListLimitsRequest_FieldPathSelectorOrderBy:
		return "order_by"
	case ListLimitsRequest_FieldPathSelectorFilter:
		return "filter"
	case ListLimitsRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case ListLimitsRequest_FieldPathSelectorView:
		return "view"
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", s))
	}
}

func BuildListLimitsRequest_FieldPath(fp gotenobject.RawFieldPath) (ListLimitsRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ListLimitsRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "parent":
			return &ListLimitsRequest_FieldTerminalPath{selector: ListLimitsRequest_FieldPathSelectorParent}, nil
		case "page_size", "pageSize", "page-size":
			return &ListLimitsRequest_FieldTerminalPath{selector: ListLimitsRequest_FieldPathSelectorPageSize}, nil
		case "page_token", "pageToken", "page-token":
			return &ListLimitsRequest_FieldTerminalPath{selector: ListLimitsRequest_FieldPathSelectorPageToken}, nil
		case "order_by", "orderBy", "order-by":
			return &ListLimitsRequest_FieldTerminalPath{selector: ListLimitsRequest_FieldPathSelectorOrderBy}, nil
		case "filter":
			return &ListLimitsRequest_FieldTerminalPath{selector: ListLimitsRequest_FieldPathSelectorFilter}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &ListLimitsRequest_FieldTerminalPath{selector: ListLimitsRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &ListLimitsRequest_FieldTerminalPath{selector: ListLimitsRequest_FieldPathSelectorView}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ListLimitsRequest", fp)
}

func ParseListLimitsRequest_FieldPath(rawField string) (ListLimitsRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildListLimitsRequest_FieldPath(fp)
}

func MustParseListLimitsRequest_FieldPath(rawField string) ListLimitsRequest_FieldPath {
	fp, err := ParseListLimitsRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ListLimitsRequest_FieldTerminalPath struct {
	selector ListLimitsRequest_FieldPathSelector
}

var _ ListLimitsRequest_FieldPath = (*ListLimitsRequest_FieldTerminalPath)(nil)

func (fp *ListLimitsRequest_FieldTerminalPath) Selector() ListLimitsRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ListLimitsRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ListLimitsRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ListLimitsRequest
func (fp *ListLimitsRequest_FieldTerminalPath) Get(source *ListLimitsRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ListLimitsRequest_FieldPathSelectorParent:
			if source.Parent != nil {
				values = append(values, source.Parent)
			}
		case ListLimitsRequest_FieldPathSelectorPageSize:
			values = append(values, source.PageSize)
		case ListLimitsRequest_FieldPathSelectorPageToken:
			if source.PageToken != nil {
				values = append(values, source.PageToken)
			}
		case ListLimitsRequest_FieldPathSelectorOrderBy:
			if source.OrderBy != nil {
				values = append(values, source.OrderBy)
			}
		case ListLimitsRequest_FieldPathSelectorFilter:
			if source.Filter != nil {
				values = append(values, source.Filter)
			}
		case ListLimitsRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case ListLimitsRequest_FieldPathSelectorView:
			values = append(values, source.View)
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *ListLimitsRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ListLimitsRequest))
}

// GetSingle returns value pointed by specific field of from source ListLimitsRequest
func (fp *ListLimitsRequest_FieldTerminalPath) GetSingle(source *ListLimitsRequest) (interface{}, bool) {
	switch fp.selector {
	case ListLimitsRequest_FieldPathSelectorParent:
		res := source.GetParent()
		return res, res != nil
	case ListLimitsRequest_FieldPathSelectorPageSize:
		return source.GetPageSize(), source != nil
	case ListLimitsRequest_FieldPathSelectorPageToken:
		res := source.GetPageToken()
		return res, res != nil
	case ListLimitsRequest_FieldPathSelectorOrderBy:
		res := source.GetOrderBy()
		return res, res != nil
	case ListLimitsRequest_FieldPathSelectorFilter:
		res := source.GetFilter()
		return res, res != nil
	case ListLimitsRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case ListLimitsRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fp.selector))
	}
}

func (fp *ListLimitsRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ListLimitsRequest))
}

// GetDefault returns a default value of the field type
func (fp *ListLimitsRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ListLimitsRequest_FieldPathSelectorParent:
		return (*limit.ParentName)(nil)
	case ListLimitsRequest_FieldPathSelectorPageSize:
		return int32(0)
	case ListLimitsRequest_FieldPathSelectorPageToken:
		return (*limit.PagerCursor)(nil)
	case ListLimitsRequest_FieldPathSelectorOrderBy:
		return (*limit.OrderBy)(nil)
	case ListLimitsRequest_FieldPathSelectorFilter:
		return (*limit.Filter)(nil)
	case ListLimitsRequest_FieldPathSelectorFieldMask:
		return (*limit.Limit_FieldMask)(nil)
	case ListLimitsRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fp.selector))
	}
}

func (fp *ListLimitsRequest_FieldTerminalPath) ClearValue(item *ListLimitsRequest) {
	if item != nil {
		switch fp.selector {
		case ListLimitsRequest_FieldPathSelectorParent:
			item.Parent = nil
		case ListLimitsRequest_FieldPathSelectorPageSize:
			item.PageSize = int32(0)
		case ListLimitsRequest_FieldPathSelectorPageToken:
			item.PageToken = nil
		case ListLimitsRequest_FieldPathSelectorOrderBy:
			item.OrderBy = nil
		case ListLimitsRequest_FieldPathSelectorFilter:
			item.Filter = nil
		case ListLimitsRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case ListLimitsRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fp.selector))
		}
	}
}

func (fp *ListLimitsRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ListLimitsRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *ListLimitsRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ListLimitsRequest_FieldPathSelectorParent ||
		fp.selector == ListLimitsRequest_FieldPathSelectorPageSize ||
		fp.selector == ListLimitsRequest_FieldPathSelectorPageToken ||
		fp.selector == ListLimitsRequest_FieldPathSelectorOrderBy ||
		fp.selector == ListLimitsRequest_FieldPathSelectorFilter ||
		fp.selector == ListLimitsRequest_FieldPathSelectorFieldMask ||
		fp.selector == ListLimitsRequest_FieldPathSelectorView
}

func (fp *ListLimitsRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ListLimitsRequest_FieldTerminalPath) WithIValue(value interface{}) ListLimitsRequest_FieldPathValue {
	switch fp.selector {
	case ListLimitsRequest_FieldPathSelectorParent:
		return &ListLimitsRequest_FieldTerminalPathValue{ListLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.ParentName)}
	case ListLimitsRequest_FieldPathSelectorPageSize:
		return &ListLimitsRequest_FieldTerminalPathValue{ListLimitsRequest_FieldTerminalPath: *fp, value: value.(int32)}
	case ListLimitsRequest_FieldPathSelectorPageToken:
		return &ListLimitsRequest_FieldTerminalPathValue{ListLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.PagerCursor)}
	case ListLimitsRequest_FieldPathSelectorOrderBy:
		return &ListLimitsRequest_FieldTerminalPathValue{ListLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.OrderBy)}
	case ListLimitsRequest_FieldPathSelectorFilter:
		return &ListLimitsRequest_FieldTerminalPathValue{ListLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.Filter)}
	case ListLimitsRequest_FieldPathSelectorFieldMask:
		return &ListLimitsRequest_FieldTerminalPathValue{ListLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.Limit_FieldMask)}
	case ListLimitsRequest_FieldPathSelectorView:
		return &ListLimitsRequest_FieldTerminalPathValue{ListLimitsRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fp.selector))
	}
}

func (fp *ListLimitsRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ListLimitsRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) ListLimitsRequest_FieldPathArrayOfValues {
	fpaov := &ListLimitsRequest_FieldTerminalPathArrayOfValues{ListLimitsRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case ListLimitsRequest_FieldPathSelectorParent:
		return &ListLimitsRequest_FieldTerminalPathArrayOfValues{ListLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.ParentName)}
	case ListLimitsRequest_FieldPathSelectorPageSize:
		return &ListLimitsRequest_FieldTerminalPathArrayOfValues{ListLimitsRequest_FieldTerminalPath: *fp, values: values.([]int32)}
	case ListLimitsRequest_FieldPathSelectorPageToken:
		return &ListLimitsRequest_FieldTerminalPathArrayOfValues{ListLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.PagerCursor)}
	case ListLimitsRequest_FieldPathSelectorOrderBy:
		return &ListLimitsRequest_FieldTerminalPathArrayOfValues{ListLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.OrderBy)}
	case ListLimitsRequest_FieldPathSelectorFilter:
		return &ListLimitsRequest_FieldTerminalPathArrayOfValues{ListLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.Filter)}
	case ListLimitsRequest_FieldPathSelectorFieldMask:
		return &ListLimitsRequest_FieldTerminalPathArrayOfValues{ListLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.Limit_FieldMask)}
	case ListLimitsRequest_FieldPathSelectorView:
		return &ListLimitsRequest_FieldTerminalPathArrayOfValues{ListLimitsRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *ListLimitsRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ListLimitsRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) ListLimitsRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fp.selector))
	}
}

func (fp *ListLimitsRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// ListLimitsRequest_FieldPathValue allows storing values for ListLimitsRequest fields according to their type
type ListLimitsRequest_FieldPathValue interface {
	ListLimitsRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ListLimitsRequest)
	CompareWith(*ListLimitsRequest) (cmp int, comparable bool)
}

func ParseListLimitsRequest_FieldPathValue(pathStr, valueStr string) (ListLimitsRequest_FieldPathValue, error) {
	fp, err := ParseListLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitsRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(ListLimitsRequest_FieldPathValue), nil
}

func MustParseListLimitsRequest_FieldPathValue(pathStr, valueStr string) ListLimitsRequest_FieldPathValue {
	fpv, err := ParseListLimitsRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ListLimitsRequest_FieldTerminalPathValue struct {
	ListLimitsRequest_FieldTerminalPath
	value interface{}
}

var _ ListLimitsRequest_FieldPathValue = (*ListLimitsRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ListLimitsRequest' as interface{}
func (fpv *ListLimitsRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ListLimitsRequest_FieldTerminalPathValue) AsParentValue() (*limit.ParentName, bool) {
	res, ok := fpv.value.(*limit.ParentName)
	return res, ok
}
func (fpv *ListLimitsRequest_FieldTerminalPathValue) AsPageSizeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *ListLimitsRequest_FieldTerminalPathValue) AsPageTokenValue() (*limit.PagerCursor, bool) {
	res, ok := fpv.value.(*limit.PagerCursor)
	return res, ok
}
func (fpv *ListLimitsRequest_FieldTerminalPathValue) AsOrderByValue() (*limit.OrderBy, bool) {
	res, ok := fpv.value.(*limit.OrderBy)
	return res, ok
}
func (fpv *ListLimitsRequest_FieldTerminalPathValue) AsFilterValue() (*limit.Filter, bool) {
	res, ok := fpv.value.(*limit.Filter)
	return res, ok
}
func (fpv *ListLimitsRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit.Limit_FieldMask, bool) {
	res, ok := fpv.value.(*limit.Limit_FieldMask)
	return res, ok
}
func (fpv *ListLimitsRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}

// SetTo stores value for selected field for object ListLimitsRequest
func (fpv *ListLimitsRequest_FieldTerminalPathValue) SetTo(target **ListLimitsRequest) {
	if *target == nil {
		*target = new(ListLimitsRequest)
	}
	switch fpv.selector {
	case ListLimitsRequest_FieldPathSelectorParent:
		(*target).Parent = fpv.value.(*limit.ParentName)
	case ListLimitsRequest_FieldPathSelectorPageSize:
		(*target).PageSize = fpv.value.(int32)
	case ListLimitsRequest_FieldPathSelectorPageToken:
		(*target).PageToken = fpv.value.(*limit.PagerCursor)
	case ListLimitsRequest_FieldPathSelectorOrderBy:
		(*target).OrderBy = fpv.value.(*limit.OrderBy)
	case ListLimitsRequest_FieldPathSelectorFilter:
		(*target).Filter = fpv.value.(*limit.Filter)
	case ListLimitsRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit.Limit_FieldMask)
	case ListLimitsRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fpv.selector))
	}
}

func (fpv *ListLimitsRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ListLimitsRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ListLimitsRequest_FieldTerminalPathValue' with the value under path in 'ListLimitsRequest'.
func (fpv *ListLimitsRequest_FieldTerminalPathValue) CompareWith(source *ListLimitsRequest) (int, bool) {
	switch fpv.selector {
	case ListLimitsRequest_FieldPathSelectorParent:
		leftValue := fpv.value.(*limit.ParentName)
		rightValue := source.GetParent()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case ListLimitsRequest_FieldPathSelectorPageSize:
		leftValue := fpv.value.(int32)
		rightValue := source.GetPageSize()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case ListLimitsRequest_FieldPathSelectorPageToken:
		return 0, false
	case ListLimitsRequest_FieldPathSelectorOrderBy:
		return 0, false
	case ListLimitsRequest_FieldPathSelectorFilter:
		return 0, false
	case ListLimitsRequest_FieldPathSelectorFieldMask:
		return 0, false
	case ListLimitsRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsRequest: %d", fpv.selector))
	}
}

func (fpv *ListLimitsRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ListLimitsRequest))
}

// ListLimitsRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for ListLimitsRequest according to their type
// Present only for array (repeated) types.
type ListLimitsRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ListLimitsRequest_FieldPath
	ContainsValue(*ListLimitsRequest) bool
}

// ParseListLimitsRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseListLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr string) (ListLimitsRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseListLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitsRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ListLimitsRequest_FieldPathArrayItemValue), nil
}

func MustParseListLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr string) ListLimitsRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseListLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ListLimitsRequest_FieldTerminalPathArrayItemValue struct {
	ListLimitsRequest_FieldTerminalPath
	value interface{}
}

var _ ListLimitsRequest_FieldPathArrayItemValue = (*ListLimitsRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ListLimitsRequest as interface{}
func (fpaiv *ListLimitsRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *ListLimitsRequest_FieldTerminalPathArrayItemValue) GetSingle(source *ListLimitsRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ListLimitsRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ListLimitsRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ListLimitsRequest'
func (fpaiv *ListLimitsRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *ListLimitsRequest) bool {
	slice := fpaiv.ListLimitsRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// ListLimitsRequest_FieldPathArrayOfValues allows storing slice of values for ListLimitsRequest fields according to their type
type ListLimitsRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ListLimitsRequest_FieldPath
}

func ParseListLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (ListLimitsRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseListLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitsRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ListLimitsRequest_FieldPathArrayOfValues), nil
}

func MustParseListLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) ListLimitsRequest_FieldPathArrayOfValues {
	fpaov, err := ParseListLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ListLimitsRequest_FieldTerminalPathArrayOfValues struct {
	ListLimitsRequest_FieldTerminalPath
	values interface{}
}

var _ ListLimitsRequest_FieldPathArrayOfValues = (*ListLimitsRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ListLimitsRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ListLimitsRequest_FieldPathSelectorParent:
		for _, v := range fpaov.values.([]*limit.ParentName) {
			values = append(values, v)
		}
	case ListLimitsRequest_FieldPathSelectorPageSize:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case ListLimitsRequest_FieldPathSelectorPageToken:
		for _, v := range fpaov.values.([]*limit.PagerCursor) {
			values = append(values, v)
		}
	case ListLimitsRequest_FieldPathSelectorOrderBy:
		for _, v := range fpaov.values.([]*limit.OrderBy) {
			values = append(values, v)
		}
	case ListLimitsRequest_FieldPathSelectorFilter:
		for _, v := range fpaov.values.([]*limit.Filter) {
			values = append(values, v)
		}
	case ListLimitsRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit.Limit_FieldMask) {
			values = append(values, v)
		}
	case ListLimitsRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ListLimitsRequest_FieldTerminalPathArrayOfValues) AsParentArrayOfValues() ([]*limit.ParentName, bool) {
	res, ok := fpaov.values.([]*limit.ParentName)
	return res, ok
}
func (fpaov *ListLimitsRequest_FieldTerminalPathArrayOfValues) AsPageSizeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *ListLimitsRequest_FieldTerminalPathArrayOfValues) AsPageTokenArrayOfValues() ([]*limit.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit.PagerCursor)
	return res, ok
}
func (fpaov *ListLimitsRequest_FieldTerminalPathArrayOfValues) AsOrderByArrayOfValues() ([]*limit.OrderBy, bool) {
	res, ok := fpaov.values.([]*limit.OrderBy)
	return res, ok
}
func (fpaov *ListLimitsRequest_FieldTerminalPathArrayOfValues) AsFilterArrayOfValues() ([]*limit.Filter, bool) {
	res, ok := fpaov.values.([]*limit.Filter)
	return res, ok
}
func (fpaov *ListLimitsRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit.Limit_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit.Limit_FieldMask)
	return res, ok
}
func (fpaov *ListLimitsRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type ListLimitsResponse_FieldPath interface {
	gotenobject.FieldPath
	Selector() ListLimitsResponse_FieldPathSelector
	Get(source *ListLimitsResponse) []interface{}
	GetSingle(source *ListLimitsResponse) (interface{}, bool)
	ClearValue(item *ListLimitsResponse)

	// Those methods build corresponding ListLimitsResponse_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) ListLimitsResponse_FieldPathValue
	WithIArrayOfValues(values interface{}) ListLimitsResponse_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) ListLimitsResponse_FieldPathArrayItemValue
}

type ListLimitsResponse_FieldPathSelector int32

const (
	ListLimitsResponse_FieldPathSelectorLimits        ListLimitsResponse_FieldPathSelector = 0
	ListLimitsResponse_FieldPathSelectorPrevPageToken ListLimitsResponse_FieldPathSelector = 1
	ListLimitsResponse_FieldPathSelectorNextPageToken ListLimitsResponse_FieldPathSelector = 2
)

func (s ListLimitsResponse_FieldPathSelector) String() string {
	switch s {
	case ListLimitsResponse_FieldPathSelectorLimits:
		return "limits"
	case ListLimitsResponse_FieldPathSelectorPrevPageToken:
		return "prev_page_token"
	case ListLimitsResponse_FieldPathSelectorNextPageToken:
		return "next_page_token"
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", s))
	}
}

func BuildListLimitsResponse_FieldPath(fp gotenobject.RawFieldPath) (ListLimitsResponse_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object ListLimitsResponse")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limits":
			return &ListLimitsResponse_FieldTerminalPath{selector: ListLimitsResponse_FieldPathSelectorLimits}, nil
		case "prev_page_token", "prevPageToken", "prev-page-token":
			return &ListLimitsResponse_FieldTerminalPath{selector: ListLimitsResponse_FieldPathSelectorPrevPageToken}, nil
		case "next_page_token", "nextPageToken", "next-page-token":
			return &ListLimitsResponse_FieldTerminalPath{selector: ListLimitsResponse_FieldPathSelectorNextPageToken}, nil
		}
	} else {
		switch fp[0] {
		case "limits":
			if subpath, err := limit.BuildLimit_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &ListLimitsResponse_FieldSubPath{selector: ListLimitsResponse_FieldPathSelectorLimits, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object ListLimitsResponse", fp)
}

func ParseListLimitsResponse_FieldPath(rawField string) (ListLimitsResponse_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildListLimitsResponse_FieldPath(fp)
}

func MustParseListLimitsResponse_FieldPath(rawField string) ListLimitsResponse_FieldPath {
	fp, err := ParseListLimitsResponse_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type ListLimitsResponse_FieldTerminalPath struct {
	selector ListLimitsResponse_FieldPathSelector
}

var _ ListLimitsResponse_FieldPath = (*ListLimitsResponse_FieldTerminalPath)(nil)

func (fp *ListLimitsResponse_FieldTerminalPath) Selector() ListLimitsResponse_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *ListLimitsResponse_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *ListLimitsResponse_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source ListLimitsResponse
func (fp *ListLimitsResponse_FieldTerminalPath) Get(source *ListLimitsResponse) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case ListLimitsResponse_FieldPathSelectorLimits:
			for _, value := range source.GetLimits() {
				values = append(values, value)
			}
		case ListLimitsResponse_FieldPathSelectorPrevPageToken:
			if source.PrevPageToken != nil {
				values = append(values, source.PrevPageToken)
			}
		case ListLimitsResponse_FieldPathSelectorNextPageToken:
			if source.NextPageToken != nil {
				values = append(values, source.NextPageToken)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fp.selector))
		}
	}
	return
}

func (fp *ListLimitsResponse_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*ListLimitsResponse))
}

// GetSingle returns value pointed by specific field of from source ListLimitsResponse
func (fp *ListLimitsResponse_FieldTerminalPath) GetSingle(source *ListLimitsResponse) (interface{}, bool) {
	switch fp.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		res := source.GetLimits()
		return res, res != nil
	case ListLimitsResponse_FieldPathSelectorPrevPageToken:
		res := source.GetPrevPageToken()
		return res, res != nil
	case ListLimitsResponse_FieldPathSelectorNextPageToken:
		res := source.GetNextPageToken()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fp.selector))
	}
}

func (fp *ListLimitsResponse_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*ListLimitsResponse))
}

// GetDefault returns a default value of the field type
func (fp *ListLimitsResponse_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		return ([]*limit.Limit)(nil)
	case ListLimitsResponse_FieldPathSelectorPrevPageToken:
		return (*limit.PagerCursor)(nil)
	case ListLimitsResponse_FieldPathSelectorNextPageToken:
		return (*limit.PagerCursor)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fp.selector))
	}
}

func (fp *ListLimitsResponse_FieldTerminalPath) ClearValue(item *ListLimitsResponse) {
	if item != nil {
		switch fp.selector {
		case ListLimitsResponse_FieldPathSelectorLimits:
			item.Limits = nil
		case ListLimitsResponse_FieldPathSelectorPrevPageToken:
			item.PrevPageToken = nil
		case ListLimitsResponse_FieldPathSelectorNextPageToken:
			item.NextPageToken = nil
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fp.selector))
		}
	}
}

func (fp *ListLimitsResponse_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*ListLimitsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fp *ListLimitsResponse_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == ListLimitsResponse_FieldPathSelectorPrevPageToken ||
		fp.selector == ListLimitsResponse_FieldPathSelectorNextPageToken
}

func (fp *ListLimitsResponse_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *ListLimitsResponse_FieldTerminalPath) WithIValue(value interface{}) ListLimitsResponse_FieldPathValue {
	switch fp.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		return &ListLimitsResponse_FieldTerminalPathValue{ListLimitsResponse_FieldTerminalPath: *fp, value: value.([]*limit.Limit)}
	case ListLimitsResponse_FieldPathSelectorPrevPageToken:
		return &ListLimitsResponse_FieldTerminalPathValue{ListLimitsResponse_FieldTerminalPath: *fp, value: value.(*limit.PagerCursor)}
	case ListLimitsResponse_FieldPathSelectorNextPageToken:
		return &ListLimitsResponse_FieldTerminalPathValue{ListLimitsResponse_FieldTerminalPath: *fp, value: value.(*limit.PagerCursor)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fp.selector))
	}
}

func (fp *ListLimitsResponse_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *ListLimitsResponse_FieldTerminalPath) WithIArrayOfValues(values interface{}) ListLimitsResponse_FieldPathArrayOfValues {
	fpaov := &ListLimitsResponse_FieldTerminalPathArrayOfValues{ListLimitsResponse_FieldTerminalPath: *fp}
	switch fp.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		return &ListLimitsResponse_FieldTerminalPathArrayOfValues{ListLimitsResponse_FieldTerminalPath: *fp, values: values.([][]*limit.Limit)}
	case ListLimitsResponse_FieldPathSelectorPrevPageToken:
		return &ListLimitsResponse_FieldTerminalPathArrayOfValues{ListLimitsResponse_FieldTerminalPath: *fp, values: values.([]*limit.PagerCursor)}
	case ListLimitsResponse_FieldPathSelectorNextPageToken:
		return &ListLimitsResponse_FieldTerminalPathArrayOfValues{ListLimitsResponse_FieldTerminalPath: *fp, values: values.([]*limit.PagerCursor)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fp.selector))
	}
	return fpaov
}

func (fp *ListLimitsResponse_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *ListLimitsResponse_FieldTerminalPath) WithIArrayItemValue(value interface{}) ListLimitsResponse_FieldPathArrayItemValue {
	switch fp.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		return &ListLimitsResponse_FieldTerminalPathArrayItemValue{ListLimitsResponse_FieldTerminalPath: *fp, value: value.(*limit.Limit)}
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fp.selector))
	}
}

func (fp *ListLimitsResponse_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type ListLimitsResponse_FieldSubPath struct {
	selector ListLimitsResponse_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ ListLimitsResponse_FieldPath = (*ListLimitsResponse_FieldSubPath)(nil)

func (fps *ListLimitsResponse_FieldSubPath) Selector() ListLimitsResponse_FieldPathSelector {
	return fps.selector
}
func (fps *ListLimitsResponse_FieldSubPath) AsLimitsSubPath() (limit.Limit_FieldPath, bool) {
	res, ok := fps.subPath.(limit.Limit_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *ListLimitsResponse_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *ListLimitsResponse_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source ListLimitsResponse
func (fps *ListLimitsResponse_FieldSubPath) Get(source *ListLimitsResponse) (values []interface{}) {
	if asLimitFieldPath, ok := fps.AsLimitsSubPath(); ok {
		for _, item := range source.GetLimits() {
			values = append(values, asLimitFieldPath.Get(item)...)
		}
	} else {
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fps.selector))
	}
	return
}

func (fps *ListLimitsResponse_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*ListLimitsResponse))
}

// GetSingle returns value of selected field from source ListLimitsResponse
func (fps *ListLimitsResponse_FieldSubPath) GetSingle(source *ListLimitsResponse) (interface{}, bool) {
	switch fps.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		if len(source.GetLimits()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetLimits()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fps.selector))
	}
}

func (fps *ListLimitsResponse_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*ListLimitsResponse))
}

// GetDefault returns a default value of the field type
func (fps *ListLimitsResponse_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *ListLimitsResponse_FieldSubPath) ClearValue(item *ListLimitsResponse) {
	if item != nil {
		switch fps.selector {
		case ListLimitsResponse_FieldPathSelectorLimits:
			for _, subItem := range item.Limits {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fps.selector))
		}
	}
}

func (fps *ListLimitsResponse_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*ListLimitsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fps *ListLimitsResponse_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *ListLimitsResponse_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&ListLimitsResponse_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *ListLimitsResponse_FieldSubPath) WithIValue(value interface{}) ListLimitsResponse_FieldPathValue {
	return &ListLimitsResponse_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *ListLimitsResponse_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *ListLimitsResponse_FieldSubPath) WithIArrayOfValues(values interface{}) ListLimitsResponse_FieldPathArrayOfValues {
	return &ListLimitsResponse_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *ListLimitsResponse_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *ListLimitsResponse_FieldSubPath) WithIArrayItemValue(value interface{}) ListLimitsResponse_FieldPathArrayItemValue {
	return &ListLimitsResponse_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *ListLimitsResponse_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// ListLimitsResponse_FieldPathValue allows storing values for ListLimitsResponse fields according to their type
type ListLimitsResponse_FieldPathValue interface {
	ListLimitsResponse_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **ListLimitsResponse)
	CompareWith(*ListLimitsResponse) (cmp int, comparable bool)
}

func ParseListLimitsResponse_FieldPathValue(pathStr, valueStr string) (ListLimitsResponse_FieldPathValue, error) {
	fp, err := ParseListLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitsResponse field path value from %s: %v", valueStr, err)
	}
	return fpv.(ListLimitsResponse_FieldPathValue), nil
}

func MustParseListLimitsResponse_FieldPathValue(pathStr, valueStr string) ListLimitsResponse_FieldPathValue {
	fpv, err := ParseListLimitsResponse_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type ListLimitsResponse_FieldTerminalPathValue struct {
	ListLimitsResponse_FieldTerminalPath
	value interface{}
}

var _ ListLimitsResponse_FieldPathValue = (*ListLimitsResponse_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'ListLimitsResponse' as interface{}
func (fpv *ListLimitsResponse_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *ListLimitsResponse_FieldTerminalPathValue) AsLimitsValue() ([]*limit.Limit, bool) {
	res, ok := fpv.value.([]*limit.Limit)
	return res, ok
}
func (fpv *ListLimitsResponse_FieldTerminalPathValue) AsPrevPageTokenValue() (*limit.PagerCursor, bool) {
	res, ok := fpv.value.(*limit.PagerCursor)
	return res, ok
}
func (fpv *ListLimitsResponse_FieldTerminalPathValue) AsNextPageTokenValue() (*limit.PagerCursor, bool) {
	res, ok := fpv.value.(*limit.PagerCursor)
	return res, ok
}

// SetTo stores value for selected field for object ListLimitsResponse
func (fpv *ListLimitsResponse_FieldTerminalPathValue) SetTo(target **ListLimitsResponse) {
	if *target == nil {
		*target = new(ListLimitsResponse)
	}
	switch fpv.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		(*target).Limits = fpv.value.([]*limit.Limit)
	case ListLimitsResponse_FieldPathSelectorPrevPageToken:
		(*target).PrevPageToken = fpv.value.(*limit.PagerCursor)
	case ListLimitsResponse_FieldPathSelectorNextPageToken:
		(*target).NextPageToken = fpv.value.(*limit.PagerCursor)
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fpv.selector))
	}
}

func (fpv *ListLimitsResponse_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ListLimitsResponse)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'ListLimitsResponse_FieldTerminalPathValue' with the value under path in 'ListLimitsResponse'.
func (fpv *ListLimitsResponse_FieldTerminalPathValue) CompareWith(source *ListLimitsResponse) (int, bool) {
	switch fpv.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		return 0, false
	case ListLimitsResponse_FieldPathSelectorPrevPageToken:
		return 0, false
	case ListLimitsResponse_FieldPathSelectorNextPageToken:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fpv.selector))
	}
}

func (fpv *ListLimitsResponse_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*ListLimitsResponse))
}

type ListLimitsResponse_FieldSubPathValue struct {
	ListLimitsResponse_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ ListLimitsResponse_FieldPathValue = (*ListLimitsResponse_FieldSubPathValue)(nil)

func (fpvs *ListLimitsResponse_FieldSubPathValue) AsLimitsPathValue() (limit.Limit_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(limit.Limit_FieldPathValue)
	return res, ok
}

func (fpvs *ListLimitsResponse_FieldSubPathValue) SetTo(target **ListLimitsResponse) {
	if *target == nil {
		*target = new(ListLimitsResponse)
	}
	switch fpvs.Selector() {
	case ListLimitsResponse_FieldPathSelectorLimits:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *ListLimitsResponse_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*ListLimitsResponse)
	fpvs.SetTo(&typedObject)
}

func (fpvs *ListLimitsResponse_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *ListLimitsResponse_FieldSubPathValue) CompareWith(source *ListLimitsResponse) (int, bool) {
	switch fpvs.Selector() {
	case ListLimitsResponse_FieldPathSelectorLimits:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *ListLimitsResponse_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*ListLimitsResponse))
}

// ListLimitsResponse_FieldPathArrayItemValue allows storing single item in Path-specific values for ListLimitsResponse according to their type
// Present only for array (repeated) types.
type ListLimitsResponse_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	ListLimitsResponse_FieldPath
	ContainsValue(*ListLimitsResponse) bool
}

// ParseListLimitsResponse_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseListLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr string) (ListLimitsResponse_FieldPathArrayItemValue, error) {
	fp, err := ParseListLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitsResponse field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(ListLimitsResponse_FieldPathArrayItemValue), nil
}

func MustParseListLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr string) ListLimitsResponse_FieldPathArrayItemValue {
	fpaiv, err := ParseListLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type ListLimitsResponse_FieldTerminalPathArrayItemValue struct {
	ListLimitsResponse_FieldTerminalPath
	value interface{}
}

var _ ListLimitsResponse_FieldPathArrayItemValue = (*ListLimitsResponse_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object ListLimitsResponse as interface{}
func (fpaiv *ListLimitsResponse_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *ListLimitsResponse_FieldTerminalPathArrayItemValue) AsLimitsItemValue() (*limit.Limit, bool) {
	res, ok := fpaiv.value.(*limit.Limit)
	return res, ok
}

func (fpaiv *ListLimitsResponse_FieldTerminalPathArrayItemValue) GetSingle(source *ListLimitsResponse) (interface{}, bool) {
	return nil, false
}

func (fpaiv *ListLimitsResponse_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*ListLimitsResponse))
}

// Contains returns a boolean indicating if value that is being held is present in given 'ListLimitsResponse'
func (fpaiv *ListLimitsResponse_FieldTerminalPathArrayItemValue) ContainsValue(source *ListLimitsResponse) bool {
	slice := fpaiv.ListLimitsResponse_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type ListLimitsResponse_FieldSubPathArrayItemValue struct {
	ListLimitsResponse_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *ListLimitsResponse_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *ListLimitsResponse_FieldSubPathArrayItemValue) AsLimitsPathItemValue() (limit.Limit_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(limit.Limit_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'ListLimitsResponse'
func (fpaivs *ListLimitsResponse_FieldSubPathArrayItemValue) ContainsValue(source *ListLimitsResponse) bool {
	switch fpaivs.Selector() {
	case ListLimitsResponse_FieldPathSelectorLimits:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for ListLimitsResponse: %d", fpaivs.Selector()))
	}
}

// ListLimitsResponse_FieldPathArrayOfValues allows storing slice of values for ListLimitsResponse fields according to their type
type ListLimitsResponse_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	ListLimitsResponse_FieldPath
}

func ParseListLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) (ListLimitsResponse_FieldPathArrayOfValues, error) {
	fp, err := ParseListLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing ListLimitsResponse field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(ListLimitsResponse_FieldPathArrayOfValues), nil
}

func MustParseListLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) ListLimitsResponse_FieldPathArrayOfValues {
	fpaov, err := ParseListLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type ListLimitsResponse_FieldTerminalPathArrayOfValues struct {
	ListLimitsResponse_FieldTerminalPath
	values interface{}
}

var _ ListLimitsResponse_FieldPathArrayOfValues = (*ListLimitsResponse_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *ListLimitsResponse_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case ListLimitsResponse_FieldPathSelectorLimits:
		for _, v := range fpaov.values.([][]*limit.Limit) {
			values = append(values, v)
		}
	case ListLimitsResponse_FieldPathSelectorPrevPageToken:
		for _, v := range fpaov.values.([]*limit.PagerCursor) {
			values = append(values, v)
		}
	case ListLimitsResponse_FieldPathSelectorNextPageToken:
		for _, v := range fpaov.values.([]*limit.PagerCursor) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *ListLimitsResponse_FieldTerminalPathArrayOfValues) AsLimitsArrayOfValues() ([][]*limit.Limit, bool) {
	res, ok := fpaov.values.([][]*limit.Limit)
	return res, ok
}
func (fpaov *ListLimitsResponse_FieldTerminalPathArrayOfValues) AsPrevPageTokenArrayOfValues() ([]*limit.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit.PagerCursor)
	return res, ok
}
func (fpaov *ListLimitsResponse_FieldTerminalPathArrayOfValues) AsNextPageTokenArrayOfValues() ([]*limit.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit.PagerCursor)
	return res, ok
}

type ListLimitsResponse_FieldSubPathArrayOfValues struct {
	ListLimitsResponse_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ ListLimitsResponse_FieldPathArrayOfValues = (*ListLimitsResponse_FieldSubPathArrayOfValues)(nil)

func (fpsaov *ListLimitsResponse_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *ListLimitsResponse_FieldSubPathArrayOfValues) AsLimitsPathArrayOfValues() (limit.Limit_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(limit.Limit_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitRequest_FieldPathSelector
	Get(source *WatchLimitRequest) []interface{}
	GetSingle(source *WatchLimitRequest) (interface{}, bool)
	ClearValue(item *WatchLimitRequest)

	// Those methods build corresponding WatchLimitRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitRequest_FieldPathArrayItemValue
}

type WatchLimitRequest_FieldPathSelector int32

const (
	WatchLimitRequest_FieldPathSelectorName      WatchLimitRequest_FieldPathSelector = 0
	WatchLimitRequest_FieldPathSelectorFieldMask WatchLimitRequest_FieldPathSelector = 1
	WatchLimitRequest_FieldPathSelectorView      WatchLimitRequest_FieldPathSelector = 2
)

func (s WatchLimitRequest_FieldPathSelector) String() string {
	switch s {
	case WatchLimitRequest_FieldPathSelectorName:
		return "name"
	case WatchLimitRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case WatchLimitRequest_FieldPathSelectorView:
		return "view"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", s))
	}
}

func BuildWatchLimitRequest_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &WatchLimitRequest_FieldTerminalPath{selector: WatchLimitRequest_FieldPathSelectorName}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &WatchLimitRequest_FieldTerminalPath{selector: WatchLimitRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &WatchLimitRequest_FieldTerminalPath{selector: WatchLimitRequest_FieldPathSelectorView}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitRequest", fp)
}

func ParseWatchLimitRequest_FieldPath(rawField string) (WatchLimitRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitRequest_FieldPath(fp)
}

func MustParseWatchLimitRequest_FieldPath(rawField string) WatchLimitRequest_FieldPath {
	fp, err := ParseWatchLimitRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitRequest_FieldTerminalPath struct {
	selector WatchLimitRequest_FieldPathSelector
}

var _ WatchLimitRequest_FieldPath = (*WatchLimitRequest_FieldTerminalPath)(nil)

func (fp *WatchLimitRequest_FieldTerminalPath) Selector() WatchLimitRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitRequest
func (fp *WatchLimitRequest_FieldTerminalPath) Get(source *WatchLimitRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitRequest_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		case WatchLimitRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case WatchLimitRequest_FieldPathSelectorView:
			values = append(values, source.View)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitRequest))
}

// GetSingle returns value pointed by specific field of from source WatchLimitRequest
func (fp *WatchLimitRequest_FieldTerminalPath) GetSingle(source *WatchLimitRequest) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitRequest_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	case WatchLimitRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case WatchLimitRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitRequest))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitRequest_FieldPathSelectorName:
		return (*limit.Reference)(nil)
	case WatchLimitRequest_FieldPathSelectorFieldMask:
		return (*limit.Limit_FieldMask)(nil)
	case WatchLimitRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitRequest_FieldTerminalPath) ClearValue(item *WatchLimitRequest) {
	if item != nil {
		switch fp.selector {
		case WatchLimitRequest_FieldPathSelectorName:
			item.Name = nil
		case WatchLimitRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case WatchLimitRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitRequest_FieldPathSelectorName ||
		fp.selector == WatchLimitRequest_FieldPathSelectorFieldMask ||
		fp.selector == WatchLimitRequest_FieldPathSelectorView
}

func (fp *WatchLimitRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitRequest_FieldTerminalPath) WithIValue(value interface{}) WatchLimitRequest_FieldPathValue {
	switch fp.selector {
	case WatchLimitRequest_FieldPathSelectorName:
		return &WatchLimitRequest_FieldTerminalPathValue{WatchLimitRequest_FieldTerminalPath: *fp, value: value.(*limit.Reference)}
	case WatchLimitRequest_FieldPathSelectorFieldMask:
		return &WatchLimitRequest_FieldTerminalPathValue{WatchLimitRequest_FieldTerminalPath: *fp, value: value.(*limit.Limit_FieldMask)}
	case WatchLimitRequest_FieldPathSelectorView:
		return &WatchLimitRequest_FieldTerminalPathValue{WatchLimitRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitRequest_FieldPathArrayOfValues {
	fpaov := &WatchLimitRequest_FieldTerminalPathArrayOfValues{WatchLimitRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitRequest_FieldPathSelectorName:
		return &WatchLimitRequest_FieldTerminalPathArrayOfValues{WatchLimitRequest_FieldTerminalPath: *fp, values: values.([]*limit.Reference)}
	case WatchLimitRequest_FieldPathSelectorFieldMask:
		return &WatchLimitRequest_FieldTerminalPathArrayOfValues{WatchLimitRequest_FieldTerminalPath: *fp, values: values.([]*limit.Limit_FieldMask)}
	case WatchLimitRequest_FieldPathSelectorView:
		return &WatchLimitRequest_FieldTerminalPathArrayOfValues{WatchLimitRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WatchLimitRequest_FieldPathValue allows storing values for WatchLimitRequest fields according to their type
type WatchLimitRequest_FieldPathValue interface {
	WatchLimitRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitRequest)
	CompareWith(*WatchLimitRequest) (cmp int, comparable bool)
}

func ParseWatchLimitRequest_FieldPathValue(pathStr, valueStr string) (WatchLimitRequest_FieldPathValue, error) {
	fp, err := ParseWatchLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitRequest_FieldPathValue), nil
}

func MustParseWatchLimitRequest_FieldPathValue(pathStr, valueStr string) WatchLimitRequest_FieldPathValue {
	fpv, err := ParseWatchLimitRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitRequest_FieldTerminalPathValue struct {
	WatchLimitRequest_FieldTerminalPath
	value interface{}
}

var _ WatchLimitRequest_FieldPathValue = (*WatchLimitRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WatchLimitRequest' as interface{}
func (fpv *WatchLimitRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitRequest_FieldTerminalPathValue) AsNameValue() (*limit.Reference, bool) {
	res, ok := fpv.value.(*limit.Reference)
	return res, ok
}
func (fpv *WatchLimitRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit.Limit_FieldMask, bool) {
	res, ok := fpv.value.(*limit.Limit_FieldMask)
	return res, ok
}
func (fpv *WatchLimitRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}

// SetTo stores value for selected field for object WatchLimitRequest
func (fpv *WatchLimitRequest_FieldTerminalPathValue) SetTo(target **WatchLimitRequest) {
	if *target == nil {
		*target = new(WatchLimitRequest)
	}
	switch fpv.selector {
	case WatchLimitRequest_FieldPathSelectorName:
		(*target).Name = fpv.value.(*limit.Reference)
	case WatchLimitRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit.Limit_FieldMask)
	case WatchLimitRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fpv.selector))
	}
}

func (fpv *WatchLimitRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitRequest_FieldTerminalPathValue' with the value under path in 'WatchLimitRequest'.
func (fpv *WatchLimitRequest_FieldTerminalPathValue) CompareWith(source *WatchLimitRequest) (int, bool) {
	switch fpv.selector {
	case WatchLimitRequest_FieldPathSelectorName:
		leftValue := fpv.value.(*limit.Reference)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitRequest_FieldPathSelectorFieldMask:
		return 0, false
	case WatchLimitRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitRequest: %d", fpv.selector))
	}
}

func (fpv *WatchLimitRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitRequest))
}

// WatchLimitRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for WatchLimitRequest according to their type
// Present only for array (repeated) types.
type WatchLimitRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitRequest_FieldPath
	ContainsValue(*WatchLimitRequest) bool
}

// ParseWatchLimitRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitRequest_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitRequest_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitRequest_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitRequest_FieldTerminalPathArrayItemValue struct {
	WatchLimitRequest_FieldTerminalPath
	value interface{}
}

var _ WatchLimitRequest_FieldPathArrayItemValue = (*WatchLimitRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitRequest as interface{}
func (fpaiv *WatchLimitRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WatchLimitRequest_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitRequest'
func (fpaiv *WatchLimitRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitRequest) bool {
	slice := fpaiv.WatchLimitRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WatchLimitRequest_FieldPathArrayOfValues allows storing slice of values for WatchLimitRequest fields according to their type
type WatchLimitRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitRequest_FieldPath
}

func ParseWatchLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitRequest_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitRequest_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitRequest_FieldTerminalPathArrayOfValues struct {
	WatchLimitRequest_FieldTerminalPath
	values interface{}
}

var _ WatchLimitRequest_FieldPathArrayOfValues = (*WatchLimitRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitRequest_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*limit.Reference) {
			values = append(values, v)
		}
	case WatchLimitRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit.Limit_FieldMask) {
			values = append(values, v)
		}
	case WatchLimitRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitRequest_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*limit.Reference, bool) {
	res, ok := fpaov.values.([]*limit.Reference)
	return res, ok
}
func (fpaov *WatchLimitRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit.Limit_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit.Limit_FieldMask)
	return res, ok
}
func (fpaov *WatchLimitRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitResponse_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitResponse_FieldPathSelector
	Get(source *WatchLimitResponse) []interface{}
	GetSingle(source *WatchLimitResponse) (interface{}, bool)
	ClearValue(item *WatchLimitResponse)

	// Those methods build corresponding WatchLimitResponse_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitResponse_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitResponse_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitResponse_FieldPathArrayItemValue
}

type WatchLimitResponse_FieldPathSelector int32

const (
	WatchLimitResponse_FieldPathSelectorChange WatchLimitResponse_FieldPathSelector = 0
)

func (s WatchLimitResponse_FieldPathSelector) String() string {
	switch s {
	case WatchLimitResponse_FieldPathSelectorChange:
		return "change"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", s))
	}
}

func BuildWatchLimitResponse_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitResponse_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitResponse")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "change":
			return &WatchLimitResponse_FieldTerminalPath{selector: WatchLimitResponse_FieldPathSelectorChange}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitResponse", fp)
}

func ParseWatchLimitResponse_FieldPath(rawField string) (WatchLimitResponse_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitResponse_FieldPath(fp)
}

func MustParseWatchLimitResponse_FieldPath(rawField string) WatchLimitResponse_FieldPath {
	fp, err := ParseWatchLimitResponse_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitResponse_FieldTerminalPath struct {
	selector WatchLimitResponse_FieldPathSelector
}

var _ WatchLimitResponse_FieldPath = (*WatchLimitResponse_FieldTerminalPath)(nil)

func (fp *WatchLimitResponse_FieldTerminalPath) Selector() WatchLimitResponse_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitResponse_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitResponse_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitResponse
func (fp *WatchLimitResponse_FieldTerminalPath) Get(source *WatchLimitResponse) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitResponse_FieldPathSelectorChange:
			if source.Change != nil {
				values = append(values, source.Change)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitResponse_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitResponse))
}

// GetSingle returns value pointed by specific field of from source WatchLimitResponse
func (fp *WatchLimitResponse_FieldTerminalPath) GetSingle(source *WatchLimitResponse) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitResponse_FieldPathSelectorChange:
		res := source.GetChange()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitResponse_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitResponse))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitResponse_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitResponse_FieldPathSelectorChange:
		return (*limit.LimitChange)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitResponse_FieldTerminalPath) ClearValue(item *WatchLimitResponse) {
	if item != nil {
		switch fp.selector {
		case WatchLimitResponse_FieldPathSelectorChange:
			item.Change = nil
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitResponse_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitResponse))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitResponse_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitResponse_FieldPathSelectorChange
}

func (fp *WatchLimitResponse_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitResponse_FieldTerminalPath) WithIValue(value interface{}) WatchLimitResponse_FieldPathValue {
	switch fp.selector {
	case WatchLimitResponse_FieldPathSelectorChange:
		return &WatchLimitResponse_FieldTerminalPathValue{WatchLimitResponse_FieldTerminalPath: *fp, value: value.(*limit.LimitChange)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitResponse_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitResponse_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitResponse_FieldPathArrayOfValues {
	fpaov := &WatchLimitResponse_FieldTerminalPathArrayOfValues{WatchLimitResponse_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitResponse_FieldPathSelectorChange:
		return &WatchLimitResponse_FieldTerminalPathArrayOfValues{WatchLimitResponse_FieldTerminalPath: *fp, values: values.([]*limit.LimitChange)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitResponse_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitResponse_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitResponse_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitResponse_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WatchLimitResponse_FieldPathValue allows storing values for WatchLimitResponse fields according to their type
type WatchLimitResponse_FieldPathValue interface {
	WatchLimitResponse_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitResponse)
	CompareWith(*WatchLimitResponse) (cmp int, comparable bool)
}

func ParseWatchLimitResponse_FieldPathValue(pathStr, valueStr string) (WatchLimitResponse_FieldPathValue, error) {
	fp, err := ParseWatchLimitResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitResponse field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitResponse_FieldPathValue), nil
}

func MustParseWatchLimitResponse_FieldPathValue(pathStr, valueStr string) WatchLimitResponse_FieldPathValue {
	fpv, err := ParseWatchLimitResponse_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitResponse_FieldTerminalPathValue struct {
	WatchLimitResponse_FieldTerminalPath
	value interface{}
}

var _ WatchLimitResponse_FieldPathValue = (*WatchLimitResponse_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WatchLimitResponse' as interface{}
func (fpv *WatchLimitResponse_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitResponse_FieldTerminalPathValue) AsChangeValue() (*limit.LimitChange, bool) {
	res, ok := fpv.value.(*limit.LimitChange)
	return res, ok
}

// SetTo stores value for selected field for object WatchLimitResponse
func (fpv *WatchLimitResponse_FieldTerminalPathValue) SetTo(target **WatchLimitResponse) {
	if *target == nil {
		*target = new(WatchLimitResponse)
	}
	switch fpv.selector {
	case WatchLimitResponse_FieldPathSelectorChange:
		(*target).Change = fpv.value.(*limit.LimitChange)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fpv.selector))
	}
}

func (fpv *WatchLimitResponse_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitResponse)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitResponse_FieldTerminalPathValue' with the value under path in 'WatchLimitResponse'.
func (fpv *WatchLimitResponse_FieldTerminalPathValue) CompareWith(source *WatchLimitResponse) (int, bool) {
	switch fpv.selector {
	case WatchLimitResponse_FieldPathSelectorChange:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitResponse: %d", fpv.selector))
	}
}

func (fpv *WatchLimitResponse_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitResponse))
}

// WatchLimitResponse_FieldPathArrayItemValue allows storing single item in Path-specific values for WatchLimitResponse according to their type
// Present only for array (repeated) types.
type WatchLimitResponse_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitResponse_FieldPath
	ContainsValue(*WatchLimitResponse) bool
}

// ParseWatchLimitResponse_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitResponse_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitResponse_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitResponse field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitResponse_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitResponse_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitResponse_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitResponse_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitResponse_FieldTerminalPathArrayItemValue struct {
	WatchLimitResponse_FieldTerminalPath
	value interface{}
}

var _ WatchLimitResponse_FieldPathArrayItemValue = (*WatchLimitResponse_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitResponse as interface{}
func (fpaiv *WatchLimitResponse_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WatchLimitResponse_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitResponse) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitResponse_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitResponse))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitResponse'
func (fpaiv *WatchLimitResponse_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitResponse) bool {
	slice := fpaiv.WatchLimitResponse_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WatchLimitResponse_FieldPathArrayOfValues allows storing slice of values for WatchLimitResponse fields according to their type
type WatchLimitResponse_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitResponse_FieldPath
}

func ParseWatchLimitResponse_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitResponse_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitResponse field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitResponse_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitResponse_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitResponse_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitResponse_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitResponse_FieldTerminalPathArrayOfValues struct {
	WatchLimitResponse_FieldTerminalPath
	values interface{}
}

var _ WatchLimitResponse_FieldPathArrayOfValues = (*WatchLimitResponse_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitResponse_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitResponse_FieldPathSelectorChange:
		for _, v := range fpaov.values.([]*limit.LimitChange) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitResponse_FieldTerminalPathArrayOfValues) AsChangeArrayOfValues() ([]*limit.LimitChange, bool) {
	res, ok := fpaov.values.([]*limit.LimitChange)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitsRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitsRequest_FieldPathSelector
	Get(source *WatchLimitsRequest) []interface{}
	GetSingle(source *WatchLimitsRequest) (interface{}, bool)
	ClearValue(item *WatchLimitsRequest)

	// Those methods build corresponding WatchLimitsRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitsRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitsRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitsRequest_FieldPathArrayItemValue
}

type WatchLimitsRequest_FieldPathSelector int32

const (
	WatchLimitsRequest_FieldPathSelectorType         WatchLimitsRequest_FieldPathSelector = 0
	WatchLimitsRequest_FieldPathSelectorParent       WatchLimitsRequest_FieldPathSelector = 1
	WatchLimitsRequest_FieldPathSelectorPageSize     WatchLimitsRequest_FieldPathSelector = 2
	WatchLimitsRequest_FieldPathSelectorPageToken    WatchLimitsRequest_FieldPathSelector = 3
	WatchLimitsRequest_FieldPathSelectorOrderBy      WatchLimitsRequest_FieldPathSelector = 4
	WatchLimitsRequest_FieldPathSelectorResumeToken  WatchLimitsRequest_FieldPathSelector = 5
	WatchLimitsRequest_FieldPathSelectorStartingTime WatchLimitsRequest_FieldPathSelector = 6
	WatchLimitsRequest_FieldPathSelectorFilter       WatchLimitsRequest_FieldPathSelector = 7
	WatchLimitsRequest_FieldPathSelectorFieldMask    WatchLimitsRequest_FieldPathSelector = 8
	WatchLimitsRequest_FieldPathSelectorView         WatchLimitsRequest_FieldPathSelector = 9
	WatchLimitsRequest_FieldPathSelectorMaxChunkSize WatchLimitsRequest_FieldPathSelector = 10
)

func (s WatchLimitsRequest_FieldPathSelector) String() string {
	switch s {
	case WatchLimitsRequest_FieldPathSelectorType:
		return "type"
	case WatchLimitsRequest_FieldPathSelectorParent:
		return "parent"
	case WatchLimitsRequest_FieldPathSelectorPageSize:
		return "page_size"
	case WatchLimitsRequest_FieldPathSelectorPageToken:
		return "page_token"
	case WatchLimitsRequest_FieldPathSelectorOrderBy:
		return "order_by"
	case WatchLimitsRequest_FieldPathSelectorResumeToken:
		return "resume_token"
	case WatchLimitsRequest_FieldPathSelectorStartingTime:
		return "starting_time"
	case WatchLimitsRequest_FieldPathSelectorFilter:
		return "filter"
	case WatchLimitsRequest_FieldPathSelectorFieldMask:
		return "field_mask"
	case WatchLimitsRequest_FieldPathSelectorView:
		return "view"
	case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
		return "max_chunk_size"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", s))
	}
}

func BuildWatchLimitsRequest_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitsRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitsRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "type":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorType}, nil
		case "parent":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorParent}, nil
		case "page_size", "pageSize", "page-size":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorPageSize}, nil
		case "page_token", "pageToken", "page-token":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorPageToken}, nil
		case "order_by", "orderBy", "order-by":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorOrderBy}, nil
		case "resume_token", "resumeToken", "resume-token":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorResumeToken}, nil
		case "starting_time", "startingTime", "starting-time":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorStartingTime}, nil
		case "filter":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorFilter}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorFieldMask}, nil
		case "view":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorView}, nil
		case "max_chunk_size", "maxChunkSize", "max-chunk-size":
			return &WatchLimitsRequest_FieldTerminalPath{selector: WatchLimitsRequest_FieldPathSelectorMaxChunkSize}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitsRequest", fp)
}

func ParseWatchLimitsRequest_FieldPath(rawField string) (WatchLimitsRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitsRequest_FieldPath(fp)
}

func MustParseWatchLimitsRequest_FieldPath(rawField string) WatchLimitsRequest_FieldPath {
	fp, err := ParseWatchLimitsRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitsRequest_FieldTerminalPath struct {
	selector WatchLimitsRequest_FieldPathSelector
}

var _ WatchLimitsRequest_FieldPath = (*WatchLimitsRequest_FieldTerminalPath)(nil)

func (fp *WatchLimitsRequest_FieldTerminalPath) Selector() WatchLimitsRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitsRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitsRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitsRequest
func (fp *WatchLimitsRequest_FieldTerminalPath) Get(source *WatchLimitsRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitsRequest_FieldPathSelectorType:
			values = append(values, source.Type)
		case WatchLimitsRequest_FieldPathSelectorParent:
			if source.Parent != nil {
				values = append(values, source.Parent)
			}
		case WatchLimitsRequest_FieldPathSelectorPageSize:
			values = append(values, source.PageSize)
		case WatchLimitsRequest_FieldPathSelectorPageToken:
			if source.PageToken != nil {
				values = append(values, source.PageToken)
			}
		case WatchLimitsRequest_FieldPathSelectorOrderBy:
			if source.OrderBy != nil {
				values = append(values, source.OrderBy)
			}
		case WatchLimitsRequest_FieldPathSelectorResumeToken:
			values = append(values, source.ResumeToken)
		case WatchLimitsRequest_FieldPathSelectorStartingTime:
			if source.StartingTime != nil {
				values = append(values, source.StartingTime)
			}
		case WatchLimitsRequest_FieldPathSelectorFilter:
			if source.Filter != nil {
				values = append(values, source.Filter)
			}
		case WatchLimitsRequest_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		case WatchLimitsRequest_FieldPathSelectorView:
			values = append(values, source.View)
		case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
			values = append(values, source.MaxChunkSize)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitsRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitsRequest))
}

// GetSingle returns value pointed by specific field of from source WatchLimitsRequest
func (fp *WatchLimitsRequest_FieldTerminalPath) GetSingle(source *WatchLimitsRequest) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitsRequest_FieldPathSelectorType:
		return source.GetType(), source != nil
	case WatchLimitsRequest_FieldPathSelectorParent:
		res := source.GetParent()
		return res, res != nil
	case WatchLimitsRequest_FieldPathSelectorPageSize:
		return source.GetPageSize(), source != nil
	case WatchLimitsRequest_FieldPathSelectorPageToken:
		res := source.GetPageToken()
		return res, res != nil
	case WatchLimitsRequest_FieldPathSelectorOrderBy:
		res := source.GetOrderBy()
		return res, res != nil
	case WatchLimitsRequest_FieldPathSelectorResumeToken:
		return source.GetResumeToken(), source != nil
	case WatchLimitsRequest_FieldPathSelectorStartingTime:
		res := source.GetStartingTime()
		return res, res != nil
	case WatchLimitsRequest_FieldPathSelectorFilter:
		res := source.GetFilter()
		return res, res != nil
	case WatchLimitsRequest_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	case WatchLimitsRequest_FieldPathSelectorView:
		return source.GetView(), source != nil
	case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
		return source.GetMaxChunkSize(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitsRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitsRequest))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitsRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitsRequest_FieldPathSelectorType:
		return watch_type.WatchType_STATEFUL
	case WatchLimitsRequest_FieldPathSelectorParent:
		return (*limit.ParentReference)(nil)
	case WatchLimitsRequest_FieldPathSelectorPageSize:
		return int32(0)
	case WatchLimitsRequest_FieldPathSelectorPageToken:
		return (*limit.PagerCursor)(nil)
	case WatchLimitsRequest_FieldPathSelectorOrderBy:
		return (*limit.OrderBy)(nil)
	case WatchLimitsRequest_FieldPathSelectorResumeToken:
		return ""
	case WatchLimitsRequest_FieldPathSelectorStartingTime:
		return (*timestamp.Timestamp)(nil)
	case WatchLimitsRequest_FieldPathSelectorFilter:
		return (*limit.Filter)(nil)
	case WatchLimitsRequest_FieldPathSelectorFieldMask:
		return (*limit.Limit_FieldMask)(nil)
	case WatchLimitsRequest_FieldPathSelectorView:
		return view.View_UNSPECIFIED
	case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
		return int32(0)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitsRequest_FieldTerminalPath) ClearValue(item *WatchLimitsRequest) {
	if item != nil {
		switch fp.selector {
		case WatchLimitsRequest_FieldPathSelectorType:
			item.Type = watch_type.WatchType_STATEFUL
		case WatchLimitsRequest_FieldPathSelectorParent:
			item.Parent = nil
		case WatchLimitsRequest_FieldPathSelectorPageSize:
			item.PageSize = int32(0)
		case WatchLimitsRequest_FieldPathSelectorPageToken:
			item.PageToken = nil
		case WatchLimitsRequest_FieldPathSelectorOrderBy:
			item.OrderBy = nil
		case WatchLimitsRequest_FieldPathSelectorResumeToken:
			item.ResumeToken = ""
		case WatchLimitsRequest_FieldPathSelectorStartingTime:
			item.StartingTime = nil
		case WatchLimitsRequest_FieldPathSelectorFilter:
			item.Filter = nil
		case WatchLimitsRequest_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		case WatchLimitsRequest_FieldPathSelectorView:
			item.View = view.View_UNSPECIFIED
		case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
			item.MaxChunkSize = int32(0)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitsRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitsRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitsRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitsRequest_FieldPathSelectorType ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorParent ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorPageSize ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorPageToken ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorOrderBy ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorResumeToken ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorStartingTime ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorFilter ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorFieldMask ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorView ||
		fp.selector == WatchLimitsRequest_FieldPathSelectorMaxChunkSize
}

func (fp *WatchLimitsRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitsRequest_FieldTerminalPath) WithIValue(value interface{}) WatchLimitsRequest_FieldPathValue {
	switch fp.selector {
	case WatchLimitsRequest_FieldPathSelectorType:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(watch_type.WatchType)}
	case WatchLimitsRequest_FieldPathSelectorParent:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.ParentReference)}
	case WatchLimitsRequest_FieldPathSelectorPageSize:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(int32)}
	case WatchLimitsRequest_FieldPathSelectorPageToken:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.PagerCursor)}
	case WatchLimitsRequest_FieldPathSelectorOrderBy:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.OrderBy)}
	case WatchLimitsRequest_FieldPathSelectorResumeToken:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(string)}
	case WatchLimitsRequest_FieldPathSelectorStartingTime:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(*timestamp.Timestamp)}
	case WatchLimitsRequest_FieldPathSelectorFilter:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.Filter)}
	case WatchLimitsRequest_FieldPathSelectorFieldMask:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(*limit.Limit_FieldMask)}
	case WatchLimitsRequest_FieldPathSelectorView:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(view.View)}
	case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
		return &WatchLimitsRequest_FieldTerminalPathValue{WatchLimitsRequest_FieldTerminalPath: *fp, value: value.(int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitsRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitsRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitsRequest_FieldPathArrayOfValues {
	fpaov := &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitsRequest_FieldPathSelectorType:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]watch_type.WatchType)}
	case WatchLimitsRequest_FieldPathSelectorParent:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.ParentReference)}
	case WatchLimitsRequest_FieldPathSelectorPageSize:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]int32)}
	case WatchLimitsRequest_FieldPathSelectorPageToken:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.PagerCursor)}
	case WatchLimitsRequest_FieldPathSelectorOrderBy:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.OrderBy)}
	case WatchLimitsRequest_FieldPathSelectorResumeToken:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]string)}
	case WatchLimitsRequest_FieldPathSelectorStartingTime:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]*timestamp.Timestamp)}
	case WatchLimitsRequest_FieldPathSelectorFilter:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.Filter)}
	case WatchLimitsRequest_FieldPathSelectorFieldMask:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]*limit.Limit_FieldMask)}
	case WatchLimitsRequest_FieldPathSelectorView:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]view.View)}
	case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
		return &WatchLimitsRequest_FieldTerminalPathArrayOfValues{WatchLimitsRequest_FieldTerminalPath: *fp, values: values.([]int32)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitsRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitsRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitsRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fp.selector))
	}
}

func (fp *WatchLimitsRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WatchLimitsRequest_FieldPathValue allows storing values for WatchLimitsRequest fields according to their type
type WatchLimitsRequest_FieldPathValue interface {
	WatchLimitsRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitsRequest)
	CompareWith(*WatchLimitsRequest) (cmp int, comparable bool)
}

func ParseWatchLimitsRequest_FieldPathValue(pathStr, valueStr string) (WatchLimitsRequest_FieldPathValue, error) {
	fp, err := ParseWatchLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitsRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitsRequest_FieldPathValue), nil
}

func MustParseWatchLimitsRequest_FieldPathValue(pathStr, valueStr string) WatchLimitsRequest_FieldPathValue {
	fpv, err := ParseWatchLimitsRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitsRequest_FieldTerminalPathValue struct {
	WatchLimitsRequest_FieldTerminalPath
	value interface{}
}

var _ WatchLimitsRequest_FieldPathValue = (*WatchLimitsRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WatchLimitsRequest' as interface{}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsTypeValue() (watch_type.WatchType, bool) {
	res, ok := fpv.value.(watch_type.WatchType)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsParentValue() (*limit.ParentReference, bool) {
	res, ok := fpv.value.(*limit.ParentReference)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsPageSizeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsPageTokenValue() (*limit.PagerCursor, bool) {
	res, ok := fpv.value.(*limit.PagerCursor)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsOrderByValue() (*limit.OrderBy, bool) {
	res, ok := fpv.value.(*limit.OrderBy)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsResumeTokenValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsStartingTimeValue() (*timestamp.Timestamp, bool) {
	res, ok := fpv.value.(*timestamp.Timestamp)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsFilterValue() (*limit.Filter, bool) {
	res, ok := fpv.value.(*limit.Filter)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsFieldMaskValue() (*limit.Limit_FieldMask, bool) {
	res, ok := fpv.value.(*limit.Limit_FieldMask)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsViewValue() (view.View, bool) {
	res, ok := fpv.value.(view.View)
	return res, ok
}
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) AsMaxChunkSizeValue() (int32, bool) {
	res, ok := fpv.value.(int32)
	return res, ok
}

// SetTo stores value for selected field for object WatchLimitsRequest
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) SetTo(target **WatchLimitsRequest) {
	if *target == nil {
		*target = new(WatchLimitsRequest)
	}
	switch fpv.selector {
	case WatchLimitsRequest_FieldPathSelectorType:
		(*target).Type = fpv.value.(watch_type.WatchType)
	case WatchLimitsRequest_FieldPathSelectorParent:
		(*target).Parent = fpv.value.(*limit.ParentReference)
	case WatchLimitsRequest_FieldPathSelectorPageSize:
		(*target).PageSize = fpv.value.(int32)
	case WatchLimitsRequest_FieldPathSelectorPageToken:
		(*target).PageToken = fpv.value.(*limit.PagerCursor)
	case WatchLimitsRequest_FieldPathSelectorOrderBy:
		(*target).OrderBy = fpv.value.(*limit.OrderBy)
	case WatchLimitsRequest_FieldPathSelectorResumeToken:
		(*target).ResumeToken = fpv.value.(string)
	case WatchLimitsRequest_FieldPathSelectorStartingTime:
		(*target).StartingTime = fpv.value.(*timestamp.Timestamp)
	case WatchLimitsRequest_FieldPathSelectorFilter:
		(*target).Filter = fpv.value.(*limit.Filter)
	case WatchLimitsRequest_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit.Limit_FieldMask)
	case WatchLimitsRequest_FieldPathSelectorView:
		(*target).View = fpv.value.(view.View)
	case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
		(*target).MaxChunkSize = fpv.value.(int32)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fpv.selector))
	}
}

func (fpv *WatchLimitsRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitsRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitsRequest_FieldTerminalPathValue' with the value under path in 'WatchLimitsRequest'.
func (fpv *WatchLimitsRequest_FieldTerminalPathValue) CompareWith(source *WatchLimitsRequest) (int, bool) {
	switch fpv.selector {
	case WatchLimitsRequest_FieldPathSelectorType:
		leftValue := fpv.value.(watch_type.WatchType)
		rightValue := source.GetType()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsRequest_FieldPathSelectorParent:
		leftValue := fpv.value.(*limit.ParentReference)
		rightValue := source.GetParent()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsRequest_FieldPathSelectorPageSize:
		leftValue := fpv.value.(int32)
		rightValue := source.GetPageSize()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsRequest_FieldPathSelectorPageToken:
		return 0, false
	case WatchLimitsRequest_FieldPathSelectorOrderBy:
		return 0, false
	case WatchLimitsRequest_FieldPathSelectorResumeToken:
		leftValue := fpv.value.(string)
		rightValue := source.GetResumeToken()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsRequest_FieldPathSelectorStartingTime:
		leftValue := fpv.value.(*timestamp.Timestamp)
		rightValue := source.GetStartingTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsRequest_FieldPathSelectorFilter:
		return 0, false
	case WatchLimitsRequest_FieldPathSelectorFieldMask:
		return 0, false
	case WatchLimitsRequest_FieldPathSelectorView:
		leftValue := fpv.value.(view.View)
		rightValue := source.GetView()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
		leftValue := fpv.value.(int32)
		rightValue := source.GetMaxChunkSize()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsRequest: %d", fpv.selector))
	}
}

func (fpv *WatchLimitsRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitsRequest))
}

// WatchLimitsRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for WatchLimitsRequest according to their type
// Present only for array (repeated) types.
type WatchLimitsRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitsRequest_FieldPath
	ContainsValue(*WatchLimitsRequest) bool
}

// ParseWatchLimitsRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitsRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitsRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitsRequest_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitsRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitsRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitsRequest_FieldTerminalPathArrayItemValue struct {
	WatchLimitsRequest_FieldTerminalPath
	value interface{}
}

var _ WatchLimitsRequest_FieldPathArrayItemValue = (*WatchLimitsRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitsRequest as interface{}
func (fpaiv *WatchLimitsRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WatchLimitsRequest_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitsRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitsRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitsRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitsRequest'
func (fpaiv *WatchLimitsRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitsRequest) bool {
	slice := fpaiv.WatchLimitsRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WatchLimitsRequest_FieldPathArrayOfValues allows storing slice of values for WatchLimitsRequest fields according to their type
type WatchLimitsRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitsRequest_FieldPath
}

func ParseWatchLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitsRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitsRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitsRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitsRequest_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitsRequest_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitsRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitsRequest_FieldTerminalPathArrayOfValues struct {
	WatchLimitsRequest_FieldTerminalPath
	values interface{}
}

var _ WatchLimitsRequest_FieldPathArrayOfValues = (*WatchLimitsRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitsRequest_FieldPathSelectorType:
		for _, v := range fpaov.values.([]watch_type.WatchType) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorParent:
		for _, v := range fpaov.values.([]*limit.ParentReference) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorPageSize:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorPageToken:
		for _, v := range fpaov.values.([]*limit.PagerCursor) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorOrderBy:
		for _, v := range fpaov.values.([]*limit.OrderBy) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorResumeToken:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorStartingTime:
		for _, v := range fpaov.values.([]*timestamp.Timestamp) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorFilter:
		for _, v := range fpaov.values.([]*limit.Filter) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit.Limit_FieldMask) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorView:
		for _, v := range fpaov.values.([]view.View) {
			values = append(values, v)
		}
	case WatchLimitsRequest_FieldPathSelectorMaxChunkSize:
		for _, v := range fpaov.values.([]int32) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsTypeArrayOfValues() ([]watch_type.WatchType, bool) {
	res, ok := fpaov.values.([]watch_type.WatchType)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsParentArrayOfValues() ([]*limit.ParentReference, bool) {
	res, ok := fpaov.values.([]*limit.ParentReference)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsPageSizeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsPageTokenArrayOfValues() ([]*limit.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit.PagerCursor)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsOrderByArrayOfValues() ([]*limit.OrderBy, bool) {
	res, ok := fpaov.values.([]*limit.OrderBy)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsResumeTokenArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsStartingTimeArrayOfValues() ([]*timestamp.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamp.Timestamp)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsFilterArrayOfValues() ([]*limit.Filter, bool) {
	res, ok := fpaov.values.([]*limit.Filter)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit.Limit_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit.Limit_FieldMask)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsViewArrayOfValues() ([]view.View, bool) {
	res, ok := fpaov.values.([]view.View)
	return res, ok
}
func (fpaov *WatchLimitsRequest_FieldTerminalPathArrayOfValues) AsMaxChunkSizeArrayOfValues() ([]int32, bool) {
	res, ok := fpaov.values.([]int32)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitsResponse_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitsResponse_FieldPathSelector
	Get(source *WatchLimitsResponse) []interface{}
	GetSingle(source *WatchLimitsResponse) (interface{}, bool)
	ClearValue(item *WatchLimitsResponse)

	// Those methods build corresponding WatchLimitsResponse_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitsResponse_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitsResponse_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitsResponse_FieldPathArrayItemValue
}

type WatchLimitsResponse_FieldPathSelector int32

const (
	WatchLimitsResponse_FieldPathSelectorLimitChanges    WatchLimitsResponse_FieldPathSelector = 0
	WatchLimitsResponse_FieldPathSelectorIsCurrent       WatchLimitsResponse_FieldPathSelector = 1
	WatchLimitsResponse_FieldPathSelectorPageTokenChange WatchLimitsResponse_FieldPathSelector = 2
	WatchLimitsResponse_FieldPathSelectorResumeToken     WatchLimitsResponse_FieldPathSelector = 3
	WatchLimitsResponse_FieldPathSelectorSnapshotSize    WatchLimitsResponse_FieldPathSelector = 4
	WatchLimitsResponse_FieldPathSelectorIsSoftReset     WatchLimitsResponse_FieldPathSelector = 5
	WatchLimitsResponse_FieldPathSelectorIsHardReset     WatchLimitsResponse_FieldPathSelector = 6
)

func (s WatchLimitsResponse_FieldPathSelector) String() string {
	switch s {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		return "limit_changes"
	case WatchLimitsResponse_FieldPathSelectorIsCurrent:
		return "is_current"
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		return "page_token_change"
	case WatchLimitsResponse_FieldPathSelectorResumeToken:
		return "resume_token"
	case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
		return "snapshot_size"
	case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
		return "is_soft_reset"
	case WatchLimitsResponse_FieldPathSelectorIsHardReset:
		return "is_hard_reset"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", s))
	}
}

func BuildWatchLimitsResponse_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitsResponse_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitsResponse")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limit_changes", "limitChanges", "limit-changes":
			return &WatchLimitsResponse_FieldTerminalPath{selector: WatchLimitsResponse_FieldPathSelectorLimitChanges}, nil
		case "is_current", "isCurrent", "is-current":
			return &WatchLimitsResponse_FieldTerminalPath{selector: WatchLimitsResponse_FieldPathSelectorIsCurrent}, nil
		case "page_token_change", "pageTokenChange", "page-token-change":
			return &WatchLimitsResponse_FieldTerminalPath{selector: WatchLimitsResponse_FieldPathSelectorPageTokenChange}, nil
		case "resume_token", "resumeToken", "resume-token":
			return &WatchLimitsResponse_FieldTerminalPath{selector: WatchLimitsResponse_FieldPathSelectorResumeToken}, nil
		case "snapshot_size", "snapshotSize", "snapshot-size":
			return &WatchLimitsResponse_FieldTerminalPath{selector: WatchLimitsResponse_FieldPathSelectorSnapshotSize}, nil
		case "is_soft_reset", "isSoftReset", "is-soft-reset":
			return &WatchLimitsResponse_FieldTerminalPath{selector: WatchLimitsResponse_FieldPathSelectorIsSoftReset}, nil
		case "is_hard_reset", "isHardReset", "is-hard-reset":
			return &WatchLimitsResponse_FieldTerminalPath{selector: WatchLimitsResponse_FieldPathSelectorIsHardReset}, nil
		}
	} else {
		switch fp[0] {
		case "page_token_change", "pageTokenChange", "page-token-change":
			if subpath, err := BuildWatchLimitsResponsePageTokenChange_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &WatchLimitsResponse_FieldSubPath{selector: WatchLimitsResponse_FieldPathSelectorPageTokenChange, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitsResponse", fp)
}

func ParseWatchLimitsResponse_FieldPath(rawField string) (WatchLimitsResponse_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitsResponse_FieldPath(fp)
}

func MustParseWatchLimitsResponse_FieldPath(rawField string) WatchLimitsResponse_FieldPath {
	fp, err := ParseWatchLimitsResponse_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitsResponse_FieldTerminalPath struct {
	selector WatchLimitsResponse_FieldPathSelector
}

var _ WatchLimitsResponse_FieldPath = (*WatchLimitsResponse_FieldTerminalPath)(nil)

func (fp *WatchLimitsResponse_FieldTerminalPath) Selector() WatchLimitsResponse_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitsResponse_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitsResponse_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitsResponse
func (fp *WatchLimitsResponse_FieldTerminalPath) Get(source *WatchLimitsResponse) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitsResponse_FieldPathSelectorLimitChanges:
			for _, value := range source.GetLimitChanges() {
				values = append(values, value)
			}
		case WatchLimitsResponse_FieldPathSelectorIsCurrent:
			values = append(values, source.IsCurrent)
		case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
			if source.PageTokenChange != nil {
				values = append(values, source.PageTokenChange)
			}
		case WatchLimitsResponse_FieldPathSelectorResumeToken:
			values = append(values, source.ResumeToken)
		case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
			values = append(values, source.SnapshotSize)
		case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
			values = append(values, source.IsSoftReset)
		case WatchLimitsResponse_FieldPathSelectorIsHardReset:
			values = append(values, source.IsHardReset)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitsResponse_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitsResponse))
}

// GetSingle returns value pointed by specific field of from source WatchLimitsResponse
func (fp *WatchLimitsResponse_FieldTerminalPath) GetSingle(source *WatchLimitsResponse) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		res := source.GetLimitChanges()
		return res, res != nil
	case WatchLimitsResponse_FieldPathSelectorIsCurrent:
		return source.GetIsCurrent(), source != nil
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		res := source.GetPageTokenChange()
		return res, res != nil
	case WatchLimitsResponse_FieldPathSelectorResumeToken:
		return source.GetResumeToken(), source != nil
	case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
		return source.GetSnapshotSize(), source != nil
	case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
		return source.GetIsSoftReset(), source != nil
	case WatchLimitsResponse_FieldPathSelectorIsHardReset:
		return source.GetIsHardReset(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitsResponse_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitsResponse))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitsResponse_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		return ([]*limit.LimitChange)(nil)
	case WatchLimitsResponse_FieldPathSelectorIsCurrent:
		return false
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		return (*WatchLimitsResponse_PageTokenChange)(nil)
	case WatchLimitsResponse_FieldPathSelectorResumeToken:
		return ""
	case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
		return int64(0)
	case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
		return false
	case WatchLimitsResponse_FieldPathSelectorIsHardReset:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitsResponse_FieldTerminalPath) ClearValue(item *WatchLimitsResponse) {
	if item != nil {
		switch fp.selector {
		case WatchLimitsResponse_FieldPathSelectorLimitChanges:
			item.LimitChanges = nil
		case WatchLimitsResponse_FieldPathSelectorIsCurrent:
			item.IsCurrent = false
		case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
			item.PageTokenChange = nil
		case WatchLimitsResponse_FieldPathSelectorResumeToken:
			item.ResumeToken = ""
		case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
			item.SnapshotSize = int64(0)
		case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
			item.IsSoftReset = false
		case WatchLimitsResponse_FieldPathSelectorIsHardReset:
			item.IsHardReset = false
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitsResponse_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitsResponse_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitsResponse_FieldPathSelectorLimitChanges ||
		fp.selector == WatchLimitsResponse_FieldPathSelectorIsCurrent ||
		fp.selector == WatchLimitsResponse_FieldPathSelectorResumeToken ||
		fp.selector == WatchLimitsResponse_FieldPathSelectorSnapshotSize ||
		fp.selector == WatchLimitsResponse_FieldPathSelectorIsSoftReset ||
		fp.selector == WatchLimitsResponse_FieldPathSelectorIsHardReset
}

func (fp *WatchLimitsResponse_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitsResponse_FieldTerminalPath) WithIValue(value interface{}) WatchLimitsResponse_FieldPathValue {
	switch fp.selector {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		return &WatchLimitsResponse_FieldTerminalPathValue{WatchLimitsResponse_FieldTerminalPath: *fp, value: value.([]*limit.LimitChange)}
	case WatchLimitsResponse_FieldPathSelectorIsCurrent:
		return &WatchLimitsResponse_FieldTerminalPathValue{WatchLimitsResponse_FieldTerminalPath: *fp, value: value.(bool)}
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		return &WatchLimitsResponse_FieldTerminalPathValue{WatchLimitsResponse_FieldTerminalPath: *fp, value: value.(*WatchLimitsResponse_PageTokenChange)}
	case WatchLimitsResponse_FieldPathSelectorResumeToken:
		return &WatchLimitsResponse_FieldTerminalPathValue{WatchLimitsResponse_FieldTerminalPath: *fp, value: value.(string)}
	case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
		return &WatchLimitsResponse_FieldTerminalPathValue{WatchLimitsResponse_FieldTerminalPath: *fp, value: value.(int64)}
	case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
		return &WatchLimitsResponse_FieldTerminalPathValue{WatchLimitsResponse_FieldTerminalPath: *fp, value: value.(bool)}
	case WatchLimitsResponse_FieldPathSelectorIsHardReset:
		return &WatchLimitsResponse_FieldTerminalPathValue{WatchLimitsResponse_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitsResponse_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitsResponse_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitsResponse_FieldPathArrayOfValues {
	fpaov := &WatchLimitsResponse_FieldTerminalPathArrayOfValues{WatchLimitsResponse_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		return &WatchLimitsResponse_FieldTerminalPathArrayOfValues{WatchLimitsResponse_FieldTerminalPath: *fp, values: values.([][]*limit.LimitChange)}
	case WatchLimitsResponse_FieldPathSelectorIsCurrent:
		return &WatchLimitsResponse_FieldTerminalPathArrayOfValues{WatchLimitsResponse_FieldTerminalPath: *fp, values: values.([]bool)}
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		return &WatchLimitsResponse_FieldTerminalPathArrayOfValues{WatchLimitsResponse_FieldTerminalPath: *fp, values: values.([]*WatchLimitsResponse_PageTokenChange)}
	case WatchLimitsResponse_FieldPathSelectorResumeToken:
		return &WatchLimitsResponse_FieldTerminalPathArrayOfValues{WatchLimitsResponse_FieldTerminalPath: *fp, values: values.([]string)}
	case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
		return &WatchLimitsResponse_FieldTerminalPathArrayOfValues{WatchLimitsResponse_FieldTerminalPath: *fp, values: values.([]int64)}
	case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
		return &WatchLimitsResponse_FieldTerminalPathArrayOfValues{WatchLimitsResponse_FieldTerminalPath: *fp, values: values.([]bool)}
	case WatchLimitsResponse_FieldPathSelectorIsHardReset:
		return &WatchLimitsResponse_FieldTerminalPathArrayOfValues{WatchLimitsResponse_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitsResponse_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitsResponse_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitsResponse_FieldPathArrayItemValue {
	switch fp.selector {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		return &WatchLimitsResponse_FieldTerminalPathArrayItemValue{WatchLimitsResponse_FieldTerminalPath: *fp, value: value.(*limit.LimitChange)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fp.selector))
	}
}

func (fp *WatchLimitsResponse_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type WatchLimitsResponse_FieldSubPath struct {
	selector WatchLimitsResponse_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ WatchLimitsResponse_FieldPath = (*WatchLimitsResponse_FieldSubPath)(nil)

func (fps *WatchLimitsResponse_FieldSubPath) Selector() WatchLimitsResponse_FieldPathSelector {
	return fps.selector
}
func (fps *WatchLimitsResponse_FieldSubPath) AsPageTokenChangeSubPath() (WatchLimitsResponsePageTokenChange_FieldPath, bool) {
	res, ok := fps.subPath.(WatchLimitsResponsePageTokenChange_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *WatchLimitsResponse_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *WatchLimitsResponse_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source WatchLimitsResponse
func (fps *WatchLimitsResponse_FieldSubPath) Get(source *WatchLimitsResponse) (values []interface{}) {
	if asPageTokenChangeFieldPath, ok := fps.AsPageTokenChangeSubPath(); ok {
		values = append(values, asPageTokenChangeFieldPath.Get(source.GetPageTokenChange())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fps.selector))
	}
	return
}

func (fps *WatchLimitsResponse_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*WatchLimitsResponse))
}

// GetSingle returns value of selected field from source WatchLimitsResponse
func (fps *WatchLimitsResponse_FieldSubPath) GetSingle(source *WatchLimitsResponse) (interface{}, bool) {
	switch fps.selector {
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		if source.GetPageTokenChange() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetPageTokenChange())
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fps.selector))
	}
}

func (fps *WatchLimitsResponse_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*WatchLimitsResponse))
}

// GetDefault returns a default value of the field type
func (fps *WatchLimitsResponse_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *WatchLimitsResponse_FieldSubPath) ClearValue(item *WatchLimitsResponse) {
	if item != nil {
		switch fps.selector {
		case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
			fps.subPath.ClearValueRaw(item.PageTokenChange)
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fps.selector))
		}
	}
}

func (fps *WatchLimitsResponse_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*WatchLimitsResponse))
}

// IsLeaf - whether field path is holds simple value
func (fps *WatchLimitsResponse_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *WatchLimitsResponse_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&WatchLimitsResponse_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *WatchLimitsResponse_FieldSubPath) WithIValue(value interface{}) WatchLimitsResponse_FieldPathValue {
	return &WatchLimitsResponse_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *WatchLimitsResponse_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *WatchLimitsResponse_FieldSubPath) WithIArrayOfValues(values interface{}) WatchLimitsResponse_FieldPathArrayOfValues {
	return &WatchLimitsResponse_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *WatchLimitsResponse_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *WatchLimitsResponse_FieldSubPath) WithIArrayItemValue(value interface{}) WatchLimitsResponse_FieldPathArrayItemValue {
	return &WatchLimitsResponse_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *WatchLimitsResponse_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// WatchLimitsResponse_FieldPathValue allows storing values for WatchLimitsResponse fields according to their type
type WatchLimitsResponse_FieldPathValue interface {
	WatchLimitsResponse_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitsResponse)
	CompareWith(*WatchLimitsResponse) (cmp int, comparable bool)
}

func ParseWatchLimitsResponse_FieldPathValue(pathStr, valueStr string) (WatchLimitsResponse_FieldPathValue, error) {
	fp, err := ParseWatchLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitsResponse field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitsResponse_FieldPathValue), nil
}

func MustParseWatchLimitsResponse_FieldPathValue(pathStr, valueStr string) WatchLimitsResponse_FieldPathValue {
	fpv, err := ParseWatchLimitsResponse_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitsResponse_FieldTerminalPathValue struct {
	WatchLimitsResponse_FieldTerminalPath
	value interface{}
}

var _ WatchLimitsResponse_FieldPathValue = (*WatchLimitsResponse_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'WatchLimitsResponse' as interface{}
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) AsLimitChangesValue() ([]*limit.LimitChange, bool) {
	res, ok := fpv.value.([]*limit.LimitChange)
	return res, ok
}
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) AsIsCurrentValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) AsPageTokenChangeValue() (*WatchLimitsResponse_PageTokenChange, bool) {
	res, ok := fpv.value.(*WatchLimitsResponse_PageTokenChange)
	return res, ok
}
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) AsResumeTokenValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) AsSnapshotSizeValue() (int64, bool) {
	res, ok := fpv.value.(int64)
	return res, ok
}
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) AsIsSoftResetValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) AsIsHardResetValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object WatchLimitsResponse
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) SetTo(target **WatchLimitsResponse) {
	if *target == nil {
		*target = new(WatchLimitsResponse)
	}
	switch fpv.selector {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		(*target).LimitChanges = fpv.value.([]*limit.LimitChange)
	case WatchLimitsResponse_FieldPathSelectorIsCurrent:
		(*target).IsCurrent = fpv.value.(bool)
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		(*target).PageTokenChange = fpv.value.(*WatchLimitsResponse_PageTokenChange)
	case WatchLimitsResponse_FieldPathSelectorResumeToken:
		(*target).ResumeToken = fpv.value.(string)
	case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
		(*target).SnapshotSize = fpv.value.(int64)
	case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
		(*target).IsSoftReset = fpv.value.(bool)
	case WatchLimitsResponse_FieldPathSelectorIsHardReset:
		(*target).IsHardReset = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fpv.selector))
	}
}

func (fpv *WatchLimitsResponse_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitsResponse)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitsResponse_FieldTerminalPathValue' with the value under path in 'WatchLimitsResponse'.
func (fpv *WatchLimitsResponse_FieldTerminalPathValue) CompareWith(source *WatchLimitsResponse) (int, bool) {
	switch fpv.selector {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		return 0, false
	case WatchLimitsResponse_FieldPathSelectorIsCurrent:
		leftValue := fpv.value.(bool)
		rightValue := source.GetIsCurrent()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		return 0, false
	case WatchLimitsResponse_FieldPathSelectorResumeToken:
		leftValue := fpv.value.(string)
		rightValue := source.GetResumeToken()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
		leftValue := fpv.value.(int64)
		rightValue := source.GetSnapshotSize()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
		leftValue := fpv.value.(bool)
		rightValue := source.GetIsSoftReset()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case WatchLimitsResponse_FieldPathSelectorIsHardReset:
		leftValue := fpv.value.(bool)
		rightValue := source.GetIsHardReset()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fpv.selector))
	}
}

func (fpv *WatchLimitsResponse_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitsResponse))
}

type WatchLimitsResponse_FieldSubPathValue struct {
	WatchLimitsResponse_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ WatchLimitsResponse_FieldPathValue = (*WatchLimitsResponse_FieldSubPathValue)(nil)

func (fpvs *WatchLimitsResponse_FieldSubPathValue) AsPageTokenChangePathValue() (WatchLimitsResponsePageTokenChange_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(WatchLimitsResponsePageTokenChange_FieldPathValue)
	return res, ok
}

func (fpvs *WatchLimitsResponse_FieldSubPathValue) SetTo(target **WatchLimitsResponse) {
	if *target == nil {
		*target = new(WatchLimitsResponse)
	}
	switch fpvs.Selector() {
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		fpvs.subPathValue.(WatchLimitsResponsePageTokenChange_FieldPathValue).SetTo(&(*target).PageTokenChange)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *WatchLimitsResponse_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitsResponse)
	fpvs.SetTo(&typedObject)
}

func (fpvs *WatchLimitsResponse_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *WatchLimitsResponse_FieldSubPathValue) CompareWith(source *WatchLimitsResponse) (int, bool) {
	switch fpvs.Selector() {
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		return fpvs.subPathValue.(WatchLimitsResponsePageTokenChange_FieldPathValue).CompareWith(source.GetPageTokenChange())
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fpvs.Selector()))
	}
}

func (fpvs *WatchLimitsResponse_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*WatchLimitsResponse))
}

// WatchLimitsResponse_FieldPathArrayItemValue allows storing single item in Path-specific values for WatchLimitsResponse according to their type
// Present only for array (repeated) types.
type WatchLimitsResponse_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitsResponse_FieldPath
	ContainsValue(*WatchLimitsResponse) bool
}

// ParseWatchLimitsResponse_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitsResponse_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitsResponse field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitsResponse_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitsResponse_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitsResponse_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitsResponse_FieldTerminalPathArrayItemValue struct {
	WatchLimitsResponse_FieldTerminalPath
	value interface{}
}

var _ WatchLimitsResponse_FieldPathArrayItemValue = (*WatchLimitsResponse_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitsResponse as interface{}
func (fpaiv *WatchLimitsResponse_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *WatchLimitsResponse_FieldTerminalPathArrayItemValue) AsLimitChangesItemValue() (*limit.LimitChange, bool) {
	res, ok := fpaiv.value.(*limit.LimitChange)
	return res, ok
}

func (fpaiv *WatchLimitsResponse_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitsResponse) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitsResponse_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitsResponse))
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitsResponse'
func (fpaiv *WatchLimitsResponse_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitsResponse) bool {
	slice := fpaiv.WatchLimitsResponse_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type WatchLimitsResponse_FieldSubPathArrayItemValue struct {
	WatchLimitsResponse_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *WatchLimitsResponse_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *WatchLimitsResponse_FieldSubPathArrayItemValue) AsPageTokenChangePathItemValue() (WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'WatchLimitsResponse'
func (fpaivs *WatchLimitsResponse_FieldSubPathArrayItemValue) ContainsValue(source *WatchLimitsResponse) bool {
	switch fpaivs.Selector() {
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		return fpaivs.subPathItemValue.(WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue).ContainsValue(source.GetPageTokenChange())
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse: %d", fpaivs.Selector()))
	}
}

// WatchLimitsResponse_FieldPathArrayOfValues allows storing slice of values for WatchLimitsResponse fields according to their type
type WatchLimitsResponse_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitsResponse_FieldPath
}

func ParseWatchLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitsResponse_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitsResponse_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing WatchLimitsResponse field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitsResponse_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitsResponse_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitsResponse_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitsResponse_FieldTerminalPathArrayOfValues struct {
	WatchLimitsResponse_FieldTerminalPath
	values interface{}
}

var _ WatchLimitsResponse_FieldPathArrayOfValues = (*WatchLimitsResponse_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitsResponse_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitsResponse_FieldPathSelectorLimitChanges:
		for _, v := range fpaov.values.([][]*limit.LimitChange) {
			values = append(values, v)
		}
	case WatchLimitsResponse_FieldPathSelectorIsCurrent:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case WatchLimitsResponse_FieldPathSelectorPageTokenChange:
		for _, v := range fpaov.values.([]*WatchLimitsResponse_PageTokenChange) {
			values = append(values, v)
		}
	case WatchLimitsResponse_FieldPathSelectorResumeToken:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case WatchLimitsResponse_FieldPathSelectorSnapshotSize:
		for _, v := range fpaov.values.([]int64) {
			values = append(values, v)
		}
	case WatchLimitsResponse_FieldPathSelectorIsSoftReset:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case WatchLimitsResponse_FieldPathSelectorIsHardReset:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitsResponse_FieldTerminalPathArrayOfValues) AsLimitChangesArrayOfValues() ([][]*limit.LimitChange, bool) {
	res, ok := fpaov.values.([][]*limit.LimitChange)
	return res, ok
}
func (fpaov *WatchLimitsResponse_FieldTerminalPathArrayOfValues) AsIsCurrentArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *WatchLimitsResponse_FieldTerminalPathArrayOfValues) AsPageTokenChangeArrayOfValues() ([]*WatchLimitsResponse_PageTokenChange, bool) {
	res, ok := fpaov.values.([]*WatchLimitsResponse_PageTokenChange)
	return res, ok
}
func (fpaov *WatchLimitsResponse_FieldTerminalPathArrayOfValues) AsResumeTokenArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *WatchLimitsResponse_FieldTerminalPathArrayOfValues) AsSnapshotSizeArrayOfValues() ([]int64, bool) {
	res, ok := fpaov.values.([]int64)
	return res, ok
}
func (fpaov *WatchLimitsResponse_FieldTerminalPathArrayOfValues) AsIsSoftResetArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *WatchLimitsResponse_FieldTerminalPathArrayOfValues) AsIsHardResetArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

type WatchLimitsResponse_FieldSubPathArrayOfValues struct {
	WatchLimitsResponse_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ WatchLimitsResponse_FieldPathArrayOfValues = (*WatchLimitsResponse_FieldSubPathArrayOfValues)(nil)

func (fpsaov *WatchLimitsResponse_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *WatchLimitsResponse_FieldSubPathArrayOfValues) AsPageTokenChangePathArrayOfValues() (WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type WatchLimitsResponsePageTokenChange_FieldPath interface {
	gotenobject.FieldPath
	Selector() WatchLimitsResponsePageTokenChange_FieldPathSelector
	Get(source *WatchLimitsResponse_PageTokenChange) []interface{}
	GetSingle(source *WatchLimitsResponse_PageTokenChange) (interface{}, bool)
	ClearValue(item *WatchLimitsResponse_PageTokenChange)

	// Those methods build corresponding WatchLimitsResponsePageTokenChange_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) WatchLimitsResponsePageTokenChange_FieldPathValue
	WithIArrayOfValues(values interface{}) WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue
}

type WatchLimitsResponsePageTokenChange_FieldPathSelector int32

const (
	WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken WatchLimitsResponsePageTokenChange_FieldPathSelector = 0
	WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken WatchLimitsResponsePageTokenChange_FieldPathSelector = 1
)

func (s WatchLimitsResponsePageTokenChange_FieldPathSelector) String() string {
	switch s {
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return "prev_page_token"
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return "next_page_token"
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", s))
	}
}

func BuildWatchLimitsResponsePageTokenChange_FieldPath(fp gotenobject.RawFieldPath) (WatchLimitsResponsePageTokenChange_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object WatchLimitsResponse_PageTokenChange")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "prev_page_token", "prevPageToken", "prev-page-token":
			return &WatchLimitsResponsePageTokenChange_FieldTerminalPath{selector: WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken}, nil
		case "next_page_token", "nextPageToken", "next-page-token":
			return &WatchLimitsResponsePageTokenChange_FieldTerminalPath{selector: WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object WatchLimitsResponse_PageTokenChange", fp)
}

func ParseWatchLimitsResponsePageTokenChange_FieldPath(rawField string) (WatchLimitsResponsePageTokenChange_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildWatchLimitsResponsePageTokenChange_FieldPath(fp)
}

func MustParseWatchLimitsResponsePageTokenChange_FieldPath(rawField string) WatchLimitsResponsePageTokenChange_FieldPath {
	fp, err := ParseWatchLimitsResponsePageTokenChange_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type WatchLimitsResponsePageTokenChange_FieldTerminalPath struct {
	selector WatchLimitsResponsePageTokenChange_FieldPathSelector
}

var _ WatchLimitsResponsePageTokenChange_FieldPath = (*WatchLimitsResponsePageTokenChange_FieldTerminalPath)(nil)

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) Selector() WatchLimitsResponsePageTokenChange_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source WatchLimitsResponse_PageTokenChange
func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) Get(source *WatchLimitsResponse_PageTokenChange) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
			if source.PrevPageToken != nil {
				values = append(values, source.PrevPageToken)
			}
		case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
			if source.NextPageToken != nil {
				values = append(values, source.NextPageToken)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fp.selector))
		}
	}
	return
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*WatchLimitsResponse_PageTokenChange))
}

// GetSingle returns value pointed by specific field of from source WatchLimitsResponse_PageTokenChange
func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) GetSingle(source *WatchLimitsResponse_PageTokenChange) (interface{}, bool) {
	switch fp.selector {
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		res := source.GetPrevPageToken()
		return res, res != nil
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		res := source.GetNextPageToken()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fp.selector))
	}
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*WatchLimitsResponse_PageTokenChange))
}

// GetDefault returns a default value of the field type
func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return (*limit.PagerCursor)(nil)
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return (*limit.PagerCursor)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fp.selector))
	}
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) ClearValue(item *WatchLimitsResponse_PageTokenChange) {
	if item != nil {
		switch fp.selector {
		case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
			item.PrevPageToken = nil
		case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
			item.NextPageToken = nil
		default:
			panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fp.selector))
		}
	}
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*WatchLimitsResponse_PageTokenChange))
}

// IsLeaf - whether field path is holds simple value
func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken ||
		fp.selector == WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) WithIValue(value interface{}) WatchLimitsResponsePageTokenChange_FieldPathValue {
	switch fp.selector {
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return &WatchLimitsResponsePageTokenChange_FieldTerminalPathValue{WatchLimitsResponsePageTokenChange_FieldTerminalPath: *fp, value: value.(*limit.PagerCursor)}
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return &WatchLimitsResponsePageTokenChange_FieldTerminalPathValue{WatchLimitsResponsePageTokenChange_FieldTerminalPath: *fp, value: value.(*limit.PagerCursor)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fp.selector))
	}
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) WithIArrayOfValues(values interface{}) WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues {
	fpaov := &WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayOfValues{WatchLimitsResponsePageTokenChange_FieldTerminalPath: *fp}
	switch fp.selector {
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return &WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayOfValues{WatchLimitsResponsePageTokenChange_FieldTerminalPath: *fp, values: values.([]*limit.PagerCursor)}
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return &WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayOfValues{WatchLimitsResponsePageTokenChange_FieldTerminalPath: *fp, values: values.([]*limit.PagerCursor)}
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fp.selector))
	}
	return fpaov
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) WithIArrayItemValue(value interface{}) WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fp.selector))
	}
}

func (fp *WatchLimitsResponsePageTokenChange_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// WatchLimitsResponsePageTokenChange_FieldPathValue allows storing values for PageTokenChange fields according to their type
type WatchLimitsResponsePageTokenChange_FieldPathValue interface {
	WatchLimitsResponsePageTokenChange_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **WatchLimitsResponse_PageTokenChange)
	CompareWith(*WatchLimitsResponse_PageTokenChange) (cmp int, comparable bool)
}

func ParseWatchLimitsResponsePageTokenChange_FieldPathValue(pathStr, valueStr string) (WatchLimitsResponsePageTokenChange_FieldPathValue, error) {
	fp, err := ParseWatchLimitsResponsePageTokenChange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PageTokenChange field path value from %s: %v", valueStr, err)
	}
	return fpv.(WatchLimitsResponsePageTokenChange_FieldPathValue), nil
}

func MustParseWatchLimitsResponsePageTokenChange_FieldPathValue(pathStr, valueStr string) WatchLimitsResponsePageTokenChange_FieldPathValue {
	fpv, err := ParseWatchLimitsResponsePageTokenChange_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type WatchLimitsResponsePageTokenChange_FieldTerminalPathValue struct {
	WatchLimitsResponsePageTokenChange_FieldTerminalPath
	value interface{}
}

var _ WatchLimitsResponsePageTokenChange_FieldPathValue = (*WatchLimitsResponsePageTokenChange_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'PageTokenChange' as interface{}
func (fpv *WatchLimitsResponsePageTokenChange_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *WatchLimitsResponsePageTokenChange_FieldTerminalPathValue) AsPrevPageTokenValue() (*limit.PagerCursor, bool) {
	res, ok := fpv.value.(*limit.PagerCursor)
	return res, ok
}
func (fpv *WatchLimitsResponsePageTokenChange_FieldTerminalPathValue) AsNextPageTokenValue() (*limit.PagerCursor, bool) {
	res, ok := fpv.value.(*limit.PagerCursor)
	return res, ok
}

// SetTo stores value for selected field for object PageTokenChange
func (fpv *WatchLimitsResponsePageTokenChange_FieldTerminalPathValue) SetTo(target **WatchLimitsResponse_PageTokenChange) {
	if *target == nil {
		*target = new(WatchLimitsResponse_PageTokenChange)
	}
	switch fpv.selector {
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		(*target).PrevPageToken = fpv.value.(*limit.PagerCursor)
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		(*target).NextPageToken = fpv.value.(*limit.PagerCursor)
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fpv.selector))
	}
}

func (fpv *WatchLimitsResponsePageTokenChange_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*WatchLimitsResponse_PageTokenChange)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'WatchLimitsResponsePageTokenChange_FieldTerminalPathValue' with the value under path in 'WatchLimitsResponse_PageTokenChange'.
func (fpv *WatchLimitsResponsePageTokenChange_FieldTerminalPathValue) CompareWith(source *WatchLimitsResponse_PageTokenChange) (int, bool) {
	switch fpv.selector {
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		return 0, false
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for WatchLimitsResponse_PageTokenChange: %d", fpv.selector))
	}
}

func (fpv *WatchLimitsResponsePageTokenChange_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*WatchLimitsResponse_PageTokenChange))
}

// WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue allows storing single item in Path-specific values for PageTokenChange according to their type
// Present only for array (repeated) types.
type WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	WatchLimitsResponsePageTokenChange_FieldPath
	ContainsValue(*WatchLimitsResponse_PageTokenChange) bool
}

// ParseWatchLimitsResponsePageTokenChange_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseWatchLimitsResponsePageTokenChange_FieldPathArrayItemValue(pathStr, valueStr string) (WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue, error) {
	fp, err := ParseWatchLimitsResponsePageTokenChange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PageTokenChange field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue), nil
}

func MustParseWatchLimitsResponsePageTokenChange_FieldPathArrayItemValue(pathStr, valueStr string) WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue {
	fpaiv, err := ParseWatchLimitsResponsePageTokenChange_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayItemValue struct {
	WatchLimitsResponsePageTokenChange_FieldTerminalPath
	value interface{}
}

var _ WatchLimitsResponsePageTokenChange_FieldPathArrayItemValue = (*WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object WatchLimitsResponse_PageTokenChange as interface{}
func (fpaiv *WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayItemValue) GetSingle(source *WatchLimitsResponse_PageTokenChange) (interface{}, bool) {
	return nil, false
}

func (fpaiv *WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*WatchLimitsResponse_PageTokenChange))
}

// Contains returns a boolean indicating if value that is being held is present in given 'PageTokenChange'
func (fpaiv *WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayItemValue) ContainsValue(source *WatchLimitsResponse_PageTokenChange) bool {
	slice := fpaiv.WatchLimitsResponsePageTokenChange_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues allows storing slice of values for PageTokenChange fields according to their type
type WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	WatchLimitsResponsePageTokenChange_FieldPath
}

func ParseWatchLimitsResponsePageTokenChange_FieldPathArrayOfValues(pathStr, valuesStr string) (WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues, error) {
	fp, err := ParseWatchLimitsResponsePageTokenChange_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing PageTokenChange field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues), nil
}

func MustParseWatchLimitsResponsePageTokenChange_FieldPathArrayOfValues(pathStr, valuesStr string) WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues {
	fpaov, err := ParseWatchLimitsResponsePageTokenChange_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayOfValues struct {
	WatchLimitsResponsePageTokenChange_FieldTerminalPath
	values interface{}
}

var _ WatchLimitsResponsePageTokenChange_FieldPathArrayOfValues = (*WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
		for _, v := range fpaov.values.([]*limit.PagerCursor) {
			values = append(values, v)
		}
	case WatchLimitsResponsePageTokenChange_FieldPathSelectorNextPageToken:
		for _, v := range fpaov.values.([]*limit.PagerCursor) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayOfValues) AsPrevPageTokenArrayOfValues() ([]*limit.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit.PagerCursor)
	return res, ok
}
func (fpaov *WatchLimitsResponsePageTokenChange_FieldTerminalPathArrayOfValues) AsNextPageTokenArrayOfValues() ([]*limit.PagerCursor, bool) {
	res, ok := fpaov.values.([]*limit.PagerCursor)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type UpdateLimitRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() UpdateLimitRequest_FieldPathSelector
	Get(source *UpdateLimitRequest) []interface{}
	GetSingle(source *UpdateLimitRequest) (interface{}, bool)
	ClearValue(item *UpdateLimitRequest)

	// Those methods build corresponding UpdateLimitRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) UpdateLimitRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) UpdateLimitRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) UpdateLimitRequest_FieldPathArrayItemValue
}

type UpdateLimitRequest_FieldPathSelector int32

const (
	UpdateLimitRequest_FieldPathSelectorLimit      UpdateLimitRequest_FieldPathSelector = 0
	UpdateLimitRequest_FieldPathSelectorUpdateMask UpdateLimitRequest_FieldPathSelector = 1
	UpdateLimitRequest_FieldPathSelectorCas        UpdateLimitRequest_FieldPathSelector = 2
)

func (s UpdateLimitRequest_FieldPathSelector) String() string {
	switch s {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		return "limit"
	case UpdateLimitRequest_FieldPathSelectorUpdateMask:
		return "update_mask"
	case UpdateLimitRequest_FieldPathSelectorCas:
		return "cas"
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", s))
	}
}

func BuildUpdateLimitRequest_FieldPath(fp gotenobject.RawFieldPath) (UpdateLimitRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object UpdateLimitRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "limit":
			return &UpdateLimitRequest_FieldTerminalPath{selector: UpdateLimitRequest_FieldPathSelectorLimit}, nil
		case "update_mask", "updateMask", "update-mask":
			return &UpdateLimitRequest_FieldTerminalPath{selector: UpdateLimitRequest_FieldPathSelectorUpdateMask}, nil
		case "cas":
			return &UpdateLimitRequest_FieldTerminalPath{selector: UpdateLimitRequest_FieldPathSelectorCas}, nil
		}
	} else {
		switch fp[0] {
		case "limit":
			if subpath, err := limit.BuildLimit_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &UpdateLimitRequest_FieldSubPath{selector: UpdateLimitRequest_FieldPathSelectorLimit, subPath: subpath}, nil
			}
		case "cas":
			if subpath, err := BuildUpdateLimitRequestCAS_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &UpdateLimitRequest_FieldSubPath{selector: UpdateLimitRequest_FieldPathSelectorCas, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object UpdateLimitRequest", fp)
}

func ParseUpdateLimitRequest_FieldPath(rawField string) (UpdateLimitRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildUpdateLimitRequest_FieldPath(fp)
}

func MustParseUpdateLimitRequest_FieldPath(rawField string) UpdateLimitRequest_FieldPath {
	fp, err := ParseUpdateLimitRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type UpdateLimitRequest_FieldTerminalPath struct {
	selector UpdateLimitRequest_FieldPathSelector
}

var _ UpdateLimitRequest_FieldPath = (*UpdateLimitRequest_FieldTerminalPath)(nil)

func (fp *UpdateLimitRequest_FieldTerminalPath) Selector() UpdateLimitRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *UpdateLimitRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *UpdateLimitRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source UpdateLimitRequest
func (fp *UpdateLimitRequest_FieldTerminalPath) Get(source *UpdateLimitRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case UpdateLimitRequest_FieldPathSelectorLimit:
			if source.Limit != nil {
				values = append(values, source.Limit)
			}
		case UpdateLimitRequest_FieldPathSelectorUpdateMask:
			if source.UpdateMask != nil {
				values = append(values, source.UpdateMask)
			}
		case UpdateLimitRequest_FieldPathSelectorCas:
			if source.Cas != nil {
				values = append(values, source.Cas)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *UpdateLimitRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*UpdateLimitRequest))
}

// GetSingle returns value pointed by specific field of from source UpdateLimitRequest
func (fp *UpdateLimitRequest_FieldTerminalPath) GetSingle(source *UpdateLimitRequest) (interface{}, bool) {
	switch fp.selector {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		res := source.GetLimit()
		return res, res != nil
	case UpdateLimitRequest_FieldPathSelectorUpdateMask:
		res := source.GetUpdateMask()
		return res, res != nil
	case UpdateLimitRequest_FieldPathSelectorCas:
		res := source.GetCas()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fp.selector))
	}
}

func (fp *UpdateLimitRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*UpdateLimitRequest))
}

// GetDefault returns a default value of the field type
func (fp *UpdateLimitRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		return (*limit.Limit)(nil)
	case UpdateLimitRequest_FieldPathSelectorUpdateMask:
		return (*limit.Limit_FieldMask)(nil)
	case UpdateLimitRequest_FieldPathSelectorCas:
		return (*UpdateLimitRequest_CAS)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fp.selector))
	}
}

func (fp *UpdateLimitRequest_FieldTerminalPath) ClearValue(item *UpdateLimitRequest) {
	if item != nil {
		switch fp.selector {
		case UpdateLimitRequest_FieldPathSelectorLimit:
			item.Limit = nil
		case UpdateLimitRequest_FieldPathSelectorUpdateMask:
			item.UpdateMask = nil
		case UpdateLimitRequest_FieldPathSelectorCas:
			item.Cas = nil
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fp.selector))
		}
	}
}

func (fp *UpdateLimitRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*UpdateLimitRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *UpdateLimitRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == UpdateLimitRequest_FieldPathSelectorUpdateMask
}

func (fp *UpdateLimitRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *UpdateLimitRequest_FieldTerminalPath) WithIValue(value interface{}) UpdateLimitRequest_FieldPathValue {
	switch fp.selector {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		return &UpdateLimitRequest_FieldTerminalPathValue{UpdateLimitRequest_FieldTerminalPath: *fp, value: value.(*limit.Limit)}
	case UpdateLimitRequest_FieldPathSelectorUpdateMask:
		return &UpdateLimitRequest_FieldTerminalPathValue{UpdateLimitRequest_FieldTerminalPath: *fp, value: value.(*limit.Limit_FieldMask)}
	case UpdateLimitRequest_FieldPathSelectorCas:
		return &UpdateLimitRequest_FieldTerminalPathValue{UpdateLimitRequest_FieldTerminalPath: *fp, value: value.(*UpdateLimitRequest_CAS)}
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fp.selector))
	}
}

func (fp *UpdateLimitRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *UpdateLimitRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) UpdateLimitRequest_FieldPathArrayOfValues {
	fpaov := &UpdateLimitRequest_FieldTerminalPathArrayOfValues{UpdateLimitRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		return &UpdateLimitRequest_FieldTerminalPathArrayOfValues{UpdateLimitRequest_FieldTerminalPath: *fp, values: values.([]*limit.Limit)}
	case UpdateLimitRequest_FieldPathSelectorUpdateMask:
		return &UpdateLimitRequest_FieldTerminalPathArrayOfValues{UpdateLimitRequest_FieldTerminalPath: *fp, values: values.([]*limit.Limit_FieldMask)}
	case UpdateLimitRequest_FieldPathSelectorCas:
		return &UpdateLimitRequest_FieldTerminalPathArrayOfValues{UpdateLimitRequest_FieldTerminalPath: *fp, values: values.([]*UpdateLimitRequest_CAS)}
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *UpdateLimitRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *UpdateLimitRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) UpdateLimitRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fp.selector))
	}
}

func (fp *UpdateLimitRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type UpdateLimitRequest_FieldSubPath struct {
	selector UpdateLimitRequest_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ UpdateLimitRequest_FieldPath = (*UpdateLimitRequest_FieldSubPath)(nil)

func (fps *UpdateLimitRequest_FieldSubPath) Selector() UpdateLimitRequest_FieldPathSelector {
	return fps.selector
}
func (fps *UpdateLimitRequest_FieldSubPath) AsLimitSubPath() (limit.Limit_FieldPath, bool) {
	res, ok := fps.subPath.(limit.Limit_FieldPath)
	return res, ok
}
func (fps *UpdateLimitRequest_FieldSubPath) AsCasSubPath() (UpdateLimitRequestCAS_FieldPath, bool) {
	res, ok := fps.subPath.(UpdateLimitRequestCAS_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *UpdateLimitRequest_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *UpdateLimitRequest_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source UpdateLimitRequest
func (fps *UpdateLimitRequest_FieldSubPath) Get(source *UpdateLimitRequest) (values []interface{}) {
	if asLimitFieldPath, ok := fps.AsLimitSubPath(); ok {
		values = append(values, asLimitFieldPath.Get(source.GetLimit())...)
	} else if asCASFieldPath, ok := fps.AsCasSubPath(); ok {
		values = append(values, asCASFieldPath.Get(source.GetCas())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fps.selector))
	}
	return
}

func (fps *UpdateLimitRequest_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*UpdateLimitRequest))
}

// GetSingle returns value of selected field from source UpdateLimitRequest
func (fps *UpdateLimitRequest_FieldSubPath) GetSingle(source *UpdateLimitRequest) (interface{}, bool) {
	switch fps.selector {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		if source.GetLimit() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetLimit())
	case UpdateLimitRequest_FieldPathSelectorCas:
		if source.GetCas() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetCas())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fps.selector))
	}
}

func (fps *UpdateLimitRequest_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*UpdateLimitRequest))
}

// GetDefault returns a default value of the field type
func (fps *UpdateLimitRequest_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *UpdateLimitRequest_FieldSubPath) ClearValue(item *UpdateLimitRequest) {
	if item != nil {
		switch fps.selector {
		case UpdateLimitRequest_FieldPathSelectorLimit:
			fps.subPath.ClearValueRaw(item.Limit)
		case UpdateLimitRequest_FieldPathSelectorCas:
			fps.subPath.ClearValueRaw(item.Cas)
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fps.selector))
		}
	}
}

func (fps *UpdateLimitRequest_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*UpdateLimitRequest))
}

// IsLeaf - whether field path is holds simple value
func (fps *UpdateLimitRequest_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *UpdateLimitRequest_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&UpdateLimitRequest_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *UpdateLimitRequest_FieldSubPath) WithIValue(value interface{}) UpdateLimitRequest_FieldPathValue {
	return &UpdateLimitRequest_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *UpdateLimitRequest_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *UpdateLimitRequest_FieldSubPath) WithIArrayOfValues(values interface{}) UpdateLimitRequest_FieldPathArrayOfValues {
	return &UpdateLimitRequest_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *UpdateLimitRequest_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *UpdateLimitRequest_FieldSubPath) WithIArrayItemValue(value interface{}) UpdateLimitRequest_FieldPathArrayItemValue {
	return &UpdateLimitRequest_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *UpdateLimitRequest_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// UpdateLimitRequest_FieldPathValue allows storing values for UpdateLimitRequest fields according to their type
type UpdateLimitRequest_FieldPathValue interface {
	UpdateLimitRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **UpdateLimitRequest)
	CompareWith(*UpdateLimitRequest) (cmp int, comparable bool)
}

func ParseUpdateLimitRequest_FieldPathValue(pathStr, valueStr string) (UpdateLimitRequest_FieldPathValue, error) {
	fp, err := ParseUpdateLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing UpdateLimitRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(UpdateLimitRequest_FieldPathValue), nil
}

func MustParseUpdateLimitRequest_FieldPathValue(pathStr, valueStr string) UpdateLimitRequest_FieldPathValue {
	fpv, err := ParseUpdateLimitRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type UpdateLimitRequest_FieldTerminalPathValue struct {
	UpdateLimitRequest_FieldTerminalPath
	value interface{}
}

var _ UpdateLimitRequest_FieldPathValue = (*UpdateLimitRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'UpdateLimitRequest' as interface{}
func (fpv *UpdateLimitRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *UpdateLimitRequest_FieldTerminalPathValue) AsLimitValue() (*limit.Limit, bool) {
	res, ok := fpv.value.(*limit.Limit)
	return res, ok
}
func (fpv *UpdateLimitRequest_FieldTerminalPathValue) AsUpdateMaskValue() (*limit.Limit_FieldMask, bool) {
	res, ok := fpv.value.(*limit.Limit_FieldMask)
	return res, ok
}
func (fpv *UpdateLimitRequest_FieldTerminalPathValue) AsCasValue() (*UpdateLimitRequest_CAS, bool) {
	res, ok := fpv.value.(*UpdateLimitRequest_CAS)
	return res, ok
}

// SetTo stores value for selected field for object UpdateLimitRequest
func (fpv *UpdateLimitRequest_FieldTerminalPathValue) SetTo(target **UpdateLimitRequest) {
	if *target == nil {
		*target = new(UpdateLimitRequest)
	}
	switch fpv.selector {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		(*target).Limit = fpv.value.(*limit.Limit)
	case UpdateLimitRequest_FieldPathSelectorUpdateMask:
		(*target).UpdateMask = fpv.value.(*limit.Limit_FieldMask)
	case UpdateLimitRequest_FieldPathSelectorCas:
		(*target).Cas = fpv.value.(*UpdateLimitRequest_CAS)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fpv.selector))
	}
}

func (fpv *UpdateLimitRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*UpdateLimitRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'UpdateLimitRequest_FieldTerminalPathValue' with the value under path in 'UpdateLimitRequest'.
func (fpv *UpdateLimitRequest_FieldTerminalPathValue) CompareWith(source *UpdateLimitRequest) (int, bool) {
	switch fpv.selector {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		return 0, false
	case UpdateLimitRequest_FieldPathSelectorUpdateMask:
		return 0, false
	case UpdateLimitRequest_FieldPathSelectorCas:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fpv.selector))
	}
}

func (fpv *UpdateLimitRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*UpdateLimitRequest))
}

type UpdateLimitRequest_FieldSubPathValue struct {
	UpdateLimitRequest_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ UpdateLimitRequest_FieldPathValue = (*UpdateLimitRequest_FieldSubPathValue)(nil)

func (fpvs *UpdateLimitRequest_FieldSubPathValue) AsLimitPathValue() (limit.Limit_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(limit.Limit_FieldPathValue)
	return res, ok
}
func (fpvs *UpdateLimitRequest_FieldSubPathValue) AsCasPathValue() (UpdateLimitRequestCAS_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(UpdateLimitRequestCAS_FieldPathValue)
	return res, ok
}

func (fpvs *UpdateLimitRequest_FieldSubPathValue) SetTo(target **UpdateLimitRequest) {
	if *target == nil {
		*target = new(UpdateLimitRequest)
	}
	switch fpvs.Selector() {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		fpvs.subPathValue.(limit.Limit_FieldPathValue).SetTo(&(*target).Limit)
	case UpdateLimitRequest_FieldPathSelectorCas:
		fpvs.subPathValue.(UpdateLimitRequestCAS_FieldPathValue).SetTo(&(*target).Cas)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fpvs.Selector()))
	}
}

func (fpvs *UpdateLimitRequest_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*UpdateLimitRequest)
	fpvs.SetTo(&typedObject)
}

func (fpvs *UpdateLimitRequest_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *UpdateLimitRequest_FieldSubPathValue) CompareWith(source *UpdateLimitRequest) (int, bool) {
	switch fpvs.Selector() {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		return fpvs.subPathValue.(limit.Limit_FieldPathValue).CompareWith(source.GetLimit())
	case UpdateLimitRequest_FieldPathSelectorCas:
		return fpvs.subPathValue.(UpdateLimitRequestCAS_FieldPathValue).CompareWith(source.GetCas())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fpvs.Selector()))
	}
}

func (fpvs *UpdateLimitRequest_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*UpdateLimitRequest))
}

// UpdateLimitRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for UpdateLimitRequest according to their type
// Present only for array (repeated) types.
type UpdateLimitRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	UpdateLimitRequest_FieldPath
	ContainsValue(*UpdateLimitRequest) bool
}

// ParseUpdateLimitRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseUpdateLimitRequest_FieldPathArrayItemValue(pathStr, valueStr string) (UpdateLimitRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseUpdateLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing UpdateLimitRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(UpdateLimitRequest_FieldPathArrayItemValue), nil
}

func MustParseUpdateLimitRequest_FieldPathArrayItemValue(pathStr, valueStr string) UpdateLimitRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseUpdateLimitRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type UpdateLimitRequest_FieldTerminalPathArrayItemValue struct {
	UpdateLimitRequest_FieldTerminalPath
	value interface{}
}

var _ UpdateLimitRequest_FieldPathArrayItemValue = (*UpdateLimitRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object UpdateLimitRequest as interface{}
func (fpaiv *UpdateLimitRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *UpdateLimitRequest_FieldTerminalPathArrayItemValue) GetSingle(source *UpdateLimitRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *UpdateLimitRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*UpdateLimitRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'UpdateLimitRequest'
func (fpaiv *UpdateLimitRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *UpdateLimitRequest) bool {
	slice := fpaiv.UpdateLimitRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type UpdateLimitRequest_FieldSubPathArrayItemValue struct {
	UpdateLimitRequest_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *UpdateLimitRequest_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *UpdateLimitRequest_FieldSubPathArrayItemValue) AsLimitPathItemValue() (limit.Limit_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(limit.Limit_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *UpdateLimitRequest_FieldSubPathArrayItemValue) AsCasPathItemValue() (UpdateLimitRequestCAS_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(UpdateLimitRequestCAS_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'UpdateLimitRequest'
func (fpaivs *UpdateLimitRequest_FieldSubPathArrayItemValue) ContainsValue(source *UpdateLimitRequest) bool {
	switch fpaivs.Selector() {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		return fpaivs.subPathItemValue.(limit.Limit_FieldPathArrayItemValue).ContainsValue(source.GetLimit())
	case UpdateLimitRequest_FieldPathSelectorCas:
		return fpaivs.subPathItemValue.(UpdateLimitRequestCAS_FieldPathArrayItemValue).ContainsValue(source.GetCas())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest: %d", fpaivs.Selector()))
	}
}

// UpdateLimitRequest_FieldPathArrayOfValues allows storing slice of values for UpdateLimitRequest fields according to their type
type UpdateLimitRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	UpdateLimitRequest_FieldPath
}

func ParseUpdateLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (UpdateLimitRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseUpdateLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing UpdateLimitRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(UpdateLimitRequest_FieldPathArrayOfValues), nil
}

func MustParseUpdateLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr string) UpdateLimitRequest_FieldPathArrayOfValues {
	fpaov, err := ParseUpdateLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type UpdateLimitRequest_FieldTerminalPathArrayOfValues struct {
	UpdateLimitRequest_FieldTerminalPath
	values interface{}
}

var _ UpdateLimitRequest_FieldPathArrayOfValues = (*UpdateLimitRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *UpdateLimitRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case UpdateLimitRequest_FieldPathSelectorLimit:
		for _, v := range fpaov.values.([]*limit.Limit) {
			values = append(values, v)
		}
	case UpdateLimitRequest_FieldPathSelectorUpdateMask:
		for _, v := range fpaov.values.([]*limit.Limit_FieldMask) {
			values = append(values, v)
		}
	case UpdateLimitRequest_FieldPathSelectorCas:
		for _, v := range fpaov.values.([]*UpdateLimitRequest_CAS) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *UpdateLimitRequest_FieldTerminalPathArrayOfValues) AsLimitArrayOfValues() ([]*limit.Limit, bool) {
	res, ok := fpaov.values.([]*limit.Limit)
	return res, ok
}
func (fpaov *UpdateLimitRequest_FieldTerminalPathArrayOfValues) AsUpdateMaskArrayOfValues() ([]*limit.Limit_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit.Limit_FieldMask)
	return res, ok
}
func (fpaov *UpdateLimitRequest_FieldTerminalPathArrayOfValues) AsCasArrayOfValues() ([]*UpdateLimitRequest_CAS, bool) {
	res, ok := fpaov.values.([]*UpdateLimitRequest_CAS)
	return res, ok
}

type UpdateLimitRequest_FieldSubPathArrayOfValues struct {
	UpdateLimitRequest_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ UpdateLimitRequest_FieldPathArrayOfValues = (*UpdateLimitRequest_FieldSubPathArrayOfValues)(nil)

func (fpsaov *UpdateLimitRequest_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *UpdateLimitRequest_FieldSubPathArrayOfValues) AsLimitPathArrayOfValues() (limit.Limit_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(limit.Limit_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *UpdateLimitRequest_FieldSubPathArrayOfValues) AsCasPathArrayOfValues() (UpdateLimitRequestCAS_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(UpdateLimitRequestCAS_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type UpdateLimitRequestCAS_FieldPath interface {
	gotenobject.FieldPath
	Selector() UpdateLimitRequestCAS_FieldPathSelector
	Get(source *UpdateLimitRequest_CAS) []interface{}
	GetSingle(source *UpdateLimitRequest_CAS) (interface{}, bool)
	ClearValue(item *UpdateLimitRequest_CAS)

	// Those methods build corresponding UpdateLimitRequestCAS_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) UpdateLimitRequestCAS_FieldPathValue
	WithIArrayOfValues(values interface{}) UpdateLimitRequestCAS_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) UpdateLimitRequestCAS_FieldPathArrayItemValue
}

type UpdateLimitRequestCAS_FieldPathSelector int32

const (
	UpdateLimitRequestCAS_FieldPathSelectorConditionalState UpdateLimitRequestCAS_FieldPathSelector = 0
	UpdateLimitRequestCAS_FieldPathSelectorFieldMask        UpdateLimitRequestCAS_FieldPathSelector = 1
)

func (s UpdateLimitRequestCAS_FieldPathSelector) String() string {
	switch s {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		return "conditional_state"
	case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
		return "field_mask"
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", s))
	}
}

func BuildUpdateLimitRequestCAS_FieldPath(fp gotenobject.RawFieldPath) (UpdateLimitRequestCAS_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object UpdateLimitRequest_CAS")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "conditional_state", "conditionalState", "conditional-state":
			return &UpdateLimitRequestCAS_FieldTerminalPath{selector: UpdateLimitRequestCAS_FieldPathSelectorConditionalState}, nil
		case "field_mask", "fieldMask", "field-mask":
			return &UpdateLimitRequestCAS_FieldTerminalPath{selector: UpdateLimitRequestCAS_FieldPathSelectorFieldMask}, nil
		}
	} else {
		switch fp[0] {
		case "conditional_state", "conditionalState", "conditional-state":
			if subpath, err := limit.BuildLimit_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &UpdateLimitRequestCAS_FieldSubPath{selector: UpdateLimitRequestCAS_FieldPathSelectorConditionalState, subPath: subpath}, nil
			}
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object UpdateLimitRequest_CAS", fp)
}

func ParseUpdateLimitRequestCAS_FieldPath(rawField string) (UpdateLimitRequestCAS_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildUpdateLimitRequestCAS_FieldPath(fp)
}

func MustParseUpdateLimitRequestCAS_FieldPath(rawField string) UpdateLimitRequestCAS_FieldPath {
	fp, err := ParseUpdateLimitRequestCAS_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type UpdateLimitRequestCAS_FieldTerminalPath struct {
	selector UpdateLimitRequestCAS_FieldPathSelector
}

var _ UpdateLimitRequestCAS_FieldPath = (*UpdateLimitRequestCAS_FieldTerminalPath)(nil)

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) Selector() UpdateLimitRequestCAS_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *UpdateLimitRequestCAS_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *UpdateLimitRequestCAS_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source UpdateLimitRequest_CAS
func (fp *UpdateLimitRequestCAS_FieldTerminalPath) Get(source *UpdateLimitRequest_CAS) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
			if source.ConditionalState != nil {
				values = append(values, source.ConditionalState)
			}
		case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
			if source.FieldMask != nil {
				values = append(values, source.FieldMask)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fp.selector))
		}
	}
	return
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*UpdateLimitRequest_CAS))
}

// GetSingle returns value pointed by specific field of from source UpdateLimitRequest_CAS
func (fp *UpdateLimitRequestCAS_FieldTerminalPath) GetSingle(source *UpdateLimitRequest_CAS) (interface{}, bool) {
	switch fp.selector {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		res := source.GetConditionalState()
		return res, res != nil
	case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
		res := source.GetFieldMask()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fp.selector))
	}
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*UpdateLimitRequest_CAS))
}

// GetDefault returns a default value of the field type
func (fp *UpdateLimitRequestCAS_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		return (*limit.Limit)(nil)
	case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
		return (*limit.Limit_FieldMask)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fp.selector))
	}
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) ClearValue(item *UpdateLimitRequest_CAS) {
	if item != nil {
		switch fp.selector {
		case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
			item.ConditionalState = nil
		case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
			item.FieldMask = nil
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fp.selector))
		}
	}
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*UpdateLimitRequest_CAS))
}

// IsLeaf - whether field path is holds simple value
func (fp *UpdateLimitRequestCAS_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == UpdateLimitRequestCAS_FieldPathSelectorFieldMask
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) WithIValue(value interface{}) UpdateLimitRequestCAS_FieldPathValue {
	switch fp.selector {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		return &UpdateLimitRequestCAS_FieldTerminalPathValue{UpdateLimitRequestCAS_FieldTerminalPath: *fp, value: value.(*limit.Limit)}
	case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
		return &UpdateLimitRequestCAS_FieldTerminalPathValue{UpdateLimitRequestCAS_FieldTerminalPath: *fp, value: value.(*limit.Limit_FieldMask)}
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fp.selector))
	}
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) WithIArrayOfValues(values interface{}) UpdateLimitRequestCAS_FieldPathArrayOfValues {
	fpaov := &UpdateLimitRequestCAS_FieldTerminalPathArrayOfValues{UpdateLimitRequestCAS_FieldTerminalPath: *fp}
	switch fp.selector {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		return &UpdateLimitRequestCAS_FieldTerminalPathArrayOfValues{UpdateLimitRequestCAS_FieldTerminalPath: *fp, values: values.([]*limit.Limit)}
	case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
		return &UpdateLimitRequestCAS_FieldTerminalPathArrayOfValues{UpdateLimitRequestCAS_FieldTerminalPath: *fp, values: values.([]*limit.Limit_FieldMask)}
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fp.selector))
	}
	return fpaov
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) WithIArrayItemValue(value interface{}) UpdateLimitRequestCAS_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fp.selector))
	}
}

func (fp *UpdateLimitRequestCAS_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

type UpdateLimitRequestCAS_FieldSubPath struct {
	selector UpdateLimitRequestCAS_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ UpdateLimitRequestCAS_FieldPath = (*UpdateLimitRequestCAS_FieldSubPath)(nil)

func (fps *UpdateLimitRequestCAS_FieldSubPath) Selector() UpdateLimitRequestCAS_FieldPathSelector {
	return fps.selector
}
func (fps *UpdateLimitRequestCAS_FieldSubPath) AsConditionalStateSubPath() (limit.Limit_FieldPath, bool) {
	res, ok := fps.subPath.(limit.Limit_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *UpdateLimitRequestCAS_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *UpdateLimitRequestCAS_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source UpdateLimitRequest_CAS
func (fps *UpdateLimitRequestCAS_FieldSubPath) Get(source *UpdateLimitRequest_CAS) (values []interface{}) {
	if asLimitFieldPath, ok := fps.AsConditionalStateSubPath(); ok {
		values = append(values, asLimitFieldPath.Get(source.GetConditionalState())...)
	} else {
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fps.selector))
	}
	return
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*UpdateLimitRequest_CAS))
}

// GetSingle returns value of selected field from source UpdateLimitRequest_CAS
func (fps *UpdateLimitRequestCAS_FieldSubPath) GetSingle(source *UpdateLimitRequest_CAS) (interface{}, bool) {
	switch fps.selector {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		if source.GetConditionalState() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetConditionalState())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fps.selector))
	}
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*UpdateLimitRequest_CAS))
}

// GetDefault returns a default value of the field type
func (fps *UpdateLimitRequestCAS_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) ClearValue(item *UpdateLimitRequest_CAS) {
	if item != nil {
		switch fps.selector {
		case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
			fps.subPath.ClearValueRaw(item.ConditionalState)
		default:
			panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fps.selector))
		}
	}
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*UpdateLimitRequest_CAS))
}

// IsLeaf - whether field path is holds simple value
func (fps *UpdateLimitRequestCAS_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&UpdateLimitRequestCAS_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) WithIValue(value interface{}) UpdateLimitRequestCAS_FieldPathValue {
	return &UpdateLimitRequestCAS_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) WithIArrayOfValues(values interface{}) UpdateLimitRequestCAS_FieldPathArrayOfValues {
	return &UpdateLimitRequestCAS_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) WithIArrayItemValue(value interface{}) UpdateLimitRequestCAS_FieldPathArrayItemValue {
	return &UpdateLimitRequestCAS_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *UpdateLimitRequestCAS_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// UpdateLimitRequestCAS_FieldPathValue allows storing values for CAS fields according to their type
type UpdateLimitRequestCAS_FieldPathValue interface {
	UpdateLimitRequestCAS_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **UpdateLimitRequest_CAS)
	CompareWith(*UpdateLimitRequest_CAS) (cmp int, comparable bool)
}

func ParseUpdateLimitRequestCAS_FieldPathValue(pathStr, valueStr string) (UpdateLimitRequestCAS_FieldPathValue, error) {
	fp, err := ParseUpdateLimitRequestCAS_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CAS field path value from %s: %v", valueStr, err)
	}
	return fpv.(UpdateLimitRequestCAS_FieldPathValue), nil
}

func MustParseUpdateLimitRequestCAS_FieldPathValue(pathStr, valueStr string) UpdateLimitRequestCAS_FieldPathValue {
	fpv, err := ParseUpdateLimitRequestCAS_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type UpdateLimitRequestCAS_FieldTerminalPathValue struct {
	UpdateLimitRequestCAS_FieldTerminalPath
	value interface{}
}

var _ UpdateLimitRequestCAS_FieldPathValue = (*UpdateLimitRequestCAS_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'CAS' as interface{}
func (fpv *UpdateLimitRequestCAS_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *UpdateLimitRequestCAS_FieldTerminalPathValue) AsConditionalStateValue() (*limit.Limit, bool) {
	res, ok := fpv.value.(*limit.Limit)
	return res, ok
}
func (fpv *UpdateLimitRequestCAS_FieldTerminalPathValue) AsFieldMaskValue() (*limit.Limit_FieldMask, bool) {
	res, ok := fpv.value.(*limit.Limit_FieldMask)
	return res, ok
}

// SetTo stores value for selected field for object CAS
func (fpv *UpdateLimitRequestCAS_FieldTerminalPathValue) SetTo(target **UpdateLimitRequest_CAS) {
	if *target == nil {
		*target = new(UpdateLimitRequest_CAS)
	}
	switch fpv.selector {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		(*target).ConditionalState = fpv.value.(*limit.Limit)
	case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
		(*target).FieldMask = fpv.value.(*limit.Limit_FieldMask)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fpv.selector))
	}
}

func (fpv *UpdateLimitRequestCAS_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*UpdateLimitRequest_CAS)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'UpdateLimitRequestCAS_FieldTerminalPathValue' with the value under path in 'UpdateLimitRequest_CAS'.
func (fpv *UpdateLimitRequestCAS_FieldTerminalPathValue) CompareWith(source *UpdateLimitRequest_CAS) (int, bool) {
	switch fpv.selector {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		return 0, false
	case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fpv.selector))
	}
}

func (fpv *UpdateLimitRequestCAS_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*UpdateLimitRequest_CAS))
}

type UpdateLimitRequestCAS_FieldSubPathValue struct {
	UpdateLimitRequestCAS_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ UpdateLimitRequestCAS_FieldPathValue = (*UpdateLimitRequestCAS_FieldSubPathValue)(nil)

func (fpvs *UpdateLimitRequestCAS_FieldSubPathValue) AsConditionalStatePathValue() (limit.Limit_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(limit.Limit_FieldPathValue)
	return res, ok
}

func (fpvs *UpdateLimitRequestCAS_FieldSubPathValue) SetTo(target **UpdateLimitRequest_CAS) {
	if *target == nil {
		*target = new(UpdateLimitRequest_CAS)
	}
	switch fpvs.Selector() {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		fpvs.subPathValue.(limit.Limit_FieldPathValue).SetTo(&(*target).ConditionalState)
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fpvs.Selector()))
	}
}

func (fpvs *UpdateLimitRequestCAS_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*UpdateLimitRequest_CAS)
	fpvs.SetTo(&typedObject)
}

func (fpvs *UpdateLimitRequestCAS_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *UpdateLimitRequestCAS_FieldSubPathValue) CompareWith(source *UpdateLimitRequest_CAS) (int, bool) {
	switch fpvs.Selector() {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		return fpvs.subPathValue.(limit.Limit_FieldPathValue).CompareWith(source.GetConditionalState())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fpvs.Selector()))
	}
}

func (fpvs *UpdateLimitRequestCAS_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*UpdateLimitRequest_CAS))
}

// UpdateLimitRequestCAS_FieldPathArrayItemValue allows storing single item in Path-specific values for CAS according to their type
// Present only for array (repeated) types.
type UpdateLimitRequestCAS_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	UpdateLimitRequestCAS_FieldPath
	ContainsValue(*UpdateLimitRequest_CAS) bool
}

// ParseUpdateLimitRequestCAS_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseUpdateLimitRequestCAS_FieldPathArrayItemValue(pathStr, valueStr string) (UpdateLimitRequestCAS_FieldPathArrayItemValue, error) {
	fp, err := ParseUpdateLimitRequestCAS_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CAS field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(UpdateLimitRequestCAS_FieldPathArrayItemValue), nil
}

func MustParseUpdateLimitRequestCAS_FieldPathArrayItemValue(pathStr, valueStr string) UpdateLimitRequestCAS_FieldPathArrayItemValue {
	fpaiv, err := ParseUpdateLimitRequestCAS_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type UpdateLimitRequestCAS_FieldTerminalPathArrayItemValue struct {
	UpdateLimitRequestCAS_FieldTerminalPath
	value interface{}
}

var _ UpdateLimitRequestCAS_FieldPathArrayItemValue = (*UpdateLimitRequestCAS_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object UpdateLimitRequest_CAS as interface{}
func (fpaiv *UpdateLimitRequestCAS_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *UpdateLimitRequestCAS_FieldTerminalPathArrayItemValue) GetSingle(source *UpdateLimitRequest_CAS) (interface{}, bool) {
	return nil, false
}

func (fpaiv *UpdateLimitRequestCAS_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*UpdateLimitRequest_CAS))
}

// Contains returns a boolean indicating if value that is being held is present in given 'CAS'
func (fpaiv *UpdateLimitRequestCAS_FieldTerminalPathArrayItemValue) ContainsValue(source *UpdateLimitRequest_CAS) bool {
	slice := fpaiv.UpdateLimitRequestCAS_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type UpdateLimitRequestCAS_FieldSubPathArrayItemValue struct {
	UpdateLimitRequestCAS_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *UpdateLimitRequestCAS_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *UpdateLimitRequestCAS_FieldSubPathArrayItemValue) AsConditionalStatePathItemValue() (limit.Limit_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(limit.Limit_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'CAS'
func (fpaivs *UpdateLimitRequestCAS_FieldSubPathArrayItemValue) ContainsValue(source *UpdateLimitRequest_CAS) bool {
	switch fpaivs.Selector() {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		return fpaivs.subPathItemValue.(limit.Limit_FieldPathArrayItemValue).ContainsValue(source.GetConditionalState())
	default:
		panic(fmt.Sprintf("Invalid selector for UpdateLimitRequest_CAS: %d", fpaivs.Selector()))
	}
}

// UpdateLimitRequestCAS_FieldPathArrayOfValues allows storing slice of values for CAS fields according to their type
type UpdateLimitRequestCAS_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	UpdateLimitRequestCAS_FieldPath
}

func ParseUpdateLimitRequestCAS_FieldPathArrayOfValues(pathStr, valuesStr string) (UpdateLimitRequestCAS_FieldPathArrayOfValues, error) {
	fp, err := ParseUpdateLimitRequestCAS_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing CAS field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(UpdateLimitRequestCAS_FieldPathArrayOfValues), nil
}

func MustParseUpdateLimitRequestCAS_FieldPathArrayOfValues(pathStr, valuesStr string) UpdateLimitRequestCAS_FieldPathArrayOfValues {
	fpaov, err := ParseUpdateLimitRequestCAS_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type UpdateLimitRequestCAS_FieldTerminalPathArrayOfValues struct {
	UpdateLimitRequestCAS_FieldTerminalPath
	values interface{}
}

var _ UpdateLimitRequestCAS_FieldPathArrayOfValues = (*UpdateLimitRequestCAS_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *UpdateLimitRequestCAS_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case UpdateLimitRequestCAS_FieldPathSelectorConditionalState:
		for _, v := range fpaov.values.([]*limit.Limit) {
			values = append(values, v)
		}
	case UpdateLimitRequestCAS_FieldPathSelectorFieldMask:
		for _, v := range fpaov.values.([]*limit.Limit_FieldMask) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *UpdateLimitRequestCAS_FieldTerminalPathArrayOfValues) AsConditionalStateArrayOfValues() ([]*limit.Limit, bool) {
	res, ok := fpaov.values.([]*limit.Limit)
	return res, ok
}
func (fpaov *UpdateLimitRequestCAS_FieldTerminalPathArrayOfValues) AsFieldMaskArrayOfValues() ([]*limit.Limit_FieldMask, bool) {
	res, ok := fpaov.values.([]*limit.Limit_FieldMask)
	return res, ok
}

type UpdateLimitRequestCAS_FieldSubPathArrayOfValues struct {
	UpdateLimitRequestCAS_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ UpdateLimitRequestCAS_FieldPathArrayOfValues = (*UpdateLimitRequestCAS_FieldSubPathArrayOfValues)(nil)

func (fpsaov *UpdateLimitRequestCAS_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *UpdateLimitRequestCAS_FieldSubPathArrayOfValues) AsConditionalStatePathArrayOfValues() (limit.Limit_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(limit.Limit_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type DeleteLimitRequest_FieldPath interface {
	gotenobject.FieldPath
	Selector() DeleteLimitRequest_FieldPathSelector
	Get(source *DeleteLimitRequest) []interface{}
	GetSingle(source *DeleteLimitRequest) (interface{}, bool)
	ClearValue(item *DeleteLimitRequest)

	// Those methods build corresponding DeleteLimitRequest_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) DeleteLimitRequest_FieldPathValue
	WithIArrayOfValues(values interface{}) DeleteLimitRequest_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) DeleteLimitRequest_FieldPathArrayItemValue
}

type DeleteLimitRequest_FieldPathSelector int32

const (
	DeleteLimitRequest_FieldPathSelectorName DeleteLimitRequest_FieldPathSelector = 0
)

func (s DeleteLimitRequest_FieldPathSelector) String() string {
	switch s {
	case DeleteLimitRequest_FieldPathSelectorName:
		return "name"
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", s))
	}
}

func BuildDeleteLimitRequest_FieldPath(fp gotenobject.RawFieldPath) (DeleteLimitRequest_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object DeleteLimitRequest")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "name":
			return &DeleteLimitRequest_FieldTerminalPath{selector: DeleteLimitRequest_FieldPathSelectorName}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object DeleteLimitRequest", fp)
}

func ParseDeleteLimitRequest_FieldPath(rawField string) (DeleteLimitRequest_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildDeleteLimitRequest_FieldPath(fp)
}

func MustParseDeleteLimitRequest_FieldPath(rawField string) DeleteLimitRequest_FieldPath {
	fp, err := ParseDeleteLimitRequest_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type DeleteLimitRequest_FieldTerminalPath struct {
	selector DeleteLimitRequest_FieldPathSelector
}

var _ DeleteLimitRequest_FieldPath = (*DeleteLimitRequest_FieldTerminalPath)(nil)

func (fp *DeleteLimitRequest_FieldTerminalPath) Selector() DeleteLimitRequest_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *DeleteLimitRequest_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *DeleteLimitRequest_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source DeleteLimitRequest
func (fp *DeleteLimitRequest_FieldTerminalPath) Get(source *DeleteLimitRequest) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case DeleteLimitRequest_FieldPathSelectorName:
			if source.Name != nil {
				values = append(values, source.Name)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fp.selector))
		}
	}
	return
}

func (fp *DeleteLimitRequest_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*DeleteLimitRequest))
}

// GetSingle returns value pointed by specific field of from source DeleteLimitRequest
func (fp *DeleteLimitRequest_FieldTerminalPath) GetSingle(source *DeleteLimitRequest) (interface{}, bool) {
	switch fp.selector {
	case DeleteLimitRequest_FieldPathSelectorName:
		res := source.GetName()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fp.selector))
	}
}

func (fp *DeleteLimitRequest_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*DeleteLimitRequest))
}

// GetDefault returns a default value of the field type
func (fp *DeleteLimitRequest_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case DeleteLimitRequest_FieldPathSelectorName:
		return (*limit.Reference)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fp.selector))
	}
}

func (fp *DeleteLimitRequest_FieldTerminalPath) ClearValue(item *DeleteLimitRequest) {
	if item != nil {
		switch fp.selector {
		case DeleteLimitRequest_FieldPathSelectorName:
			item.Name = nil
		default:
			panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fp.selector))
		}
	}
}

func (fp *DeleteLimitRequest_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*DeleteLimitRequest))
}

// IsLeaf - whether field path is holds simple value
func (fp *DeleteLimitRequest_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == DeleteLimitRequest_FieldPathSelectorName
}

func (fp *DeleteLimitRequest_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *DeleteLimitRequest_FieldTerminalPath) WithIValue(value interface{}) DeleteLimitRequest_FieldPathValue {
	switch fp.selector {
	case DeleteLimitRequest_FieldPathSelectorName:
		return &DeleteLimitRequest_FieldTerminalPathValue{DeleteLimitRequest_FieldTerminalPath: *fp, value: value.(*limit.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fp.selector))
	}
}

func (fp *DeleteLimitRequest_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *DeleteLimitRequest_FieldTerminalPath) WithIArrayOfValues(values interface{}) DeleteLimitRequest_FieldPathArrayOfValues {
	fpaov := &DeleteLimitRequest_FieldTerminalPathArrayOfValues{DeleteLimitRequest_FieldTerminalPath: *fp}
	switch fp.selector {
	case DeleteLimitRequest_FieldPathSelectorName:
		return &DeleteLimitRequest_FieldTerminalPathArrayOfValues{DeleteLimitRequest_FieldTerminalPath: *fp, values: values.([]*limit.Reference)}
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fp.selector))
	}
	return fpaov
}

func (fp *DeleteLimitRequest_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *DeleteLimitRequest_FieldTerminalPath) WithIArrayItemValue(value interface{}) DeleteLimitRequest_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fp.selector))
	}
}

func (fp *DeleteLimitRequest_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// DeleteLimitRequest_FieldPathValue allows storing values for DeleteLimitRequest fields according to their type
type DeleteLimitRequest_FieldPathValue interface {
	DeleteLimitRequest_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **DeleteLimitRequest)
	CompareWith(*DeleteLimitRequest) (cmp int, comparable bool)
}

func ParseDeleteLimitRequest_FieldPathValue(pathStr, valueStr string) (DeleteLimitRequest_FieldPathValue, error) {
	fp, err := ParseDeleteLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DeleteLimitRequest field path value from %s: %v", valueStr, err)
	}
	return fpv.(DeleteLimitRequest_FieldPathValue), nil
}

func MustParseDeleteLimitRequest_FieldPathValue(pathStr, valueStr string) DeleteLimitRequest_FieldPathValue {
	fpv, err := ParseDeleteLimitRequest_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type DeleteLimitRequest_FieldTerminalPathValue struct {
	DeleteLimitRequest_FieldTerminalPath
	value interface{}
}

var _ DeleteLimitRequest_FieldPathValue = (*DeleteLimitRequest_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'DeleteLimitRequest' as interface{}
func (fpv *DeleteLimitRequest_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *DeleteLimitRequest_FieldTerminalPathValue) AsNameValue() (*limit.Reference, bool) {
	res, ok := fpv.value.(*limit.Reference)
	return res, ok
}

// SetTo stores value for selected field for object DeleteLimitRequest
func (fpv *DeleteLimitRequest_FieldTerminalPathValue) SetTo(target **DeleteLimitRequest) {
	if *target == nil {
		*target = new(DeleteLimitRequest)
	}
	switch fpv.selector {
	case DeleteLimitRequest_FieldPathSelectorName:
		(*target).Name = fpv.value.(*limit.Reference)
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fpv.selector))
	}
}

func (fpv *DeleteLimitRequest_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*DeleteLimitRequest)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'DeleteLimitRequest_FieldTerminalPathValue' with the value under path in 'DeleteLimitRequest'.
func (fpv *DeleteLimitRequest_FieldTerminalPathValue) CompareWith(source *DeleteLimitRequest) (int, bool) {
	switch fpv.selector {
	case DeleteLimitRequest_FieldPathSelectorName:
		leftValue := fpv.value.(*limit.Reference)
		rightValue := source.GetName()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.String() == rightValue.String() {
			return 0, true
		} else if leftValue.String() < rightValue.String() {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for DeleteLimitRequest: %d", fpv.selector))
	}
}

func (fpv *DeleteLimitRequest_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*DeleteLimitRequest))
}

// DeleteLimitRequest_FieldPathArrayItemValue allows storing single item in Path-specific values for DeleteLimitRequest according to their type
// Present only for array (repeated) types.
type DeleteLimitRequest_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	DeleteLimitRequest_FieldPath
	ContainsValue(*DeleteLimitRequest) bool
}

// ParseDeleteLimitRequest_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseDeleteLimitRequest_FieldPathArrayItemValue(pathStr, valueStr string) (DeleteLimitRequest_FieldPathArrayItemValue, error) {
	fp, err := ParseDeleteLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DeleteLimitRequest field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(DeleteLimitRequest_FieldPathArrayItemValue), nil
}

func MustParseDeleteLimitRequest_FieldPathArrayItemValue(pathStr, valueStr string) DeleteLimitRequest_FieldPathArrayItemValue {
	fpaiv, err := ParseDeleteLimitRequest_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type DeleteLimitRequest_FieldTerminalPathArrayItemValue struct {
	DeleteLimitRequest_FieldTerminalPath
	value interface{}
}

var _ DeleteLimitRequest_FieldPathArrayItemValue = (*DeleteLimitRequest_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object DeleteLimitRequest as interface{}
func (fpaiv *DeleteLimitRequest_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *DeleteLimitRequest_FieldTerminalPathArrayItemValue) GetSingle(source *DeleteLimitRequest) (interface{}, bool) {
	return nil, false
}

func (fpaiv *DeleteLimitRequest_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*DeleteLimitRequest))
}

// Contains returns a boolean indicating if value that is being held is present in given 'DeleteLimitRequest'
func (fpaiv *DeleteLimitRequest_FieldTerminalPathArrayItemValue) ContainsValue(source *DeleteLimitRequest) bool {
	slice := fpaiv.DeleteLimitRequest_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// DeleteLimitRequest_FieldPathArrayOfValues allows storing slice of values for DeleteLimitRequest fields according to their type
type DeleteLimitRequest_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	DeleteLimitRequest_FieldPath
}

func ParseDeleteLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr string) (DeleteLimitRequest_FieldPathArrayOfValues, error) {
	fp, err := ParseDeleteLimitRequest_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing DeleteLimitRequest field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(DeleteLimitRequest_FieldPathArrayOfValues), nil
}

func MustParseDeleteLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr string) DeleteLimitRequest_FieldPathArrayOfValues {
	fpaov, err := ParseDeleteLimitRequest_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type DeleteLimitRequest_FieldTerminalPathArrayOfValues struct {
	DeleteLimitRequest_FieldTerminalPath
	values interface{}
}

var _ DeleteLimitRequest_FieldPathArrayOfValues = (*DeleteLimitRequest_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *DeleteLimitRequest_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case DeleteLimitRequest_FieldPathSelectorName:
		for _, v := range fpaov.values.([]*limit.Reference) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *DeleteLimitRequest_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]*limit.Reference, bool) {
	res, ok := fpaov.values.([]*limit.Reference)
	return res, ok
}
