// Code generated by protoc-gen-goten-object
// File: edgelq/limits/proto/v1alpha2/plan_assignment_request.proto
// DO NOT EDIT!!!

package plan_assignment_request

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	ntt_meta "github.com/cloudwan/edgelq-sdk/common/types/meta"
	iam_organization "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/organization"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/project"
	common "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/common"
	plan "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/plan"
	plan_assignment "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/plan_assignment"
	meta_service "github.com/cloudwan/edgelq-sdk/meta/resources/v1alpha2/service"
)

// ensure the imports are used
var (
	_ = json.Marshaler(nil)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = proto.Message(nil)
	_ = preflect.Message(nil)
	_ = fieldmaskpb.FieldMask{}

	_ = gotenobject.FieldMask(nil)
)

// make sure we're using proto imports
var (
	_ = &ntt_meta.Meta{}
	_ = &iam_organization.Organization{}
	_ = &iam_project.Project{}
	_ = &common.Allowance{}
	_ = &plan.Plan{}
	_ = &plan_assignment.PlanAssignment{}
	_ = &meta_service.Service{}
)

type PlanAssignmentRequest_FieldMask struct {
	Paths []PlanAssignmentRequest_FieldPath
}

func FullPlanAssignmentRequest_FieldMask() *PlanAssignmentRequest_FieldMask {
	res := &PlanAssignmentRequest_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorRequest})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorService})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorApprover})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorMetadata})
	return res
}

func (fieldMask *PlanAssignmentRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PlanAssignmentRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PlanAssignmentRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePlanAssignmentRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequest_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Subtract(other *PlanAssignmentRequest_FieldMask) *PlanAssignmentRequest_FieldMask {
	result := &PlanAssignmentRequest_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[PlanAssignmentRequest_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequest_FieldPathSelectorRequest:  &PlanAssignmentRequest_Request_FieldMask{},
		PlanAssignmentRequest_FieldPathSelectorStatus:   &PlanAssignmentRequest_Status_FieldMask{},
		PlanAssignmentRequest_FieldPathSelectorMetadata: &ntt_meta.Meta_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequest_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequest_FieldPathSelectorRequest:  &PlanAssignmentRequest_Request_FieldMask{},
		PlanAssignmentRequest_FieldPathSelectorStatus:   &PlanAssignmentRequest_Status_FieldMask{},
		PlanAssignmentRequest_FieldPathSelectorMetadata: &ntt_meta.Meta_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequest_FieldPathSelectorRequest:
						mySubMasks[PlanAssignmentRequest_FieldPathSelectorRequest] = FullPlanAssignmentRequest_Request_FieldMask()
					case PlanAssignmentRequest_FieldPathSelectorStatus:
						mySubMasks[PlanAssignmentRequest_FieldPathSelectorStatus] = FullPlanAssignmentRequest_Status_FieldMask()
					case PlanAssignmentRequest_FieldPathSelectorMetadata:
						mySubMasks[PlanAssignmentRequest_FieldPathSelectorMetadata] = ntt_meta.FullMeta_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_FieldMask) FilterInputFields() *PlanAssignmentRequest_FieldMask {
	result := &PlanAssignmentRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case PlanAssignmentRequest_FieldPathSelectorService:
		case PlanAssignmentRequest_FieldPathSelectorApprover:
		case PlanAssignmentRequest_FieldPathSelectorStatus:
		case PlanAssignmentRequest_FieldPathSelectorMetadata:
			if _, ok := path.(*PlanAssignmentRequest_FieldTerminalPath); ok {
				for _, subpath := range ntt_meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &PlanAssignmentRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*PlanAssignmentRequest_FieldSubPath); ok {
				selectedMask := &ntt_meta.Meta_FieldMask{
					Paths: []ntt_meta.Meta_FieldPath{sub.subPath.(ntt_meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &PlanAssignmentRequest_FieldSubPath{selector: PlanAssignmentRequest_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_FieldMask) AppendPath(path PlanAssignmentRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequest_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_FieldMask) GetPaths() []PlanAssignmentRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Set(target, source *PlanAssignmentRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest), source.(*PlanAssignmentRequest))
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Project(source *PlanAssignmentRequest) *PlanAssignmentRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest{}
	requestMask := &PlanAssignmentRequest_Request_FieldMask{}
	wholeRequestAccepted := false
	statusMask := &PlanAssignmentRequest_Status_FieldMask{}
	wholeStatusAccepted := false
	metadataMask := &ntt_meta.Meta_FieldMask{}
	wholeMetadataAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequest_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequest_FieldPathSelectorName:
				result.Name = source.Name
			case PlanAssignmentRequest_FieldPathSelectorRequest:
				result.Request = source.Request
				wholeRequestAccepted = true
			case PlanAssignmentRequest_FieldPathSelectorService:
				result.Service = source.Service
			case PlanAssignmentRequest_FieldPathSelectorApprover:
				result.Approver = source.Approver
			case PlanAssignmentRequest_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			case PlanAssignmentRequest_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			}
		case *PlanAssignmentRequest_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequest_FieldPathSelectorRequest:
				requestMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequest_FieldPath))
			case PlanAssignmentRequest_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(PlanAssignmentRequestStatus_FieldPath))
			case PlanAssignmentRequest_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(ntt_meta.Meta_FieldPath))
			}
		}
	}
	if wholeRequestAccepted == false && len(requestMask.Paths) > 0 {
		result.Request = requestMask.Project(source.GetRequest())
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest))
}

func (fieldMask *PlanAssignmentRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_Status_FieldMask struct {
	Paths []PlanAssignmentRequestStatus_FieldPath
}

func FullPlanAssignmentRequest_Status_FieldMask() *PlanAssignmentRequest_Status_FieldMask {
	res := &PlanAssignmentRequest_Status_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestStatus_FieldTerminalPath{selector: PlanAssignmentRequestStatus_FieldPathSelectorConclusion})
	res.Paths = append(res.Paths, &PlanAssignmentRequestStatus_FieldTerminalPath{selector: PlanAssignmentRequestStatus_FieldPathSelectorReason})
	return res
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PlanAssignmentRequest_Status_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePlanAssignmentRequestStatus_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestStatus_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Subtract(other *PlanAssignmentRequest_Status_FieldMask) *PlanAssignmentRequest_Status_FieldMask {
	result := &PlanAssignmentRequest_Status_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_Status_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_Status_FieldMask) FilterInputFields() *PlanAssignmentRequest_Status_FieldMask {
	result := &PlanAssignmentRequest_Status_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_Status_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_Status_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_Status_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) AppendPath(path PlanAssignmentRequestStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestStatus_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) GetPaths() []PlanAssignmentRequestStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Set(target, source *PlanAssignmentRequest_Status) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_Status), source.(*PlanAssignmentRequest_Status))
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Project(source *PlanAssignmentRequest_Status) *PlanAssignmentRequest_Status {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_Status{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestStatus_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestStatus_FieldPathSelectorConclusion:
				result.Conclusion = source.Conclusion
			case PlanAssignmentRequestStatus_FieldPathSelectorReason:
				result.Reason = source.Reason
			}
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_Status))
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_Request_FieldMask struct {
	Paths []PlanAssignmentRequestRequest_FieldPath
}

func FullPlanAssignmentRequest_Request_FieldMask() *PlanAssignmentRequest_Request_FieldMask {
	res := &PlanAssignmentRequest_Request_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequest_FieldTerminalPath{selector: PlanAssignmentRequestRequest_FieldPathSelectorAssign})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequest_FieldTerminalPath{selector: PlanAssignmentRequestRequest_FieldPathSelectorExtend})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequest_FieldTerminalPath{selector: PlanAssignmentRequestRequest_FieldPathSelectorRedistribute})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequest_FieldTerminalPath{selector: PlanAssignmentRequestRequest_FieldPathSelectorUnassign})
	return res
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PlanAssignmentRequest_Request_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePlanAssignmentRequestRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequest_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) Subtract(other *PlanAssignmentRequest_Request_FieldMask) *PlanAssignmentRequest_Request_FieldMask {
	result := &PlanAssignmentRequest_Request_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[PlanAssignmentRequestRequest_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequest_FieldPathSelectorAssign:       &PlanAssignmentRequest_Request_Assign_FieldMask{},
		PlanAssignmentRequestRequest_FieldPathSelectorExtend:       &PlanAssignmentRequest_Request_Extend_FieldMask{},
		PlanAssignmentRequestRequest_FieldPathSelectorRedistribute: &PlanAssignmentRequest_Request_Redistribute_FieldMask{},
		PlanAssignmentRequestRequest_FieldPathSelectorUnassign:     &PlanAssignmentRequest_Request_Unassign_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequestRequest_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequest_FieldPathSelectorAssign:       &PlanAssignmentRequest_Request_Assign_FieldMask{},
		PlanAssignmentRequestRequest_FieldPathSelectorExtend:       &PlanAssignmentRequest_Request_Extend_FieldMask{},
		PlanAssignmentRequestRequest_FieldPathSelectorRedistribute: &PlanAssignmentRequest_Request_Redistribute_FieldMask{},
		PlanAssignmentRequestRequest_FieldPathSelectorUnassign:     &PlanAssignmentRequest_Request_Unassign_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequestRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequestRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequestRequest_FieldPathSelectorAssign:
						mySubMasks[PlanAssignmentRequestRequest_FieldPathSelectorAssign] = FullPlanAssignmentRequest_Request_Assign_FieldMask()
					case PlanAssignmentRequestRequest_FieldPathSelectorExtend:
						mySubMasks[PlanAssignmentRequestRequest_FieldPathSelectorExtend] = FullPlanAssignmentRequest_Request_Extend_FieldMask()
					case PlanAssignmentRequestRequest_FieldPathSelectorRedistribute:
						mySubMasks[PlanAssignmentRequestRequest_FieldPathSelectorRedistribute] = FullPlanAssignmentRequest_Request_Redistribute_FieldMask()
					case PlanAssignmentRequestRequest_FieldPathSelectorUnassign:
						mySubMasks[PlanAssignmentRequestRequest_FieldPathSelectorUnassign] = FullPlanAssignmentRequest_Request_Unassign_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequestRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequestRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_Request_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_Request_FieldMask) FilterInputFields() *PlanAssignmentRequest_Request_FieldMask {
	result := &PlanAssignmentRequest_Request_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_Request_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_Request_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_Request_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) AppendPath(path PlanAssignmentRequestRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequest_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) GetPaths() []PlanAssignmentRequestRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) Set(target, source *PlanAssignmentRequest_Request) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_Request), source.(*PlanAssignmentRequest_Request))
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) Project(source *PlanAssignmentRequest_Request) *PlanAssignmentRequest_Request {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_Request{}
	assignMask := &PlanAssignmentRequest_Request_Assign_FieldMask{}
	wholeAssignAccepted := false
	extendMask := &PlanAssignmentRequest_Request_Extend_FieldMask{}
	wholeExtendAccepted := false
	redistributeMask := &PlanAssignmentRequest_Request_Redistribute_FieldMask{}
	wholeRedistributeAccepted := false
	unassignMask := &PlanAssignmentRequest_Request_Unassign_FieldMask{}
	wholeUnassignAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequest_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequest_FieldPathSelectorAssign:
				if source, ok := source.Request.(*PlanAssignmentRequest_Request_Assign_); ok {
					result.Request = &PlanAssignmentRequest_Request_Assign_{
						Assign: source.Assign,
					}
				}
				wholeAssignAccepted = true
			case PlanAssignmentRequestRequest_FieldPathSelectorExtend:
				if source, ok := source.Request.(*PlanAssignmentRequest_Request_Extend_); ok {
					result.Request = &PlanAssignmentRequest_Request_Extend_{
						Extend: source.Extend,
					}
				}
				wholeExtendAccepted = true
			case PlanAssignmentRequestRequest_FieldPathSelectorRedistribute:
				if source, ok := source.Request.(*PlanAssignmentRequest_Request_Redistribute_); ok {
					result.Request = &PlanAssignmentRequest_Request_Redistribute_{
						Redistribute: source.Redistribute,
					}
				}
				wholeRedistributeAccepted = true
			case PlanAssignmentRequestRequest_FieldPathSelectorUnassign:
				if source, ok := source.Request.(*PlanAssignmentRequest_Request_Unassign_); ok {
					result.Request = &PlanAssignmentRequest_Request_Unassign_{
						Unassign: source.Unassign,
					}
				}
				wholeUnassignAccepted = true
			}
		case *PlanAssignmentRequestRequest_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequestRequest_FieldPathSelectorAssign:
				assignMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestAssign_FieldPath))
			case PlanAssignmentRequestRequest_FieldPathSelectorExtend:
				extendMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestExtend_FieldPath))
			case PlanAssignmentRequestRequest_FieldPathSelectorRedistribute:
				redistributeMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestRedistribute_FieldPath))
			case PlanAssignmentRequestRequest_FieldPathSelectorUnassign:
				unassignMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestUnassign_FieldPath))
			}
		}
	}
	if wholeAssignAccepted == false && len(assignMask.Paths) > 0 {
		if asOneOf, ok := source.Request.(*PlanAssignmentRequest_Request_Assign_); ok {
			result.Request = (*PlanAssignmentRequest_Request_Assign_)(nil)
			if asOneOf != nil {
				oneOfRes := &PlanAssignmentRequest_Request_Assign_{}
				oneOfRes.Assign = assignMask.Project(asOneOf.Assign)
				result.Request = oneOfRes
			}
		}
	}
	if wholeExtendAccepted == false && len(extendMask.Paths) > 0 {
		if asOneOf, ok := source.Request.(*PlanAssignmentRequest_Request_Extend_); ok {
			result.Request = (*PlanAssignmentRequest_Request_Extend_)(nil)
			if asOneOf != nil {
				oneOfRes := &PlanAssignmentRequest_Request_Extend_{}
				oneOfRes.Extend = extendMask.Project(asOneOf.Extend)
				result.Request = oneOfRes
			}
		}
	}
	if wholeRedistributeAccepted == false && len(redistributeMask.Paths) > 0 {
		if asOneOf, ok := source.Request.(*PlanAssignmentRequest_Request_Redistribute_); ok {
			result.Request = (*PlanAssignmentRequest_Request_Redistribute_)(nil)
			if asOneOf != nil {
				oneOfRes := &PlanAssignmentRequest_Request_Redistribute_{}
				oneOfRes.Redistribute = redistributeMask.Project(asOneOf.Redistribute)
				result.Request = oneOfRes
			}
		}
	}
	if wholeUnassignAccepted == false && len(unassignMask.Paths) > 0 {
		if asOneOf, ok := source.Request.(*PlanAssignmentRequest_Request_Unassign_); ok {
			result.Request = (*PlanAssignmentRequest_Request_Unassign_)(nil)
			if asOneOf != nil {
				oneOfRes := &PlanAssignmentRequest_Request_Unassign_{}
				oneOfRes.Unassign = unassignMask.Project(asOneOf.Unassign)
				result.Request = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_Request))
}

func (fieldMask *PlanAssignmentRequest_Request_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_Request_Assign_FieldMask struct {
	Paths []PlanAssignmentRequestRequestAssign_FieldPath
}

func FullPlanAssignmentRequest_Request_Assign_FieldMask() *PlanAssignmentRequest_Request_Assign_FieldMask {
	res := &PlanAssignmentRequest_Request_Assign_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestAssign_FieldTerminalPath{selector: PlanAssignmentRequestRequestAssign_FieldPathSelectorPlan})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestAssign_FieldTerminalPath{selector: PlanAssignmentRequestRequestAssign_FieldPathSelectorExtensions})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestAssign_FieldTerminalPath{selector: PlanAssignmentRequestRequestAssign_FieldPathSelectorRegionalDistributions})
	return res
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePlanAssignmentRequestRequestAssign_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestAssign_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestAssign_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) Subtract(other *PlanAssignmentRequest_Request_Assign_FieldMask) *PlanAssignmentRequest_Request_Assign_FieldMask {
	result := &PlanAssignmentRequest_Request_Assign_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[PlanAssignmentRequestRequestAssign_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestAssign_FieldPathSelectorExtensions:            &common.Allowance_FieldMask{},
		PlanAssignmentRequestRequestAssign_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequestRequestAssign_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestAssign_FieldPathSelectorExtensions:            &common.Allowance_FieldMask{},
		PlanAssignmentRequestRequestAssign_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestAssign_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequestRequestAssign_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequestRequestAssign_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequestRequestAssign_FieldPathSelectorExtensions:
						mySubMasks[PlanAssignmentRequestRequestAssign_FieldPathSelectorExtensions] = common.FullAllowance_FieldMask()
					case PlanAssignmentRequestRequestAssign_FieldPathSelectorRegionalDistributions:
						mySubMasks[PlanAssignmentRequestRequestAssign_FieldPathSelectorRegionalDistributions] = common.FullRegionalDistribution_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequestRequestAssign_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequestRequestAssign_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_Request_Assign_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) FilterInputFields() *PlanAssignmentRequest_Request_Assign_FieldMask {
	result := &PlanAssignmentRequest_Request_Assign_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestAssign_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestAssign_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_Request_Assign_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_Request_Assign_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) AppendPath(path PlanAssignmentRequestRequestAssign_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestAssign_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) GetPaths() []PlanAssignmentRequestRequestAssign_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestAssign_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) Set(target, source *PlanAssignmentRequest_Request_Assign) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_Request_Assign), source.(*PlanAssignmentRequest_Request_Assign))
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) Project(source *PlanAssignmentRequest_Request_Assign) *PlanAssignmentRequest_Request_Assign {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_Request_Assign{}
	extensionsMask := &common.Allowance_FieldMask{}
	wholeExtensionsAccepted := false
	regionalDistributionsMask := &common.RegionalDistribution_FieldMask{}
	wholeRegionalDistributionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestAssign_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestAssign_FieldPathSelectorPlan:
				result.Plan = source.Plan
			case PlanAssignmentRequestRequestAssign_FieldPathSelectorExtensions:
				result.Extensions = source.Extensions
				wholeExtensionsAccepted = true
			case PlanAssignmentRequestRequestAssign_FieldPathSelectorRegionalDistributions:
				result.RegionalDistributions = source.RegionalDistributions
				wholeRegionalDistributionsAccepted = true
			}
		case *PlanAssignmentRequestRequestAssign_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestAssign_FieldPathSelectorExtensions:
				extensionsMask.AppendPath(tp.subPath.(common.Allowance_FieldPath))
			case PlanAssignmentRequestRequestAssign_FieldPathSelectorRegionalDistributions:
				regionalDistributionsMask.AppendPath(tp.subPath.(common.RegionalDistribution_FieldPath))
			}
		}
	}
	if wholeExtensionsAccepted == false && len(extensionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetExtensions() {
			result.Extensions = append(result.Extensions, extensionsMask.Project(sourceItem))
		}
	}
	if wholeRegionalDistributionsAccepted == false && len(regionalDistributionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetRegionalDistributions() {
			result.RegionalDistributions = append(result.RegionalDistributions, regionalDistributionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_Request_Assign))
}

func (fieldMask *PlanAssignmentRequest_Request_Assign_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_Request_Extend_FieldMask struct {
	Paths []PlanAssignmentRequestRequestExtend_FieldPath
}

func FullPlanAssignmentRequest_Request_Extend_FieldMask() *PlanAssignmentRequest_Request_Extend_FieldMask {
	res := &PlanAssignmentRequest_Request_Extend_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestExtend_FieldTerminalPath{selector: PlanAssignmentRequestRequestExtend_FieldPathSelectorAssignment})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestExtend_FieldTerminalPath{selector: PlanAssignmentRequestRequestExtend_FieldPathSelectorAdditions})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestExtend_FieldTerminalPath{selector: PlanAssignmentRequestRequestExtend_FieldPathSelectorRegionalDistributions})
	return res
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePlanAssignmentRequestRequestExtend_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestExtend_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestExtend_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) Subtract(other *PlanAssignmentRequest_Request_Extend_FieldMask) *PlanAssignmentRequest_Request_Extend_FieldMask {
	result := &PlanAssignmentRequest_Request_Extend_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[PlanAssignmentRequestRequestExtend_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestExtend_FieldPathSelectorAdditions:             &common.Allowance_FieldMask{},
		PlanAssignmentRequestRequestExtend_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequestRequestExtend_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestExtend_FieldPathSelectorAdditions:             &common.Allowance_FieldMask{},
		PlanAssignmentRequestRequestExtend_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestExtend_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequestRequestExtend_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequestRequestExtend_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequestRequestExtend_FieldPathSelectorAdditions:
						mySubMasks[PlanAssignmentRequestRequestExtend_FieldPathSelectorAdditions] = common.FullAllowance_FieldMask()
					case PlanAssignmentRequestRequestExtend_FieldPathSelectorRegionalDistributions:
						mySubMasks[PlanAssignmentRequestRequestExtend_FieldPathSelectorRegionalDistributions] = common.FullRegionalDistribution_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequestRequestExtend_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequestRequestExtend_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_Request_Extend_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) FilterInputFields() *PlanAssignmentRequest_Request_Extend_FieldMask {
	result := &PlanAssignmentRequest_Request_Extend_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestExtend_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestExtend_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_Request_Extend_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_Request_Extend_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) AppendPath(path PlanAssignmentRequestRequestExtend_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestExtend_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) GetPaths() []PlanAssignmentRequestRequestExtend_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestExtend_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) Set(target, source *PlanAssignmentRequest_Request_Extend) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_Request_Extend), source.(*PlanAssignmentRequest_Request_Extend))
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) Project(source *PlanAssignmentRequest_Request_Extend) *PlanAssignmentRequest_Request_Extend {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_Request_Extend{}
	additionsMask := &common.Allowance_FieldMask{}
	wholeAdditionsAccepted := false
	regionalDistributionsMask := &common.RegionalDistribution_FieldMask{}
	wholeRegionalDistributionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestExtend_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestExtend_FieldPathSelectorAssignment:
				result.Assignment = source.Assignment
			case PlanAssignmentRequestRequestExtend_FieldPathSelectorAdditions:
				result.Additions = source.Additions
				wholeAdditionsAccepted = true
			case PlanAssignmentRequestRequestExtend_FieldPathSelectorRegionalDistributions:
				result.RegionalDistributions = source.RegionalDistributions
				wholeRegionalDistributionsAccepted = true
			}
		case *PlanAssignmentRequestRequestExtend_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestExtend_FieldPathSelectorAdditions:
				additionsMask.AppendPath(tp.subPath.(common.Allowance_FieldPath))
			case PlanAssignmentRequestRequestExtend_FieldPathSelectorRegionalDistributions:
				regionalDistributionsMask.AppendPath(tp.subPath.(common.RegionalDistribution_FieldPath))
			}
		}
	}
	if wholeAdditionsAccepted == false && len(additionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetAdditions() {
			result.Additions = append(result.Additions, additionsMask.Project(sourceItem))
		}
	}
	if wholeRegionalDistributionsAccepted == false && len(regionalDistributionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetRegionalDistributions() {
			result.RegionalDistributions = append(result.RegionalDistributions, regionalDistributionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_Request_Extend))
}

func (fieldMask *PlanAssignmentRequest_Request_Extend_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_Request_Redistribute_FieldMask struct {
	Paths []PlanAssignmentRequestRequestRedistribute_FieldPath
}

func FullPlanAssignmentRequest_Request_Redistribute_FieldMask() *PlanAssignmentRequest_Request_Redistribute_FieldMask {
	res := &PlanAssignmentRequest_Request_Redistribute_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestRedistribute_FieldTerminalPath{selector: PlanAssignmentRequestRequestRedistribute_FieldPathSelectorAssignment})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestRedistribute_FieldTerminalPath{selector: PlanAssignmentRequestRequestRedistribute_FieldPathSelectorRegionalDistributions})
	return res
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePlanAssignmentRequestRequestRedistribute_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestRedistribute_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestRedistribute_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) Subtract(other *PlanAssignmentRequest_Request_Redistribute_FieldMask) *PlanAssignmentRequest_Request_Redistribute_FieldMask {
	result := &PlanAssignmentRequest_Request_Redistribute_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[PlanAssignmentRequestRequestRedistribute_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestRedistribute_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequestRequestRedistribute_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestRedistribute_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestRedistribute_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequestRequestRedistribute_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequestRequestRedistribute_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequestRequestRedistribute_FieldPathSelectorRegionalDistributions:
						mySubMasks[PlanAssignmentRequestRequestRedistribute_FieldPathSelectorRegionalDistributions] = common.FullRegionalDistribution_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequestRequestRedistribute_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequestRequestRedistribute_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_Request_Redistribute_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) FilterInputFields() *PlanAssignmentRequest_Request_Redistribute_FieldMask {
	result := &PlanAssignmentRequest_Request_Redistribute_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestRedistribute_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestRedistribute_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_Request_Redistribute_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_Request_Redistribute_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) AppendPath(path PlanAssignmentRequestRequestRedistribute_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestRedistribute_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) GetPaths() []PlanAssignmentRequestRequestRedistribute_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestRedistribute_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) Set(target, source *PlanAssignmentRequest_Request_Redistribute) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_Request_Redistribute), source.(*PlanAssignmentRequest_Request_Redistribute))
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) Project(source *PlanAssignmentRequest_Request_Redistribute) *PlanAssignmentRequest_Request_Redistribute {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_Request_Redistribute{}
	regionalDistributionsMask := &common.RegionalDistribution_FieldMask{}
	wholeRegionalDistributionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestRedistribute_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestRedistribute_FieldPathSelectorAssignment:
				result.Assignment = source.Assignment
			case PlanAssignmentRequestRequestRedistribute_FieldPathSelectorRegionalDistributions:
				result.RegionalDistributions = source.RegionalDistributions
				wholeRegionalDistributionsAccepted = true
			}
		case *PlanAssignmentRequestRequestRedistribute_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestRedistribute_FieldPathSelectorRegionalDistributions:
				regionalDistributionsMask.AppendPath(tp.subPath.(common.RegionalDistribution_FieldPath))
			}
		}
	}
	if wholeRegionalDistributionsAccepted == false && len(regionalDistributionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetRegionalDistributions() {
			result.RegionalDistributions = append(result.RegionalDistributions, regionalDistributionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_Request_Redistribute))
}

func (fieldMask *PlanAssignmentRequest_Request_Redistribute_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_Request_Unassign_FieldMask struct {
	Paths []PlanAssignmentRequestRequestUnassign_FieldPath
}

func FullPlanAssignmentRequest_Request_Unassign_FieldMask() *PlanAssignmentRequest_Request_Unassign_FieldMask {
	res := &PlanAssignmentRequest_Request_Unassign_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestUnassign_FieldTerminalPath{selector: PlanAssignmentRequestRequestUnassign_FieldPathSelectorAssignment})
	return res
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParsePlanAssignmentRequestRequestUnassign_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestUnassign_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestUnassign_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) Subtract(other *PlanAssignmentRequest_Request_Unassign_FieldMask) *PlanAssignmentRequest_Request_Unassign_FieldMask {
	result := &PlanAssignmentRequest_Request_Unassign_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestUnassign_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_Request_Unassign_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) FilterInputFields() *PlanAssignmentRequest_Request_Unassign_FieldMask {
	result := &PlanAssignmentRequest_Request_Unassign_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestUnassign_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestUnassign_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_Request_Unassign_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_Request_Unassign_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) AppendPath(path PlanAssignmentRequestRequestUnassign_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestUnassign_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) GetPaths() []PlanAssignmentRequestRequestUnassign_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestUnassign_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) Set(target, source *PlanAssignmentRequest_Request_Unassign) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_Request_Unassign), source.(*PlanAssignmentRequest_Request_Unassign))
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) Project(source *PlanAssignmentRequest_Request_Unassign) *PlanAssignmentRequest_Request_Unassign {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_Request_Unassign{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestUnassign_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestUnassign_FieldPathSelectorAssignment:
				result.Assignment = source.Assignment
			}
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_Request_Unassign))
}

func (fieldMask *PlanAssignmentRequest_Request_Unassign_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
