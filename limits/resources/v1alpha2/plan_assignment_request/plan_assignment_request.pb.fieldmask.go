// Code generated by protoc-gen-goten-object
// File: edgelq/limits/proto/v1alpha2/plan_assignment_request.proto
// DO NOT EDIT!!!

package plan_assignment_request

import (
	"encoding/json"
	"strings"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	iam_organization "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/organization"
	iam_project "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/project"
	common "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/common"
	plan "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/plan"
	plan_assignment "github.com/cloudwan/edgelq-sdk/limits/resources/v1alpha2/plan_assignment"
	meta_service "github.com/cloudwan/edgelq-sdk/meta/resources/v1alpha2/service"
	meta "github.com/cloudwan/goten-sdk/types/meta"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &iam_organization.Organization{}
	_ = &iam_project.Project{}
	_ = &common.Allowance{}
	_ = &plan.Plan{}
	_ = &plan_assignment.PlanAssignment{}
	_ = &meta_service.Service{}
	_ = &meta.Meta{}
)

type PlanAssignmentRequest_FieldMask struct {
	Paths []PlanAssignmentRequest_FieldPath
}

func FullPlanAssignmentRequest_FieldMask() *PlanAssignmentRequest_FieldMask {
	res := &PlanAssignmentRequest_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorRequest})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorService})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorApprover})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorStatus})
	res.Paths = append(res.Paths, &PlanAssignmentRequest_FieldTerminalPath{selector: PlanAssignmentRequest_FieldPathSelectorMetadata})
	return res
}

func (fieldMask *PlanAssignmentRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PlanAssignmentRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequest_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Subtract(other *PlanAssignmentRequest_FieldMask) *PlanAssignmentRequest_FieldMask {
	result := &PlanAssignmentRequest_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[PlanAssignmentRequest_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequest_FieldPathSelectorRequest:  &PlanAssignmentRequest_RequestType_FieldMask{},
		PlanAssignmentRequest_FieldPathSelectorStatus:   &PlanAssignmentRequest_Status_FieldMask{},
		PlanAssignmentRequest_FieldPathSelectorMetadata: &meta.Meta_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequest_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequest_FieldPathSelectorRequest:  &PlanAssignmentRequest_RequestType_FieldMask{},
		PlanAssignmentRequest_FieldPathSelectorStatus:   &PlanAssignmentRequest_Status_FieldMask{},
		PlanAssignmentRequest_FieldPathSelectorMetadata: &meta.Meta_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequest_FieldPathSelectorRequest:
						mySubMasks[PlanAssignmentRequest_FieldPathSelectorRequest] = FullPlanAssignmentRequest_RequestType_FieldMask()
					case PlanAssignmentRequest_FieldPathSelectorStatus:
						mySubMasks[PlanAssignmentRequest_FieldPathSelectorStatus] = FullPlanAssignmentRequest_Status_FieldMask()
					case PlanAssignmentRequest_FieldPathSelectorMetadata:
						mySubMasks[PlanAssignmentRequest_FieldPathSelectorMetadata] = meta.FullMeta_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_FieldMask) FilterInputFields() *PlanAssignmentRequest_FieldMask {
	result := &PlanAssignmentRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case PlanAssignmentRequest_FieldPathSelectorService:
		case PlanAssignmentRequest_FieldPathSelectorApprover:
		case PlanAssignmentRequest_FieldPathSelectorStatus:
		case PlanAssignmentRequest_FieldPathSelectorMetadata:
			if _, ok := path.(*PlanAssignmentRequest_FieldTerminalPath); ok {
				for _, subpath := range meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &PlanAssignmentRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*PlanAssignmentRequest_FieldSubPath); ok {
				selectedMask := &meta.Meta_FieldMask{
					Paths: []meta.Meta_FieldPath{sub.subPath.(meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &PlanAssignmentRequest_FieldSubPath{selector: PlanAssignmentRequest_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_FieldMask) AppendPath(path PlanAssignmentRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequest_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_FieldMask) GetPaths() []PlanAssignmentRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Set(target, source *PlanAssignmentRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest), source.(*PlanAssignmentRequest))
}

func (fieldMask *PlanAssignmentRequest_FieldMask) Project(source *PlanAssignmentRequest) *PlanAssignmentRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest{}
	requestMask := &PlanAssignmentRequest_RequestType_FieldMask{}
	wholeRequestAccepted := false
	statusMask := &PlanAssignmentRequest_Status_FieldMask{}
	wholeStatusAccepted := false
	metadataMask := &meta.Meta_FieldMask{}
	wholeMetadataAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequest_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequest_FieldPathSelectorName:
				result.Name = source.Name
			case PlanAssignmentRequest_FieldPathSelectorRequest:
				result.Request = source.Request
				wholeRequestAccepted = true
			case PlanAssignmentRequest_FieldPathSelectorService:
				result.Service = source.Service
			case PlanAssignmentRequest_FieldPathSelectorApprover:
				result.Approver = source.Approver
			case PlanAssignmentRequest_FieldPathSelectorStatus:
				result.Status = source.Status
				wholeStatusAccepted = true
			case PlanAssignmentRequest_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			}
		case *PlanAssignmentRequest_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequest_FieldPathSelectorRequest:
				requestMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestType_FieldPath))
			case PlanAssignmentRequest_FieldPathSelectorStatus:
				statusMask.AppendPath(tp.subPath.(PlanAssignmentRequestStatus_FieldPath))
			case PlanAssignmentRequest_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(meta.Meta_FieldPath))
			}
		}
	}
	if wholeRequestAccepted == false && len(requestMask.Paths) > 0 {
		result.Request = requestMask.Project(source.GetRequest())
	}
	if wholeStatusAccepted == false && len(statusMask.Paths) > 0 {
		result.Status = statusMask.Project(source.GetStatus())
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest))
}

func (fieldMask *PlanAssignmentRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_Status_FieldMask struct {
	Paths []PlanAssignmentRequestStatus_FieldPath
}

func FullPlanAssignmentRequest_Status_FieldMask() *PlanAssignmentRequest_Status_FieldMask {
	res := &PlanAssignmentRequest_Status_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestStatus_FieldTerminalPath{selector: PlanAssignmentRequestStatus_FieldPathSelectorConclusion})
	res.Paths = append(res.Paths, &PlanAssignmentRequestStatus_FieldTerminalPath{selector: PlanAssignmentRequestStatus_FieldPathSelectorReason})
	return res
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestStatus_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestStatus_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Subtract(other *PlanAssignmentRequest_Status_FieldMask) *PlanAssignmentRequest_Status_FieldMask {
	result := &PlanAssignmentRequest_Status_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestStatus_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_Status_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_Status_FieldMask) FilterInputFields() *PlanAssignmentRequest_Status_FieldMask {
	result := &PlanAssignmentRequest_Status_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_Status_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestStatus_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestStatus_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_Status_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_Status_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) AppendPath(path PlanAssignmentRequestStatus_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestStatus_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) GetPaths() []PlanAssignmentRequestStatus_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestStatus_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Set(target, source *PlanAssignmentRequest_Status) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_Status), source.(*PlanAssignmentRequest_Status))
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) Project(source *PlanAssignmentRequest_Status) *PlanAssignmentRequest_Status {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_Status{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestStatus_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestStatus_FieldPathSelectorConclusion:
				result.Conclusion = source.Conclusion
			case PlanAssignmentRequestStatus_FieldPathSelectorReason:
				result.Reason = source.Reason
			}
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_Status))
}

func (fieldMask *PlanAssignmentRequest_Status_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_RequestType_FieldMask struct {
	Paths []PlanAssignmentRequestRequestType_FieldPath
}

func FullPlanAssignmentRequest_RequestType_FieldMask() *PlanAssignmentRequest_RequestType_FieldMask {
	res := &PlanAssignmentRequest_RequestType_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestType_FieldTerminalPath{selector: PlanAssignmentRequestRequestType_FieldPathSelectorAssign})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestType_FieldTerminalPath{selector: PlanAssignmentRequestRequestType_FieldPathSelectorExtend})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestType_FieldTerminalPath{selector: PlanAssignmentRequestRequestType_FieldPathSelectorRedistribute})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestType_FieldTerminalPath{selector: PlanAssignmentRequestRequestType_FieldPathSelectorUnassign})
	return res
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestType_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestType_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) Subtract(other *PlanAssignmentRequest_RequestType_FieldMask) *PlanAssignmentRequest_RequestType_FieldMask {
	result := &PlanAssignmentRequest_RequestType_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[PlanAssignmentRequestRequestType_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestType_FieldPathSelectorAssign:       &PlanAssignmentRequest_RequestType_Assign_FieldMask{},
		PlanAssignmentRequestRequestType_FieldPathSelectorExtend:       &PlanAssignmentRequest_RequestType_Extend_FieldMask{},
		PlanAssignmentRequestRequestType_FieldPathSelectorRedistribute: &PlanAssignmentRequest_RequestType_Redistribute_FieldMask{},
		PlanAssignmentRequestRequestType_FieldPathSelectorUnassign:     &PlanAssignmentRequest_RequestType_Unassign_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequestRequestType_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestType_FieldPathSelectorAssign:       &PlanAssignmentRequest_RequestType_Assign_FieldMask{},
		PlanAssignmentRequestRequestType_FieldPathSelectorExtend:       &PlanAssignmentRequest_RequestType_Extend_FieldMask{},
		PlanAssignmentRequestRequestType_FieldPathSelectorRedistribute: &PlanAssignmentRequest_RequestType_Redistribute_FieldMask{},
		PlanAssignmentRequestRequestType_FieldPathSelectorUnassign:     &PlanAssignmentRequest_RequestType_Unassign_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestType_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequestRequestType_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequestRequestType_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequestRequestType_FieldPathSelectorAssign:
						mySubMasks[PlanAssignmentRequestRequestType_FieldPathSelectorAssign] = FullPlanAssignmentRequest_RequestType_Assign_FieldMask()
					case PlanAssignmentRequestRequestType_FieldPathSelectorExtend:
						mySubMasks[PlanAssignmentRequestRequestType_FieldPathSelectorExtend] = FullPlanAssignmentRequest_RequestType_Extend_FieldMask()
					case PlanAssignmentRequestRequestType_FieldPathSelectorRedistribute:
						mySubMasks[PlanAssignmentRequestRequestType_FieldPathSelectorRedistribute] = FullPlanAssignmentRequest_RequestType_Redistribute_FieldMask()
					case PlanAssignmentRequestRequestType_FieldPathSelectorUnassign:
						mySubMasks[PlanAssignmentRequestRequestType_FieldPathSelectorUnassign] = FullPlanAssignmentRequest_RequestType_Unassign_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequestRequestType_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequestRequestType_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_RequestType_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) FilterInputFields() *PlanAssignmentRequest_RequestType_FieldMask {
	result := &PlanAssignmentRequest_RequestType_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestType_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestType_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_RequestType_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_RequestType_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) AppendPath(path PlanAssignmentRequestRequestType_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestType_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) GetPaths() []PlanAssignmentRequestRequestType_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestType_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) Set(target, source *PlanAssignmentRequest_RequestType) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_RequestType), source.(*PlanAssignmentRequest_RequestType))
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) Project(source *PlanAssignmentRequest_RequestType) *PlanAssignmentRequest_RequestType {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_RequestType{}
	assignMask := &PlanAssignmentRequest_RequestType_Assign_FieldMask{}
	wholeAssignAccepted := false
	extendMask := &PlanAssignmentRequest_RequestType_Extend_FieldMask{}
	wholeExtendAccepted := false
	redistributeMask := &PlanAssignmentRequest_RequestType_Redistribute_FieldMask{}
	wholeRedistributeAccepted := false
	unassignMask := &PlanAssignmentRequest_RequestType_Unassign_FieldMask{}
	wholeUnassignAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestType_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestType_FieldPathSelectorAssign:
				if source, ok := source.Request.(*PlanAssignmentRequest_RequestType_Assign_); ok {
					result.Request = &PlanAssignmentRequest_RequestType_Assign_{
						Assign: source.Assign,
					}
				}
				wholeAssignAccepted = true
			case PlanAssignmentRequestRequestType_FieldPathSelectorExtend:
				if source, ok := source.Request.(*PlanAssignmentRequest_RequestType_Extend_); ok {
					result.Request = &PlanAssignmentRequest_RequestType_Extend_{
						Extend: source.Extend,
					}
				}
				wholeExtendAccepted = true
			case PlanAssignmentRequestRequestType_FieldPathSelectorRedistribute:
				if source, ok := source.Request.(*PlanAssignmentRequest_RequestType_Redistribute_); ok {
					result.Request = &PlanAssignmentRequest_RequestType_Redistribute_{
						Redistribute: source.Redistribute,
					}
				}
				wholeRedistributeAccepted = true
			case PlanAssignmentRequestRequestType_FieldPathSelectorUnassign:
				if source, ok := source.Request.(*PlanAssignmentRequest_RequestType_Unassign_); ok {
					result.Request = &PlanAssignmentRequest_RequestType_Unassign_{
						Unassign: source.Unassign,
					}
				}
				wholeUnassignAccepted = true
			}
		case *PlanAssignmentRequestRequestType_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestType_FieldPathSelectorAssign:
				assignMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestTypeAssign_FieldPath))
			case PlanAssignmentRequestRequestType_FieldPathSelectorExtend:
				extendMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestTypeExtend_FieldPath))
			case PlanAssignmentRequestRequestType_FieldPathSelectorRedistribute:
				redistributeMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestTypeRedistribute_FieldPath))
			case PlanAssignmentRequestRequestType_FieldPathSelectorUnassign:
				unassignMask.AppendPath(tp.subPath.(PlanAssignmentRequestRequestTypeUnassign_FieldPath))
			}
		}
	}
	if wholeAssignAccepted == false && len(assignMask.Paths) > 0 {
		if asOneOf, ok := source.Request.(*PlanAssignmentRequest_RequestType_Assign_); ok {
			result.Request = (*PlanAssignmentRequest_RequestType_Assign_)(nil)
			if asOneOf != nil {
				oneOfRes := &PlanAssignmentRequest_RequestType_Assign_{}
				oneOfRes.Assign = assignMask.Project(asOneOf.Assign)
				result.Request = oneOfRes
			}
		}
	}
	if wholeExtendAccepted == false && len(extendMask.Paths) > 0 {
		if asOneOf, ok := source.Request.(*PlanAssignmentRequest_RequestType_Extend_); ok {
			result.Request = (*PlanAssignmentRequest_RequestType_Extend_)(nil)
			if asOneOf != nil {
				oneOfRes := &PlanAssignmentRequest_RequestType_Extend_{}
				oneOfRes.Extend = extendMask.Project(asOneOf.Extend)
				result.Request = oneOfRes
			}
		}
	}
	if wholeRedistributeAccepted == false && len(redistributeMask.Paths) > 0 {
		if asOneOf, ok := source.Request.(*PlanAssignmentRequest_RequestType_Redistribute_); ok {
			result.Request = (*PlanAssignmentRequest_RequestType_Redistribute_)(nil)
			if asOneOf != nil {
				oneOfRes := &PlanAssignmentRequest_RequestType_Redistribute_{}
				oneOfRes.Redistribute = redistributeMask.Project(asOneOf.Redistribute)
				result.Request = oneOfRes
			}
		}
	}
	if wholeUnassignAccepted == false && len(unassignMask.Paths) > 0 {
		if asOneOf, ok := source.Request.(*PlanAssignmentRequest_RequestType_Unassign_); ok {
			result.Request = (*PlanAssignmentRequest_RequestType_Unassign_)(nil)
			if asOneOf != nil {
				oneOfRes := &PlanAssignmentRequest_RequestType_Unassign_{}
				oneOfRes.Unassign = unassignMask.Project(asOneOf.Unassign)
				result.Request = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_RequestType))
}

func (fieldMask *PlanAssignmentRequest_RequestType_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_RequestType_Assign_FieldMask struct {
	Paths []PlanAssignmentRequestRequestTypeAssign_FieldPath
}

func FullPlanAssignmentRequest_RequestType_Assign_FieldMask() *PlanAssignmentRequest_RequestType_Assign_FieldMask {
	res := &PlanAssignmentRequest_RequestType_Assign_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeAssign_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorPlan})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeAssign_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorExtensions})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeAssign_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorRegionalDistributions})
	return res
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestTypeAssign_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestTypeAssign_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) Subtract(other *PlanAssignmentRequest_RequestType_Assign_FieldMask) *PlanAssignmentRequest_RequestType_Assign_FieldMask {
	result := &PlanAssignmentRequest_RequestType_Assign_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[PlanAssignmentRequestRequestTypeAssign_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorExtensions:            &common.Allowance_FieldMask{},
		PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequestRequestTypeAssign_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorExtensions:            &common.Allowance_FieldMask{},
		PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestTypeAssign_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequestRequestTypeAssign_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequestRequestTypeAssign_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorExtensions:
						mySubMasks[PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorExtensions] = common.FullAllowance_FieldMask()
					case PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorRegionalDistributions:
						mySubMasks[PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorRegionalDistributions] = common.FullRegionalDistribution_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequestRequestTypeAssign_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequestRequestTypeAssign_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_RequestType_Assign_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) FilterInputFields() *PlanAssignmentRequest_RequestType_Assign_FieldMask {
	result := &PlanAssignmentRequest_RequestType_Assign_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestTypeAssign_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestTypeAssign_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_RequestType_Assign_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_RequestType_Assign_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) AppendPath(path PlanAssignmentRequestRequestTypeAssign_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestTypeAssign_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) GetPaths() []PlanAssignmentRequestRequestTypeAssign_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestTypeAssign_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) Set(target, source *PlanAssignmentRequest_RequestType_Assign) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_RequestType_Assign), source.(*PlanAssignmentRequest_RequestType_Assign))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) Project(source *PlanAssignmentRequest_RequestType_Assign) *PlanAssignmentRequest_RequestType_Assign {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_RequestType_Assign{}
	extensionsMask := &common.Allowance_FieldMask{}
	wholeExtensionsAccepted := false
	regionalDistributionsMask := &common.RegionalDistribution_FieldMask{}
	wholeRegionalDistributionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestTypeAssign_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorPlan:
				result.Plan = source.Plan
			case PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorExtensions:
				result.Extensions = source.Extensions
				wholeExtensionsAccepted = true
			case PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorRegionalDistributions:
				result.RegionalDistributions = source.RegionalDistributions
				wholeRegionalDistributionsAccepted = true
			}
		case *PlanAssignmentRequestRequestTypeAssign_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorExtensions:
				extensionsMask.AppendPath(tp.subPath.(common.Allowance_FieldPath))
			case PlanAssignmentRequestRequestTypeAssign_FieldPathSelectorRegionalDistributions:
				regionalDistributionsMask.AppendPath(tp.subPath.(common.RegionalDistribution_FieldPath))
			}
		}
	}
	if wholeExtensionsAccepted == false && len(extensionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetExtensions() {
			result.Extensions = append(result.Extensions, extensionsMask.Project(sourceItem))
		}
	}
	if wholeRegionalDistributionsAccepted == false && len(regionalDistributionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetRegionalDistributions() {
			result.RegionalDistributions = append(result.RegionalDistributions, regionalDistributionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_RequestType_Assign))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Assign_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_RequestType_Extend_FieldMask struct {
	Paths []PlanAssignmentRequestRequestTypeExtend_FieldPath
}

func FullPlanAssignmentRequest_RequestType_Extend_FieldMask() *PlanAssignmentRequest_RequestType_Extend_FieldMask {
	res := &PlanAssignmentRequest_RequestType_Extend_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeExtend_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAssignment})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeExtend_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAdditions})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeExtend_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorRegionalDistributions})
	return res
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestTypeExtend_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestTypeExtend_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) Subtract(other *PlanAssignmentRequest_RequestType_Extend_FieldMask) *PlanAssignmentRequest_RequestType_Extend_FieldMask {
	result := &PlanAssignmentRequest_RequestType_Extend_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[PlanAssignmentRequestRequestTypeExtend_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAdditions:             &common.Allowance_FieldMask{},
		PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequestRequestTypeExtend_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAdditions:             &common.Allowance_FieldMask{},
		PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestTypeExtend_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequestRequestTypeExtend_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequestRequestTypeExtend_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAdditions:
						mySubMasks[PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAdditions] = common.FullAllowance_FieldMask()
					case PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorRegionalDistributions:
						mySubMasks[PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorRegionalDistributions] = common.FullRegionalDistribution_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequestRequestTypeExtend_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequestRequestTypeExtend_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_RequestType_Extend_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) FilterInputFields() *PlanAssignmentRequest_RequestType_Extend_FieldMask {
	result := &PlanAssignmentRequest_RequestType_Extend_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestTypeExtend_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestTypeExtend_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_RequestType_Extend_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_RequestType_Extend_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) AppendPath(path PlanAssignmentRequestRequestTypeExtend_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestTypeExtend_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) GetPaths() []PlanAssignmentRequestRequestTypeExtend_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestTypeExtend_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) Set(target, source *PlanAssignmentRequest_RequestType_Extend) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_RequestType_Extend), source.(*PlanAssignmentRequest_RequestType_Extend))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) Project(source *PlanAssignmentRequest_RequestType_Extend) *PlanAssignmentRequest_RequestType_Extend {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_RequestType_Extend{}
	additionsMask := &common.Allowance_FieldMask{}
	wholeAdditionsAccepted := false
	regionalDistributionsMask := &common.RegionalDistribution_FieldMask{}
	wholeRegionalDistributionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestTypeExtend_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAssignment:
				result.Assignment = source.Assignment
			case PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAdditions:
				result.Additions = source.Additions
				wholeAdditionsAccepted = true
			case PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorRegionalDistributions:
				result.RegionalDistributions = source.RegionalDistributions
				wholeRegionalDistributionsAccepted = true
			}
		case *PlanAssignmentRequestRequestTypeExtend_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorAdditions:
				additionsMask.AppendPath(tp.subPath.(common.Allowance_FieldPath))
			case PlanAssignmentRequestRequestTypeExtend_FieldPathSelectorRegionalDistributions:
				regionalDistributionsMask.AppendPath(tp.subPath.(common.RegionalDistribution_FieldPath))
			}
		}
	}
	if wholeAdditionsAccepted == false && len(additionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetAdditions() {
			result.Additions = append(result.Additions, additionsMask.Project(sourceItem))
		}
	}
	if wholeRegionalDistributionsAccepted == false && len(regionalDistributionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetRegionalDistributions() {
			result.RegionalDistributions = append(result.RegionalDistributions, regionalDistributionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_RequestType_Extend))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Extend_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_RequestType_Redistribute_FieldMask struct {
	Paths []PlanAssignmentRequestRequestTypeRedistribute_FieldPath
}

func FullPlanAssignmentRequest_RequestType_Redistribute_FieldMask() *PlanAssignmentRequest_RequestType_Redistribute_FieldMask {
	res := &PlanAssignmentRequest_RequestType_Redistribute_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeRedistribute_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorAssignment})
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeRedistribute_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorRegionalDistributions})
	return res
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestTypeRedistribute_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestTypeRedistribute_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) Subtract(other *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) *PlanAssignmentRequest_RequestType_Redistribute_FieldMask {
	result := &PlanAssignmentRequest_RequestType_Redistribute_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}
	mySubMasks := map[PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelector]gotenobject.FieldMask{
		PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorRegionalDistributions: &common.RegionalDistribution_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestTypeRedistribute_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PlanAssignmentRequestRequestTypeRedistribute_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PlanAssignmentRequestRequestTypeRedistribute_FieldTerminalPath); ok {
					switch tp.selector {
					case PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorRegionalDistributions:
						mySubMasks[PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorRegionalDistributions] = common.FullRegionalDistribution_FieldMask()
					}
				} else if tp, ok := path.(*PlanAssignmentRequestRequestTypeRedistribute_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PlanAssignmentRequestRequestTypeRedistribute_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_RequestType_Redistribute_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) FilterInputFields() *PlanAssignmentRequest_RequestType_Redistribute_FieldMask {
	result := &PlanAssignmentRequest_RequestType_Redistribute_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestTypeRedistribute_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestTypeRedistribute_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_RequestType_Redistribute_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_RequestType_Redistribute_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) AppendPath(path PlanAssignmentRequestRequestTypeRedistribute_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestTypeRedistribute_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) GetPaths() []PlanAssignmentRequestRequestTypeRedistribute_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestTypeRedistribute_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) Set(target, source *PlanAssignmentRequest_RequestType_Redistribute) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_RequestType_Redistribute), source.(*PlanAssignmentRequest_RequestType_Redistribute))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) Project(source *PlanAssignmentRequest_RequestType_Redistribute) *PlanAssignmentRequest_RequestType_Redistribute {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_RequestType_Redistribute{}
	regionalDistributionsMask := &common.RegionalDistribution_FieldMask{}
	wholeRegionalDistributionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestTypeRedistribute_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorAssignment:
				result.Assignment = source.Assignment
			case PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorRegionalDistributions:
				result.RegionalDistributions = source.RegionalDistributions
				wholeRegionalDistributionsAccepted = true
			}
		case *PlanAssignmentRequestRequestTypeRedistribute_FieldSubPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestTypeRedistribute_FieldPathSelectorRegionalDistributions:
				regionalDistributionsMask.AppendPath(tp.subPath.(common.RegionalDistribution_FieldPath))
			}
		}
	}
	if wholeRegionalDistributionsAccepted == false && len(regionalDistributionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetRegionalDistributions() {
			result.RegionalDistributions = append(result.RegionalDistributions, regionalDistributionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_RequestType_Redistribute))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Redistribute_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PlanAssignmentRequest_RequestType_Unassign_FieldMask struct {
	Paths []PlanAssignmentRequestRequestTypeUnassign_FieldPath
}

func FullPlanAssignmentRequest_RequestType_Unassign_FieldMask() *PlanAssignmentRequest_RequestType_Unassign_FieldMask {
	res := &PlanAssignmentRequest_RequestType_Unassign_FieldMask{}
	res.Paths = append(res.Paths, &PlanAssignmentRequestRequestTypeUnassign_FieldTerminalPath{selector: PlanAssignmentRequestRequestTypeUnassign_FieldPathSelectorAssignment})
	return res
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PlanAssignmentRequestRequestTypeUnassign_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePlanAssignmentRequestRequestTypeUnassign_FieldPath(raw)
	})
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) ProtoMessage() {}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) Subtract(other *PlanAssignmentRequest_RequestType_Unassign_FieldMask) *PlanAssignmentRequest_RequestType_Unassign_FieldMask {
	result := &PlanAssignmentRequest_RequestType_Unassign_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PlanAssignmentRequestRequestTypeUnassign_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PlanAssignmentRequest_RequestType_Unassign_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) FilterInputFields() *PlanAssignmentRequest_RequestType_Unassign_FieldMask {
	result := &PlanAssignmentRequest_RequestType_Unassign_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PlanAssignmentRequestRequestTypeUnassign_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePlanAssignmentRequestRequestTypeUnassign_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PlanAssignmentRequest_RequestType_Unassign_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PlanAssignmentRequest_RequestType_Unassign_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) AppendPath(path PlanAssignmentRequestRequestTypeUnassign_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PlanAssignmentRequestRequestTypeUnassign_FieldPath))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) GetPaths() []PlanAssignmentRequestRequestTypeUnassign_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePlanAssignmentRequestRequestTypeUnassign_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) Set(target, source *PlanAssignmentRequest_RequestType_Unassign) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PlanAssignmentRequest_RequestType_Unassign), source.(*PlanAssignmentRequest_RequestType_Unassign))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) Project(source *PlanAssignmentRequest_RequestType_Unassign) *PlanAssignmentRequest_RequestType_Unassign {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PlanAssignmentRequest_RequestType_Unassign{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PlanAssignmentRequestRequestTypeUnassign_FieldTerminalPath:
			switch tp.selector {
			case PlanAssignmentRequestRequestTypeUnassign_FieldPathSelectorAssignment:
				result.Assignment = source.Assignment
			}
		}
	}
	return result
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PlanAssignmentRequest_RequestType_Unassign))
}

func (fieldMask *PlanAssignmentRequest_RequestType_Unassign_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
