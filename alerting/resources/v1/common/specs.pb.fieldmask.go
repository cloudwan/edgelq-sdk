// Code generated by protoc-gen-goten-object
// File: edgelq/alerting/proto/v1/specs.proto
// DO NOT EDIT!!!

package rcommon

import (
	"encoding/json"
	"strings"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	logging_log "github.com/cloudwan/edgelq-sdk/logging/resources/v1/log"
	monitoring_common "github.com/cloudwan/edgelq-sdk/monitoring/resources/v4/common"
	monitoring_time_serie "github.com/cloudwan/edgelq-sdk/monitoring/resources/v4/time_serie"
	meta_resource "github.com/cloudwan/goten-sdk/meta-service/resources/v1/resource"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	fieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &logging_log.Log{}
	_ = &monitoring_common.LabelDescriptor{}
	_ = &monitoring_time_serie.Point{}
	_ = &durationpb.Duration{}
	_ = &fieldmaskpb.FieldMask{}
	_ = &meta_resource.Resource{}
)

type LogCndSpec_FieldMask struct {
	Paths []LogCndSpec_FieldPath
}

func FullLogCndSpec_FieldMask() *LogCndSpec_FieldMask {
	res := &LogCndSpec_FieldMask{}
	res.Paths = append(res.Paths, &LogCndSpec_FieldTerminalPath{selector: LogCndSpec_FieldPathSelectorQuery})
	res.Paths = append(res.Paths, &LogCndSpec_FieldTerminalPath{selector: LogCndSpec_FieldPathSelectorGroupByLabels})
	return res
}

func (fieldMask *LogCndSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *LogCndSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LogCndSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LogCndSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLogCndSpec_FieldPath(raw)
	})
}

func (fieldMask *LogCndSpec_FieldMask) ProtoMessage() {}

func (fieldMask *LogCndSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LogCndSpec_FieldMask) Subtract(other *LogCndSpec_FieldMask) *LogCndSpec_FieldMask {
	result := &LogCndSpec_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[LogCndSpec_FieldPathSelector]gotenobject.FieldMask{
		LogCndSpec_FieldPathSelectorQuery: &LogCndSpec_Query_FieldMask{},
	}
	mySubMasks := map[LogCndSpec_FieldPathSelector]gotenobject.FieldMask{
		LogCndSpec_FieldPathSelectorQuery: &LogCndSpec_Query_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LogCndSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *LogCndSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*LogCndSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case LogCndSpec_FieldPathSelectorQuery:
						mySubMasks[LogCndSpec_FieldPathSelectorQuery] = FullLogCndSpec_Query_FieldMask()
					}
				} else if tp, ok := path.(*LogCndSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &LogCndSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LogCndSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LogCndSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LogCndSpec_FieldMask) FilterInputFields() *LogCndSpec_FieldMask {
	result := &LogCndSpec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LogCndSpec_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LogCndSpec_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LogCndSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLogCndSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LogCndSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LogCndSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LogCndSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LogCndSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_FieldMask) AppendPath(path LogCndSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LogCndSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LogCndSpec_FieldPath))
}

func (fieldMask *LogCndSpec_FieldMask) GetPaths() []LogCndSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LogCndSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LogCndSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLogCndSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LogCndSpec_FieldMask) Set(target, source *LogCndSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LogCndSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LogCndSpec), source.(*LogCndSpec))
}

func (fieldMask *LogCndSpec_FieldMask) Project(source *LogCndSpec) *LogCndSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LogCndSpec{}
	queryMask := &LogCndSpec_Query_FieldMask{}
	wholeQueryAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LogCndSpec_FieldTerminalPath:
			switch tp.selector {
			case LogCndSpec_FieldPathSelectorQuery:
				result.Query = source.Query
				wholeQueryAccepted = true
			case LogCndSpec_FieldPathSelectorGroupByLabels:
				result.GroupByLabels = source.GroupByLabels
			}
		case *LogCndSpec_FieldSubPath:
			switch tp.selector {
			case LogCndSpec_FieldPathSelectorQuery:
				queryMask.AppendPath(tp.subPath.(LogCndSpecQuery_FieldPath))
			}
		}
	}
	if wholeQueryAccepted == false && len(queryMask.Paths) > 0 {
		result.Query = queryMask.Project(source.GetQuery())
	}
	return result
}

func (fieldMask *LogCndSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LogCndSpec))
}

func (fieldMask *LogCndSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type LogCndSpec_Query_FieldMask struct {
	Paths []LogCndSpecQuery_FieldPath
}

func FullLogCndSpec_Query_FieldMask() *LogCndSpec_Query_FieldMask {
	res := &LogCndSpec_Query_FieldMask{}
	res.Paths = append(res.Paths, &LogCndSpecQuery_FieldTerminalPath{selector: LogCndSpecQuery_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &LogCndSpecQuery_FieldTerminalPath{selector: LogCndSpecQuery_FieldPathSelectorTrigger})
	res.Paths = append(res.Paths, &LogCndSpecQuery_FieldTerminalPath{selector: LogCndSpecQuery_FieldPathSelectorMinDuration})
	return res
}

func (fieldMask *LogCndSpec_Query_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *LogCndSpec_Query_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LogCndSpecQuery_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LogCndSpec_Query_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLogCndSpecQuery_FieldPath(raw)
	})
}

func (fieldMask *LogCndSpec_Query_FieldMask) ProtoMessage() {}

func (fieldMask *LogCndSpec_Query_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LogCndSpec_Query_FieldMask) Subtract(other *LogCndSpec_Query_FieldMask) *LogCndSpec_Query_FieldMask {
	result := &LogCndSpec_Query_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LogCndSpecQuery_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LogCndSpec_Query_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LogCndSpec_Query_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LogCndSpec_Query_FieldMask) FilterInputFields() *LogCndSpec_Query_FieldMask {
	result := &LogCndSpec_Query_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LogCndSpec_Query_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LogCndSpec_Query_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LogCndSpecQuery_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLogCndSpecQuery_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LogCndSpec_Query_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LogCndSpec_Query_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_Query_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LogCndSpec_Query_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LogCndSpec_Query_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_Query_FieldMask) AppendPath(path LogCndSpecQuery_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LogCndSpec_Query_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LogCndSpecQuery_FieldPath))
}

func (fieldMask *LogCndSpec_Query_FieldMask) GetPaths() []LogCndSpecQuery_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LogCndSpec_Query_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LogCndSpec_Query_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLogCndSpecQuery_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LogCndSpec_Query_FieldMask) Set(target, source *LogCndSpec_Query) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LogCndSpec_Query_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LogCndSpec_Query), source.(*LogCndSpec_Query))
}

func (fieldMask *LogCndSpec_Query_FieldMask) Project(source *LogCndSpec_Query) *LogCndSpec_Query {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LogCndSpec_Query{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LogCndSpecQuery_FieldTerminalPath:
			switch tp.selector {
			case LogCndSpecQuery_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case LogCndSpecQuery_FieldPathSelectorTrigger:
				result.Trigger = source.Trigger
			case LogCndSpecQuery_FieldPathSelectorMinDuration:
				result.MinDuration = source.MinDuration
			}
		}
	}
	return result
}

func (fieldMask *LogCndSpec_Query_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LogCndSpec_Query))
}

func (fieldMask *LogCndSpec_Query_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type LogCndSpec_Query_LabelTrigger_FieldMask struct {
	Paths []LogCndSpecQueryLabelTrigger_FieldPath
}

func FullLogCndSpec_Query_LabelTrigger_FieldMask() *LogCndSpec_Query_LabelTrigger_FieldMask {
	res := &LogCndSpec_Query_LabelTrigger_FieldMask{}
	res.Paths = append(res.Paths, &LogCndSpecQueryLabelTrigger_FieldTerminalPath{selector: LogCndSpecQueryLabelTrigger_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &LogCndSpecQueryLabelTrigger_FieldTerminalPath{selector: LogCndSpecQueryLabelTrigger_FieldPathSelectorValues})
	return res
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LogCndSpecQueryLabelTrigger_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLogCndSpecQueryLabelTrigger_FieldPath(raw)
	})
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) ProtoMessage() {}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) Subtract(other *LogCndSpec_Query_LabelTrigger_FieldMask) *LogCndSpec_Query_LabelTrigger_FieldMask {
	result := &LogCndSpec_Query_LabelTrigger_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LogCndSpecQueryLabelTrigger_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LogCndSpec_Query_LabelTrigger_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) FilterInputFields() *LogCndSpec_Query_LabelTrigger_FieldMask {
	result := &LogCndSpec_Query_LabelTrigger_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LogCndSpecQueryLabelTrigger_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLogCndSpecQueryLabelTrigger_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LogCndSpec_Query_LabelTrigger_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LogCndSpec_Query_LabelTrigger_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) AppendPath(path LogCndSpecQueryLabelTrigger_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LogCndSpecQueryLabelTrigger_FieldPath))
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) GetPaths() []LogCndSpecQueryLabelTrigger_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLogCndSpecQueryLabelTrigger_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) Set(target, source *LogCndSpec_Query_LabelTrigger) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LogCndSpec_Query_LabelTrigger), source.(*LogCndSpec_Query_LabelTrigger))
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) Project(source *LogCndSpec_Query_LabelTrigger) *LogCndSpec_Query_LabelTrigger {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LogCndSpec_Query_LabelTrigger{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LogCndSpecQueryLabelTrigger_FieldTerminalPath:
			switch tp.selector {
			case LogCndSpecQueryLabelTrigger_FieldPathSelectorKey:
				result.Key = source.Key
			case LogCndSpecQueryLabelTrigger_FieldPathSelectorValues:
				result.Values = source.Values
			}
		}
	}
	return result
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LogCndSpec_Query_LabelTrigger))
}

func (fieldMask *LogCndSpec_Query_LabelTrigger_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type LogCndSpec_Query_StringPayloadTrigger_FieldMask struct {
	Paths []LogCndSpecQueryStringPayloadTrigger_FieldPath
}

func FullLogCndSpec_Query_StringPayloadTrigger_FieldMask() *LogCndSpec_Query_StringPayloadTrigger_FieldMask {
	res := &LogCndSpec_Query_StringPayloadTrigger_FieldMask{}
	res.Paths = append(res.Paths, &LogCndSpecQueryStringPayloadTrigger_FieldTerminalPath{selector: LogCndSpecQueryStringPayloadTrigger_FieldPathSelectorObjectSelector})
	res.Paths = append(res.Paths, &LogCndSpecQueryStringPayloadTrigger_FieldTerminalPath{selector: LogCndSpecQueryStringPayloadTrigger_FieldPathSelectorRegex})
	return res
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LogCndSpecQueryStringPayloadTrigger_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLogCndSpecQueryStringPayloadTrigger_FieldPath(raw)
	})
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) ProtoMessage() {}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) Subtract(other *LogCndSpec_Query_StringPayloadTrigger_FieldMask) *LogCndSpec_Query_StringPayloadTrigger_FieldMask {
	result := &LogCndSpec_Query_StringPayloadTrigger_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LogCndSpecQueryStringPayloadTrigger_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LogCndSpec_Query_StringPayloadTrigger_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) FilterInputFields() *LogCndSpec_Query_StringPayloadTrigger_FieldMask {
	result := &LogCndSpec_Query_StringPayloadTrigger_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LogCndSpecQueryStringPayloadTrigger_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLogCndSpecQueryStringPayloadTrigger_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LogCndSpec_Query_StringPayloadTrigger_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LogCndSpec_Query_StringPayloadTrigger_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) AppendPath(path LogCndSpecQueryStringPayloadTrigger_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LogCndSpecQueryStringPayloadTrigger_FieldPath))
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) GetPaths() []LogCndSpecQueryStringPayloadTrigger_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLogCndSpecQueryStringPayloadTrigger_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) Set(target, source *LogCndSpec_Query_StringPayloadTrigger) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LogCndSpec_Query_StringPayloadTrigger), source.(*LogCndSpec_Query_StringPayloadTrigger))
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) Project(source *LogCndSpec_Query_StringPayloadTrigger) *LogCndSpec_Query_StringPayloadTrigger {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LogCndSpec_Query_StringPayloadTrigger{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LogCndSpecQueryStringPayloadTrigger_FieldTerminalPath:
			switch tp.selector {
			case LogCndSpecQueryStringPayloadTrigger_FieldPathSelectorObjectSelector:
				result.ObjectSelector = source.ObjectSelector
			case LogCndSpecQueryStringPayloadTrigger_FieldPathSelectorRegex:
				result.Regex = source.Regex
			}
		}
	}
	return result
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LogCndSpec_Query_StringPayloadTrigger))
}

func (fieldMask *LogCndSpec_Query_StringPayloadTrigger_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type LogCndSpec_Query_CompositeTrigger_FieldMask struct {
	Paths []LogCndSpecQueryCompositeTrigger_FieldPath
}

func FullLogCndSpec_Query_CompositeTrigger_FieldMask() *LogCndSpec_Query_CompositeTrigger_FieldMask {
	res := &LogCndSpec_Query_CompositeTrigger_FieldMask{}
	res.Paths = append(res.Paths, &LogCndSpecQueryCompositeTrigger_FieldTerminalPath{selector: LogCndSpecQueryCompositeTrigger_FieldPathSelectorTriggers})
	res.Paths = append(res.Paths, &LogCndSpecQueryCompositeTrigger_FieldTerminalPath{selector: LogCndSpecQueryCompositeTrigger_FieldPathSelectorOperator})
	return res
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*LogCndSpecQueryCompositeTrigger_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseLogCndSpecQueryCompositeTrigger_FieldPath(raw)
	})
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) ProtoMessage() {}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) Subtract(other *LogCndSpec_Query_CompositeTrigger_FieldMask) *LogCndSpec_Query_CompositeTrigger_FieldMask {
	result := &LogCndSpec_Query_CompositeTrigger_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *LogCndSpecQueryCompositeTrigger_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*LogCndSpec_Query_CompositeTrigger_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) FilterInputFields() *LogCndSpec_Query_CompositeTrigger_FieldMask {
	result := &LogCndSpec_Query_CompositeTrigger_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]LogCndSpecQueryCompositeTrigger_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseLogCndSpecQueryCompositeTrigger_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask LogCndSpec_Query_CompositeTrigger_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask LogCndSpec_Query_CompositeTrigger_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) AppendPath(path LogCndSpecQueryCompositeTrigger_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(LogCndSpecQueryCompositeTrigger_FieldPath))
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) GetPaths() []LogCndSpecQueryCompositeTrigger_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseLogCndSpecQueryCompositeTrigger_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) Set(target, source *LogCndSpec_Query_CompositeTrigger) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*LogCndSpec_Query_CompositeTrigger), source.(*LogCndSpec_Query_CompositeTrigger))
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) Project(source *LogCndSpec_Query_CompositeTrigger) *LogCndSpec_Query_CompositeTrigger {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &LogCndSpec_Query_CompositeTrigger{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *LogCndSpecQueryCompositeTrigger_FieldTerminalPath:
			switch tp.selector {
			case LogCndSpecQueryCompositeTrigger_FieldPathSelectorTriggers:
				result.Triggers = source.Triggers
			case LogCndSpecQueryCompositeTrigger_FieldPathSelectorOperator:
				result.Operator = source.Operator
			}
		}
	}
	return result
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*LogCndSpec_Query_CompositeTrigger))
}

func (fieldMask *LogCndSpec_Query_CompositeTrigger_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsCndSpec_FieldMask struct {
	Paths []TsCndSpec_FieldPath
}

func FullTsCndSpec_FieldMask() *TsCndSpec_FieldMask {
	res := &TsCndSpec_FieldMask{}
	res.Paths = append(res.Paths, &TsCndSpec_FieldTerminalPath{selector: TsCndSpec_FieldPathSelectorQueries})
	res.Paths = append(res.Paths, &TsCndSpec_FieldTerminalPath{selector: TsCndSpec_FieldPathSelectorQueryGroupBy})
	res.Paths = append(res.Paths, &TsCndSpec_FieldTerminalPath{selector: TsCndSpec_FieldPathSelectorThresholdAlerting})
	res.Paths = append(res.Paths, &TsCndSpec_FieldTerminalPath{selector: TsCndSpec_FieldPathSelectorAnomalyAlerting})
	return res
}

func (fieldMask *TsCndSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsCndSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsCndSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsCndSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsCndSpec_FieldPath(raw)
	})
}

func (fieldMask *TsCndSpec_FieldMask) ProtoMessage() {}

func (fieldMask *TsCndSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsCndSpec_FieldMask) Subtract(other *TsCndSpec_FieldMask) *TsCndSpec_FieldMask {
	result := &TsCndSpec_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[TsCndSpec_FieldPathSelector]gotenobject.FieldMask{
		TsCndSpec_FieldPathSelectorQueries:           &TsCndSpec_Query_FieldMask{},
		TsCndSpec_FieldPathSelectorThresholdAlerting: &TsCndSpec_ThresholdAlertingCfg_FieldMask{},
		TsCndSpec_FieldPathSelectorAnomalyAlerting:   &TsCndSpec_AnomalyAlertingCfg_FieldMask{},
	}
	mySubMasks := map[TsCndSpec_FieldPathSelector]gotenobject.FieldMask{
		TsCndSpec_FieldPathSelectorQueries:           &TsCndSpec_Query_FieldMask{},
		TsCndSpec_FieldPathSelectorThresholdAlerting: &TsCndSpec_ThresholdAlertingCfg_FieldMask{},
		TsCndSpec_FieldPathSelectorAnomalyAlerting:   &TsCndSpec_AnomalyAlertingCfg_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsCndSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsCndSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsCndSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case TsCndSpec_FieldPathSelectorQueries:
						mySubMasks[TsCndSpec_FieldPathSelectorQueries] = FullTsCndSpec_Query_FieldMask()
					case TsCndSpec_FieldPathSelectorThresholdAlerting:
						mySubMasks[TsCndSpec_FieldPathSelectorThresholdAlerting] = FullTsCndSpec_ThresholdAlertingCfg_FieldMask()
					case TsCndSpec_FieldPathSelectorAnomalyAlerting:
						mySubMasks[TsCndSpec_FieldPathSelectorAnomalyAlerting] = FullTsCndSpec_AnomalyAlertingCfg_FieldMask()
					}
				} else if tp, ok := path.(*TsCndSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsCndSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsCndSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsCndSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsCndSpec_FieldMask) FilterInputFields() *TsCndSpec_FieldMask {
	result := &TsCndSpec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsCndSpec_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsCndSpec_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsCndSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsCndSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsCndSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsCndSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsCndSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsCndSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_FieldMask) AppendPath(path TsCndSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsCndSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsCndSpec_FieldPath))
}

func (fieldMask *TsCndSpec_FieldMask) GetPaths() []TsCndSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsCndSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsCndSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsCndSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsCndSpec_FieldMask) Set(target, source *TsCndSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsCndSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsCndSpec), source.(*TsCndSpec))
}

func (fieldMask *TsCndSpec_FieldMask) Project(source *TsCndSpec) *TsCndSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsCndSpec{}
	queriesMask := &TsCndSpec_Query_FieldMask{}
	wholeQueriesAccepted := false
	thresholdAlertingMask := &TsCndSpec_ThresholdAlertingCfg_FieldMask{}
	wholeThresholdAlertingAccepted := false
	anomalyAlertingMask := &TsCndSpec_AnomalyAlertingCfg_FieldMask{}
	wholeAnomalyAlertingAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsCndSpec_FieldTerminalPath:
			switch tp.selector {
			case TsCndSpec_FieldPathSelectorQueries:
				result.Queries = source.Queries
				wholeQueriesAccepted = true
			case TsCndSpec_FieldPathSelectorQueryGroupBy:
				result.QueryGroupBy = source.QueryGroupBy
			case TsCndSpec_FieldPathSelectorThresholdAlerting:
				result.ThresholdAlerting = source.ThresholdAlerting
				wholeThresholdAlertingAccepted = true
			case TsCndSpec_FieldPathSelectorAnomalyAlerting:
				result.AnomalyAlerting = source.AnomalyAlerting
				wholeAnomalyAlertingAccepted = true
			}
		case *TsCndSpec_FieldSubPath:
			switch tp.selector {
			case TsCndSpec_FieldPathSelectorQueries:
				queriesMask.AppendPath(tp.subPath.(TsCndSpecQuery_FieldPath))
			case TsCndSpec_FieldPathSelectorThresholdAlerting:
				thresholdAlertingMask.AppendPath(tp.subPath.(TsCndSpecThresholdAlertingCfg_FieldPath))
			case TsCndSpec_FieldPathSelectorAnomalyAlerting:
				anomalyAlertingMask.AppendPath(tp.subPath.(TsCndSpecAnomalyAlertingCfg_FieldPath))
			}
		}
	}
	if wholeQueriesAccepted == false && len(queriesMask.Paths) > 0 {
		for _, sourceItem := range source.GetQueries() {
			result.Queries = append(result.Queries, queriesMask.Project(sourceItem))
		}
	}
	if wholeThresholdAlertingAccepted == false && len(thresholdAlertingMask.Paths) > 0 {
		result.ThresholdAlerting = thresholdAlertingMask.Project(source.GetThresholdAlerting())
	}
	if wholeAnomalyAlertingAccepted == false && len(anomalyAlertingMask.Paths) > 0 {
		for _, sourceItem := range source.GetAnomalyAlerting() {
			result.AnomalyAlerting = append(result.AnomalyAlerting, anomalyAlertingMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *TsCndSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsCndSpec))
}

func (fieldMask *TsCndSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsCndSpec_Query_FieldMask struct {
	Paths []TsCndSpecQuery_FieldPath
}

func FullTsCndSpec_Query_FieldMask() *TsCndSpec_Query_FieldMask {
	res := &TsCndSpec_Query_FieldMask{}
	res.Paths = append(res.Paths, &TsCndSpecQuery_FieldTerminalPath{selector: TsCndSpecQuery_FieldPathSelectorName})
	res.Paths = append(res.Paths, &TsCndSpecQuery_FieldTerminalPath{selector: TsCndSpecQuery_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &TsCndSpecQuery_FieldTerminalPath{selector: TsCndSpecQuery_FieldPathSelectorAligner})
	res.Paths = append(res.Paths, &TsCndSpecQuery_FieldTerminalPath{selector: TsCndSpecQuery_FieldPathSelectorReducer})
	res.Paths = append(res.Paths, &TsCndSpecQuery_FieldTerminalPath{selector: TsCndSpecQuery_FieldPathSelectorMaxValue})
	return res
}

func (fieldMask *TsCndSpec_Query_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsCndSpec_Query_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsCndSpecQuery_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsCndSpec_Query_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsCndSpecQuery_FieldPath(raw)
	})
}

func (fieldMask *TsCndSpec_Query_FieldMask) ProtoMessage() {}

func (fieldMask *TsCndSpec_Query_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsCndSpec_Query_FieldMask) Subtract(other *TsCndSpec_Query_FieldMask) *TsCndSpec_Query_FieldMask {
	result := &TsCndSpec_Query_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsCndSpecQuery_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsCndSpec_Query_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsCndSpec_Query_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsCndSpec_Query_FieldMask) FilterInputFields() *TsCndSpec_Query_FieldMask {
	result := &TsCndSpec_Query_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsCndSpec_Query_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsCndSpec_Query_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsCndSpecQuery_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsCndSpecQuery_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsCndSpec_Query_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsCndSpec_Query_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_Query_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsCndSpec_Query_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsCndSpec_Query_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_Query_FieldMask) AppendPath(path TsCndSpecQuery_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsCndSpec_Query_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsCndSpecQuery_FieldPath))
}

func (fieldMask *TsCndSpec_Query_FieldMask) GetPaths() []TsCndSpecQuery_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsCndSpec_Query_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsCndSpec_Query_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsCndSpecQuery_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsCndSpec_Query_FieldMask) Set(target, source *TsCndSpec_Query) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsCndSpec_Query_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsCndSpec_Query), source.(*TsCndSpec_Query))
}

func (fieldMask *TsCndSpec_Query_FieldMask) Project(source *TsCndSpec_Query) *TsCndSpec_Query {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsCndSpec_Query{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsCndSpecQuery_FieldTerminalPath:
			switch tp.selector {
			case TsCndSpecQuery_FieldPathSelectorName:
				result.Name = source.Name
			case TsCndSpecQuery_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case TsCndSpecQuery_FieldPathSelectorAligner:
				result.Aligner = source.Aligner
			case TsCndSpecQuery_FieldPathSelectorReducer:
				result.Reducer = source.Reducer
			case TsCndSpecQuery_FieldPathSelectorMaxValue:
				result.MaxValue = source.MaxValue
			}
		}
	}
	return result
}

func (fieldMask *TsCndSpec_Query_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsCndSpec_Query))
}

func (fieldMask *TsCndSpec_Query_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsCndSpec_ThresholdAlertingCfg_FieldMask struct {
	Paths []TsCndSpecThresholdAlertingCfg_FieldPath
}

func FullTsCndSpec_ThresholdAlertingCfg_FieldMask() *TsCndSpec_ThresholdAlertingCfg_FieldMask {
	res := &TsCndSpec_ThresholdAlertingCfg_FieldMask{}
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfg_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfg_FieldPathSelectorOperator})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfg_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfg_FieldPathSelectorAlignmentPeriod})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfg_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfg_FieldPathSelectorRaiseAfter})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfg_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfg_FieldPathSelectorSilenceAfter})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfg_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfg_FieldPathSelectorPerQueryThresholds})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfg_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfg_FieldPathSelectorAdaptiveThresholdsDetectionPeriod})
	return res
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsCndSpecThresholdAlertingCfg_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsCndSpecThresholdAlertingCfg_FieldPath(raw)
	})
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) ProtoMessage() {}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) Subtract(other *TsCndSpec_ThresholdAlertingCfg_FieldMask) *TsCndSpec_ThresholdAlertingCfg_FieldMask {
	result := &TsCndSpec_ThresholdAlertingCfg_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[TsCndSpecThresholdAlertingCfg_FieldPathSelector]gotenobject.FieldMask{
		TsCndSpecThresholdAlertingCfg_FieldPathSelectorPerQueryThresholds: &TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask{},
	}
	mySubMasks := map[TsCndSpecThresholdAlertingCfg_FieldPathSelector]gotenobject.FieldMask{
		TsCndSpecThresholdAlertingCfg_FieldPathSelectorPerQueryThresholds: &TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsCndSpecThresholdAlertingCfg_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsCndSpecThresholdAlertingCfg_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsCndSpecThresholdAlertingCfg_FieldTerminalPath); ok {
					switch tp.selector {
					case TsCndSpecThresholdAlertingCfg_FieldPathSelectorPerQueryThresholds:
						mySubMasks[TsCndSpecThresholdAlertingCfg_FieldPathSelectorPerQueryThresholds] = FullTsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask()
					}
				} else if tp, ok := path.(*TsCndSpecThresholdAlertingCfg_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsCndSpecThresholdAlertingCfg_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsCndSpec_ThresholdAlertingCfg_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) FilterInputFields() *TsCndSpec_ThresholdAlertingCfg_FieldMask {
	result := &TsCndSpec_ThresholdAlertingCfg_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsCndSpecThresholdAlertingCfg_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsCndSpecThresholdAlertingCfg_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsCndSpec_ThresholdAlertingCfg_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsCndSpec_ThresholdAlertingCfg_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) AppendPath(path TsCndSpecThresholdAlertingCfg_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsCndSpecThresholdAlertingCfg_FieldPath))
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) GetPaths() []TsCndSpecThresholdAlertingCfg_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsCndSpecThresholdAlertingCfg_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) Set(target, source *TsCndSpec_ThresholdAlertingCfg) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsCndSpec_ThresholdAlertingCfg), source.(*TsCndSpec_ThresholdAlertingCfg))
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) Project(source *TsCndSpec_ThresholdAlertingCfg) *TsCndSpec_ThresholdAlertingCfg {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsCndSpec_ThresholdAlertingCfg{}
	perQueryThresholdsMask := &TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask{}
	wholePerQueryThresholdsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsCndSpecThresholdAlertingCfg_FieldTerminalPath:
			switch tp.selector {
			case TsCndSpecThresholdAlertingCfg_FieldPathSelectorOperator:
				result.Operator = source.Operator
			case TsCndSpecThresholdAlertingCfg_FieldPathSelectorAlignmentPeriod:
				result.AlignmentPeriod = source.AlignmentPeriod
			case TsCndSpecThresholdAlertingCfg_FieldPathSelectorRaiseAfter:
				result.RaiseAfter = source.RaiseAfter
			case TsCndSpecThresholdAlertingCfg_FieldPathSelectorSilenceAfter:
				result.SilenceAfter = source.SilenceAfter
			case TsCndSpecThresholdAlertingCfg_FieldPathSelectorPerQueryThresholds:
				result.PerQueryThresholds = source.PerQueryThresholds
				wholePerQueryThresholdsAccepted = true
			case TsCndSpecThresholdAlertingCfg_FieldPathSelectorAdaptiveThresholdsDetectionPeriod:
				result.AdaptiveThresholdsDetectionPeriod = source.AdaptiveThresholdsDetectionPeriod
			}
		case *TsCndSpecThresholdAlertingCfg_FieldSubPath:
			switch tp.selector {
			case TsCndSpecThresholdAlertingCfg_FieldPathSelectorPerQueryThresholds:
				perQueryThresholdsMask.AppendPath(tp.subPath.(TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath))
			}
		}
	}
	if wholePerQueryThresholdsAccepted == false && len(perQueryThresholdsMask.Paths) > 0 {
		for _, sourceItem := range source.GetPerQueryThresholds() {
			result.PerQueryThresholds = append(result.PerQueryThresholds, perQueryThresholdsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsCndSpec_ThresholdAlertingCfg))
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsCndSpec_AnomalyAlertingCfg_FieldMask struct {
	Paths []TsCndSpecAnomalyAlertingCfg_FieldPath
}

func FullTsCndSpec_AnomalyAlertingCfg_FieldMask() *TsCndSpec_AnomalyAlertingCfg_FieldMask {
	res := &TsCndSpec_AnomalyAlertingCfg_FieldMask{}
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfg_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfg_FieldPathSelectorAnalysisWindow})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfg_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfg_FieldPathSelectorStepInterval})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfg_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfg_FieldPathSelectorTrainStepInterval})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfg_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfg_FieldPathSelectorAlignmentPeriod})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfg_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfg_FieldPathSelectorLstmAutoencoder})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfg_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfg_FieldPathSelectorRaiseAfter})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfg_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfg_FieldPathSelectorSilenceAfter})
	return res
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsCndSpecAnomalyAlertingCfg_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsCndSpecAnomalyAlertingCfg_FieldPath(raw)
	})
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) ProtoMessage() {}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) Subtract(other *TsCndSpec_AnomalyAlertingCfg_FieldMask) *TsCndSpec_AnomalyAlertingCfg_FieldMask {
	result := &TsCndSpec_AnomalyAlertingCfg_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[TsCndSpecAnomalyAlertingCfg_FieldPathSelector]gotenobject.FieldMask{
		TsCndSpecAnomalyAlertingCfg_FieldPathSelectorLstmAutoencoder: &TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask{},
	}
	mySubMasks := map[TsCndSpecAnomalyAlertingCfg_FieldPathSelector]gotenobject.FieldMask{
		TsCndSpecAnomalyAlertingCfg_FieldPathSelectorLstmAutoencoder: &TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsCndSpecAnomalyAlertingCfg_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsCndSpecAnomalyAlertingCfg_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsCndSpecAnomalyAlertingCfg_FieldTerminalPath); ok {
					switch tp.selector {
					case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorLstmAutoencoder:
						mySubMasks[TsCndSpecAnomalyAlertingCfg_FieldPathSelectorLstmAutoencoder] = FullTsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask()
					}
				} else if tp, ok := path.(*TsCndSpecAnomalyAlertingCfg_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsCndSpecAnomalyAlertingCfg_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsCndSpec_AnomalyAlertingCfg_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) FilterInputFields() *TsCndSpec_AnomalyAlertingCfg_FieldMask {
	result := &TsCndSpec_AnomalyAlertingCfg_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsCndSpecAnomalyAlertingCfg_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsCndSpecAnomalyAlertingCfg_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsCndSpec_AnomalyAlertingCfg_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsCndSpec_AnomalyAlertingCfg_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) AppendPath(path TsCndSpecAnomalyAlertingCfg_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsCndSpecAnomalyAlertingCfg_FieldPath))
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) GetPaths() []TsCndSpecAnomalyAlertingCfg_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsCndSpecAnomalyAlertingCfg_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) Set(target, source *TsCndSpec_AnomalyAlertingCfg) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsCndSpec_AnomalyAlertingCfg), source.(*TsCndSpec_AnomalyAlertingCfg))
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) Project(source *TsCndSpec_AnomalyAlertingCfg) *TsCndSpec_AnomalyAlertingCfg {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsCndSpec_AnomalyAlertingCfg{}
	lstmAutoencoderMask := &TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask{}
	wholeLstmAutoencoderAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsCndSpecAnomalyAlertingCfg_FieldTerminalPath:
			switch tp.selector {
			case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorAnalysisWindow:
				result.AnalysisWindow = source.AnalysisWindow
			case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorStepInterval:
				result.StepInterval = source.StepInterval
			case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorTrainStepInterval:
				result.TrainStepInterval = source.TrainStepInterval
			case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorAlignmentPeriod:
				result.AlignmentPeriod = source.AlignmentPeriod
			case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorLstmAutoencoder:
				if source, ok := source.Model.(*TsCndSpec_AnomalyAlertingCfg_LstmAutoencoder); ok {
					result.Model = &TsCndSpec_AnomalyAlertingCfg_LstmAutoencoder{
						LstmAutoencoder: source.LstmAutoencoder,
					}
				}
				wholeLstmAutoencoderAccepted = true
			case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorRaiseAfter:
				result.RaiseAfter = source.RaiseAfter
			case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorSilenceAfter:
				result.SilenceAfter = source.SilenceAfter
			}
		case *TsCndSpecAnomalyAlertingCfg_FieldSubPath:
			switch tp.selector {
			case TsCndSpecAnomalyAlertingCfg_FieldPathSelectorLstmAutoencoder:
				lstmAutoencoderMask.AppendPath(tp.subPath.(TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath))
			}
		}
	}
	if wholeLstmAutoencoderAccepted == false && len(lstmAutoencoderMask.Paths) > 0 {
		if asOneOf, ok := source.Model.(*TsCndSpec_AnomalyAlertingCfg_LstmAutoencoder); ok {
			result.Model = (*TsCndSpec_AnomalyAlertingCfg_LstmAutoencoder)(nil)
			if asOneOf != nil {
				oneOfRes := &TsCndSpec_AnomalyAlertingCfg_LstmAutoencoder{}
				oneOfRes.LstmAutoencoder = lstmAutoencoderMask.Project(asOneOf.LstmAutoencoder)
				result.Model = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsCndSpec_AnomalyAlertingCfg))
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask struct {
	Paths []TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath
}

func FullTsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask() *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask {
	res := &TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask{}
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorAutoAdaptUpper})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorAutoAdaptLower})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxUpper})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxLower})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinUpper})
	res.Paths = append(res.Paths, &TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath{selector: TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinLower})
	return res
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath(raw)
	})
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) ProtoMessage() {}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) Subtract(other *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask {
	result := &TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask{}
	removedSelectors := make([]bool, 6)
	otherSubMasks := map[TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelector]gotenobject.FieldMask{
		TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxUpper: &AlertingThreshold_FieldMask{},
		TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxLower: &AlertingThreshold_FieldMask{},
		TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinUpper: &AlertingThreshold_FieldMask{},
		TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinLower: &AlertingThreshold_FieldMask{},
	}
	mySubMasks := map[TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelector]gotenobject.FieldMask{
		TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxUpper: &AlertingThreshold_FieldMask{},
		TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxLower: &AlertingThreshold_FieldMask{},
		TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinUpper: &AlertingThreshold_FieldMask{},
		TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinLower: &AlertingThreshold_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath); ok {
					switch tp.selector {
					case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxUpper:
						mySubMasks[TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxUpper] = FullAlertingThreshold_FieldMask()
					case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxLower:
						mySubMasks[TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxLower] = FullAlertingThreshold_FieldMask()
					case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinUpper:
						mySubMasks[TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinUpper] = FullAlertingThreshold_FieldMask()
					case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinLower:
						mySubMasks[TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinLower] = FullAlertingThreshold_FieldMask()
					}
				} else if tp, ok := path.(*TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) FilterInputFields() *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask {
	result := &TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) AppendPath(path TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath))
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) GetPaths() []TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) Set(target, source *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsCndSpec_ThresholdAlertingCfg_AlertingThresholds), source.(*TsCndSpec_ThresholdAlertingCfg_AlertingThresholds))
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) Project(source *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds) *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsCndSpec_ThresholdAlertingCfg_AlertingThresholds{}
	maxUpperMask := &AlertingThreshold_FieldMask{}
	wholeMaxUpperAccepted := false
	maxLowerMask := &AlertingThreshold_FieldMask{}
	wholeMaxLowerAccepted := false
	minUpperMask := &AlertingThreshold_FieldMask{}
	wholeMinUpperAccepted := false
	minLowerMask := &AlertingThreshold_FieldMask{}
	wholeMinLowerAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldTerminalPath:
			switch tp.selector {
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorAutoAdaptUpper:
				result.AutoAdaptUpper = source.AutoAdaptUpper
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorAutoAdaptLower:
				result.AutoAdaptLower = source.AutoAdaptLower
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxUpper:
				result.MaxUpper = source.MaxUpper
				wholeMaxUpperAccepted = true
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxLower:
				result.MaxLower = source.MaxLower
				wholeMaxLowerAccepted = true
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinUpper:
				result.MinUpper = source.MinUpper
				wholeMinUpperAccepted = true
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinLower:
				result.MinLower = source.MinLower
				wholeMinLowerAccepted = true
			}
		case *TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldSubPath:
			switch tp.selector {
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxUpper:
				maxUpperMask.AppendPath(tp.subPath.(AlertingThreshold_FieldPath))
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMaxLower:
				maxLowerMask.AppendPath(tp.subPath.(AlertingThreshold_FieldPath))
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinUpper:
				minUpperMask.AppendPath(tp.subPath.(AlertingThreshold_FieldPath))
			case TsCndSpecThresholdAlertingCfgAlertingThresholds_FieldPathSelectorMinLower:
				minLowerMask.AppendPath(tp.subPath.(AlertingThreshold_FieldPath))
			}
		}
	}
	if wholeMaxUpperAccepted == false && len(maxUpperMask.Paths) > 0 {
		result.MaxUpper = maxUpperMask.Project(source.GetMaxUpper())
	}
	if wholeMaxLowerAccepted == false && len(maxLowerMask.Paths) > 0 {
		result.MaxLower = maxLowerMask.Project(source.GetMaxLower())
	}
	if wholeMinUpperAccepted == false && len(minUpperMask.Paths) > 0 {
		result.MinUpper = minUpperMask.Project(source.GetMinUpper())
	}
	if wholeMinLowerAccepted == false && len(minLowerMask.Paths) > 0 {
		result.MinLower = minLowerMask.Project(source.GetMinLower())
	}
	return result
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsCndSpec_ThresholdAlertingCfg_AlertingThresholds))
}

func (fieldMask *TsCndSpec_ThresholdAlertingCfg_AlertingThresholds_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask struct {
	Paths []TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath
}

func FullTsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask() *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask {
	res := &TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask{}
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorHiddenSize})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorLearnRate})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorMaxTrainingEpochs})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorMinTrainingEpochs})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorAcceptableTrainingError})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorTrainingPeriod})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorCheckPeriodFraction})
	res.Paths = append(res.Paths, &TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath{selector: TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorTeacherForceAtInference})
	return res
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath(raw)
	})
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) ProtoMessage() {}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) Subtract(other *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask {
	result := &TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) FilterInputFields() *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask {
	result := &TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) AppendPath(path TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath))
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) GetPaths() []TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) Set(target, source *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder), source.(*TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder))
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) Project(source *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder) *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldTerminalPath:
			switch tp.selector {
			case TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorHiddenSize:
				result.HiddenSize = source.HiddenSize
			case TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorLearnRate:
				result.LearnRate = source.LearnRate
			case TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorMaxTrainingEpochs:
				result.MaxTrainingEpochs = source.MaxTrainingEpochs
			case TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorMinTrainingEpochs:
				result.MinTrainingEpochs = source.MinTrainingEpochs
			case TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorAcceptableTrainingError:
				result.AcceptableTrainingError = source.AcceptableTrainingError
			case TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorTrainingPeriod:
				result.TrainingPeriod = source.TrainingPeriod
			case TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorCheckPeriodFraction:
				result.CheckPeriodFraction = source.CheckPeriodFraction
			case TsCndSpecAnomalyAlertingCfgLstmAutoEncoder_FieldPathSelectorTeacherForceAtInference:
				result.TeacherForceAtInference = source.TeacherForceAtInference
			}
		}
	}
	return result
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder))
}

func (fieldMask *TsCndSpec_AnomalyAlertingCfg_LstmAutoEncoder_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_FieldMask struct {
	Paths []PolicySpec_FieldPath
}

func FullPolicySpec_FieldMask() *PolicySpec_FieldMask {
	res := &PolicySpec_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpec_FieldTerminalPath{selector: PolicySpec_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &PolicySpec_FieldTerminalPath{selector: PolicySpec_FieldPathSelectorProcessingLocation})
	res.Paths = append(res.Paths, &PolicySpec_FieldTerminalPath{selector: PolicySpec_FieldPathSelectorResourceIdentity})
	res.Paths = append(res.Paths, &PolicySpec_FieldTerminalPath{selector: PolicySpec_FieldPathSelectorSupportingQueries})
	res.Paths = append(res.Paths, &PolicySpec_FieldTerminalPath{selector: PolicySpec_FieldPathSelectorAiAgent})
	return res
}

func (fieldMask *PolicySpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpec_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_FieldMask) Subtract(other *PolicySpec_FieldMask) *PolicySpec_FieldMask {
	result := &PolicySpec_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[PolicySpec_FieldPathSelector]gotenobject.FieldMask{
		PolicySpec_FieldPathSelectorResourceIdentity:  &PolicySpec_ResourceIdentity_FieldMask{},
		PolicySpec_FieldPathSelectorSupportingQueries: &PolicySpec_SupportingAlertQuery_FieldMask{},
		PolicySpec_FieldPathSelectorAiAgent:           &PolicySpec_AIAgentHandling_FieldMask{},
	}
	mySubMasks := map[PolicySpec_FieldPathSelector]gotenobject.FieldMask{
		PolicySpec_FieldPathSelectorResourceIdentity:  &PolicySpec_ResourceIdentity_FieldMask{},
		PolicySpec_FieldPathSelectorSupportingQueries: &PolicySpec_SupportingAlertQuery_FieldMask{},
		PolicySpec_FieldPathSelectorAiAgent:           &PolicySpec_AIAgentHandling_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PolicySpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PolicySpec_FieldTerminalPath); ok {
					switch tp.selector {
					case PolicySpec_FieldPathSelectorResourceIdentity:
						mySubMasks[PolicySpec_FieldPathSelectorResourceIdentity] = FullPolicySpec_ResourceIdentity_FieldMask()
					case PolicySpec_FieldPathSelectorSupportingQueries:
						mySubMasks[PolicySpec_FieldPathSelectorSupportingQueries] = FullPolicySpec_SupportingAlertQuery_FieldMask()
					case PolicySpec_FieldPathSelectorAiAgent:
						mySubMasks[PolicySpec_FieldPathSelectorAiAgent] = FullPolicySpec_AIAgentHandling_FieldMask()
					}
				} else if tp, ok := path.(*PolicySpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PolicySpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_FieldMask) FilterInputFields() *PolicySpec_FieldMask {
	result := &PolicySpec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_FieldMask) AppendPath(path PolicySpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpec_FieldPath))
}

func (fieldMask *PolicySpec_FieldMask) GetPaths() []PolicySpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_FieldMask) Set(target, source *PolicySpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec), source.(*PolicySpec))
}

func (fieldMask *PolicySpec_FieldMask) Project(source *PolicySpec) *PolicySpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec{}
	resourceIdentityMask := &PolicySpec_ResourceIdentity_FieldMask{}
	wholeResourceIdentityAccepted := false
	supportingQueriesMask := &PolicySpec_SupportingAlertQuery_FieldMask{}
	wholeSupportingQueriesAccepted := false
	aiAgentMask := &PolicySpec_AIAgentHandling_FieldMask{}
	wholeAiAgentAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpec_FieldTerminalPath:
			switch tp.selector {
			case PolicySpec_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case PolicySpec_FieldPathSelectorProcessingLocation:
				result.ProcessingLocation = source.ProcessingLocation
			case PolicySpec_FieldPathSelectorResourceIdentity:
				result.ResourceIdentity = source.ResourceIdentity
				wholeResourceIdentityAccepted = true
			case PolicySpec_FieldPathSelectorSupportingQueries:
				result.SupportingQueries = source.SupportingQueries
				wholeSupportingQueriesAccepted = true
			case PolicySpec_FieldPathSelectorAiAgent:
				result.AiAgent = source.AiAgent
				wholeAiAgentAccepted = true
			}
		case *PolicySpec_FieldSubPath:
			switch tp.selector {
			case PolicySpec_FieldPathSelectorResourceIdentity:
				resourceIdentityMask.AppendPath(tp.subPath.(PolicySpecResourceIdentity_FieldPath))
			case PolicySpec_FieldPathSelectorSupportingQueries:
				supportingQueriesMask.AppendPath(tp.subPath.(PolicySpecSupportingAlertQuery_FieldPath))
			case PolicySpec_FieldPathSelectorAiAgent:
				aiAgentMask.AppendPath(tp.subPath.(PolicySpecAIAgentHandling_FieldPath))
			}
		}
	}
	if wholeResourceIdentityAccepted == false && len(resourceIdentityMask.Paths) > 0 {
		result.ResourceIdentity = resourceIdentityMask.Project(source.GetResourceIdentity())
	}
	if wholeSupportingQueriesAccepted == false && len(supportingQueriesMask.Paths) > 0 {
		for _, sourceItem := range source.GetSupportingQueries() {
			result.SupportingQueries = append(result.SupportingQueries, supportingQueriesMask.Project(sourceItem))
		}
	}
	if wholeAiAgentAccepted == false && len(aiAgentMask.Paths) > 0 {
		result.AiAgent = aiAgentMask.Project(source.GetAiAgent())
	}
	return result
}

func (fieldMask *PolicySpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec))
}

func (fieldMask *PolicySpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_ResourceIdentity_FieldMask struct {
	Paths []PolicySpecResourceIdentity_FieldPath
}

func FullPolicySpec_ResourceIdentity_FieldMask() *PolicySpec_ResourceIdentity_FieldMask {
	res := &PolicySpec_ResourceIdentity_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecResourceIdentity_FieldTerminalPath{selector: PolicySpecResourceIdentity_FieldPathSelectorAlertingResource})
	res.Paths = append(res.Paths, &PolicySpecResourceIdentity_FieldTerminalPath{selector: PolicySpecResourceIdentity_FieldPathSelectorLabels})
	res.Paths = append(res.Paths, &PolicySpecResourceIdentity_FieldTerminalPath{selector: PolicySpecResourceIdentity_FieldPathSelectorNamePatterns})
	return res
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecResourceIdentity_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecResourceIdentity_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) Subtract(other *PolicySpec_ResourceIdentity_FieldMask) *PolicySpec_ResourceIdentity_FieldMask {
	result := &PolicySpec_ResourceIdentity_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[PolicySpecResourceIdentity_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecResourceIdentity_FieldPathSelectorLabels: &PolicySpec_ResourceIdentity_LabelInfo_FieldMask{},
	}
	mySubMasks := map[PolicySpecResourceIdentity_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecResourceIdentity_FieldPathSelectorLabels: &PolicySpec_ResourceIdentity_LabelInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecResourceIdentity_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PolicySpecResourceIdentity_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PolicySpecResourceIdentity_FieldTerminalPath); ok {
					switch tp.selector {
					case PolicySpecResourceIdentity_FieldPathSelectorLabels:
						mySubMasks[PolicySpecResourceIdentity_FieldPathSelectorLabels] = FullPolicySpec_ResourceIdentity_LabelInfo_FieldMask()
					}
				} else if tp, ok := path.(*PolicySpecResourceIdentity_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PolicySpecResourceIdentity_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_ResourceIdentity_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) FilterInputFields() *PolicySpec_ResourceIdentity_FieldMask {
	result := &PolicySpec_ResourceIdentity_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecResourceIdentity_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecResourceIdentity_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_ResourceIdentity_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_ResourceIdentity_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) AppendPath(path PolicySpecResourceIdentity_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecResourceIdentity_FieldPath))
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) GetPaths() []PolicySpecResourceIdentity_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecResourceIdentity_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) Set(target, source *PolicySpec_ResourceIdentity) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_ResourceIdentity), source.(*PolicySpec_ResourceIdentity))
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) Project(source *PolicySpec_ResourceIdentity) *PolicySpec_ResourceIdentity {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_ResourceIdentity{}
	labelsMask := &PolicySpec_ResourceIdentity_LabelInfo_FieldMask{}
	wholeLabelsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecResourceIdentity_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecResourceIdentity_FieldPathSelectorAlertingResource:
				result.AlertingResource = source.AlertingResource
			case PolicySpecResourceIdentity_FieldPathSelectorLabels:
				result.Labels = source.Labels
				wholeLabelsAccepted = true
			case PolicySpecResourceIdentity_FieldPathSelectorNamePatterns:
				result.NamePatterns = source.NamePatterns
			}
		case *PolicySpecResourceIdentity_FieldSubPath:
			switch tp.selector {
			case PolicySpecResourceIdentity_FieldPathSelectorLabels:
				labelsMask.AppendPath(tp.subPath.(PolicySpecResourceIdentityLabelInfo_FieldPath))
			}
		}
	}
	if wholeLabelsAccepted == false && len(labelsMask.Paths) > 0 {
		for _, sourceItem := range source.GetLabels() {
			result.Labels = append(result.Labels, labelsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_ResourceIdentity))
}

func (fieldMask *PolicySpec_ResourceIdentity_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_SupportingAlertQuery_FieldMask struct {
	Paths []PolicySpecSupportingAlertQuery_FieldPath
}

func FullPolicySpec_SupportingAlertQuery_FieldMask() *PolicySpec_SupportingAlertQuery_FieldMask {
	res := &PolicySpec_SupportingAlertQuery_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQuery_FieldPathSelectorTsQuery})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQuery_FieldPathSelectorLogQuery})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQuery_FieldPathSelectorRestGetQuery})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQuery_FieldPathSelectorRestListQuery})
	return res
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecSupportingAlertQuery_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecSupportingAlertQuery_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) Subtract(other *PolicySpec_SupportingAlertQuery_FieldMask) *PolicySpec_SupportingAlertQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[PolicySpecSupportingAlertQuery_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecSupportingAlertQuery_FieldPathSelectorTsQuery:       &PolicySpec_SupportingAlertQuery_TsQuery_FieldMask{},
		PolicySpecSupportingAlertQuery_FieldPathSelectorLogQuery:      &PolicySpec_SupportingAlertQuery_LogQuery_FieldMask{},
		PolicySpecSupportingAlertQuery_FieldPathSelectorRestGetQuery:  &PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask{},
		PolicySpecSupportingAlertQuery_FieldPathSelectorRestListQuery: &PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask{},
	}
	mySubMasks := map[PolicySpecSupportingAlertQuery_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecSupportingAlertQuery_FieldPathSelectorTsQuery:       &PolicySpec_SupportingAlertQuery_TsQuery_FieldMask{},
		PolicySpecSupportingAlertQuery_FieldPathSelectorLogQuery:      &PolicySpec_SupportingAlertQuery_LogQuery_FieldMask{},
		PolicySpecSupportingAlertQuery_FieldPathSelectorRestGetQuery:  &PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask{},
		PolicySpecSupportingAlertQuery_FieldPathSelectorRestListQuery: &PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecSupportingAlertQuery_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PolicySpecSupportingAlertQuery_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PolicySpecSupportingAlertQuery_FieldTerminalPath); ok {
					switch tp.selector {
					case PolicySpecSupportingAlertQuery_FieldPathSelectorTsQuery:
						mySubMasks[PolicySpecSupportingAlertQuery_FieldPathSelectorTsQuery] = FullPolicySpec_SupportingAlertQuery_TsQuery_FieldMask()
					case PolicySpecSupportingAlertQuery_FieldPathSelectorLogQuery:
						mySubMasks[PolicySpecSupportingAlertQuery_FieldPathSelectorLogQuery] = FullPolicySpec_SupportingAlertQuery_LogQuery_FieldMask()
					case PolicySpecSupportingAlertQuery_FieldPathSelectorRestGetQuery:
						mySubMasks[PolicySpecSupportingAlertQuery_FieldPathSelectorRestGetQuery] = FullPolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask()
					case PolicySpecSupportingAlertQuery_FieldPathSelectorRestListQuery:
						mySubMasks[PolicySpecSupportingAlertQuery_FieldPathSelectorRestListQuery] = FullPolicySpec_SupportingAlertQuery_RestListQuery_FieldMask()
					}
				} else if tp, ok := path.(*PolicySpecSupportingAlertQuery_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PolicySpecSupportingAlertQuery_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_SupportingAlertQuery_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) FilterInputFields() *PolicySpec_SupportingAlertQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecSupportingAlertQuery_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecSupportingAlertQuery_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_SupportingAlertQuery_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_SupportingAlertQuery_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) AppendPath(path PolicySpecSupportingAlertQuery_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecSupportingAlertQuery_FieldPath))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) GetPaths() []PolicySpecSupportingAlertQuery_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecSupportingAlertQuery_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) Set(target, source *PolicySpec_SupportingAlertQuery) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_SupportingAlertQuery), source.(*PolicySpec_SupportingAlertQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) Project(source *PolicySpec_SupportingAlertQuery) *PolicySpec_SupportingAlertQuery {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_SupportingAlertQuery{}
	tsQueryMask := &PolicySpec_SupportingAlertQuery_TsQuery_FieldMask{}
	wholeTsQueryAccepted := false
	logQueryMask := &PolicySpec_SupportingAlertQuery_LogQuery_FieldMask{}
	wholeLogQueryAccepted := false
	restGetQueryMask := &PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask{}
	wholeRestGetQueryAccepted := false
	restListQueryMask := &PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask{}
	wholeRestListQueryAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecSupportingAlertQuery_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecSupportingAlertQuery_FieldPathSelectorTsQuery:
				if source, ok := source.Query.(*PolicySpec_SupportingAlertQuery_TsQuery_); ok {
					result.Query = &PolicySpec_SupportingAlertQuery_TsQuery_{
						TsQuery: source.TsQuery,
					}
				}
				wholeTsQueryAccepted = true
			case PolicySpecSupportingAlertQuery_FieldPathSelectorLogQuery:
				if source, ok := source.Query.(*PolicySpec_SupportingAlertQuery_LogQuery_); ok {
					result.Query = &PolicySpec_SupportingAlertQuery_LogQuery_{
						LogQuery: source.LogQuery,
					}
				}
				wholeLogQueryAccepted = true
			case PolicySpecSupportingAlertQuery_FieldPathSelectorRestGetQuery:
				if source, ok := source.Query.(*PolicySpec_SupportingAlertQuery_RestGetQuery_); ok {
					result.Query = &PolicySpec_SupportingAlertQuery_RestGetQuery_{
						RestGetQuery: source.RestGetQuery,
					}
				}
				wholeRestGetQueryAccepted = true
			case PolicySpecSupportingAlertQuery_FieldPathSelectorRestListQuery:
				if source, ok := source.Query.(*PolicySpec_SupportingAlertQuery_RestListQuery_); ok {
					result.Query = &PolicySpec_SupportingAlertQuery_RestListQuery_{
						RestListQuery: source.RestListQuery,
					}
				}
				wholeRestListQueryAccepted = true
			}
		case *PolicySpecSupportingAlertQuery_FieldSubPath:
			switch tp.selector {
			case PolicySpecSupportingAlertQuery_FieldPathSelectorTsQuery:
				tsQueryMask.AppendPath(tp.subPath.(PolicySpecSupportingAlertQueryTsQuery_FieldPath))
			case PolicySpecSupportingAlertQuery_FieldPathSelectorLogQuery:
				logQueryMask.AppendPath(tp.subPath.(PolicySpecSupportingAlertQueryLogQuery_FieldPath))
			case PolicySpecSupportingAlertQuery_FieldPathSelectorRestGetQuery:
				restGetQueryMask.AppendPath(tp.subPath.(PolicySpecSupportingAlertQueryRestGetQuery_FieldPath))
			case PolicySpecSupportingAlertQuery_FieldPathSelectorRestListQuery:
				restListQueryMask.AppendPath(tp.subPath.(PolicySpecSupportingAlertQueryRestListQuery_FieldPath))
			}
		}
	}
	if wholeTsQueryAccepted == false && len(tsQueryMask.Paths) > 0 {
		if asOneOf, ok := source.Query.(*PolicySpec_SupportingAlertQuery_TsQuery_); ok {
			result.Query = (*PolicySpec_SupportingAlertQuery_TsQuery_)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_SupportingAlertQuery_TsQuery_{}
				oneOfRes.TsQuery = tsQueryMask.Project(asOneOf.TsQuery)
				result.Query = oneOfRes
			}
		}
	}
	if wholeLogQueryAccepted == false && len(logQueryMask.Paths) > 0 {
		if asOneOf, ok := source.Query.(*PolicySpec_SupportingAlertQuery_LogQuery_); ok {
			result.Query = (*PolicySpec_SupportingAlertQuery_LogQuery_)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_SupportingAlertQuery_LogQuery_{}
				oneOfRes.LogQuery = logQueryMask.Project(asOneOf.LogQuery)
				result.Query = oneOfRes
			}
		}
	}
	if wholeRestGetQueryAccepted == false && len(restGetQueryMask.Paths) > 0 {
		if asOneOf, ok := source.Query.(*PolicySpec_SupportingAlertQuery_RestGetQuery_); ok {
			result.Query = (*PolicySpec_SupportingAlertQuery_RestGetQuery_)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_SupportingAlertQuery_RestGetQuery_{}
				oneOfRes.RestGetQuery = restGetQueryMask.Project(asOneOf.RestGetQuery)
				result.Query = oneOfRes
			}
		}
	}
	if wholeRestListQueryAccepted == false && len(restListQueryMask.Paths) > 0 {
		if asOneOf, ok := source.Query.(*PolicySpec_SupportingAlertQuery_RestListQuery_); ok {
			result.Query = (*PolicySpec_SupportingAlertQuery_RestListQuery_)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_SupportingAlertQuery_RestListQuery_{}
				oneOfRes.RestListQuery = restListQueryMask.Project(asOneOf.RestListQuery)
				result.Query = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_SupportingAlertQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_AIAgentHandling_FieldMask struct {
	Paths []PolicySpecAIAgentHandling_FieldPath
}

func FullPolicySpec_AIAgentHandling_FieldMask() *PolicySpec_AIAgentHandling_FieldMask {
	res := &PolicySpec_AIAgentHandling_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandling_FieldTerminalPath{selector: PolicySpecAIAgentHandling_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandling_FieldTerminalPath{selector: PolicySpecAIAgentHandling_FieldPathSelectorEnabledConnectivity})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandling_FieldTerminalPath{selector: PolicySpecAIAgentHandling_FieldPathSelectorAutoAcceptRemediation})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandling_FieldTerminalPath{selector: PolicySpecAIAgentHandling_FieldPathSelectorEdgeConnectivity})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandling_FieldTerminalPath{selector: PolicySpecAIAgentHandling_FieldPathSelectorRemediationOptions})
	return res
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecAIAgentHandling_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecAIAgentHandling_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) Subtract(other *PolicySpec_AIAgentHandling_FieldMask) *PolicySpec_AIAgentHandling_FieldMask {
	result := &PolicySpec_AIAgentHandling_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[PolicySpecAIAgentHandling_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecAIAgentHandling_FieldPathSelectorEdgeConnectivity:   &PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask{},
		PolicySpecAIAgentHandling_FieldPathSelectorRemediationOptions: &PolicySpec_AIAgentHandling_Remediation_FieldMask{},
	}
	mySubMasks := map[PolicySpecAIAgentHandling_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecAIAgentHandling_FieldPathSelectorEdgeConnectivity:   &PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask{},
		PolicySpecAIAgentHandling_FieldPathSelectorRemediationOptions: &PolicySpec_AIAgentHandling_Remediation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecAIAgentHandling_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PolicySpecAIAgentHandling_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PolicySpecAIAgentHandling_FieldTerminalPath); ok {
					switch tp.selector {
					case PolicySpecAIAgentHandling_FieldPathSelectorEdgeConnectivity:
						mySubMasks[PolicySpecAIAgentHandling_FieldPathSelectorEdgeConnectivity] = FullPolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask()
					case PolicySpecAIAgentHandling_FieldPathSelectorRemediationOptions:
						mySubMasks[PolicySpecAIAgentHandling_FieldPathSelectorRemediationOptions] = FullPolicySpec_AIAgentHandling_Remediation_FieldMask()
					}
				} else if tp, ok := path.(*PolicySpecAIAgentHandling_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PolicySpecAIAgentHandling_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_AIAgentHandling_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) FilterInputFields() *PolicySpec_AIAgentHandling_FieldMask {
	result := &PolicySpec_AIAgentHandling_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecAIAgentHandling_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecAIAgentHandling_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_AIAgentHandling_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_AIAgentHandling_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) AppendPath(path PolicySpecAIAgentHandling_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecAIAgentHandling_FieldPath))
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) GetPaths() []PolicySpecAIAgentHandling_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecAIAgentHandling_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) Set(target, source *PolicySpec_AIAgentHandling) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_AIAgentHandling), source.(*PolicySpec_AIAgentHandling))
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) Project(source *PolicySpec_AIAgentHandling) *PolicySpec_AIAgentHandling {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_AIAgentHandling{}
	edgeConnectivityMask := &PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask{}
	wholeEdgeConnectivityAccepted := false
	remediationOptionsMask := &PolicySpec_AIAgentHandling_Remediation_FieldMask{}
	wholeRemediationOptionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecAIAgentHandling_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecAIAgentHandling_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case PolicySpecAIAgentHandling_FieldPathSelectorEnabledConnectivity:
				result.EnabledConnectivity = source.EnabledConnectivity
			case PolicySpecAIAgentHandling_FieldPathSelectorAutoAcceptRemediation:
				result.AutoAcceptRemediation = source.AutoAcceptRemediation
			case PolicySpecAIAgentHandling_FieldPathSelectorEdgeConnectivity:
				result.EdgeConnectivity = source.EdgeConnectivity
				wholeEdgeConnectivityAccepted = true
			case PolicySpecAIAgentHandling_FieldPathSelectorRemediationOptions:
				result.RemediationOptions = source.RemediationOptions
				wholeRemediationOptionsAccepted = true
			}
		case *PolicySpecAIAgentHandling_FieldSubPath:
			switch tp.selector {
			case PolicySpecAIAgentHandling_FieldPathSelectorEdgeConnectivity:
				edgeConnectivityMask.AppendPath(tp.subPath.(PolicySpecAIAgentHandlingEdgeConnectivity_FieldPath))
			case PolicySpecAIAgentHandling_FieldPathSelectorRemediationOptions:
				remediationOptionsMask.AppendPath(tp.subPath.(PolicySpecAIAgentHandlingRemediation_FieldPath))
			}
		}
	}
	if wholeEdgeConnectivityAccepted == false && len(edgeConnectivityMask.Paths) > 0 {
		result.EdgeConnectivity = edgeConnectivityMask.Project(source.GetEdgeConnectivity())
	}
	if wholeRemediationOptionsAccepted == false && len(remediationOptionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetRemediationOptions() {
			result.RemediationOptions = append(result.RemediationOptions, remediationOptionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_AIAgentHandling))
}

func (fieldMask *PolicySpec_AIAgentHandling_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_ResourceIdentity_LabelInfo_FieldMask struct {
	Paths []PolicySpecResourceIdentityLabelInfo_FieldPath
}

func FullPolicySpec_ResourceIdentity_LabelInfo_FieldMask() *PolicySpec_ResourceIdentity_LabelInfo_FieldMask {
	res := &PolicySpec_ResourceIdentity_LabelInfo_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecResourceIdentityLabelInfo_FieldTerminalPath{selector: PolicySpecResourceIdentityLabelInfo_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &PolicySpecResourceIdentityLabelInfo_FieldTerminalPath{selector: PolicySpecResourceIdentityLabelInfo_FieldPathSelectorContexts})
	res.Paths = append(res.Paths, &PolicySpecResourceIdentityLabelInfo_FieldTerminalPath{selector: PolicySpecResourceIdentityLabelInfo_FieldPathSelectorMappedNameSegment})
	return res
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecResourceIdentityLabelInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecResourceIdentityLabelInfo_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) Subtract(other *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) *PolicySpec_ResourceIdentity_LabelInfo_FieldMask {
	result := &PolicySpec_ResourceIdentity_LabelInfo_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecResourceIdentityLabelInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_ResourceIdentity_LabelInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) FilterInputFields() *PolicySpec_ResourceIdentity_LabelInfo_FieldMask {
	result := &PolicySpec_ResourceIdentity_LabelInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecResourceIdentityLabelInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecResourceIdentityLabelInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_ResourceIdentity_LabelInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_ResourceIdentity_LabelInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) AppendPath(path PolicySpecResourceIdentityLabelInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecResourceIdentityLabelInfo_FieldPath))
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) GetPaths() []PolicySpecResourceIdentityLabelInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecResourceIdentityLabelInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) Set(target, source *PolicySpec_ResourceIdentity_LabelInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_ResourceIdentity_LabelInfo), source.(*PolicySpec_ResourceIdentity_LabelInfo))
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) Project(source *PolicySpec_ResourceIdentity_LabelInfo) *PolicySpec_ResourceIdentity_LabelInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_ResourceIdentity_LabelInfo{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecResourceIdentityLabelInfo_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecResourceIdentityLabelInfo_FieldPathSelectorKey:
				result.Key = source.Key
			case PolicySpecResourceIdentityLabelInfo_FieldPathSelectorContexts:
				result.Contexts = source.Contexts
			case PolicySpecResourceIdentityLabelInfo_FieldPathSelectorMappedNameSegment:
				result.MappedNameSegment = source.MappedNameSegment
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_ResourceIdentity_LabelInfo))
}

func (fieldMask *PolicySpec_ResourceIdentity_LabelInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_SupportingAlertQuery_TsQuery_FieldMask struct {
	Paths []PolicySpecSupportingAlertQueryTsQuery_FieldPath
}

func FullPolicySpec_SupportingAlertQuery_TsQuery_FieldMask() *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask {
	res := &PolicySpec_SupportingAlertQuery_TsQuery_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryTsQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryTsQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorFilterTemplate})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryTsQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorAggregation})
	return res
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecSupportingAlertQueryTsQuery_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecSupportingAlertQueryTsQuery_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) Subtract(other *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_TsQuery_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[PolicySpecSupportingAlertQueryTsQuery_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorAggregation: &monitoring_common.Aggregation_FieldMask{},
	}
	mySubMasks := map[PolicySpecSupportingAlertQueryTsQuery_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorAggregation: &monitoring_common.Aggregation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecSupportingAlertQueryTsQuery_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PolicySpecSupportingAlertQueryTsQuery_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PolicySpecSupportingAlertQueryTsQuery_FieldTerminalPath); ok {
					switch tp.selector {
					case PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorAggregation:
						mySubMasks[PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorAggregation] = monitoring_common.FullAggregation_FieldMask()
					}
				} else if tp, ok := path.(*PolicySpecSupportingAlertQueryTsQuery_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PolicySpecSupportingAlertQueryTsQuery_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_SupportingAlertQuery_TsQuery_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) FilterInputFields() *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_TsQuery_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecSupportingAlertQueryTsQuery_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecSupportingAlertQueryTsQuery_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) AppendPath(path PolicySpecSupportingAlertQueryTsQuery_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecSupportingAlertQueryTsQuery_FieldPath))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) GetPaths() []PolicySpecSupportingAlertQueryTsQuery_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecSupportingAlertQueryTsQuery_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) Set(target, source *PolicySpec_SupportingAlertQuery_TsQuery) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_SupportingAlertQuery_TsQuery), source.(*PolicySpec_SupportingAlertQuery_TsQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) Project(source *PolicySpec_SupportingAlertQuery_TsQuery) *PolicySpec_SupportingAlertQuery_TsQuery {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_SupportingAlertQuery_TsQuery{}
	aggregationMask := &monitoring_common.Aggregation_FieldMask{}
	wholeAggregationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecSupportingAlertQueryTsQuery_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorDescription:
				result.Description = source.Description
			case PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorFilterTemplate:
				result.FilterTemplate = source.FilterTemplate
			case PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorAggregation:
				result.Aggregation = source.Aggregation
				wholeAggregationAccepted = true
			}
		case *PolicySpecSupportingAlertQueryTsQuery_FieldSubPath:
			switch tp.selector {
			case PolicySpecSupportingAlertQueryTsQuery_FieldPathSelectorAggregation:
				aggregationMask.AppendPath(tp.subPath.(monitoring_common.Aggregation_FieldPath))
			}
		}
	}
	if wholeAggregationAccepted == false && len(aggregationMask.Paths) > 0 {
		result.Aggregation = aggregationMask.Project(source.GetAggregation())
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_SupportingAlertQuery_TsQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_TsQuery_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_SupportingAlertQuery_LogQuery_FieldMask struct {
	Paths []PolicySpecSupportingAlertQueryLogQuery_FieldPath
}

func FullPolicySpec_SupportingAlertQuery_LogQuery_FieldMask() *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask {
	res := &PolicySpec_SupportingAlertQuery_LogQuery_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryLogQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryLogQuery_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryLogQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryLogQuery_FieldPathSelectorFilterTemplate})
	return res
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecSupportingAlertQueryLogQuery_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecSupportingAlertQueryLogQuery_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) Subtract(other *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_LogQuery_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecSupportingAlertQueryLogQuery_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_SupportingAlertQuery_LogQuery_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) FilterInputFields() *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_LogQuery_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecSupportingAlertQueryLogQuery_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecSupportingAlertQueryLogQuery_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) AppendPath(path PolicySpecSupportingAlertQueryLogQuery_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecSupportingAlertQueryLogQuery_FieldPath))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) GetPaths() []PolicySpecSupportingAlertQueryLogQuery_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecSupportingAlertQueryLogQuery_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) Set(target, source *PolicySpec_SupportingAlertQuery_LogQuery) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_SupportingAlertQuery_LogQuery), source.(*PolicySpec_SupportingAlertQuery_LogQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) Project(source *PolicySpec_SupportingAlertQuery_LogQuery) *PolicySpec_SupportingAlertQuery_LogQuery {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_SupportingAlertQuery_LogQuery{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecSupportingAlertQueryLogQuery_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecSupportingAlertQueryLogQuery_FieldPathSelectorDescription:
				result.Description = source.Description
			case PolicySpecSupportingAlertQueryLogQuery_FieldPathSelectorFilterTemplate:
				result.FilterTemplate = source.FilterTemplate
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_SupportingAlertQuery_LogQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_LogQuery_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask struct {
	Paths []PolicySpecSupportingAlertQueryRestGetQuery_FieldPath
}

func FullPolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask() *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask {
	res := &PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestGetQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestGetQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorEndpoint})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestGetQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorPathTemplate})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestGetQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorView})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestGetQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecSupportingAlertQueryRestGetQuery_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecSupportingAlertQueryRestGetQuery_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) Subtract(other *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask{}
	removedSelectors := make([]bool, 5)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecSupportingAlertQueryRestGetQuery_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) FilterInputFields() *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecSupportingAlertQueryRestGetQuery_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecSupportingAlertQueryRestGetQuery_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) AppendPath(path PolicySpecSupportingAlertQueryRestGetQuery_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecSupportingAlertQueryRestGetQuery_FieldPath))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) GetPaths() []PolicySpecSupportingAlertQueryRestGetQuery_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecSupportingAlertQueryRestGetQuery_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) Set(target, source *PolicySpec_SupportingAlertQuery_RestGetQuery) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_SupportingAlertQuery_RestGetQuery), source.(*PolicySpec_SupportingAlertQuery_RestGetQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) Project(source *PolicySpec_SupportingAlertQuery_RestGetQuery) *PolicySpec_SupportingAlertQuery_RestGetQuery {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_SupportingAlertQuery_RestGetQuery{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecSupportingAlertQueryRestGetQuery_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorDescription:
				result.Description = source.Description
			case PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorEndpoint:
				result.Endpoint = source.Endpoint
			case PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorPathTemplate:
				result.PathTemplate = source.PathTemplate
			case PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorView:
				result.View = source.View
			case PolicySpecSupportingAlertQueryRestGetQuery_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_SupportingAlertQuery_RestGetQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestGetQuery_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask struct {
	Paths []PolicySpecSupportingAlertQueryRestListQuery_FieldPath
}

func FullPolicySpec_SupportingAlertQuery_RestListQuery_FieldMask() *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask {
	res := &PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorDescription})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorEndpoint})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorPathTemplate})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorView})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath{selector: PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorFilterTemplate})
	return res
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 6)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecSupportingAlertQueryRestListQuery_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) Subtract(other *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask{}
	removedSelectors := make([]bool, 6)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) FilterInputFields() *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask {
	result := &PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecSupportingAlertQueryRestListQuery_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecSupportingAlertQueryRestListQuery_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) AppendPath(path PolicySpecSupportingAlertQueryRestListQuery_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecSupportingAlertQueryRestListQuery_FieldPath))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) GetPaths() []PolicySpecSupportingAlertQueryRestListQuery_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecSupportingAlertQueryRestListQuery_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) Set(target, source *PolicySpec_SupportingAlertQuery_RestListQuery) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_SupportingAlertQuery_RestListQuery), source.(*PolicySpec_SupportingAlertQuery_RestListQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) Project(source *PolicySpec_SupportingAlertQuery_RestListQuery) *PolicySpec_SupportingAlertQuery_RestListQuery {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_SupportingAlertQuery_RestListQuery{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecSupportingAlertQueryRestListQuery_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorDescription:
				result.Description = source.Description
			case PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorEndpoint:
				result.Endpoint = source.Endpoint
			case PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorPathTemplate:
				result.PathTemplate = source.PathTemplate
			case PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorView:
				result.View = source.View
			case PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case PolicySpecSupportingAlertQueryRestListQuery_FieldPathSelectorFilterTemplate:
				result.FilterTemplate = source.FilterTemplate
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_SupportingAlertQuery_RestListQuery))
}

func (fieldMask *PolicySpec_SupportingAlertQuery_RestListQuery_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask struct {
	Paths []PolicySpecAIAgentHandlingEdgeConnectivity_FieldPath
}

func FullPolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask() *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask {
	res := &PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivity_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorDeviceSsh})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivity_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorProxiesSsh})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivity_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorPodSsh})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivity_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorAllowedBins})
	return res
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecAIAgentHandlingEdgeConnectivity_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecAIAgentHandlingEdgeConnectivity_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) Subtract(other *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask {
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorDeviceSsh:  &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask{},
		PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorProxiesSsh: &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask{},
		PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorPodSsh:     &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask{},
	}
	mySubMasks := map[PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorDeviceSsh:  &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask{},
		PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorProxiesSsh: &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask{},
		PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorPodSsh:     &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecAIAgentHandlingEdgeConnectivity_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PolicySpecAIAgentHandlingEdgeConnectivity_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PolicySpecAIAgentHandlingEdgeConnectivity_FieldTerminalPath); ok {
					switch tp.selector {
					case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorDeviceSsh:
						mySubMasks[PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorDeviceSsh] = FullPolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask()
					case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorProxiesSsh:
						mySubMasks[PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorProxiesSsh] = FullPolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask()
					case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorPodSsh:
						mySubMasks[PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorPodSsh] = FullPolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask()
					}
				} else if tp, ok := path.(*PolicySpecAIAgentHandlingEdgeConnectivity_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PolicySpecAIAgentHandlingEdgeConnectivity_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) FilterInputFields() *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask {
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecAIAgentHandlingEdgeConnectivity_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecAIAgentHandlingEdgeConnectivity_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) AppendPath(path PolicySpecAIAgentHandlingEdgeConnectivity_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecAIAgentHandlingEdgeConnectivity_FieldPath))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) GetPaths() []PolicySpecAIAgentHandlingEdgeConnectivity_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecAIAgentHandlingEdgeConnectivity_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) Set(target, source *PolicySpec_AIAgentHandling_EdgeConnectivity) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_AIAgentHandling_EdgeConnectivity), source.(*PolicySpec_AIAgentHandling_EdgeConnectivity))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) Project(source *PolicySpec_AIAgentHandling_EdgeConnectivity) *PolicySpec_AIAgentHandling_EdgeConnectivity {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity{}
	deviceSshMask := &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask{}
	wholeDeviceSshAccepted := false
	proxiesSshMask := &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask{}
	wholeProxiesSshAccepted := false
	podSshMask := &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask{}
	wholePodSshAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecAIAgentHandlingEdgeConnectivity_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorDeviceSsh:
				if source, ok := source.Type.(*PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSsh); ok {
					result.Type = &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSsh{
						DeviceSsh: source.DeviceSsh,
					}
				}
				wholeDeviceSshAccepted = true
			case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorProxiesSsh:
				if source, ok := source.Type.(*PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSsh); ok {
					result.Type = &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSsh{
						ProxiesSsh: source.ProxiesSsh,
					}
				}
				wholeProxiesSshAccepted = true
			case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorPodSsh:
				if source, ok := source.Type.(*PolicySpec_AIAgentHandling_EdgeConnectivity_PodSsh); ok {
					result.Type = &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSsh{
						PodSsh: source.PodSsh,
					}
				}
				wholePodSshAccepted = true
			case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorAllowedBins:
				result.AllowedBins = source.AllowedBins
			}
		case *PolicySpecAIAgentHandlingEdgeConnectivity_FieldSubPath:
			switch tp.selector {
			case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorDeviceSsh:
				deviceSshMask.AppendPath(tp.subPath.(PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath))
			case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorProxiesSsh:
				proxiesSshMask.AppendPath(tp.subPath.(PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath))
			case PolicySpecAIAgentHandlingEdgeConnectivity_FieldPathSelectorPodSsh:
				podSshMask.AppendPath(tp.subPath.(PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath))
			}
		}
	}
	if wholeDeviceSshAccepted == false && len(deviceSshMask.Paths) > 0 {
		if asOneOf, ok := source.Type.(*PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSsh); ok {
			result.Type = (*PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSsh)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSsh{}
				oneOfRes.DeviceSsh = deviceSshMask.Project(asOneOf.DeviceSsh)
				result.Type = oneOfRes
			}
		}
	}
	if wholeProxiesSshAccepted == false && len(proxiesSshMask.Paths) > 0 {
		if asOneOf, ok := source.Type.(*PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSsh); ok {
			result.Type = (*PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSsh)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSsh{}
				oneOfRes.ProxiesSsh = proxiesSshMask.Project(asOneOf.ProxiesSsh)
				result.Type = oneOfRes
			}
		}
	}
	if wholePodSshAccepted == false && len(podSshMask.Paths) > 0 {
		if asOneOf, ok := source.Type.(*PolicySpec_AIAgentHandling_EdgeConnectivity_PodSsh); ok {
			result.Type = (*PolicySpec_AIAgentHandling_EdgeConnectivity_PodSsh)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSsh{}
				oneOfRes.PodSsh = podSshMask.Project(asOneOf.PodSsh)
				result.Type = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_AIAgentHandling_EdgeConnectivity))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_AIAgentHandling_Remediation_FieldMask struct {
	Paths []PolicySpecAIAgentHandlingRemediation_FieldPath
}

func FullPolicySpec_AIAgentHandling_Remediation_FieldMask() *PolicySpec_AIAgentHandling_Remediation_FieldMask {
	res := &PolicySpec_AIAgentHandling_Remediation_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingRemediation_FieldTerminalPath{selector: PolicySpecAIAgentHandlingRemediation_FieldPathSelectorFixInSsh})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingRemediation_FieldTerminalPath{selector: PolicySpecAIAgentHandlingRemediation_FieldPathSelectorReboot})
	return res
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecAIAgentHandlingRemediation_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecAIAgentHandlingRemediation_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) Subtract(other *PolicySpec_AIAgentHandling_Remediation_FieldMask) *PolicySpec_AIAgentHandling_Remediation_FieldMask {
	result := &PolicySpec_AIAgentHandling_Remediation_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[PolicySpecAIAgentHandlingRemediation_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecAIAgentHandlingRemediation_FieldPathSelectorFixInSsh: &PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask{},
		PolicySpecAIAgentHandlingRemediation_FieldPathSelectorReboot:   &PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask{},
	}
	mySubMasks := map[PolicySpecAIAgentHandlingRemediation_FieldPathSelector]gotenobject.FieldMask{
		PolicySpecAIAgentHandlingRemediation_FieldPathSelectorFixInSsh: &PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask{},
		PolicySpecAIAgentHandlingRemediation_FieldPathSelectorReboot:   &PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecAIAgentHandlingRemediation_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *PolicySpecAIAgentHandlingRemediation_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*PolicySpecAIAgentHandlingRemediation_FieldTerminalPath); ok {
					switch tp.selector {
					case PolicySpecAIAgentHandlingRemediation_FieldPathSelectorFixInSsh:
						mySubMasks[PolicySpecAIAgentHandlingRemediation_FieldPathSelectorFixInSsh] = FullPolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask()
					case PolicySpecAIAgentHandlingRemediation_FieldPathSelectorReboot:
						mySubMasks[PolicySpecAIAgentHandlingRemediation_FieldPathSelectorReboot] = FullPolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask()
					}
				} else if tp, ok := path.(*PolicySpecAIAgentHandlingRemediation_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &PolicySpecAIAgentHandlingRemediation_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_AIAgentHandling_Remediation_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) FilterInputFields() *PolicySpec_AIAgentHandling_Remediation_FieldMask {
	result := &PolicySpec_AIAgentHandling_Remediation_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecAIAgentHandlingRemediation_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecAIAgentHandlingRemediation_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_AIAgentHandling_Remediation_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_AIAgentHandling_Remediation_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) AppendPath(path PolicySpecAIAgentHandlingRemediation_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecAIAgentHandlingRemediation_FieldPath))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) GetPaths() []PolicySpecAIAgentHandlingRemediation_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecAIAgentHandlingRemediation_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) Set(target, source *PolicySpec_AIAgentHandling_Remediation) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_AIAgentHandling_Remediation), source.(*PolicySpec_AIAgentHandling_Remediation))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) Project(source *PolicySpec_AIAgentHandling_Remediation) *PolicySpec_AIAgentHandling_Remediation {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_AIAgentHandling_Remediation{}
	fixInSshMask := &PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask{}
	wholeFixInSshAccepted := false
	rebootMask := &PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask{}
	wholeRebootAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecAIAgentHandlingRemediation_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecAIAgentHandlingRemediation_FieldPathSelectorFixInSsh:
				if source, ok := source.Type.(*PolicySpec_AIAgentHandling_Remediation_FixInSsh); ok {
					result.Type = &PolicySpec_AIAgentHandling_Remediation_FixInSsh{
						FixInSsh: source.FixInSsh,
					}
				}
				wholeFixInSshAccepted = true
			case PolicySpecAIAgentHandlingRemediation_FieldPathSelectorReboot:
				if source, ok := source.Type.(*PolicySpec_AIAgentHandling_Remediation_Reboot_); ok {
					result.Type = &PolicySpec_AIAgentHandling_Remediation_Reboot_{
						Reboot: source.Reboot,
					}
				}
				wholeRebootAccepted = true
			}
		case *PolicySpecAIAgentHandlingRemediation_FieldSubPath:
			switch tp.selector {
			case PolicySpecAIAgentHandlingRemediation_FieldPathSelectorFixInSsh:
				fixInSshMask.AppendPath(tp.subPath.(PolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath))
			case PolicySpecAIAgentHandlingRemediation_FieldPathSelectorReboot:
				rebootMask.AppendPath(tp.subPath.(PolicySpecAIAgentHandlingRemediationReboot_FieldPath))
			}
		}
	}
	if wholeFixInSshAccepted == false && len(fixInSshMask.Paths) > 0 {
		if asOneOf, ok := source.Type.(*PolicySpec_AIAgentHandling_Remediation_FixInSsh); ok {
			result.Type = (*PolicySpec_AIAgentHandling_Remediation_FixInSsh)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_AIAgentHandling_Remediation_FixInSsh{}
				oneOfRes.FixInSsh = fixInSshMask.Project(asOneOf.FixInSsh)
				result.Type = oneOfRes
			}
		}
	}
	if wholeRebootAccepted == false && len(rebootMask.Paths) > 0 {
		if asOneOf, ok := source.Type.(*PolicySpec_AIAgentHandling_Remediation_Reboot_); ok {
			result.Type = (*PolicySpec_AIAgentHandling_Remediation_Reboot_)(nil)
			if asOneOf != nil {
				oneOfRes := &PolicySpec_AIAgentHandling_Remediation_Reboot_{}
				oneOfRes.Reboot = rebootMask.Project(asOneOf.Reboot)
				result.Type = oneOfRes
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_AIAgentHandling_Remediation))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask struct {
	Paths []PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath
}

func FullPolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask() *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask {
	res := &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPathSelectorClientName})
	return res
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) Subtract(other *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask {
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) FilterInputFields() *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask {
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) AppendPath(path PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) GetPaths() []PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) Set(target, source *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH), source.(*PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) Project(source *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH) *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecAIAgentHandlingEdgeConnectivityDeviceSSH_FieldPathSelectorClientName:
				result.ClientName = source.ClientName
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_DeviceSSH_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask struct {
	Paths []PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath
}

func FullPolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask() *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask {
	res := &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPathSelectorServiceDomain})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPathSelectorProviderNameTmpl})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPathSelectorClientName})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPathSelectorServiceName})
	return res
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) Subtract(other *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask {
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask{}
	removedSelectors := make([]bool, 4)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) FilterInputFields() *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask {
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) AppendPath(path PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) GetPaths() []PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) Set(target, source *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH), source.(*PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) Project(source *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH) *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPathSelectorServiceDomain:
				result.ServiceDomain = source.ServiceDomain
			case PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPathSelectorProviderNameTmpl:
				result.ProviderNameTmpl = source.ProviderNameTmpl
			case PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPathSelectorClientName:
				result.ClientName = source.ClientName
			case PolicySpecAIAgentHandlingEdgeConnectivityProxiesSSH_FieldPathSelectorServiceName:
				result.ServiceName = source.ServiceName
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_ProxiesSSH_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask struct {
	Paths []PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath
}

func FullPolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask() *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask {
	res := &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask{}
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPathSelectorClientName})
	res.Paths = append(res.Paths, &PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldTerminalPath{selector: PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPathSelectorUsername})
	return res
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) Subtract(other *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask {
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) FilterInputFields() *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask {
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) AppendPath(path PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) GetPaths() []PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) Set(target, source *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH), source.(*PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) Project(source *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH) *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldTerminalPath:
			switch tp.selector {
			case PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPathSelectorClientName:
				result.ClientName = source.ClientName
			case PolicySpecAIAgentHandlingEdgeConnectivityPodSSH_FieldPathSelectorUsername:
				result.Username = source.Username
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH))
}

func (fieldMask *PolicySpec_AIAgentHandling_EdgeConnectivity_PodSSH_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask struct {
	Paths []PolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath
}

func FullPolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask() *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask {
	res := &PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask{}
	return res
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecAIAgentHandlingRemediationFixInSSH_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) Subtract(other *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask {
	result := &PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecAIAgentHandlingRemediationFixInSSH_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) FilterInputFields() *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask {
	result := &PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) AppendPath(path PolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) GetPaths() []PolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecAIAgentHandlingRemediationFixInSSH_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) Set(target, source *PolicySpec_AIAgentHandling_Remediation_FixInSSH) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_AIAgentHandling_Remediation_FixInSSH), source.(*PolicySpec_AIAgentHandling_Remediation_FixInSSH))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) Project(source *PolicySpec_AIAgentHandling_Remediation_FixInSSH) *PolicySpec_AIAgentHandling_Remediation_FixInSSH {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_AIAgentHandling_Remediation_FixInSSH{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecAIAgentHandlingRemediationFixInSSH_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_AIAgentHandling_Remediation_FixInSSH))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_FixInSSH_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask struct {
	Paths []PolicySpecAIAgentHandlingRemediationReboot_FieldPath
}

func FullPolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask() *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask {
	res := &PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask{}
	return res
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 0)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*PolicySpecAIAgentHandlingRemediationReboot_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParsePolicySpecAIAgentHandlingRemediationReboot_FieldPath(raw)
	})
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) ProtoMessage() {}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) Subtract(other *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask {
	result := &PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask{}
	removedSelectors := make([]bool, 0)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *PolicySpecAIAgentHandlingRemediationReboot_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) FilterInputFields() *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask {
	result := &PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]PolicySpecAIAgentHandlingRemediationReboot_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParsePolicySpecAIAgentHandlingRemediationReboot_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) AppendPath(path PolicySpecAIAgentHandlingRemediationReboot_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(PolicySpecAIAgentHandlingRemediationReboot_FieldPath))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) GetPaths() []PolicySpecAIAgentHandlingRemediationReboot_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParsePolicySpecAIAgentHandlingRemediationReboot_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) Set(target, source *PolicySpec_AIAgentHandling_Remediation_Reboot) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*PolicySpec_AIAgentHandling_Remediation_Reboot), source.(*PolicySpec_AIAgentHandling_Remediation_Reboot))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) Project(source *PolicySpec_AIAgentHandling_Remediation_Reboot) *PolicySpec_AIAgentHandling_Remediation_Reboot {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &PolicySpec_AIAgentHandling_Remediation_Reboot{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *PolicySpecAIAgentHandlingRemediationReboot_FieldTerminalPath:
			switch tp.selector {
			}
		}
	}
	return result
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*PolicySpec_AIAgentHandling_Remediation_Reboot))
}

func (fieldMask *PolicySpec_AIAgentHandling_Remediation_Reboot_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type NotificationChannelSpec_FieldMask struct {
	Paths []NotificationChannelSpec_FieldPath
}

func FullNotificationChannelSpec_FieldMask() *NotificationChannelSpec_FieldMask {
	res := &NotificationChannelSpec_FieldMask{}
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorEnabled})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorType})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorEnabledKinds})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorEmail})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorSlack})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorWebhook})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorNotificationLanguageCode})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorNotificationMask})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorMaxAlertBodiesInMsg})
	res.Paths = append(res.Paths, &NotificationChannelSpec_FieldTerminalPath{selector: NotificationChannelSpec_FieldPathSelectorPutOnlyAlertsCounterWhenOverflowing})
	return res
}

func (fieldMask *NotificationChannelSpec_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *NotificationChannelSpec_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 10)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*NotificationChannelSpec_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *NotificationChannelSpec_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseNotificationChannelSpec_FieldPath(raw)
	})
}

func (fieldMask *NotificationChannelSpec_FieldMask) ProtoMessage() {}

func (fieldMask *NotificationChannelSpec_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *NotificationChannelSpec_FieldMask) Subtract(other *NotificationChannelSpec_FieldMask) *NotificationChannelSpec_FieldMask {
	result := &NotificationChannelSpec_FieldMask{}
	removedSelectors := make([]bool, 10)
	otherSubMasks := map[NotificationChannelSpec_FieldPathSelector]gotenobject.FieldMask{
		NotificationChannelSpec_FieldPathSelectorEmail:   &NotificationChannelSpec_Email_FieldMask{},
		NotificationChannelSpec_FieldPathSelectorSlack:   &NotificationChannelSpec_Slack_FieldMask{},
		NotificationChannelSpec_FieldPathSelectorWebhook: &NotificationChannelSpec_Webhook_FieldMask{},
	}
	mySubMasks := map[NotificationChannelSpec_FieldPathSelector]gotenobject.FieldMask{
		NotificationChannelSpec_FieldPathSelectorEmail:   &NotificationChannelSpec_Email_FieldMask{},
		NotificationChannelSpec_FieldPathSelectorSlack:   &NotificationChannelSpec_Slack_FieldMask{},
		NotificationChannelSpec_FieldPathSelectorWebhook: &NotificationChannelSpec_Webhook_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *NotificationChannelSpec_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *NotificationChannelSpec_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*NotificationChannelSpec_FieldTerminalPath); ok {
					switch tp.selector {
					case NotificationChannelSpec_FieldPathSelectorEmail:
						mySubMasks[NotificationChannelSpec_FieldPathSelectorEmail] = FullNotificationChannelSpec_Email_FieldMask()
					case NotificationChannelSpec_FieldPathSelectorSlack:
						mySubMasks[NotificationChannelSpec_FieldPathSelectorSlack] = FullNotificationChannelSpec_Slack_FieldMask()
					case NotificationChannelSpec_FieldPathSelectorWebhook:
						mySubMasks[NotificationChannelSpec_FieldPathSelectorWebhook] = FullNotificationChannelSpec_Webhook_FieldMask()
					}
				} else if tp, ok := path.(*NotificationChannelSpec_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &NotificationChannelSpec_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *NotificationChannelSpec_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*NotificationChannelSpec_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *NotificationChannelSpec_FieldMask) FilterInputFields() *NotificationChannelSpec_FieldMask {
	result := &NotificationChannelSpec_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *NotificationChannelSpec_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *NotificationChannelSpec_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]NotificationChannelSpec_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseNotificationChannelSpec_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask NotificationChannelSpec_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *NotificationChannelSpec_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask NotificationChannelSpec_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *NotificationChannelSpec_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_FieldMask) AppendPath(path NotificationChannelSpec_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *NotificationChannelSpec_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(NotificationChannelSpec_FieldPath))
}

func (fieldMask *NotificationChannelSpec_FieldMask) GetPaths() []NotificationChannelSpec_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *NotificationChannelSpec_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *NotificationChannelSpec_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseNotificationChannelSpec_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *NotificationChannelSpec_FieldMask) Set(target, source *NotificationChannelSpec) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *NotificationChannelSpec_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*NotificationChannelSpec), source.(*NotificationChannelSpec))
}

func (fieldMask *NotificationChannelSpec_FieldMask) Project(source *NotificationChannelSpec) *NotificationChannelSpec {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &NotificationChannelSpec{}
	emailMask := &NotificationChannelSpec_Email_FieldMask{}
	wholeEmailAccepted := false
	slackMask := &NotificationChannelSpec_Slack_FieldMask{}
	wholeSlackAccepted := false
	webhookMask := &NotificationChannelSpec_Webhook_FieldMask{}
	wholeWebhookAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *NotificationChannelSpec_FieldTerminalPath:
			switch tp.selector {
			case NotificationChannelSpec_FieldPathSelectorEnabled:
				result.Enabled = source.Enabled
			case NotificationChannelSpec_FieldPathSelectorType:
				result.Type = source.Type
			case NotificationChannelSpec_FieldPathSelectorEnabledKinds:
				result.EnabledKinds = source.EnabledKinds
			case NotificationChannelSpec_FieldPathSelectorEmail:
				result.Email = source.Email
				wholeEmailAccepted = true
			case NotificationChannelSpec_FieldPathSelectorSlack:
				result.Slack = source.Slack
				wholeSlackAccepted = true
			case NotificationChannelSpec_FieldPathSelectorWebhook:
				result.Webhook = source.Webhook
				wholeWebhookAccepted = true
			case NotificationChannelSpec_FieldPathSelectorNotificationLanguageCode:
				result.NotificationLanguageCode = source.NotificationLanguageCode
			case NotificationChannelSpec_FieldPathSelectorNotificationMask:
				result.NotificationMask = source.NotificationMask
			case NotificationChannelSpec_FieldPathSelectorMaxAlertBodiesInMsg:
				result.MaxAlertBodiesInMsg = source.MaxAlertBodiesInMsg
			case NotificationChannelSpec_FieldPathSelectorPutOnlyAlertsCounterWhenOverflowing:
				result.PutOnlyAlertsCounterWhenOverflowing = source.PutOnlyAlertsCounterWhenOverflowing
			}
		case *NotificationChannelSpec_FieldSubPath:
			switch tp.selector {
			case NotificationChannelSpec_FieldPathSelectorEmail:
				emailMask.AppendPath(tp.subPath.(NotificationChannelSpecEmail_FieldPath))
			case NotificationChannelSpec_FieldPathSelectorSlack:
				slackMask.AppendPath(tp.subPath.(NotificationChannelSpecSlack_FieldPath))
			case NotificationChannelSpec_FieldPathSelectorWebhook:
				webhookMask.AppendPath(tp.subPath.(NotificationChannelSpecWebhook_FieldPath))
			}
		}
	}
	if wholeEmailAccepted == false && len(emailMask.Paths) > 0 {
		result.Email = emailMask.Project(source.GetEmail())
	}
	if wholeSlackAccepted == false && len(slackMask.Paths) > 0 {
		result.Slack = slackMask.Project(source.GetSlack())
	}
	if wholeWebhookAccepted == false && len(webhookMask.Paths) > 0 {
		result.Webhook = webhookMask.Project(source.GetWebhook())
	}
	return result
}

func (fieldMask *NotificationChannelSpec_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*NotificationChannelSpec))
}

func (fieldMask *NotificationChannelSpec_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type NotificationChannelSpec_Email_FieldMask struct {
	Paths []NotificationChannelSpecEmail_FieldPath
}

func FullNotificationChannelSpec_Email_FieldMask() *NotificationChannelSpec_Email_FieldMask {
	res := &NotificationChannelSpec_Email_FieldMask{}
	res.Paths = append(res.Paths, &NotificationChannelSpecEmail_FieldTerminalPath{selector: NotificationChannelSpecEmail_FieldPathSelectorAddresses})
	return res
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*NotificationChannelSpecEmail_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseNotificationChannelSpecEmail_FieldPath(raw)
	})
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) ProtoMessage() {}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) Subtract(other *NotificationChannelSpec_Email_FieldMask) *NotificationChannelSpec_Email_FieldMask {
	result := &NotificationChannelSpec_Email_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *NotificationChannelSpecEmail_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*NotificationChannelSpec_Email_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *NotificationChannelSpec_Email_FieldMask) FilterInputFields() *NotificationChannelSpec_Email_FieldMask {
	result := &NotificationChannelSpec_Email_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *NotificationChannelSpec_Email_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]NotificationChannelSpecEmail_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseNotificationChannelSpecEmail_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask NotificationChannelSpec_Email_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask NotificationChannelSpec_Email_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) AppendPath(path NotificationChannelSpecEmail_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(NotificationChannelSpecEmail_FieldPath))
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) GetPaths() []NotificationChannelSpecEmail_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseNotificationChannelSpecEmail_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) Set(target, source *NotificationChannelSpec_Email) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*NotificationChannelSpec_Email), source.(*NotificationChannelSpec_Email))
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) Project(source *NotificationChannelSpec_Email) *NotificationChannelSpec_Email {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &NotificationChannelSpec_Email{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *NotificationChannelSpecEmail_FieldTerminalPath:
			switch tp.selector {
			case NotificationChannelSpecEmail_FieldPathSelectorAddresses:
				result.Addresses = source.Addresses
			}
		}
	}
	return result
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*NotificationChannelSpec_Email))
}

func (fieldMask *NotificationChannelSpec_Email_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type NotificationChannelSpec_Slack_FieldMask struct {
	Paths []NotificationChannelSpecSlack_FieldPath
}

func FullNotificationChannelSpec_Slack_FieldMask() *NotificationChannelSpec_Slack_FieldMask {
	res := &NotificationChannelSpec_Slack_FieldMask{}
	res.Paths = append(res.Paths, &NotificationChannelSpecSlack_FieldTerminalPath{selector: NotificationChannelSpecSlack_FieldPathSelectorIncomingWebhook})
	return res
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*NotificationChannelSpecSlack_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseNotificationChannelSpecSlack_FieldPath(raw)
	})
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) ProtoMessage() {}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) Subtract(other *NotificationChannelSpec_Slack_FieldMask) *NotificationChannelSpec_Slack_FieldMask {
	result := &NotificationChannelSpec_Slack_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *NotificationChannelSpecSlack_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*NotificationChannelSpec_Slack_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *NotificationChannelSpec_Slack_FieldMask) FilterInputFields() *NotificationChannelSpec_Slack_FieldMask {
	result := &NotificationChannelSpec_Slack_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *NotificationChannelSpec_Slack_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]NotificationChannelSpecSlack_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseNotificationChannelSpecSlack_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask NotificationChannelSpec_Slack_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask NotificationChannelSpec_Slack_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) AppendPath(path NotificationChannelSpecSlack_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(NotificationChannelSpecSlack_FieldPath))
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) GetPaths() []NotificationChannelSpecSlack_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseNotificationChannelSpecSlack_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) Set(target, source *NotificationChannelSpec_Slack) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*NotificationChannelSpec_Slack), source.(*NotificationChannelSpec_Slack))
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) Project(source *NotificationChannelSpec_Slack) *NotificationChannelSpec_Slack {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &NotificationChannelSpec_Slack{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *NotificationChannelSpecSlack_FieldTerminalPath:
			switch tp.selector {
			case NotificationChannelSpecSlack_FieldPathSelectorIncomingWebhook:
				result.IncomingWebhook = source.IncomingWebhook
			}
		}
	}
	return result
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*NotificationChannelSpec_Slack))
}

func (fieldMask *NotificationChannelSpec_Slack_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type NotificationChannelSpec_PagerDuty_FieldMask struct {
	Paths []NotificationChannelSpecPagerDuty_FieldPath
}

func FullNotificationChannelSpec_PagerDuty_FieldMask() *NotificationChannelSpec_PagerDuty_FieldMask {
	res := &NotificationChannelSpec_PagerDuty_FieldMask{}
	res.Paths = append(res.Paths, &NotificationChannelSpecPagerDuty_FieldTerminalPath{selector: NotificationChannelSpecPagerDuty_FieldPathSelectorServiceKey})
	return res
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*NotificationChannelSpecPagerDuty_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseNotificationChannelSpecPagerDuty_FieldPath(raw)
	})
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) ProtoMessage() {}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) Subtract(other *NotificationChannelSpec_PagerDuty_FieldMask) *NotificationChannelSpec_PagerDuty_FieldMask {
	result := &NotificationChannelSpec_PagerDuty_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *NotificationChannelSpecPagerDuty_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*NotificationChannelSpec_PagerDuty_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) FilterInputFields() *NotificationChannelSpec_PagerDuty_FieldMask {
	result := &NotificationChannelSpec_PagerDuty_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]NotificationChannelSpecPagerDuty_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseNotificationChannelSpecPagerDuty_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask NotificationChannelSpec_PagerDuty_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask NotificationChannelSpec_PagerDuty_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) AppendPath(path NotificationChannelSpecPagerDuty_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(NotificationChannelSpecPagerDuty_FieldPath))
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) GetPaths() []NotificationChannelSpecPagerDuty_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseNotificationChannelSpecPagerDuty_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) Set(target, source *NotificationChannelSpec_PagerDuty) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*NotificationChannelSpec_PagerDuty), source.(*NotificationChannelSpec_PagerDuty))
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) Project(source *NotificationChannelSpec_PagerDuty) *NotificationChannelSpec_PagerDuty {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &NotificationChannelSpec_PagerDuty{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *NotificationChannelSpecPagerDuty_FieldTerminalPath:
			switch tp.selector {
			case NotificationChannelSpecPagerDuty_FieldPathSelectorServiceKey:
				result.ServiceKey = source.ServiceKey
			}
		}
	}
	return result
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*NotificationChannelSpec_PagerDuty))
}

func (fieldMask *NotificationChannelSpec_PagerDuty_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type NotificationChannelSpec_Webhook_FieldMask struct {
	Paths []NotificationChannelSpecWebhook_FieldPath
}

func FullNotificationChannelSpec_Webhook_FieldMask() *NotificationChannelSpec_Webhook_FieldMask {
	res := &NotificationChannelSpec_Webhook_FieldMask{}
	res.Paths = append(res.Paths, &NotificationChannelSpecWebhook_FieldTerminalPath{selector: NotificationChannelSpecWebhook_FieldPathSelectorUrl})
	res.Paths = append(res.Paths, &NotificationChannelSpecWebhook_FieldTerminalPath{selector: NotificationChannelSpecWebhook_FieldPathSelectorHeaders})
	res.Paths = append(res.Paths, &NotificationChannelSpecWebhook_FieldTerminalPath{selector: NotificationChannelSpecWebhook_FieldPathSelectorMaxMessageSizeMb})
	return res
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*NotificationChannelSpecWebhook_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseNotificationChannelSpecWebhook_FieldPath(raw)
	})
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) ProtoMessage() {}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) Subtract(other *NotificationChannelSpec_Webhook_FieldMask) *NotificationChannelSpec_Webhook_FieldMask {
	result := &NotificationChannelSpec_Webhook_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[NotificationChannelSpecWebhook_FieldPathSelector]gotenobject.FieldMask{
		NotificationChannelSpecWebhook_FieldPathSelectorHeaders: &NotificationChannelSpec_Webhook_Header_FieldMask{},
	}
	mySubMasks := map[NotificationChannelSpecWebhook_FieldPathSelector]gotenobject.FieldMask{
		NotificationChannelSpecWebhook_FieldPathSelectorHeaders: &NotificationChannelSpec_Webhook_Header_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *NotificationChannelSpecWebhook_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *NotificationChannelSpecWebhook_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*NotificationChannelSpecWebhook_FieldTerminalPath); ok {
					switch tp.selector {
					case NotificationChannelSpecWebhook_FieldPathSelectorHeaders:
						mySubMasks[NotificationChannelSpecWebhook_FieldPathSelectorHeaders] = FullNotificationChannelSpec_Webhook_Header_FieldMask()
					}
				} else if tp, ok := path.(*NotificationChannelSpecWebhook_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &NotificationChannelSpecWebhook_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*NotificationChannelSpec_Webhook_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) FilterInputFields() *NotificationChannelSpec_Webhook_FieldMask {
	result := &NotificationChannelSpec_Webhook_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]NotificationChannelSpecWebhook_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseNotificationChannelSpecWebhook_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask NotificationChannelSpec_Webhook_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask NotificationChannelSpec_Webhook_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) AppendPath(path NotificationChannelSpecWebhook_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(NotificationChannelSpecWebhook_FieldPath))
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) GetPaths() []NotificationChannelSpecWebhook_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseNotificationChannelSpecWebhook_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) Set(target, source *NotificationChannelSpec_Webhook) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*NotificationChannelSpec_Webhook), source.(*NotificationChannelSpec_Webhook))
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) Project(source *NotificationChannelSpec_Webhook) *NotificationChannelSpec_Webhook {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &NotificationChannelSpec_Webhook{}
	headersMask := &NotificationChannelSpec_Webhook_Header_FieldMask{}
	wholeHeadersAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *NotificationChannelSpecWebhook_FieldTerminalPath:
			switch tp.selector {
			case NotificationChannelSpecWebhook_FieldPathSelectorUrl:
				result.Url = source.Url
			case NotificationChannelSpecWebhook_FieldPathSelectorHeaders:
				result.Headers = source.Headers
				wholeHeadersAccepted = true
			case NotificationChannelSpecWebhook_FieldPathSelectorMaxMessageSizeMb:
				result.MaxMessageSizeMb = source.MaxMessageSizeMb
			}
		case *NotificationChannelSpecWebhook_FieldSubPath:
			switch tp.selector {
			case NotificationChannelSpecWebhook_FieldPathSelectorHeaders:
				headersMask.AppendPath(tp.subPath.(NotificationChannelSpecWebhookHeader_FieldPath))
			}
		}
	}
	if wholeHeadersAccepted == false && len(headersMask.Paths) > 0 {
		for _, sourceItem := range source.GetHeaders() {
			result.Headers = append(result.Headers, headersMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*NotificationChannelSpec_Webhook))
}

func (fieldMask *NotificationChannelSpec_Webhook_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type NotificationChannelSpec_Webhook_Header_FieldMask struct {
	Paths []NotificationChannelSpecWebhookHeader_FieldPath
}

func FullNotificationChannelSpec_Webhook_Header_FieldMask() *NotificationChannelSpec_Webhook_Header_FieldMask {
	res := &NotificationChannelSpec_Webhook_Header_FieldMask{}
	res.Paths = append(res.Paths, &NotificationChannelSpecWebhookHeader_FieldTerminalPath{selector: NotificationChannelSpecWebhookHeader_FieldPathSelectorKey})
	res.Paths = append(res.Paths, &NotificationChannelSpecWebhookHeader_FieldTerminalPath{selector: NotificationChannelSpecWebhookHeader_FieldPathSelectorValue})
	return res
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*NotificationChannelSpecWebhookHeader_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseNotificationChannelSpecWebhookHeader_FieldPath(raw)
	})
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) ProtoMessage() {}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) Subtract(other *NotificationChannelSpec_Webhook_Header_FieldMask) *NotificationChannelSpec_Webhook_Header_FieldMask {
	result := &NotificationChannelSpec_Webhook_Header_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *NotificationChannelSpecWebhookHeader_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*NotificationChannelSpec_Webhook_Header_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) FilterInputFields() *NotificationChannelSpec_Webhook_Header_FieldMask {
	result := &NotificationChannelSpec_Webhook_Header_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]NotificationChannelSpecWebhookHeader_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseNotificationChannelSpecWebhookHeader_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask NotificationChannelSpec_Webhook_Header_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask NotificationChannelSpec_Webhook_Header_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) AppendPath(path NotificationChannelSpecWebhookHeader_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(NotificationChannelSpecWebhookHeader_FieldPath))
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) GetPaths() []NotificationChannelSpecWebhookHeader_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseNotificationChannelSpecWebhookHeader_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) Set(target, source *NotificationChannelSpec_Webhook_Header) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*NotificationChannelSpec_Webhook_Header), source.(*NotificationChannelSpec_Webhook_Header))
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) Project(source *NotificationChannelSpec_Webhook_Header) *NotificationChannelSpec_Webhook_Header {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &NotificationChannelSpec_Webhook_Header{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *NotificationChannelSpecWebhookHeader_FieldTerminalPath:
			switch tp.selector {
			case NotificationChannelSpecWebhookHeader_FieldPathSelectorKey:
				result.Key = source.Key
			case NotificationChannelSpecWebhookHeader_FieldPathSelectorValue:
				result.Value = source.Value
			}
		}
	}
	return result
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*NotificationChannelSpec_Webhook_Header))
}

func (fieldMask *NotificationChannelSpec_Webhook_Header_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type AlertingThreshold_FieldMask struct {
	Paths []AlertingThreshold_FieldPath
}

func FullAlertingThreshold_FieldMask() *AlertingThreshold_FieldMask {
	res := &AlertingThreshold_FieldMask{}
	res.Paths = append(res.Paths, &AlertingThreshold_FieldTerminalPath{selector: AlertingThreshold_FieldPathSelectorValue})
	res.Paths = append(res.Paths, &AlertingThreshold_FieldTerminalPath{selector: AlertingThreshold_FieldPathSelectorIsInclusive})
	return res
}

func (fieldMask *AlertingThreshold_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *AlertingThreshold_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*AlertingThreshold_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *AlertingThreshold_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseAlertingThreshold_FieldPath(raw)
	})
}

func (fieldMask *AlertingThreshold_FieldMask) ProtoMessage() {}

func (fieldMask *AlertingThreshold_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *AlertingThreshold_FieldMask) Subtract(other *AlertingThreshold_FieldMask) *AlertingThreshold_FieldMask {
	result := &AlertingThreshold_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *AlertingThreshold_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *AlertingThreshold_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*AlertingThreshold_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *AlertingThreshold_FieldMask) FilterInputFields() *AlertingThreshold_FieldMask {
	result := &AlertingThreshold_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *AlertingThreshold_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *AlertingThreshold_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]AlertingThreshold_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseAlertingThreshold_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask AlertingThreshold_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *AlertingThreshold_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AlertingThreshold_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask AlertingThreshold_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *AlertingThreshold_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *AlertingThreshold_FieldMask) AppendPath(path AlertingThreshold_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *AlertingThreshold_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(AlertingThreshold_FieldPath))
}

func (fieldMask *AlertingThreshold_FieldMask) GetPaths() []AlertingThreshold_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *AlertingThreshold_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *AlertingThreshold_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseAlertingThreshold_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *AlertingThreshold_FieldMask) Set(target, source *AlertingThreshold) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *AlertingThreshold_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*AlertingThreshold), source.(*AlertingThreshold))
}

func (fieldMask *AlertingThreshold_FieldMask) Project(source *AlertingThreshold) *AlertingThreshold {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &AlertingThreshold{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *AlertingThreshold_FieldTerminalPath:
			switch tp.selector {
			case AlertingThreshold_FieldPathSelectorValue:
				result.Value = source.Value
			case AlertingThreshold_FieldPathSelectorIsInclusive:
				result.IsInclusive = source.IsInclusive
			}
		}
	}
	return result
}

func (fieldMask *AlertingThreshold_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*AlertingThreshold))
}

func (fieldMask *AlertingThreshold_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
