// Code generated by protoc-gen-goten-object
// File: edgelq/alerting/proto/v1/ts_entry.proto
// DO NOT EDIT!!!

package ts_entry

import (
	"encoding/json"
	"strings"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	googlefieldmaskpb "google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	rcommon "github.com/cloudwan/edgelq-sdk/alerting/resources/v1/common"
	ts_condition "github.com/cloudwan/edgelq-sdk/alerting/resources/v1/ts_condition"
	monitoring_common "github.com/cloudwan/edgelq-sdk/monitoring/resources/v4/common"
	meta "github.com/cloudwan/goten-sdk/types/meta"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = googlefieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &rcommon.LogCndSpec{}
	_ = &ts_condition.TsCondition{}
	_ = &monitoring_common.LabelDescriptor{}
	_ = &durationpb.Duration{}
	_ = &timestamppb.Timestamp{}
	_ = &meta.Meta{}
)

type TsEntry_FieldMask struct {
	Paths []TsEntry_FieldPath
}

func FullTsEntry_FieldMask() *TsEntry_FieldMask {
	res := &TsEntry_FieldMask{}
	res.Paths = append(res.Paths, &TsEntry_FieldTerminalPath{selector: TsEntry_FieldPathSelectorName})
	res.Paths = append(res.Paths, &TsEntry_FieldTerminalPath{selector: TsEntry_FieldPathSelectorMetadata})
	res.Paths = append(res.Paths, &TsEntry_FieldTerminalPath{selector: TsEntry_FieldPathSelectorInfo})
	res.Paths = append(res.Paths, &TsEntry_FieldTerminalPath{selector: TsEntry_FieldPathSelectorState})
	res.Paths = append(res.Paths, &TsEntry_FieldTerminalPath{selector: TsEntry_FieldPathSelectorInternal})
	return res
}

func (fieldMask *TsEntry_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsEntry_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsEntry_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsEntry_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsEntry_FieldPath(raw)
	})
}

func (fieldMask *TsEntry_FieldMask) ProtoMessage() {}

func (fieldMask *TsEntry_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsEntry_FieldMask) Subtract(other *TsEntry_FieldMask) *TsEntry_FieldMask {
	result := &TsEntry_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[TsEntry_FieldPathSelector]gotenobject.FieldMask{
		TsEntry_FieldPathSelectorMetadata: &meta.Meta_FieldMask{},
		TsEntry_FieldPathSelectorInfo:     &TsEntry_Info_FieldMask{},
		TsEntry_FieldPathSelectorState:    &TsEntry_State_FieldMask{},
		TsEntry_FieldPathSelectorInternal: &TsEntry_Internal_FieldMask{},
	}
	mySubMasks := map[TsEntry_FieldPathSelector]gotenobject.FieldMask{
		TsEntry_FieldPathSelectorMetadata: &meta.Meta_FieldMask{},
		TsEntry_FieldPathSelectorInfo:     &TsEntry_Info_FieldMask{},
		TsEntry_FieldPathSelectorState:    &TsEntry_State_FieldMask{},
		TsEntry_FieldPathSelectorInternal: &TsEntry_Internal_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsEntry_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsEntry_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsEntry_FieldTerminalPath); ok {
					switch tp.selector {
					case TsEntry_FieldPathSelectorMetadata:
						mySubMasks[TsEntry_FieldPathSelectorMetadata] = meta.FullMeta_FieldMask()
					case TsEntry_FieldPathSelectorInfo:
						mySubMasks[TsEntry_FieldPathSelectorInfo] = FullTsEntry_Info_FieldMask()
					case TsEntry_FieldPathSelectorState:
						mySubMasks[TsEntry_FieldPathSelectorState] = FullTsEntry_State_FieldMask()
					case TsEntry_FieldPathSelectorInternal:
						mySubMasks[TsEntry_FieldPathSelectorInternal] = FullTsEntry_Internal_FieldMask()
					}
				} else if tp, ok := path.(*TsEntry_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsEntry_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsEntry_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsEntry_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsEntry_FieldMask) FilterInputFields() *TsEntry_FieldMask {
	result := &TsEntry_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case TsEntry_FieldPathSelectorInfo:
		case TsEntry_FieldPathSelectorMetadata:
			if _, ok := path.(*TsEntry_FieldTerminalPath); ok {
				for _, subpath := range meta.FullMeta_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &TsEntry_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*TsEntry_FieldSubPath); ok {
				selectedMask := &meta.Meta_FieldMask{
					Paths: []meta.Meta_FieldPath{sub.subPath.(meta.Meta_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &TsEntry_FieldSubPath{selector: TsEntry_FieldPathSelectorMetadata, subPath: allowedPath})
				}
			}
		case TsEntry_FieldPathSelectorInternal:
			if _, ok := path.(*TsEntry_FieldTerminalPath); ok {
				for _, subpath := range FullTsEntry_Internal_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &TsEntry_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*TsEntry_FieldSubPath); ok {
				selectedMask := &TsEntry_Internal_FieldMask{
					Paths: []TsEntryInternal_FieldPath{sub.subPath.(TsEntryInternal_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &TsEntry_FieldSubPath{selector: TsEntry_FieldPathSelectorInternal, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsEntry_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsEntry_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsEntry_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsEntry_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsEntry_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsEntry_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsEntry_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsEntry_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_FieldMask) AppendPath(path TsEntry_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsEntry_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsEntry_FieldPath))
}

func (fieldMask *TsEntry_FieldMask) GetPaths() []TsEntry_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsEntry_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsEntry_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsEntry_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsEntry_FieldMask) Set(target, source *TsEntry) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsEntry_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsEntry), source.(*TsEntry))
}

func (fieldMask *TsEntry_FieldMask) Project(source *TsEntry) *TsEntry {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsEntry{}
	metadataMask := &meta.Meta_FieldMask{}
	wholeMetadataAccepted := false
	infoMask := &TsEntry_Info_FieldMask{}
	wholeInfoAccepted := false
	stateMask := &TsEntry_State_FieldMask{}
	wholeStateAccepted := false
	internalMask := &TsEntry_Internal_FieldMask{}
	wholeInternalAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsEntry_FieldTerminalPath:
			switch tp.selector {
			case TsEntry_FieldPathSelectorName:
				result.Name = source.Name
			case TsEntry_FieldPathSelectorMetadata:
				result.Metadata = source.Metadata
				wholeMetadataAccepted = true
			case TsEntry_FieldPathSelectorInfo:
				result.Info = source.Info
				wholeInfoAccepted = true
			case TsEntry_FieldPathSelectorState:
				result.State = source.State
				wholeStateAccepted = true
			case TsEntry_FieldPathSelectorInternal:
				result.Internal = source.Internal
				wholeInternalAccepted = true
			}
		case *TsEntry_FieldSubPath:
			switch tp.selector {
			case TsEntry_FieldPathSelectorMetadata:
				metadataMask.AppendPath(tp.subPath.(meta.Meta_FieldPath))
			case TsEntry_FieldPathSelectorInfo:
				infoMask.AppendPath(tp.subPath.(TsEntryInfo_FieldPath))
			case TsEntry_FieldPathSelectorState:
				stateMask.AppendPath(tp.subPath.(TsEntryState_FieldPath))
			case TsEntry_FieldPathSelectorInternal:
				internalMask.AppendPath(tp.subPath.(TsEntryInternal_FieldPath))
			}
		}
	}
	if wholeMetadataAccepted == false && len(metadataMask.Paths) > 0 {
		result.Metadata = metadataMask.Project(source.GetMetadata())
	}
	if wholeInfoAccepted == false && len(infoMask.Paths) > 0 {
		result.Info = infoMask.Project(source.GetInfo())
	}
	if wholeStateAccepted == false && len(stateMask.Paths) > 0 {
		result.State = stateMask.Project(source.GetState())
	}
	if wholeInternalAccepted == false && len(internalMask.Paths) > 0 {
		result.Internal = internalMask.Project(source.GetInternal())
	}
	return result
}

func (fieldMask *TsEntry_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsEntry))
}

func (fieldMask *TsEntry_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsEntry_Info_FieldMask struct {
	Paths []TsEntryInfo_FieldPath
}

func FullTsEntry_Info_FieldMask() *TsEntry_Info_FieldMask {
	res := &TsEntry_Info_FieldMask{}
	res.Paths = append(res.Paths, &TsEntryInfo_FieldTerminalPath{selector: TsEntryInfo_FieldPathSelectorAlertingResource})
	res.Paths = append(res.Paths, &TsEntryInfo_FieldTerminalPath{selector: TsEntryInfo_FieldPathSelectorGroupByKey})
	res.Paths = append(res.Paths, &TsEntryInfo_FieldTerminalPath{selector: TsEntryInfo_FieldPathSelectorCommonMetricLabels})
	res.Paths = append(res.Paths, &TsEntryInfo_FieldTerminalPath{selector: TsEntryInfo_FieldPathSelectorCommonResourceLabels})
	return res
}

func (fieldMask *TsEntry_Info_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsEntry_Info_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsEntryInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsEntry_Info_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsEntryInfo_FieldPath(raw)
	})
}

func (fieldMask *TsEntry_Info_FieldMask) ProtoMessage() {}

func (fieldMask *TsEntry_Info_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsEntry_Info_FieldMask) Subtract(other *TsEntry_Info_FieldMask) *TsEntry_Info_FieldMask {
	result := &TsEntry_Info_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[TsEntryInfo_FieldPathSelector]gotenobject.FieldMask{
		TsEntryInfo_FieldPathSelectorAlertingResource: &meta.OwnerReference_FieldMask{},
	}
	mySubMasks := map[TsEntryInfo_FieldPathSelector]gotenobject.FieldMask{
		TsEntryInfo_FieldPathSelectorAlertingResource: &meta.OwnerReference_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsEntryInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsEntryInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsEntryInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case TsEntryInfo_FieldPathSelectorAlertingResource:
						mySubMasks[TsEntryInfo_FieldPathSelectorAlertingResource] = meta.FullOwnerReference_FieldMask()
					}
				} else if tp, ok := path.(*TsEntryInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsEntryInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsEntry_Info_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsEntry_Info_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsEntry_Info_FieldMask) FilterInputFields() *TsEntry_Info_FieldMask {
	result := &TsEntry_Info_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsEntry_Info_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsEntry_Info_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsEntryInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsEntryInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsEntry_Info_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsEntry_Info_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_Info_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsEntry_Info_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsEntry_Info_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_Info_FieldMask) AppendPath(path TsEntryInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsEntry_Info_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsEntryInfo_FieldPath))
}

func (fieldMask *TsEntry_Info_FieldMask) GetPaths() []TsEntryInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsEntry_Info_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsEntry_Info_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsEntryInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsEntry_Info_FieldMask) Set(target, source *TsEntry_Info) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsEntry_Info_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsEntry_Info), source.(*TsEntry_Info))
}

func (fieldMask *TsEntry_Info_FieldMask) Project(source *TsEntry_Info) *TsEntry_Info {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsEntry_Info{}
	alertingResourceMask := &meta.OwnerReference_FieldMask{}
	wholeAlertingResourceAccepted := false
	var commonMetricLabelsMapKeys []string
	wholeCommonMetricLabelsAccepted := false
	var commonResourceLabelsMapKeys []string
	wholeCommonResourceLabelsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsEntryInfo_FieldTerminalPath:
			switch tp.selector {
			case TsEntryInfo_FieldPathSelectorAlertingResource:
				result.AlertingResource = source.AlertingResource
				wholeAlertingResourceAccepted = true
			case TsEntryInfo_FieldPathSelectorGroupByKey:
				result.GroupByKey = source.GroupByKey
			case TsEntryInfo_FieldPathSelectorCommonMetricLabels:
				result.CommonMetricLabels = source.CommonMetricLabels
				wholeCommonMetricLabelsAccepted = true
			case TsEntryInfo_FieldPathSelectorCommonResourceLabels:
				result.CommonResourceLabels = source.CommonResourceLabels
				wholeCommonResourceLabelsAccepted = true
			}
		case *TsEntryInfo_FieldSubPath:
			switch tp.selector {
			case TsEntryInfo_FieldPathSelectorAlertingResource:
				alertingResourceMask.AppendPath(tp.subPath.(meta.OwnerReference_FieldPath))
			}
		case *TsEntryInfo_FieldPathMap:
			switch tp.selector {
			case TsEntryInfo_FieldPathSelectorCommonMetricLabels:
				commonMetricLabelsMapKeys = append(commonMetricLabelsMapKeys, tp.key)
			case TsEntryInfo_FieldPathSelectorCommonResourceLabels:
				commonResourceLabelsMapKeys = append(commonResourceLabelsMapKeys, tp.key)
			}
		}
	}
	if wholeAlertingResourceAccepted == false && len(alertingResourceMask.Paths) > 0 {
		result.AlertingResource = alertingResourceMask.Project(source.GetAlertingResource())
	}
	if wholeCommonMetricLabelsAccepted == false && len(commonMetricLabelsMapKeys) > 0 && source.GetCommonMetricLabels() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetCommonMetricLabels()
		for _, key := range commonMetricLabelsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.CommonMetricLabels = copiedMap
	}
	if wholeCommonResourceLabelsAccepted == false && len(commonResourceLabelsMapKeys) > 0 && source.GetCommonResourceLabels() != nil {
		copiedMap := map[string]string{}
		sourceMap := source.GetCommonResourceLabels()
		for _, key := range commonResourceLabelsMapKeys {
			copiedMap[key] = sourceMap[key]
		}
		result.CommonResourceLabels = copiedMap
	}
	return result
}

func (fieldMask *TsEntry_Info_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsEntry_Info))
}

func (fieldMask *TsEntry_Info_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsEntry_State_FieldMask struct {
	Paths []TsEntryState_FieldPath
}

func FullTsEntry_State_FieldMask() *TsEntry_State_FieldMask {
	res := &TsEntry_State_FieldMask{}
	res.Paths = append(res.Paths, &TsEntryState_FieldTerminalPath{selector: TsEntryState_FieldPathSelectorModels})
	res.Paths = append(res.Paths, &TsEntryState_FieldTerminalPath{selector: TsEntryState_FieldPathSelectorThresholds})
	return res
}

func (fieldMask *TsEntry_State_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsEntry_State_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsEntryState_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsEntry_State_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsEntryState_FieldPath(raw)
	})
}

func (fieldMask *TsEntry_State_FieldMask) ProtoMessage() {}

func (fieldMask *TsEntry_State_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsEntry_State_FieldMask) Subtract(other *TsEntry_State_FieldMask) *TsEntry_State_FieldMask {
	result := &TsEntry_State_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[TsEntryState_FieldPathSelector]gotenobject.FieldMask{
		TsEntryState_FieldPathSelectorModels:     &TsEntry_State_AnomalyModelData_FieldMask{},
		TsEntryState_FieldPathSelectorThresholds: &TsEntry_State_AdaptiveThresholdInfo_FieldMask{},
	}
	mySubMasks := map[TsEntryState_FieldPathSelector]gotenobject.FieldMask{
		TsEntryState_FieldPathSelectorModels:     &TsEntry_State_AnomalyModelData_FieldMask{},
		TsEntryState_FieldPathSelectorThresholds: &TsEntry_State_AdaptiveThresholdInfo_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsEntryState_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsEntryState_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsEntryState_FieldTerminalPath); ok {
					switch tp.selector {
					case TsEntryState_FieldPathSelectorModels:
						mySubMasks[TsEntryState_FieldPathSelectorModels] = FullTsEntry_State_AnomalyModelData_FieldMask()
					case TsEntryState_FieldPathSelectorThresholds:
						mySubMasks[TsEntryState_FieldPathSelectorThresholds] = FullTsEntry_State_AdaptiveThresholdInfo_FieldMask()
					}
				} else if tp, ok := path.(*TsEntryState_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsEntryState_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsEntry_State_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsEntry_State_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsEntry_State_FieldMask) FilterInputFields() *TsEntry_State_FieldMask {
	result := &TsEntry_State_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsEntry_State_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsEntry_State_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsEntryState_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsEntryState_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsEntry_State_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsEntry_State_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_State_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsEntry_State_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsEntry_State_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_State_FieldMask) AppendPath(path TsEntryState_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsEntry_State_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsEntryState_FieldPath))
}

func (fieldMask *TsEntry_State_FieldMask) GetPaths() []TsEntryState_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsEntry_State_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsEntry_State_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsEntryState_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsEntry_State_FieldMask) Set(target, source *TsEntry_State) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsEntry_State_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsEntry_State), source.(*TsEntry_State))
}

func (fieldMask *TsEntry_State_FieldMask) Project(source *TsEntry_State) *TsEntry_State {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsEntry_State{}
	modelsMask := &TsEntry_State_AnomalyModelData_FieldMask{}
	wholeModelsAccepted := false
	thresholdsMask := &TsEntry_State_AdaptiveThresholdInfo_FieldMask{}
	wholeThresholdsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsEntryState_FieldTerminalPath:
			switch tp.selector {
			case TsEntryState_FieldPathSelectorModels:
				result.Models = source.Models
				wholeModelsAccepted = true
			case TsEntryState_FieldPathSelectorThresholds:
				result.Thresholds = source.Thresholds
				wholeThresholdsAccepted = true
			}
		case *TsEntryState_FieldSubPath:
			switch tp.selector {
			case TsEntryState_FieldPathSelectorModels:
				modelsMask.AppendPath(tp.subPath.(TsEntryStateAnomalyModelData_FieldPath))
			case TsEntryState_FieldPathSelectorThresholds:
				thresholdsMask.AppendPath(tp.subPath.(TsEntryStateAdaptiveThresholdInfo_FieldPath))
			}
		}
	}
	if wholeModelsAccepted == false && len(modelsMask.Paths) > 0 {
		for _, sourceItem := range source.GetModels() {
			result.Models = append(result.Models, modelsMask.Project(sourceItem))
		}
	}
	if wholeThresholdsAccepted == false && len(thresholdsMask.Paths) > 0 {
		for _, sourceItem := range source.GetThresholds() {
			result.Thresholds = append(result.Thresholds, thresholdsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *TsEntry_State_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsEntry_State))
}

func (fieldMask *TsEntry_State_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsEntry_Internal_FieldMask struct {
	Paths []TsEntryInternal_FieldPath
}

func FullTsEntry_Internal_FieldMask() *TsEntry_Internal_FieldMask {
	res := &TsEntry_Internal_FieldMask{}
	res.Paths = append(res.Paths, &TsEntryInternal_FieldTerminalPath{selector: TsEntryInternal_FieldPathSelectorAlertingLocation})
	res.Paths = append(res.Paths, &TsEntryInternal_FieldTerminalPath{selector: TsEntryInternal_FieldPathSelectorSpecGeneration})
	return res
}

func (fieldMask *TsEntry_Internal_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsEntry_Internal_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsEntryInternal_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsEntry_Internal_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsEntryInternal_FieldPath(raw)
	})
}

func (fieldMask *TsEntry_Internal_FieldMask) ProtoMessage() {}

func (fieldMask *TsEntry_Internal_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsEntry_Internal_FieldMask) Subtract(other *TsEntry_Internal_FieldMask) *TsEntry_Internal_FieldMask {
	result := &TsEntry_Internal_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsEntryInternal_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsEntry_Internal_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsEntry_Internal_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsEntry_Internal_FieldMask) FilterInputFields() *TsEntry_Internal_FieldMask {
	result := &TsEntry_Internal_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case TsEntryInternal_FieldPathSelectorAlertingLocation:
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsEntry_Internal_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsEntry_Internal_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsEntryInternal_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsEntryInternal_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsEntry_Internal_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsEntry_Internal_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_Internal_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsEntry_Internal_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsEntry_Internal_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_Internal_FieldMask) AppendPath(path TsEntryInternal_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsEntry_Internal_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsEntryInternal_FieldPath))
}

func (fieldMask *TsEntry_Internal_FieldMask) GetPaths() []TsEntryInternal_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsEntry_Internal_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsEntry_Internal_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsEntryInternal_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsEntry_Internal_FieldMask) Set(target, source *TsEntry_Internal) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsEntry_Internal_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsEntry_Internal), source.(*TsEntry_Internal))
}

func (fieldMask *TsEntry_Internal_FieldMask) Project(source *TsEntry_Internal) *TsEntry_Internal {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsEntry_Internal{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsEntryInternal_FieldTerminalPath:
			switch tp.selector {
			case TsEntryInternal_FieldPathSelectorAlertingLocation:
				result.AlertingLocation = source.AlertingLocation
			case TsEntryInternal_FieldPathSelectorSpecGeneration:
				result.SpecGeneration = source.SpecGeneration
			}
		}
	}
	return result
}

func (fieldMask *TsEntry_Internal_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsEntry_Internal))
}

func (fieldMask *TsEntry_Internal_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsEntry_State_AnomalyModelData_FieldMask struct {
	Paths []TsEntryStateAnomalyModelData_FieldPath
}

func FullTsEntry_State_AnomalyModelData_FieldMask() *TsEntry_State_AnomalyModelData_FieldMask {
	res := &TsEntry_State_AnomalyModelData_FieldMask{}
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorAnalysisWindow})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorModelData})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorTrainingMeanErr})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorTrainingMaxErr})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorTrainedInEpochs})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorTrainedIn})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorTrainAfter})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorTrainingPeriod})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelData_FieldTerminalPath{selector: TsEntryStateAnomalyModelData_FieldPathSelectorSensitiveness})
	return res
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 9)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsEntryStateAnomalyModelData_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsEntryStateAnomalyModelData_FieldPath(raw)
	})
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) ProtoMessage() {}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) Subtract(other *TsEntry_State_AnomalyModelData_FieldMask) *TsEntry_State_AnomalyModelData_FieldMask {
	result := &TsEntry_State_AnomalyModelData_FieldMask{}
	removedSelectors := make([]bool, 9)
	otherSubMasks := map[TsEntryStateAnomalyModelData_FieldPathSelector]gotenobject.FieldMask{
		TsEntryStateAnomalyModelData_FieldPathSelectorTrainingPeriod: &monitoring_common.TimeInterval_FieldMask{},
		TsEntryStateAnomalyModelData_FieldPathSelectorSensitiveness:  &TsEntry_State_AnomalyModelSensitiveness_FieldMask{},
	}
	mySubMasks := map[TsEntryStateAnomalyModelData_FieldPathSelector]gotenobject.FieldMask{
		TsEntryStateAnomalyModelData_FieldPathSelectorTrainingPeriod: &monitoring_common.TimeInterval_FieldMask{},
		TsEntryStateAnomalyModelData_FieldPathSelectorSensitiveness:  &TsEntry_State_AnomalyModelSensitiveness_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsEntryStateAnomalyModelData_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsEntryStateAnomalyModelData_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsEntryStateAnomalyModelData_FieldTerminalPath); ok {
					switch tp.selector {
					case TsEntryStateAnomalyModelData_FieldPathSelectorTrainingPeriod:
						mySubMasks[TsEntryStateAnomalyModelData_FieldPathSelectorTrainingPeriod] = monitoring_common.FullTimeInterval_FieldMask()
					case TsEntryStateAnomalyModelData_FieldPathSelectorSensitiveness:
						mySubMasks[TsEntryStateAnomalyModelData_FieldPathSelectorSensitiveness] = FullTsEntry_State_AnomalyModelSensitiveness_FieldMask()
					}
				} else if tp, ok := path.(*TsEntryStateAnomalyModelData_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsEntryStateAnomalyModelData_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsEntry_State_AnomalyModelData_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) FilterInputFields() *TsEntry_State_AnomalyModelData_FieldMask {
	result := &TsEntry_State_AnomalyModelData_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsEntryStateAnomalyModelData_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsEntryStateAnomalyModelData_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsEntry_State_AnomalyModelData_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsEntry_State_AnomalyModelData_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) AppendPath(path TsEntryStateAnomalyModelData_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsEntryStateAnomalyModelData_FieldPath))
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) GetPaths() []TsEntryStateAnomalyModelData_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsEntryStateAnomalyModelData_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) Set(target, source *TsEntry_State_AnomalyModelData) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsEntry_State_AnomalyModelData), source.(*TsEntry_State_AnomalyModelData))
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) Project(source *TsEntry_State_AnomalyModelData) *TsEntry_State_AnomalyModelData {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsEntry_State_AnomalyModelData{}
	trainingPeriodMask := &monitoring_common.TimeInterval_FieldMask{}
	wholeTrainingPeriodAccepted := false
	sensitivenessMask := &TsEntry_State_AnomalyModelSensitiveness_FieldMask{}
	wholeSensitivenessAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsEntryStateAnomalyModelData_FieldTerminalPath:
			switch tp.selector {
			case TsEntryStateAnomalyModelData_FieldPathSelectorAnalysisWindow:
				result.AnalysisWindow = source.AnalysisWindow
			case TsEntryStateAnomalyModelData_FieldPathSelectorModelData:
				result.ModelData = source.ModelData
			case TsEntryStateAnomalyModelData_FieldPathSelectorTrainingMeanErr:
				result.TrainingMeanErr = source.TrainingMeanErr
			case TsEntryStateAnomalyModelData_FieldPathSelectorTrainingMaxErr:
				result.TrainingMaxErr = source.TrainingMaxErr
			case TsEntryStateAnomalyModelData_FieldPathSelectorTrainedInEpochs:
				result.TrainedInEpochs = source.TrainedInEpochs
			case TsEntryStateAnomalyModelData_FieldPathSelectorTrainedIn:
				result.TrainedIn = source.TrainedIn
			case TsEntryStateAnomalyModelData_FieldPathSelectorTrainAfter:
				result.TrainAfter = source.TrainAfter
			case TsEntryStateAnomalyModelData_FieldPathSelectorTrainingPeriod:
				result.TrainingPeriod = source.TrainingPeriod
				wholeTrainingPeriodAccepted = true
			case TsEntryStateAnomalyModelData_FieldPathSelectorSensitiveness:
				result.Sensitiveness = source.Sensitiveness
				wholeSensitivenessAccepted = true
			}
		case *TsEntryStateAnomalyModelData_FieldSubPath:
			switch tp.selector {
			case TsEntryStateAnomalyModelData_FieldPathSelectorTrainingPeriod:
				trainingPeriodMask.AppendPath(tp.subPath.(monitoring_common.TimeInterval_FieldPath))
			case TsEntryStateAnomalyModelData_FieldPathSelectorSensitiveness:
				sensitivenessMask.AppendPath(tp.subPath.(TsEntryStateAnomalyModelSensitiveness_FieldPath))
			}
		}
	}
	if wholeTrainingPeriodAccepted == false && len(trainingPeriodMask.Paths) > 0 {
		result.TrainingPeriod = trainingPeriodMask.Project(source.GetTrainingPeriod())
	}
	if wholeSensitivenessAccepted == false && len(sensitivenessMask.Paths) > 0 {
		for _, sourceItem := range source.GetSensitiveness() {
			result.Sensitiveness = append(result.Sensitiveness, sensitivenessMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsEntry_State_AnomalyModelData))
}

func (fieldMask *TsEntry_State_AnomalyModelData_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsEntry_State_AnomalyModelSensitiveness_FieldMask struct {
	Paths []TsEntryStateAnomalyModelSensitiveness_FieldPath
}

func FullTsEntry_State_AnomalyModelSensitiveness_FieldMask() *TsEntry_State_AnomalyModelSensitiveness_FieldMask {
	res := &TsEntry_State_AnomalyModelSensitiveness_FieldMask{}
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelSensitiveness_FieldTerminalPath{selector: TsEntryStateAnomalyModelSensitiveness_FieldPathSelectorQueryName})
	res.Paths = append(res.Paths, &TsEntryStateAnomalyModelSensitiveness_FieldTerminalPath{selector: TsEntryStateAnomalyModelSensitiveness_FieldPathSelectorAnomalyThreshold})
	return res
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsEntryStateAnomalyModelSensitiveness_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsEntryStateAnomalyModelSensitiveness_FieldPath(raw)
	})
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) ProtoMessage() {}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) Subtract(other *TsEntry_State_AnomalyModelSensitiveness_FieldMask) *TsEntry_State_AnomalyModelSensitiveness_FieldMask {
	result := &TsEntry_State_AnomalyModelSensitiveness_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsEntryStateAnomalyModelSensitiveness_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsEntry_State_AnomalyModelSensitiveness_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) FilterInputFields() *TsEntry_State_AnomalyModelSensitiveness_FieldMask {
	result := &TsEntry_State_AnomalyModelSensitiveness_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsEntryStateAnomalyModelSensitiveness_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsEntryStateAnomalyModelSensitiveness_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsEntry_State_AnomalyModelSensitiveness_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsEntry_State_AnomalyModelSensitiveness_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) AppendPath(path TsEntryStateAnomalyModelSensitiveness_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsEntryStateAnomalyModelSensitiveness_FieldPath))
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) GetPaths() []TsEntryStateAnomalyModelSensitiveness_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsEntryStateAnomalyModelSensitiveness_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) Set(target, source *TsEntry_State_AnomalyModelSensitiveness) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsEntry_State_AnomalyModelSensitiveness), source.(*TsEntry_State_AnomalyModelSensitiveness))
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) Project(source *TsEntry_State_AnomalyModelSensitiveness) *TsEntry_State_AnomalyModelSensitiveness {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsEntry_State_AnomalyModelSensitiveness{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsEntryStateAnomalyModelSensitiveness_FieldTerminalPath:
			switch tp.selector {
			case TsEntryStateAnomalyModelSensitiveness_FieldPathSelectorQueryName:
				result.QueryName = source.QueryName
			case TsEntryStateAnomalyModelSensitiveness_FieldPathSelectorAnomalyThreshold:
				result.AnomalyThreshold = source.AnomalyThreshold
			}
		}
	}
	return result
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsEntry_State_AnomalyModelSensitiveness))
}

func (fieldMask *TsEntry_State_AnomalyModelSensitiveness_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type TsEntry_State_AdaptiveThresholdInfo_FieldMask struct {
	Paths []TsEntryStateAdaptiveThresholdInfo_FieldPath
}

func FullTsEntry_State_AdaptiveThresholdInfo_FieldMask() *TsEntry_State_AdaptiveThresholdInfo_FieldMask {
	res := &TsEntry_State_AdaptiveThresholdInfo_FieldMask{}
	res.Paths = append(res.Paths, &TsEntryStateAdaptiveThresholdInfo_FieldTerminalPath{selector: TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorQueryName})
	res.Paths = append(res.Paths, &TsEntryStateAdaptiveThresholdInfo_FieldTerminalPath{selector: TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorLower})
	res.Paths = append(res.Paths, &TsEntryStateAdaptiveThresholdInfo_FieldTerminalPath{selector: TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorUpper})
	res.Paths = append(res.Paths, &TsEntryStateAdaptiveThresholdInfo_FieldTerminalPath{selector: TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorNextCheck})
	return res
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*TsEntryStateAdaptiveThresholdInfo_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseTsEntryStateAdaptiveThresholdInfo_FieldPath(raw)
	})
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) ProtoMessage() {}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) Subtract(other *TsEntry_State_AdaptiveThresholdInfo_FieldMask) *TsEntry_State_AdaptiveThresholdInfo_FieldMask {
	result := &TsEntry_State_AdaptiveThresholdInfo_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[TsEntryStateAdaptiveThresholdInfo_FieldPathSelector]gotenobject.FieldMask{
		TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorLower: &rcommon.AlertingThreshold_FieldMask{},
		TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorUpper: &rcommon.AlertingThreshold_FieldMask{},
	}
	mySubMasks := map[TsEntryStateAdaptiveThresholdInfo_FieldPathSelector]gotenobject.FieldMask{
		TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorLower: &rcommon.AlertingThreshold_FieldMask{},
		TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorUpper: &rcommon.AlertingThreshold_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *TsEntryStateAdaptiveThresholdInfo_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *TsEntryStateAdaptiveThresholdInfo_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*TsEntryStateAdaptiveThresholdInfo_FieldTerminalPath); ok {
					switch tp.selector {
					case TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorLower:
						mySubMasks[TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorLower] = rcommon.FullAlertingThreshold_FieldMask()
					case TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorUpper:
						mySubMasks[TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorUpper] = rcommon.FullAlertingThreshold_FieldMask()
					}
				} else if tp, ok := path.(*TsEntryStateAdaptiveThresholdInfo_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &TsEntryStateAdaptiveThresholdInfo_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*TsEntry_State_AdaptiveThresholdInfo_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) FilterInputFields() *TsEntry_State_AdaptiveThresholdInfo_FieldMask {
	result := &TsEntry_State_AdaptiveThresholdInfo_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) ToProtoFieldMask() *googlefieldmaskpb.FieldMask {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) FromProtoFieldMask(protoFieldMask *googlefieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]TsEntryStateAdaptiveThresholdInfo_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseTsEntryStateAdaptiveThresholdInfo_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask TsEntry_State_AdaptiveThresholdInfo_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask TsEntry_State_AdaptiveThresholdInfo_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &googlefieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) AppendPath(path TsEntryStateAdaptiveThresholdInfo_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(TsEntryStateAdaptiveThresholdInfo_FieldPath))
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) GetPaths() []TsEntryStateAdaptiveThresholdInfo_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseTsEntryStateAdaptiveThresholdInfo_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) Set(target, source *TsEntry_State_AdaptiveThresholdInfo) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*TsEntry_State_AdaptiveThresholdInfo), source.(*TsEntry_State_AdaptiveThresholdInfo))
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) Project(source *TsEntry_State_AdaptiveThresholdInfo) *TsEntry_State_AdaptiveThresholdInfo {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &TsEntry_State_AdaptiveThresholdInfo{}
	lowerMask := &rcommon.AlertingThreshold_FieldMask{}
	wholeLowerAccepted := false
	upperMask := &rcommon.AlertingThreshold_FieldMask{}
	wholeUpperAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *TsEntryStateAdaptiveThresholdInfo_FieldTerminalPath:
			switch tp.selector {
			case TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorQueryName:
				result.QueryName = source.QueryName
			case TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorLower:
				result.Lower = source.Lower
				wholeLowerAccepted = true
			case TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorUpper:
				result.Upper = source.Upper
				wholeUpperAccepted = true
			case TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorNextCheck:
				result.NextCheck = source.NextCheck
			}
		case *TsEntryStateAdaptiveThresholdInfo_FieldSubPath:
			switch tp.selector {
			case TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorLower:
				lowerMask.AppendPath(tp.subPath.(rcommon.AlertingThreshold_FieldPath))
			case TsEntryStateAdaptiveThresholdInfo_FieldPathSelectorUpper:
				upperMask.AppendPath(tp.subPath.(rcommon.AlertingThreshold_FieldPath))
			}
		}
	}
	if wholeLowerAccepted == false && len(lowerMask.Paths) > 0 {
		result.Lower = lowerMask.Project(source.GetLower())
	}
	if wholeUpperAccepted == false && len(upperMask.Paths) > 0 {
		result.Upper = upperMask.Project(source.GetUpper())
	}
	return result
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*TsEntry_State_AdaptiveThresholdInfo))
}

func (fieldMask *TsEntry_State_AdaptiveThresholdInfo_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
