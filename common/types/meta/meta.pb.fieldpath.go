// Code generated by protoc-gen-goten-object
// File: edgelq/common/types/meta.proto
// DO NOT EDIT!!!

package ntt_meta

import (
	"encoding/json"
	"fmt"
	"reflect"
	"strings"
	"time"

	"github.com/iancoleman/strcase"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/reflect/protoregistry"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = new(fmt.Stringer)
	_ = reflect.DeepEqual
	_ = strings.Builder{}
	_ = time.Second

	_ = strcase.ToLowerCamel
	_ = codes.NotFound
	_ = status.Status{}
	_ = protojson.UnmarshalOptions{}
	_ = new(proto.Message)
	_ = protoregistry.GlobalTypes
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldPath)
)

// make sure we're using proto imports
var (
	_ = &timestamp.Timestamp{}
)

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Meta_FieldPath interface {
	gotenobject.FieldPath
	Selector() Meta_FieldPathSelector
	Get(source *Meta) []interface{}
	GetSingle(source *Meta) (interface{}, bool)
	ClearValue(item *Meta)

	// Those methods build corresponding Meta_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Meta_FieldPathValue
	WithIArrayOfValues(values interface{}) Meta_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Meta_FieldPathArrayItemValue
}

type Meta_FieldPathSelector int32

const (
	Meta_FieldPathSelectorCreateTime      Meta_FieldPathSelector = 0
	Meta_FieldPathSelectorUpdateTime      Meta_FieldPathSelector = 1
	Meta_FieldPathSelectorDeleteTime      Meta_FieldPathSelector = 2
	Meta_FieldPathSelectorUuid            Meta_FieldPathSelector = 3
	Meta_FieldPathSelectorTags            Meta_FieldPathSelector = 4
	Meta_FieldPathSelectorLabels          Meta_FieldPathSelector = 5
	Meta_FieldPathSelectorAnnotations     Meta_FieldPathSelector = 6
	Meta_FieldPathSelectorGeneration      Meta_FieldPathSelector = 7
	Meta_FieldPathSelectorResourceVersion Meta_FieldPathSelector = 8
	Meta_FieldPathSelectorOwnerReferences Meta_FieldPathSelector = 9
	Meta_FieldPathSelectorShards          Meta_FieldPathSelector = 10
	Meta_FieldPathSelectorSyncing         Meta_FieldPathSelector = 11
	Meta_FieldPathSelectorLifecycle       Meta_FieldPathSelector = 12
)

func (s Meta_FieldPathSelector) String() string {
	switch s {
	case Meta_FieldPathSelectorCreateTime:
		return "create_time"
	case Meta_FieldPathSelectorUpdateTime:
		return "update_time"
	case Meta_FieldPathSelectorDeleteTime:
		return "delete_time"
	case Meta_FieldPathSelectorUuid:
		return "uuid"
	case Meta_FieldPathSelectorTags:
		return "tags"
	case Meta_FieldPathSelectorLabels:
		return "labels"
	case Meta_FieldPathSelectorAnnotations:
		return "annotations"
	case Meta_FieldPathSelectorGeneration:
		return "generation"
	case Meta_FieldPathSelectorResourceVersion:
		return "resource_version"
	case Meta_FieldPathSelectorOwnerReferences:
		return "owner_references"
	case Meta_FieldPathSelectorShards:
		return "shards"
	case Meta_FieldPathSelectorSyncing:
		return "syncing"
	case Meta_FieldPathSelectorLifecycle:
		return "lifecycle"
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", s))
	}
}

func BuildMeta_FieldPath(fp gotenobject.RawFieldPath) (Meta_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Meta")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "create_time", "createTime", "create-time":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorCreateTime}, nil
		case "update_time", "updateTime", "update-time":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorUpdateTime}, nil
		case "delete_time", "deleteTime", "delete-time":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorDeleteTime}, nil
		case "uuid":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorUuid}, nil
		case "tags":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorTags}, nil
		case "labels":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorLabels}, nil
		case "annotations":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorAnnotations}, nil
		case "generation":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorGeneration}, nil
		case "resource_version", "resourceVersion", "resource-version":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorResourceVersion}, nil
		case "owner_references", "ownerReferences", "owner-references":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorOwnerReferences}, nil
		case "shards":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorShards}, nil
		case "syncing":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorSyncing}, nil
		case "lifecycle":
			return &Meta_FieldTerminalPath{selector: Meta_FieldPathSelectorLifecycle}, nil
		}
	} else {
		switch fp[0] {
		case "owner_references", "ownerReferences", "owner-references":
			if subpath, err := BuildOwnerReference_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Meta_FieldSubPath{selector: Meta_FieldPathSelectorOwnerReferences, subPath: subpath}, nil
			}
		case "syncing":
			if subpath, err := BuildSyncingMeta_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Meta_FieldSubPath{selector: Meta_FieldPathSelectorSyncing, subPath: subpath}, nil
			}
		case "lifecycle":
			if subpath, err := BuildLifecycle_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &Meta_FieldSubPath{selector: Meta_FieldPathSelectorLifecycle, subPath: subpath}, nil
			}
		case "labels":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object Meta)", fp)
			}
			return &Meta_FieldPathMap{selector: Meta_FieldPathSelectorLabels, key: fp[1]}, nil
		case "annotations":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object Meta)", fp)
			}
			return &Meta_FieldPathMap{selector: Meta_FieldPathSelectorAnnotations, key: fp[1]}, nil
		case "shards":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object Meta)", fp)
			}
			return &Meta_FieldPathMap{selector: Meta_FieldPathSelectorShards, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Meta", fp)
}

func ParseMeta_FieldPath(rawField string) (Meta_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildMeta_FieldPath(fp)
}

func MustParseMeta_FieldPath(rawField string) Meta_FieldPath {
	fp, err := ParseMeta_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Meta_FieldTerminalPath struct {
	selector Meta_FieldPathSelector
}

var _ Meta_FieldPath = (*Meta_FieldTerminalPath)(nil)

func (fp *Meta_FieldTerminalPath) Selector() Meta_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Meta_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Meta_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Meta
func (fp *Meta_FieldTerminalPath) Get(source *Meta) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Meta_FieldPathSelectorCreateTime:
			if source.CreateTime != nil {
				values = append(values, source.CreateTime)
			}
		case Meta_FieldPathSelectorUpdateTime:
			if source.UpdateTime != nil {
				values = append(values, source.UpdateTime)
			}
		case Meta_FieldPathSelectorDeleteTime:
			if source.DeleteTime != nil {
				values = append(values, source.DeleteTime)
			}
		case Meta_FieldPathSelectorUuid:
			values = append(values, source.Uuid)
		case Meta_FieldPathSelectorTags:
			for _, value := range source.GetTags() {
				values = append(values, value)
			}
		case Meta_FieldPathSelectorLabels:
			values = append(values, source.Labels)
		case Meta_FieldPathSelectorAnnotations:
			values = append(values, source.Annotations)
		case Meta_FieldPathSelectorGeneration:
			values = append(values, source.Generation)
		case Meta_FieldPathSelectorResourceVersion:
			values = append(values, source.ResourceVersion)
		case Meta_FieldPathSelectorOwnerReferences:
			for _, value := range source.GetOwnerReferences() {
				values = append(values, value)
			}
		case Meta_FieldPathSelectorShards:
			values = append(values, source.Shards)
		case Meta_FieldPathSelectorSyncing:
			if source.Syncing != nil {
				values = append(values, source.Syncing)
			}
		case Meta_FieldPathSelectorLifecycle:
			if source.Lifecycle != nil {
				values = append(values, source.Lifecycle)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for Meta: %d", fp.selector))
		}
	}
	return
}

func (fp *Meta_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Meta))
}

// GetSingle returns value pointed by specific field of from source Meta
func (fp *Meta_FieldTerminalPath) GetSingle(source *Meta) (interface{}, bool) {
	switch fp.selector {
	case Meta_FieldPathSelectorCreateTime:
		res := source.GetCreateTime()
		return res, res != nil
	case Meta_FieldPathSelectorUpdateTime:
		res := source.GetUpdateTime()
		return res, res != nil
	case Meta_FieldPathSelectorDeleteTime:
		res := source.GetDeleteTime()
		return res, res != nil
	case Meta_FieldPathSelectorUuid:
		return source.GetUuid(), source != nil
	case Meta_FieldPathSelectorTags:
		res := source.GetTags()
		return res, res != nil
	case Meta_FieldPathSelectorLabels:
		res := source.GetLabels()
		return res, res != nil
	case Meta_FieldPathSelectorAnnotations:
		res := source.GetAnnotations()
		return res, res != nil
	case Meta_FieldPathSelectorGeneration:
		return source.GetGeneration(), source != nil
	case Meta_FieldPathSelectorResourceVersion:
		return source.GetResourceVersion(), source != nil
	case Meta_FieldPathSelectorOwnerReferences:
		res := source.GetOwnerReferences()
		return res, res != nil
	case Meta_FieldPathSelectorShards:
		res := source.GetShards()
		return res, res != nil
	case Meta_FieldPathSelectorSyncing:
		res := source.GetSyncing()
		return res, res != nil
	case Meta_FieldPathSelectorLifecycle:
		res := source.GetLifecycle()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fp.selector))
	}
}

func (fp *Meta_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Meta))
}

// GetDefault returns a default value of the field type
func (fp *Meta_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Meta_FieldPathSelectorCreateTime:
		return (*timestamp.Timestamp)(nil)
	case Meta_FieldPathSelectorUpdateTime:
		return (*timestamp.Timestamp)(nil)
	case Meta_FieldPathSelectorDeleteTime:
		return (*timestamp.Timestamp)(nil)
	case Meta_FieldPathSelectorUuid:
		return ""
	case Meta_FieldPathSelectorTags:
		return ([]string)(nil)
	case Meta_FieldPathSelectorLabels:
		return (map[string]string)(nil)
	case Meta_FieldPathSelectorAnnotations:
		return (map[string]string)(nil)
	case Meta_FieldPathSelectorGeneration:
		return int64(0)
	case Meta_FieldPathSelectorResourceVersion:
		return ""
	case Meta_FieldPathSelectorOwnerReferences:
		return ([]*OwnerReference)(nil)
	case Meta_FieldPathSelectorShards:
		return (map[string]int64)(nil)
	case Meta_FieldPathSelectorSyncing:
		return (*SyncingMeta)(nil)
	case Meta_FieldPathSelectorLifecycle:
		return (*Lifecycle)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fp.selector))
	}
}

func (fp *Meta_FieldTerminalPath) ClearValue(item *Meta) {
	if item != nil {
		switch fp.selector {
		case Meta_FieldPathSelectorCreateTime:
			item.CreateTime = nil
		case Meta_FieldPathSelectorUpdateTime:
			item.UpdateTime = nil
		case Meta_FieldPathSelectorDeleteTime:
			item.DeleteTime = nil
		case Meta_FieldPathSelectorUuid:
			item.Uuid = ""
		case Meta_FieldPathSelectorTags:
			item.Tags = nil
		case Meta_FieldPathSelectorLabels:
			item.Labels = nil
		case Meta_FieldPathSelectorAnnotations:
			item.Annotations = nil
		case Meta_FieldPathSelectorGeneration:
			item.Generation = int64(0)
		case Meta_FieldPathSelectorResourceVersion:
			item.ResourceVersion = ""
		case Meta_FieldPathSelectorOwnerReferences:
			item.OwnerReferences = nil
		case Meta_FieldPathSelectorShards:
			item.Shards = nil
		case Meta_FieldPathSelectorSyncing:
			item.Syncing = nil
		case Meta_FieldPathSelectorLifecycle:
			item.Lifecycle = nil
		default:
			panic(fmt.Sprintf("Invalid selector for Meta: %d", fp.selector))
		}
	}
}

func (fp *Meta_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Meta))
}

// IsLeaf - whether field path is holds simple value
func (fp *Meta_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Meta_FieldPathSelectorCreateTime ||
		fp.selector == Meta_FieldPathSelectorUpdateTime ||
		fp.selector == Meta_FieldPathSelectorDeleteTime ||
		fp.selector == Meta_FieldPathSelectorUuid ||
		fp.selector == Meta_FieldPathSelectorTags ||
		fp.selector == Meta_FieldPathSelectorLabels ||
		fp.selector == Meta_FieldPathSelectorAnnotations ||
		fp.selector == Meta_FieldPathSelectorGeneration ||
		fp.selector == Meta_FieldPathSelectorResourceVersion ||
		fp.selector == Meta_FieldPathSelectorShards
}

func (fp *Meta_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Meta_FieldTerminalPath) WithIValue(value interface{}) Meta_FieldPathValue {
	switch fp.selector {
	case Meta_FieldPathSelectorCreateTime:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(*timestamp.Timestamp)}
	case Meta_FieldPathSelectorUpdateTime:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(*timestamp.Timestamp)}
	case Meta_FieldPathSelectorDeleteTime:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(*timestamp.Timestamp)}
	case Meta_FieldPathSelectorUuid:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(string)}
	case Meta_FieldPathSelectorTags:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.([]string)}
	case Meta_FieldPathSelectorLabels:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(map[string]string)}
	case Meta_FieldPathSelectorAnnotations:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(map[string]string)}
	case Meta_FieldPathSelectorGeneration:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(int64)}
	case Meta_FieldPathSelectorResourceVersion:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(string)}
	case Meta_FieldPathSelectorOwnerReferences:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.([]*OwnerReference)}
	case Meta_FieldPathSelectorShards:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(map[string]int64)}
	case Meta_FieldPathSelectorSyncing:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(*SyncingMeta)}
	case Meta_FieldPathSelectorLifecycle:
		return &Meta_FieldTerminalPathValue{Meta_FieldTerminalPath: *fp, value: value.(*Lifecycle)}
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fp.selector))
	}
}

func (fp *Meta_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Meta_FieldTerminalPath) WithIArrayOfValues(values interface{}) Meta_FieldPathArrayOfValues {
	fpaov := &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp}
	switch fp.selector {
	case Meta_FieldPathSelectorCreateTime:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]*timestamp.Timestamp)}
	case Meta_FieldPathSelectorUpdateTime:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]*timestamp.Timestamp)}
	case Meta_FieldPathSelectorDeleteTime:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]*timestamp.Timestamp)}
	case Meta_FieldPathSelectorUuid:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]string)}
	case Meta_FieldPathSelectorTags:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([][]string)}
	case Meta_FieldPathSelectorLabels:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]map[string]string)}
	case Meta_FieldPathSelectorAnnotations:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]map[string]string)}
	case Meta_FieldPathSelectorGeneration:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]int64)}
	case Meta_FieldPathSelectorResourceVersion:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]string)}
	case Meta_FieldPathSelectorOwnerReferences:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([][]*OwnerReference)}
	case Meta_FieldPathSelectorShards:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]map[string]int64)}
	case Meta_FieldPathSelectorSyncing:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]*SyncingMeta)}
	case Meta_FieldPathSelectorLifecycle:
		return &Meta_FieldTerminalPathArrayOfValues{Meta_FieldTerminalPath: *fp, values: values.([]*Lifecycle)}
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fp.selector))
	}
	return fpaov
}

func (fp *Meta_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Meta_FieldTerminalPath) WithIArrayItemValue(value interface{}) Meta_FieldPathArrayItemValue {
	switch fp.selector {
	case Meta_FieldPathSelectorTags:
		return &Meta_FieldTerminalPathArrayItemValue{Meta_FieldTerminalPath: *fp, value: value.(string)}
	case Meta_FieldPathSelectorOwnerReferences:
		return &Meta_FieldTerminalPathArrayItemValue{Meta_FieldTerminalPath: *fp, value: value.(*OwnerReference)}
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fp.selector))
	}
}

func (fp *Meta_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type Meta_FieldPathMap struct {
	key      string
	selector Meta_FieldPathSelector
}

var _ Meta_FieldPath = (*Meta_FieldPathMap)(nil)

func (fpm *Meta_FieldPathMap) Selector() Meta_FieldPathSelector {
	return fpm.selector
}

func (fpm *Meta_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *Meta_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *Meta_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source Meta
func (fpm *Meta_FieldPathMap) Get(source *Meta) (values []interface{}) {
	switch fpm.selector {
	case Meta_FieldPathSelectorLabels:
		if value, ok := source.GetLabels()[fpm.key]; ok {
			values = append(values, value)
		}
	case Meta_FieldPathSelectorAnnotations:
		if value, ok := source.GetAnnotations()[fpm.key]; ok {
			values = append(values, value)
		}
	case Meta_FieldPathSelectorShards:
		if value, ok := source.GetShards()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpm.selector))
	}
	return
}

func (fpm *Meta_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*Meta))
}

// GetSingle returns value by selected field map key from source Meta
func (fpm *Meta_FieldPathMap) GetSingle(source *Meta) (interface{}, bool) {
	switch fpm.selector {
	case Meta_FieldPathSelectorLabels:
		res, ok := source.GetLabels()[fpm.key]
		return res, ok
	case Meta_FieldPathSelectorAnnotations:
		res, ok := source.GetAnnotations()[fpm.key]
		return res, ok
	case Meta_FieldPathSelectorShards:
		res, ok := source.GetShards()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpm.selector))
	}
}

func (fpm *Meta_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*Meta))
}

// GetDefault returns a default value of the field type
func (fpm *Meta_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case Meta_FieldPathSelectorLabels:
		var v string
		return v
	case Meta_FieldPathSelectorAnnotations:
		var v string
		return v
	case Meta_FieldPathSelectorShards:
		var v int64
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpm.selector))
	}
}

func (fpm *Meta_FieldPathMap) ClearValue(item *Meta) {
	if item != nil {
		switch fpm.selector {
		case Meta_FieldPathSelectorLabels:
			delete(item.Labels, fpm.key)
		case Meta_FieldPathSelectorAnnotations:
			delete(item.Annotations, fpm.key)
		case Meta_FieldPathSelectorShards:
			delete(item.Shards, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for Meta: %d", fpm.selector))
		}
	}
}

func (fpm *Meta_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*Meta))
}

// IsLeaf - whether field path is holds simple value
func (fpm *Meta_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case Meta_FieldPathSelectorLabels:
		return true
	case Meta_FieldPathSelectorAnnotations:
		return true
	case Meta_FieldPathSelectorShards:
		return true
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpm.selector))
	}
}

func (fpm *Meta_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *Meta_FieldPathMap) WithIValue(value interface{}) Meta_FieldPathValue {
	switch fpm.selector {
	case Meta_FieldPathSelectorLabels:
		return &Meta_FieldPathMapValue{Meta_FieldPathMap: *fpm, value: value.(string)}
	case Meta_FieldPathSelectorAnnotations:
		return &Meta_FieldPathMapValue{Meta_FieldPathMap: *fpm, value: value.(string)}
	case Meta_FieldPathSelectorShards:
		return &Meta_FieldPathMapValue{Meta_FieldPathMap: *fpm, value: value.(int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpm.selector))
	}
}

func (fpm *Meta_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *Meta_FieldPathMap) WithIArrayOfValues(values interface{}) Meta_FieldPathArrayOfValues {
	switch fpm.selector {
	case Meta_FieldPathSelectorLabels:
		return &Meta_FieldPathMapArrayOfValues{Meta_FieldPathMap: *fpm, values: values.([]string)}
	case Meta_FieldPathSelectorAnnotations:
		return &Meta_FieldPathMapArrayOfValues{Meta_FieldPathMap: *fpm, values: values.([]string)}
	case Meta_FieldPathSelectorShards:
		return &Meta_FieldPathMapArrayOfValues{Meta_FieldPathMap: *fpm, values: values.([]int64)}
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpm.selector))
	}
}

func (fpm *Meta_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *Meta_FieldPathMap) WithIArrayItemValue(value interface{}) Meta_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *Meta_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

type Meta_FieldSubPath struct {
	selector Meta_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ Meta_FieldPath = (*Meta_FieldSubPath)(nil)

func (fps *Meta_FieldSubPath) Selector() Meta_FieldPathSelector {
	return fps.selector
}
func (fps *Meta_FieldSubPath) AsOwnerReferencesSubPath() (OwnerReference_FieldPath, bool) {
	res, ok := fps.subPath.(OwnerReference_FieldPath)
	return res, ok
}
func (fps *Meta_FieldSubPath) AsSyncingSubPath() (SyncingMeta_FieldPath, bool) {
	res, ok := fps.subPath.(SyncingMeta_FieldPath)
	return res, ok
}
func (fps *Meta_FieldSubPath) AsLifecycleSubPath() (Lifecycle_FieldPath, bool) {
	res, ok := fps.subPath.(Lifecycle_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *Meta_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *Meta_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source Meta
func (fps *Meta_FieldSubPath) Get(source *Meta) (values []interface{}) {
	switch fps.selector {
	case Meta_FieldPathSelectorOwnerReferences:
		for _, item := range source.GetOwnerReferences() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	case Meta_FieldPathSelectorSyncing:
		values = append(values, fps.subPath.GetRaw(source.GetSyncing())...)
	case Meta_FieldPathSelectorLifecycle:
		values = append(values, fps.subPath.GetRaw(source.GetLifecycle())...)
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fps.selector))
	}
	return
}

func (fps *Meta_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*Meta))
}

// GetSingle returns value of selected field from source Meta
func (fps *Meta_FieldSubPath) GetSingle(source *Meta) (interface{}, bool) {
	switch fps.selector {
	case Meta_FieldPathSelectorOwnerReferences:
		if len(source.GetOwnerReferences()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetOwnerReferences()[0])
	case Meta_FieldPathSelectorSyncing:
		if source.GetSyncing() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetSyncing())
	case Meta_FieldPathSelectorLifecycle:
		if source.GetLifecycle() == nil {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetLifecycle())
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fps.selector))
	}
}

func (fps *Meta_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*Meta))
}

// GetDefault returns a default value of the field type
func (fps *Meta_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *Meta_FieldSubPath) ClearValue(item *Meta) {
	if item != nil {
		switch fps.selector {
		case Meta_FieldPathSelectorOwnerReferences:
			for _, subItem := range item.OwnerReferences {
				fps.subPath.ClearValueRaw(subItem)
			}
		case Meta_FieldPathSelectorSyncing:
			fps.subPath.ClearValueRaw(item.Syncing)
		case Meta_FieldPathSelectorLifecycle:
			fps.subPath.ClearValueRaw(item.Lifecycle)
		default:
			panic(fmt.Sprintf("Invalid selector for Meta: %d", fps.selector))
		}
	}
}

func (fps *Meta_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*Meta))
}

// IsLeaf - whether field path is holds simple value
func (fps *Meta_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *Meta_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&Meta_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *Meta_FieldSubPath) WithIValue(value interface{}) Meta_FieldPathValue {
	return &Meta_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *Meta_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *Meta_FieldSubPath) WithIArrayOfValues(values interface{}) Meta_FieldPathArrayOfValues {
	return &Meta_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *Meta_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *Meta_FieldSubPath) WithIArrayItemValue(value interface{}) Meta_FieldPathArrayItemValue {
	return &Meta_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *Meta_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// Meta_FieldPathValue allows storing values for Meta fields according to their type
type Meta_FieldPathValue interface {
	Meta_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Meta)
	CompareWith(*Meta) (cmp int, comparable bool)
}

func ParseMeta_FieldPathValue(pathStr, valueStr string) (Meta_FieldPathValue, error) {
	fp, err := ParseMeta_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Meta field path value from %s: %v", valueStr, err)
	}
	return fpv.(Meta_FieldPathValue), nil
}

func MustParseMeta_FieldPathValue(pathStr, valueStr string) Meta_FieldPathValue {
	fpv, err := ParseMeta_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Meta_FieldTerminalPathValue struct {
	Meta_FieldTerminalPath
	value interface{}
}

var _ Meta_FieldPathValue = (*Meta_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Meta' as interface{}
func (fpv *Meta_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Meta_FieldTerminalPathValue) AsCreateTimeValue() (*timestamp.Timestamp, bool) {
	res, ok := fpv.value.(*timestamp.Timestamp)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsUpdateTimeValue() (*timestamp.Timestamp, bool) {
	res, ok := fpv.value.(*timestamp.Timestamp)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsDeleteTimeValue() (*timestamp.Timestamp, bool) {
	res, ok := fpv.value.(*timestamp.Timestamp)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsUuidValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsTagsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsLabelsValue() (map[string]string, bool) {
	res, ok := fpv.value.(map[string]string)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsAnnotationsValue() (map[string]string, bool) {
	res, ok := fpv.value.(map[string]string)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsGenerationValue() (int64, bool) {
	res, ok := fpv.value.(int64)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsResourceVersionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsOwnerReferencesValue() ([]*OwnerReference, bool) {
	res, ok := fpv.value.([]*OwnerReference)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsShardsValue() (map[string]int64, bool) {
	res, ok := fpv.value.(map[string]int64)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsSyncingValue() (*SyncingMeta, bool) {
	res, ok := fpv.value.(*SyncingMeta)
	return res, ok
}
func (fpv *Meta_FieldTerminalPathValue) AsLifecycleValue() (*Lifecycle, bool) {
	res, ok := fpv.value.(*Lifecycle)
	return res, ok
}

// SetTo stores value for selected field for object Meta
func (fpv *Meta_FieldTerminalPathValue) SetTo(target **Meta) {
	if *target == nil {
		*target = new(Meta)
	}
	switch fpv.selector {
	case Meta_FieldPathSelectorCreateTime:
		(*target).CreateTime = fpv.value.(*timestamp.Timestamp)
	case Meta_FieldPathSelectorUpdateTime:
		(*target).UpdateTime = fpv.value.(*timestamp.Timestamp)
	case Meta_FieldPathSelectorDeleteTime:
		(*target).DeleteTime = fpv.value.(*timestamp.Timestamp)
	case Meta_FieldPathSelectorUuid:
		(*target).Uuid = fpv.value.(string)
	case Meta_FieldPathSelectorTags:
		(*target).Tags = fpv.value.([]string)
	case Meta_FieldPathSelectorLabels:
		(*target).Labels = fpv.value.(map[string]string)
	case Meta_FieldPathSelectorAnnotations:
		(*target).Annotations = fpv.value.(map[string]string)
	case Meta_FieldPathSelectorGeneration:
		(*target).Generation = fpv.value.(int64)
	case Meta_FieldPathSelectorResourceVersion:
		(*target).ResourceVersion = fpv.value.(string)
	case Meta_FieldPathSelectorOwnerReferences:
		(*target).OwnerReferences = fpv.value.([]*OwnerReference)
	case Meta_FieldPathSelectorShards:
		(*target).Shards = fpv.value.(map[string]int64)
	case Meta_FieldPathSelectorSyncing:
		(*target).Syncing = fpv.value.(*SyncingMeta)
	case Meta_FieldPathSelectorLifecycle:
		(*target).Lifecycle = fpv.value.(*Lifecycle)
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpv.selector))
	}
}

func (fpv *Meta_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Meta)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Meta_FieldTerminalPathValue' with the value under path in 'Meta'.
func (fpv *Meta_FieldTerminalPathValue) CompareWith(source *Meta) (int, bool) {
	switch fpv.selector {
	case Meta_FieldPathSelectorCreateTime:
		leftValue := fpv.value.(*timestamp.Timestamp)
		rightValue := source.GetCreateTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case Meta_FieldPathSelectorUpdateTime:
		leftValue := fpv.value.(*timestamp.Timestamp)
		rightValue := source.GetUpdateTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case Meta_FieldPathSelectorDeleteTime:
		leftValue := fpv.value.(*timestamp.Timestamp)
		rightValue := source.GetDeleteTime()
		if leftValue == nil {
			if rightValue != nil {
				return -1, true
			}
			return 0, true
		}
		if rightValue == nil {
			return 1, true
		}
		if leftValue.AsTime().Equal(rightValue.AsTime()) {
			return 0, true
		} else if leftValue.AsTime().Before(rightValue.AsTime()) {
			return -1, true
		} else {
			return 1, true
		}
	case Meta_FieldPathSelectorUuid:
		leftValue := fpv.value.(string)
		rightValue := source.GetUuid()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Meta_FieldPathSelectorTags:
		return 0, false
	case Meta_FieldPathSelectorLabels:
		return 0, false
	case Meta_FieldPathSelectorAnnotations:
		return 0, false
	case Meta_FieldPathSelectorGeneration:
		leftValue := fpv.value.(int64)
		rightValue := source.GetGeneration()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Meta_FieldPathSelectorResourceVersion:
		leftValue := fpv.value.(string)
		rightValue := source.GetResourceVersion()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Meta_FieldPathSelectorOwnerReferences:
		return 0, false
	case Meta_FieldPathSelectorShards:
		return 0, false
	case Meta_FieldPathSelectorSyncing:
		return 0, false
	case Meta_FieldPathSelectorLifecycle:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpv.selector))
	}
}

func (fpv *Meta_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Meta))
}

type Meta_FieldPathMapValue struct {
	Meta_FieldPathMap
	value interface{}
}

var _ Meta_FieldPathValue = (*Meta_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in Meta as interface{}
func (fpmv *Meta_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *Meta_FieldPathMapValue) AsLabelsElementValue() (string, bool) {
	res, ok := fpmv.value.(string)
	return res, ok
}
func (fpmv *Meta_FieldPathMapValue) AsAnnotationsElementValue() (string, bool) {
	res, ok := fpmv.value.(string)
	return res, ok
}
func (fpmv *Meta_FieldPathMapValue) AsShardsElementValue() (int64, bool) {
	res, ok := fpmv.value.(int64)
	return res, ok
}

// SetTo stores value for selected field in Meta
func (fpmv *Meta_FieldPathMapValue) SetTo(target **Meta) {
	if *target == nil {
		*target = new(Meta)
	}
	switch fpmv.selector {
	case Meta_FieldPathSelectorLabels:
		if (*target).Labels == nil {
			(*target).Labels = make(map[string]string)
		}
		(*target).Labels[fpmv.key] = fpmv.value.(string)
	case Meta_FieldPathSelectorAnnotations:
		if (*target).Annotations == nil {
			(*target).Annotations = make(map[string]string)
		}
		(*target).Annotations[fpmv.key] = fpmv.value.(string)
	case Meta_FieldPathSelectorShards:
		if (*target).Shards == nil {
			(*target).Shards = make(map[string]int64)
		}
		(*target).Shards[fpmv.key] = fpmv.value.(int64)
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpmv.selector))
	}
}

func (fpmv *Meta_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Meta)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Meta_FieldPathMapValue' with the value under path in 'Meta'.
func (fpmv *Meta_FieldPathMapValue) CompareWith(source *Meta) (int, bool) {
	switch fpmv.selector {
	case Meta_FieldPathSelectorLabels:
		leftValue := fpmv.value.(string)
		rightValue := source.GetLabels()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Meta_FieldPathSelectorAnnotations:
		leftValue := fpmv.value.(string)
		rightValue := source.GetAnnotations()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Meta_FieldPathSelectorShards:
		leftValue := fpmv.value.(int64)
		rightValue := source.GetShards()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpmv.selector))
	}
}

func (fpmv *Meta_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*Meta))
}

type Meta_FieldSubPathValue struct {
	Meta_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ Meta_FieldPathValue = (*Meta_FieldSubPathValue)(nil)

func (fpvs *Meta_FieldSubPathValue) AsOwnerReferencesPathValue() (OwnerReference_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(OwnerReference_FieldPathValue)
	return res, ok
}
func (fpvs *Meta_FieldSubPathValue) AsSyncingPathValue() (SyncingMeta_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(SyncingMeta_FieldPathValue)
	return res, ok
}
func (fpvs *Meta_FieldSubPathValue) AsLifecyclePathValue() (Lifecycle_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(Lifecycle_FieldPathValue)
	return res, ok
}

func (fpvs *Meta_FieldSubPathValue) SetTo(target **Meta) {
	if *target == nil {
		*target = new(Meta)
	}
	switch fpvs.Selector() {
	case Meta_FieldPathSelectorOwnerReferences:
		panic("FieldPath setter is unsupported for array subpaths")
	case Meta_FieldPathSelectorSyncing:
		fpvs.subPathValue.(SyncingMeta_FieldPathValue).SetTo(&(*target).Syncing)
	case Meta_FieldPathSelectorLifecycle:
		fpvs.subPathValue.(Lifecycle_FieldPathValue).SetTo(&(*target).Lifecycle)
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpvs.Selector()))
	}
}

func (fpvs *Meta_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Meta)
	fpvs.SetTo(&typedObject)
}

func (fpvs *Meta_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *Meta_FieldSubPathValue) CompareWith(source *Meta) (int, bool) {
	switch fpvs.Selector() {
	case Meta_FieldPathSelectorOwnerReferences:
		return 0, false // repeated field
	case Meta_FieldPathSelectorSyncing:
		return fpvs.subPathValue.(SyncingMeta_FieldPathValue).CompareWith(source.GetSyncing())
	case Meta_FieldPathSelectorLifecycle:
		return fpvs.subPathValue.(Lifecycle_FieldPathValue).CompareWith(source.GetLifecycle())
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpvs.Selector()))
	}
}

func (fpvs *Meta_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*Meta))
}

// Meta_FieldPathArrayItemValue allows storing single item in Path-specific values for Meta according to their type
// Present only for array (repeated) types.
type Meta_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Meta_FieldPath
	ContainsValue(*Meta) bool
}

// ParseMeta_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseMeta_FieldPathArrayItemValue(pathStr, valueStr string) (Meta_FieldPathArrayItemValue, error) {
	fp, err := ParseMeta_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Meta field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Meta_FieldPathArrayItemValue), nil
}

func MustParseMeta_FieldPathArrayItemValue(pathStr, valueStr string) Meta_FieldPathArrayItemValue {
	fpaiv, err := ParseMeta_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Meta_FieldTerminalPathArrayItemValue struct {
	Meta_FieldTerminalPath
	value interface{}
}

var _ Meta_FieldPathArrayItemValue = (*Meta_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Meta as interface{}
func (fpaiv *Meta_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *Meta_FieldTerminalPathArrayItemValue) AsTagsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}
func (fpaiv *Meta_FieldTerminalPathArrayItemValue) AsOwnerReferencesItemValue() (*OwnerReference, bool) {
	res, ok := fpaiv.value.(*OwnerReference)
	return res, ok
}

func (fpaiv *Meta_FieldTerminalPathArrayItemValue) GetSingle(source *Meta) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Meta_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Meta))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Meta'
func (fpaiv *Meta_FieldTerminalPathArrayItemValue) ContainsValue(source *Meta) bool {
	slice := fpaiv.Meta_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type Meta_FieldSubPathArrayItemValue struct {
	Meta_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *Meta_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *Meta_FieldSubPathArrayItemValue) AsOwnerReferencesPathItemValue() (OwnerReference_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(OwnerReference_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Meta_FieldSubPathArrayItemValue) AsSyncingPathItemValue() (SyncingMeta_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(SyncingMeta_FieldPathArrayItemValue)
	return res, ok
}
func (fpaivs *Meta_FieldSubPathArrayItemValue) AsLifecyclePathItemValue() (Lifecycle_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(Lifecycle_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'Meta'
func (fpaivs *Meta_FieldSubPathArrayItemValue) ContainsValue(source *Meta) bool {
	switch fpaivs.Selector() {
	case Meta_FieldPathSelectorOwnerReferences:
		return false // repeated/map field
	case Meta_FieldPathSelectorSyncing:
		return fpaivs.subPathItemValue.(SyncingMeta_FieldPathArrayItemValue).ContainsValue(source.GetSyncing())
	case Meta_FieldPathSelectorLifecycle:
		return fpaivs.subPathItemValue.(Lifecycle_FieldPathArrayItemValue).ContainsValue(source.GetLifecycle())
	default:
		panic(fmt.Sprintf("Invalid selector for Meta: %d", fpaivs.Selector()))
	}
}

// Meta_FieldPathArrayOfValues allows storing slice of values for Meta fields according to their type
type Meta_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Meta_FieldPath
}

func ParseMeta_FieldPathArrayOfValues(pathStr, valuesStr string) (Meta_FieldPathArrayOfValues, error) {
	fp, err := ParseMeta_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Meta field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Meta_FieldPathArrayOfValues), nil
}

func MustParseMeta_FieldPathArrayOfValues(pathStr, valuesStr string) Meta_FieldPathArrayOfValues {
	fpaov, err := ParseMeta_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Meta_FieldTerminalPathArrayOfValues struct {
	Meta_FieldTerminalPath
	values interface{}
}

var _ Meta_FieldPathArrayOfValues = (*Meta_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Meta_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Meta_FieldPathSelectorCreateTime:
		for _, v := range fpaov.values.([]*timestamp.Timestamp) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorUpdateTime:
		for _, v := range fpaov.values.([]*timestamp.Timestamp) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorDeleteTime:
		for _, v := range fpaov.values.([]*timestamp.Timestamp) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorUuid:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorTags:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorLabels:
		for _, v := range fpaov.values.([]map[string]string) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorAnnotations:
		for _, v := range fpaov.values.([]map[string]string) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorGeneration:
		for _, v := range fpaov.values.([]int64) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorResourceVersion:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorOwnerReferences:
		for _, v := range fpaov.values.([][]*OwnerReference) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorShards:
		for _, v := range fpaov.values.([]map[string]int64) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorSyncing:
		for _, v := range fpaov.values.([]*SyncingMeta) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorLifecycle:
		for _, v := range fpaov.values.([]*Lifecycle) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsCreateTimeArrayOfValues() ([]*timestamp.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamp.Timestamp)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsUpdateTimeArrayOfValues() ([]*timestamp.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamp.Timestamp)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsDeleteTimeArrayOfValues() ([]*timestamp.Timestamp, bool) {
	res, ok := fpaov.values.([]*timestamp.Timestamp)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsUuidArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsTagsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsLabelsArrayOfValues() ([]map[string]string, bool) {
	res, ok := fpaov.values.([]map[string]string)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsAnnotationsArrayOfValues() ([]map[string]string, bool) {
	res, ok := fpaov.values.([]map[string]string)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsGenerationArrayOfValues() ([]int64, bool) {
	res, ok := fpaov.values.([]int64)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsResourceVersionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsOwnerReferencesArrayOfValues() ([][]*OwnerReference, bool) {
	res, ok := fpaov.values.([][]*OwnerReference)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsShardsArrayOfValues() ([]map[string]int64, bool) {
	res, ok := fpaov.values.([]map[string]int64)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsSyncingArrayOfValues() ([]*SyncingMeta, bool) {
	res, ok := fpaov.values.([]*SyncingMeta)
	return res, ok
}
func (fpaov *Meta_FieldTerminalPathArrayOfValues) AsLifecycleArrayOfValues() ([]*Lifecycle, bool) {
	res, ok := fpaov.values.([]*Lifecycle)
	return res, ok
}

type Meta_FieldPathMapArrayOfValues struct {
	Meta_FieldPathMap
	values interface{}
}

var _ Meta_FieldPathArrayOfValues = (*Meta_FieldPathMapArrayOfValues)(nil)

func (fpmaov *Meta_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case Meta_FieldPathSelectorLabels:
		for _, v := range fpmaov.values.([]string) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorAnnotations:
		for _, v := range fpmaov.values.([]string) {
			values = append(values, v)
		}
	case Meta_FieldPathSelectorShards:
		for _, v := range fpmaov.values.([]int64) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *Meta_FieldPathMapArrayOfValues) AsLabelsArrayOfElementValues() ([]string, bool) {
	res, ok := fpmaov.values.([]string)
	return res, ok
}
func (fpmaov *Meta_FieldPathMapArrayOfValues) AsAnnotationsArrayOfElementValues() ([]string, bool) {
	res, ok := fpmaov.values.([]string)
	return res, ok
}
func (fpmaov *Meta_FieldPathMapArrayOfValues) AsShardsArrayOfElementValues() ([]int64, bool) {
	res, ok := fpmaov.values.([]int64)
	return res, ok
}

type Meta_FieldSubPathArrayOfValues struct {
	Meta_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ Meta_FieldPathArrayOfValues = (*Meta_FieldSubPathArrayOfValues)(nil)

func (fpsaov *Meta_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *Meta_FieldSubPathArrayOfValues) AsOwnerReferencesPathArrayOfValues() (OwnerReference_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(OwnerReference_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Meta_FieldSubPathArrayOfValues) AsSyncingPathArrayOfValues() (SyncingMeta_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(SyncingMeta_FieldPathArrayOfValues)
	return res, ok
}
func (fpsaov *Meta_FieldSubPathArrayOfValues) AsLifecyclePathArrayOfValues() (Lifecycle_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(Lifecycle_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type LabelSelector_FieldPath interface {
	gotenobject.FieldPath
	Selector() LabelSelector_FieldPathSelector
	Get(source *LabelSelector) []interface{}
	GetSingle(source *LabelSelector) (interface{}, bool)
	ClearValue(item *LabelSelector)

	// Those methods build corresponding LabelSelector_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) LabelSelector_FieldPathValue
	WithIArrayOfValues(values interface{}) LabelSelector_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) LabelSelector_FieldPathArrayItemValue
}

type LabelSelector_FieldPathSelector int32

const (
	LabelSelector_FieldPathSelectorMatchLabels      LabelSelector_FieldPathSelector = 0
	LabelSelector_FieldPathSelectorMatchExpressions LabelSelector_FieldPathSelector = 1
)

func (s LabelSelector_FieldPathSelector) String() string {
	switch s {
	case LabelSelector_FieldPathSelectorMatchLabels:
		return "match_labels"
	case LabelSelector_FieldPathSelectorMatchExpressions:
		return "match_expressions"
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", s))
	}
}

func BuildLabelSelector_FieldPath(fp gotenobject.RawFieldPath) (LabelSelector_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object LabelSelector")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "match_labels", "matchLabels", "match-labels":
			return &LabelSelector_FieldTerminalPath{selector: LabelSelector_FieldPathSelectorMatchLabels}, nil
		case "match_expressions", "matchExpressions", "match-expressions":
			return &LabelSelector_FieldTerminalPath{selector: LabelSelector_FieldPathSelectorMatchExpressions}, nil
		}
	} else {
		switch fp[0] {
		case "match_expressions", "matchExpressions", "match-expressions":
			if subpath, err := BuildLabelSelectorRequirement_FieldPath(fp[1:]); err != nil {
				return nil, err
			} else {
				return &LabelSelector_FieldSubPath{selector: LabelSelector_FieldPathSelectorMatchExpressions, subPath: subpath}, nil
			}
		case "match_labels", "matchLabels", "match-labels":
			if len(fp) > 2 {
				return nil, status.Errorf(codes.InvalidArgument, "sub path for maps ('%s') are not supported (object LabelSelector)", fp)
			}
			return &LabelSelector_FieldPathMap{selector: LabelSelector_FieldPathSelectorMatchLabels, key: fp[1]}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object LabelSelector", fp)
}

func ParseLabelSelector_FieldPath(rawField string) (LabelSelector_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLabelSelector_FieldPath(fp)
}

func MustParseLabelSelector_FieldPath(rawField string) LabelSelector_FieldPath {
	fp, err := ParseLabelSelector_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type LabelSelector_FieldTerminalPath struct {
	selector LabelSelector_FieldPathSelector
}

var _ LabelSelector_FieldPath = (*LabelSelector_FieldTerminalPath)(nil)

func (fp *LabelSelector_FieldTerminalPath) Selector() LabelSelector_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *LabelSelector_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *LabelSelector_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source LabelSelector
func (fp *LabelSelector_FieldTerminalPath) Get(source *LabelSelector) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case LabelSelector_FieldPathSelectorMatchLabels:
			values = append(values, source.MatchLabels)
		case LabelSelector_FieldPathSelectorMatchExpressions:
			for _, value := range source.GetMatchExpressions() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fp.selector))
		}
	}
	return
}

func (fp *LabelSelector_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*LabelSelector))
}

// GetSingle returns value pointed by specific field of from source LabelSelector
func (fp *LabelSelector_FieldTerminalPath) GetSingle(source *LabelSelector) (interface{}, bool) {
	switch fp.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		res := source.GetMatchLabels()
		return res, res != nil
	case LabelSelector_FieldPathSelectorMatchExpressions:
		res := source.GetMatchExpressions()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fp.selector))
	}
}

func (fp *LabelSelector_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*LabelSelector))
}

// GetDefault returns a default value of the field type
func (fp *LabelSelector_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		return (map[string]string)(nil)
	case LabelSelector_FieldPathSelectorMatchExpressions:
		return ([]*LabelSelectorRequirement)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fp.selector))
	}
}

func (fp *LabelSelector_FieldTerminalPath) ClearValue(item *LabelSelector) {
	if item != nil {
		switch fp.selector {
		case LabelSelector_FieldPathSelectorMatchLabels:
			item.MatchLabels = nil
		case LabelSelector_FieldPathSelectorMatchExpressions:
			item.MatchExpressions = nil
		default:
			panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fp.selector))
		}
	}
}

func (fp *LabelSelector_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*LabelSelector))
}

// IsLeaf - whether field path is holds simple value
func (fp *LabelSelector_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == LabelSelector_FieldPathSelectorMatchLabels
}

func (fp *LabelSelector_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *LabelSelector_FieldTerminalPath) WithIValue(value interface{}) LabelSelector_FieldPathValue {
	switch fp.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		return &LabelSelector_FieldTerminalPathValue{LabelSelector_FieldTerminalPath: *fp, value: value.(map[string]string)}
	case LabelSelector_FieldPathSelectorMatchExpressions:
		return &LabelSelector_FieldTerminalPathValue{LabelSelector_FieldTerminalPath: *fp, value: value.([]*LabelSelectorRequirement)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fp.selector))
	}
}

func (fp *LabelSelector_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *LabelSelector_FieldTerminalPath) WithIArrayOfValues(values interface{}) LabelSelector_FieldPathArrayOfValues {
	fpaov := &LabelSelector_FieldTerminalPathArrayOfValues{LabelSelector_FieldTerminalPath: *fp}
	switch fp.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		return &LabelSelector_FieldTerminalPathArrayOfValues{LabelSelector_FieldTerminalPath: *fp, values: values.([]map[string]string)}
	case LabelSelector_FieldPathSelectorMatchExpressions:
		return &LabelSelector_FieldTerminalPathArrayOfValues{LabelSelector_FieldTerminalPath: *fp, values: values.([][]*LabelSelectorRequirement)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fp.selector))
	}
	return fpaov
}

func (fp *LabelSelector_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *LabelSelector_FieldTerminalPath) WithIArrayItemValue(value interface{}) LabelSelector_FieldPathArrayItemValue {
	switch fp.selector {
	case LabelSelector_FieldPathSelectorMatchExpressions:
		return &LabelSelector_FieldTerminalPathArrayItemValue{LabelSelector_FieldTerminalPath: *fp, value: value.(*LabelSelectorRequirement)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fp.selector))
	}
}

func (fp *LabelSelector_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// FieldPath for map type with additional Key information
type LabelSelector_FieldPathMap struct {
	key      string
	selector LabelSelector_FieldPathSelector
}

var _ LabelSelector_FieldPath = (*LabelSelector_FieldPathMap)(nil)

func (fpm *LabelSelector_FieldPathMap) Selector() LabelSelector_FieldPathSelector {
	return fpm.selector
}

func (fpm *LabelSelector_FieldPathMap) Key() string {
	return fpm.key
}

// String returns path representation in proto convention
func (fpm *LabelSelector_FieldPathMap) String() string {
	return fpm.selector.String() + "." + fpm.key
}

// JSONString returns path representation is JSON convention. Note that map keys are not transformed
func (fpm *LabelSelector_FieldPathMap) JSONString() string {
	return strcase.ToLowerCamel(fpm.selector.String()) + "." + fpm.key
}

// Get returns all values pointed by selected field map key from source LabelSelector
func (fpm *LabelSelector_FieldPathMap) Get(source *LabelSelector) (values []interface{}) {
	switch fpm.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		if value, ok := source.GetMatchLabels()[fpm.key]; ok {
			values = append(values, value)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpm.selector))
	}
	return
}

func (fpm *LabelSelector_FieldPathMap) GetRaw(source proto.Message) []interface{} {
	return fpm.Get(source.(*LabelSelector))
}

// GetSingle returns value by selected field map key from source LabelSelector
func (fpm *LabelSelector_FieldPathMap) GetSingle(source *LabelSelector) (interface{}, bool) {
	switch fpm.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		res, ok := source.GetMatchLabels()[fpm.key]
		return res, ok
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpm.selector))
	}
}

func (fpm *LabelSelector_FieldPathMap) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpm.GetSingle(source.(*LabelSelector))
}

// GetDefault returns a default value of the field type
func (fpm *LabelSelector_FieldPathMap) GetDefault() interface{} {
	switch fpm.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		var v string
		return v
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpm.selector))
	}
}

func (fpm *LabelSelector_FieldPathMap) ClearValue(item *LabelSelector) {
	if item != nil {
		switch fpm.selector {
		case LabelSelector_FieldPathSelectorMatchLabels:
			delete(item.MatchLabels, fpm.key)
		default:
			panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpm.selector))
		}
	}
}

func (fpm *LabelSelector_FieldPathMap) ClearValueRaw(item proto.Message) {
	fpm.ClearValue(item.(*LabelSelector))
}

// IsLeaf - whether field path is holds simple value
func (fpm *LabelSelector_FieldPathMap) IsLeaf() bool {
	switch fpm.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		return true
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpm.selector))
	}
}

func (fpm *LabelSelector_FieldPathMap) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fpm}
}

func (fpm *LabelSelector_FieldPathMap) WithIValue(value interface{}) LabelSelector_FieldPathValue {
	switch fpm.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		return &LabelSelector_FieldPathMapValue{LabelSelector_FieldPathMap: *fpm, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpm.selector))
	}
}

func (fpm *LabelSelector_FieldPathMap) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fpm.WithIValue(value)
}

func (fpm *LabelSelector_FieldPathMap) WithIArrayOfValues(values interface{}) LabelSelector_FieldPathArrayOfValues {
	switch fpm.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		return &LabelSelector_FieldPathMapArrayOfValues{LabelSelector_FieldPathMap: *fpm, values: values.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpm.selector))
	}
}

func (fpm *LabelSelector_FieldPathMap) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fpm.WithIArrayOfValues(values)
}

func (fpm *LabelSelector_FieldPathMap) WithIArrayItemValue(value interface{}) LabelSelector_FieldPathArrayItemValue {
	panic("Cannot create array item value from map fieldpath")
}

func (fpm *LabelSelector_FieldPathMap) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fpm.WithIArrayItemValue(value)
}

type LabelSelector_FieldSubPath struct {
	selector LabelSelector_FieldPathSelector
	subPath  gotenobject.FieldPath
}

var _ LabelSelector_FieldPath = (*LabelSelector_FieldSubPath)(nil)

func (fps *LabelSelector_FieldSubPath) Selector() LabelSelector_FieldPathSelector {
	return fps.selector
}
func (fps *LabelSelector_FieldSubPath) AsMatchExpressionsSubPath() (LabelSelectorRequirement_FieldPath, bool) {
	res, ok := fps.subPath.(LabelSelectorRequirement_FieldPath)
	return res, ok
}

// String returns path representation in proto convention
func (fps *LabelSelector_FieldSubPath) String() string {
	return fps.selector.String() + "." + fps.subPath.String()
}

// JSONString returns path representation is JSON convention
func (fps *LabelSelector_FieldSubPath) JSONString() string {
	return strcase.ToLowerCamel(fps.selector.String()) + "." + fps.subPath.JSONString()
}

// Get returns all values pointed by selected field from source LabelSelector
func (fps *LabelSelector_FieldSubPath) Get(source *LabelSelector) (values []interface{}) {
	switch fps.selector {
	case LabelSelector_FieldPathSelectorMatchExpressions:
		for _, item := range source.GetMatchExpressions() {
			values = append(values, fps.subPath.GetRaw(item)...)
		}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fps.selector))
	}
	return
}

func (fps *LabelSelector_FieldSubPath) GetRaw(source proto.Message) []interface{} {
	return fps.Get(source.(*LabelSelector))
}

// GetSingle returns value of selected field from source LabelSelector
func (fps *LabelSelector_FieldSubPath) GetSingle(source *LabelSelector) (interface{}, bool) {
	switch fps.selector {
	case LabelSelector_FieldPathSelectorMatchExpressions:
		if len(source.GetMatchExpressions()) == 0 {
			return nil, false
		}
		return fps.subPath.GetSingleRaw(source.GetMatchExpressions()[0])
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fps.selector))
	}
}

func (fps *LabelSelector_FieldSubPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fps.GetSingle(source.(*LabelSelector))
}

// GetDefault returns a default value of the field type
func (fps *LabelSelector_FieldSubPath) GetDefault() interface{} {
	return fps.subPath.GetDefault()
}

func (fps *LabelSelector_FieldSubPath) ClearValue(item *LabelSelector) {
	if item != nil {
		switch fps.selector {
		case LabelSelector_FieldPathSelectorMatchExpressions:
			for _, subItem := range item.MatchExpressions {
				fps.subPath.ClearValueRaw(subItem)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fps.selector))
		}
	}
}

func (fps *LabelSelector_FieldSubPath) ClearValueRaw(item proto.Message) {
	fps.ClearValue(item.(*LabelSelector))
}

// IsLeaf - whether field path is holds simple value
func (fps *LabelSelector_FieldSubPath) IsLeaf() bool {
	return fps.subPath.IsLeaf()
}

func (fps *LabelSelector_FieldSubPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	iPaths := []gotenobject.FieldPath{&LabelSelector_FieldTerminalPath{selector: fps.selector}}
	iPaths = append(iPaths, fps.subPath.SplitIntoTerminalIPaths()...)
	return iPaths
}

func (fps *LabelSelector_FieldSubPath) WithIValue(value interface{}) LabelSelector_FieldPathValue {
	return &LabelSelector_FieldSubPathValue{fps, fps.subPath.WithRawIValue(value)}
}

func (fps *LabelSelector_FieldSubPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fps.WithIValue(value)
}

func (fps *LabelSelector_FieldSubPath) WithIArrayOfValues(values interface{}) LabelSelector_FieldPathArrayOfValues {
	return &LabelSelector_FieldSubPathArrayOfValues{fps, fps.subPath.WithRawIArrayOfValues(values)}
}

func (fps *LabelSelector_FieldSubPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fps.WithIArrayOfValues(values)
}

func (fps *LabelSelector_FieldSubPath) WithIArrayItemValue(value interface{}) LabelSelector_FieldPathArrayItemValue {
	return &LabelSelector_FieldSubPathArrayItemValue{fps, fps.subPath.WithRawIArrayItemValue(value)}
}

func (fps *LabelSelector_FieldSubPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fps.WithIArrayItemValue(value)
}

// LabelSelector_FieldPathValue allows storing values for LabelSelector fields according to their type
type LabelSelector_FieldPathValue interface {
	LabelSelector_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **LabelSelector)
	CompareWith(*LabelSelector) (cmp int, comparable bool)
}

func ParseLabelSelector_FieldPathValue(pathStr, valueStr string) (LabelSelector_FieldPathValue, error) {
	fp, err := ParseLabelSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelSelector field path value from %s: %v", valueStr, err)
	}
	return fpv.(LabelSelector_FieldPathValue), nil
}

func MustParseLabelSelector_FieldPathValue(pathStr, valueStr string) LabelSelector_FieldPathValue {
	fpv, err := ParseLabelSelector_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type LabelSelector_FieldTerminalPathValue struct {
	LabelSelector_FieldTerminalPath
	value interface{}
}

var _ LabelSelector_FieldPathValue = (*LabelSelector_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'LabelSelector' as interface{}
func (fpv *LabelSelector_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *LabelSelector_FieldTerminalPathValue) AsMatchLabelsValue() (map[string]string, bool) {
	res, ok := fpv.value.(map[string]string)
	return res, ok
}
func (fpv *LabelSelector_FieldTerminalPathValue) AsMatchExpressionsValue() ([]*LabelSelectorRequirement, bool) {
	res, ok := fpv.value.([]*LabelSelectorRequirement)
	return res, ok
}

// SetTo stores value for selected field for object LabelSelector
func (fpv *LabelSelector_FieldTerminalPathValue) SetTo(target **LabelSelector) {
	if *target == nil {
		*target = new(LabelSelector)
	}
	switch fpv.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		(*target).MatchLabels = fpv.value.(map[string]string)
	case LabelSelector_FieldPathSelectorMatchExpressions:
		(*target).MatchExpressions = fpv.value.([]*LabelSelectorRequirement)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpv.selector))
	}
}

func (fpv *LabelSelector_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LabelSelector)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LabelSelector_FieldTerminalPathValue' with the value under path in 'LabelSelector'.
func (fpv *LabelSelector_FieldTerminalPathValue) CompareWith(source *LabelSelector) (int, bool) {
	switch fpv.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		return 0, false
	case LabelSelector_FieldPathSelectorMatchExpressions:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpv.selector))
	}
}

func (fpv *LabelSelector_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*LabelSelector))
}

type LabelSelector_FieldPathMapValue struct {
	LabelSelector_FieldPathMap
	value interface{}
}

var _ LabelSelector_FieldPathValue = (*LabelSelector_FieldPathMapValue)(nil)

// GetValue returns value stored under selected field in LabelSelector as interface{}
func (fpmv *LabelSelector_FieldPathMapValue) GetRawValue() interface{} {
	return fpmv.value
}
func (fpmv *LabelSelector_FieldPathMapValue) AsMatchLabelsElementValue() (string, bool) {
	res, ok := fpmv.value.(string)
	return res, ok
}

// SetTo stores value for selected field in LabelSelector
func (fpmv *LabelSelector_FieldPathMapValue) SetTo(target **LabelSelector) {
	if *target == nil {
		*target = new(LabelSelector)
	}
	switch fpmv.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		if (*target).MatchLabels == nil {
			(*target).MatchLabels = make(map[string]string)
		}
		(*target).MatchLabels[fpmv.key] = fpmv.value.(string)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpmv.selector))
	}
}

func (fpmv *LabelSelector_FieldPathMapValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LabelSelector)
	fpmv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LabelSelector_FieldPathMapValue' with the value under path in 'LabelSelector'.
func (fpmv *LabelSelector_FieldPathMapValue) CompareWith(source *LabelSelector) (int, bool) {
	switch fpmv.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		leftValue := fpmv.value.(string)
		rightValue := source.GetMatchLabels()[fpmv.key]
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpmv.selector))
	}
}

func (fpmv *LabelSelector_FieldPathMapValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpmv.CompareWith(source.(*LabelSelector))
}

type LabelSelector_FieldSubPathValue struct {
	LabelSelector_FieldPath
	subPathValue gotenobject.FieldPathValue
}

var _ LabelSelector_FieldPathValue = (*LabelSelector_FieldSubPathValue)(nil)

func (fpvs *LabelSelector_FieldSubPathValue) AsMatchExpressionsPathValue() (LabelSelectorRequirement_FieldPathValue, bool) {
	res, ok := fpvs.subPathValue.(LabelSelectorRequirement_FieldPathValue)
	return res, ok
}

func (fpvs *LabelSelector_FieldSubPathValue) SetTo(target **LabelSelector) {
	if *target == nil {
		*target = new(LabelSelector)
	}
	switch fpvs.Selector() {
	case LabelSelector_FieldPathSelectorMatchExpressions:
		panic("FieldPath setter is unsupported for array subpaths")
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpvs.Selector()))
	}
}

func (fpvs *LabelSelector_FieldSubPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LabelSelector)
	fpvs.SetTo(&typedObject)
}

func (fpvs *LabelSelector_FieldSubPathValue) GetRawValue() interface{} {
	return fpvs.subPathValue.GetRawValue()
}

func (fpvs *LabelSelector_FieldSubPathValue) CompareWith(source *LabelSelector) (int, bool) {
	switch fpvs.Selector() {
	case LabelSelector_FieldPathSelectorMatchExpressions:
		return 0, false // repeated field
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpvs.Selector()))
	}
}

func (fpvs *LabelSelector_FieldSubPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpvs.CompareWith(source.(*LabelSelector))
}

// LabelSelector_FieldPathArrayItemValue allows storing single item in Path-specific values for LabelSelector according to their type
// Present only for array (repeated) types.
type LabelSelector_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	LabelSelector_FieldPath
	ContainsValue(*LabelSelector) bool
}

// ParseLabelSelector_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLabelSelector_FieldPathArrayItemValue(pathStr, valueStr string) (LabelSelector_FieldPathArrayItemValue, error) {
	fp, err := ParseLabelSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelSelector field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(LabelSelector_FieldPathArrayItemValue), nil
}

func MustParseLabelSelector_FieldPathArrayItemValue(pathStr, valueStr string) LabelSelector_FieldPathArrayItemValue {
	fpaiv, err := ParseLabelSelector_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type LabelSelector_FieldTerminalPathArrayItemValue struct {
	LabelSelector_FieldTerminalPath
	value interface{}
}

var _ LabelSelector_FieldPathArrayItemValue = (*LabelSelector_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object LabelSelector as interface{}
func (fpaiv *LabelSelector_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *LabelSelector_FieldTerminalPathArrayItemValue) AsMatchExpressionsItemValue() (*LabelSelectorRequirement, bool) {
	res, ok := fpaiv.value.(*LabelSelectorRequirement)
	return res, ok
}

func (fpaiv *LabelSelector_FieldTerminalPathArrayItemValue) GetSingle(source *LabelSelector) (interface{}, bool) {
	return nil, false
}

func (fpaiv *LabelSelector_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*LabelSelector))
}

// Contains returns a boolean indicating if value that is being held is present in given 'LabelSelector'
func (fpaiv *LabelSelector_FieldTerminalPathArrayItemValue) ContainsValue(source *LabelSelector) bool {
	slice := fpaiv.LabelSelector_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

type LabelSelector_FieldSubPathArrayItemValue struct {
	LabelSelector_FieldPath
	subPathItemValue gotenobject.FieldPathArrayItemValue
}

// GetRawValue returns stored array item value
func (fpaivs *LabelSelector_FieldSubPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaivs.subPathItemValue.GetRawItemValue()
}
func (fpaivs *LabelSelector_FieldSubPathArrayItemValue) AsMatchExpressionsPathItemValue() (LabelSelectorRequirement_FieldPathArrayItemValue, bool) {
	res, ok := fpaivs.subPathItemValue.(LabelSelectorRequirement_FieldPathArrayItemValue)
	return res, ok
}

// Contains returns a boolean indicating if value that is being held is present in given 'LabelSelector'
func (fpaivs *LabelSelector_FieldSubPathArrayItemValue) ContainsValue(source *LabelSelector) bool {
	switch fpaivs.Selector() {
	case LabelSelector_FieldPathSelectorMatchExpressions:
		return false // repeated/map field
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelector: %d", fpaivs.Selector()))
	}
}

// LabelSelector_FieldPathArrayOfValues allows storing slice of values for LabelSelector fields according to their type
type LabelSelector_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	LabelSelector_FieldPath
}

func ParseLabelSelector_FieldPathArrayOfValues(pathStr, valuesStr string) (LabelSelector_FieldPathArrayOfValues, error) {
	fp, err := ParseLabelSelector_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelSelector field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(LabelSelector_FieldPathArrayOfValues), nil
}

func MustParseLabelSelector_FieldPathArrayOfValues(pathStr, valuesStr string) LabelSelector_FieldPathArrayOfValues {
	fpaov, err := ParseLabelSelector_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type LabelSelector_FieldTerminalPathArrayOfValues struct {
	LabelSelector_FieldTerminalPath
	values interface{}
}

var _ LabelSelector_FieldPathArrayOfValues = (*LabelSelector_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *LabelSelector_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		for _, v := range fpaov.values.([]map[string]string) {
			values = append(values, v)
		}
	case LabelSelector_FieldPathSelectorMatchExpressions:
		for _, v := range fpaov.values.([][]*LabelSelectorRequirement) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *LabelSelector_FieldTerminalPathArrayOfValues) AsMatchLabelsArrayOfValues() ([]map[string]string, bool) {
	res, ok := fpaov.values.([]map[string]string)
	return res, ok
}
func (fpaov *LabelSelector_FieldTerminalPathArrayOfValues) AsMatchExpressionsArrayOfValues() ([][]*LabelSelectorRequirement, bool) {
	res, ok := fpaov.values.([][]*LabelSelectorRequirement)
	return res, ok
}

type LabelSelector_FieldPathMapArrayOfValues struct {
	LabelSelector_FieldPathMap
	values interface{}
}

var _ LabelSelector_FieldPathArrayOfValues = (*LabelSelector_FieldPathMapArrayOfValues)(nil)

func (fpmaov *LabelSelector_FieldPathMapArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpmaov.selector {
	case LabelSelector_FieldPathSelectorMatchLabels:
		for _, v := range fpmaov.values.([]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpmaov *LabelSelector_FieldPathMapArrayOfValues) AsMatchLabelsArrayOfElementValues() ([]string, bool) {
	res, ok := fpmaov.values.([]string)
	return res, ok
}

type LabelSelector_FieldSubPathArrayOfValues struct {
	LabelSelector_FieldPath
	subPathArrayOfValues gotenobject.FieldPathArrayOfValues
}

var _ LabelSelector_FieldPathArrayOfValues = (*LabelSelector_FieldSubPathArrayOfValues)(nil)

func (fpsaov *LabelSelector_FieldSubPathArrayOfValues) GetRawValues() []interface{} {
	return fpsaov.subPathArrayOfValues.GetRawValues()
}
func (fpsaov *LabelSelector_FieldSubPathArrayOfValues) AsMatchExpressionsPathArrayOfValues() (LabelSelectorRequirement_FieldPathArrayOfValues, bool) {
	res, ok := fpsaov.subPathArrayOfValues.(LabelSelectorRequirement_FieldPathArrayOfValues)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type LabelSelectorRequirement_FieldPath interface {
	gotenobject.FieldPath
	Selector() LabelSelectorRequirement_FieldPathSelector
	Get(source *LabelSelectorRequirement) []interface{}
	GetSingle(source *LabelSelectorRequirement) (interface{}, bool)
	ClearValue(item *LabelSelectorRequirement)

	// Those methods build corresponding LabelSelectorRequirement_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) LabelSelectorRequirement_FieldPathValue
	WithIArrayOfValues(values interface{}) LabelSelectorRequirement_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) LabelSelectorRequirement_FieldPathArrayItemValue
}

type LabelSelectorRequirement_FieldPathSelector int32

const (
	LabelSelectorRequirement_FieldPathSelectorKey      LabelSelectorRequirement_FieldPathSelector = 0
	LabelSelectorRequirement_FieldPathSelectorOperator LabelSelectorRequirement_FieldPathSelector = 1
	LabelSelectorRequirement_FieldPathSelectorValues   LabelSelectorRequirement_FieldPathSelector = 2
)

func (s LabelSelectorRequirement_FieldPathSelector) String() string {
	switch s {
	case LabelSelectorRequirement_FieldPathSelectorKey:
		return "key"
	case LabelSelectorRequirement_FieldPathSelectorOperator:
		return "operator"
	case LabelSelectorRequirement_FieldPathSelectorValues:
		return "values"
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", s))
	}
}

func BuildLabelSelectorRequirement_FieldPath(fp gotenobject.RawFieldPath) (LabelSelectorRequirement_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object LabelSelectorRequirement")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "key":
			return &LabelSelectorRequirement_FieldTerminalPath{selector: LabelSelectorRequirement_FieldPathSelectorKey}, nil
		case "operator":
			return &LabelSelectorRequirement_FieldTerminalPath{selector: LabelSelectorRequirement_FieldPathSelectorOperator}, nil
		case "values":
			return &LabelSelectorRequirement_FieldTerminalPath{selector: LabelSelectorRequirement_FieldPathSelectorValues}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object LabelSelectorRequirement", fp)
}

func ParseLabelSelectorRequirement_FieldPath(rawField string) (LabelSelectorRequirement_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLabelSelectorRequirement_FieldPath(fp)
}

func MustParseLabelSelectorRequirement_FieldPath(rawField string) LabelSelectorRequirement_FieldPath {
	fp, err := ParseLabelSelectorRequirement_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type LabelSelectorRequirement_FieldTerminalPath struct {
	selector LabelSelectorRequirement_FieldPathSelector
}

var _ LabelSelectorRequirement_FieldPath = (*LabelSelectorRequirement_FieldTerminalPath)(nil)

func (fp *LabelSelectorRequirement_FieldTerminalPath) Selector() LabelSelectorRequirement_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *LabelSelectorRequirement_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *LabelSelectorRequirement_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source LabelSelectorRequirement
func (fp *LabelSelectorRequirement_FieldTerminalPath) Get(source *LabelSelectorRequirement) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case LabelSelectorRequirement_FieldPathSelectorKey:
			values = append(values, source.Key)
		case LabelSelectorRequirement_FieldPathSelectorOperator:
			values = append(values, source.Operator)
		case LabelSelectorRequirement_FieldPathSelectorValues:
			for _, value := range source.GetValues() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fp.selector))
		}
	}
	return
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*LabelSelectorRequirement))
}

// GetSingle returns value pointed by specific field of from source LabelSelectorRequirement
func (fp *LabelSelectorRequirement_FieldTerminalPath) GetSingle(source *LabelSelectorRequirement) (interface{}, bool) {
	switch fp.selector {
	case LabelSelectorRequirement_FieldPathSelectorKey:
		return source.GetKey(), source != nil
	case LabelSelectorRequirement_FieldPathSelectorOperator:
		return source.GetOperator(), source != nil
	case LabelSelectorRequirement_FieldPathSelectorValues:
		res := source.GetValues()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fp.selector))
	}
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*LabelSelectorRequirement))
}

// GetDefault returns a default value of the field type
func (fp *LabelSelectorRequirement_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case LabelSelectorRequirement_FieldPathSelectorKey:
		return ""
	case LabelSelectorRequirement_FieldPathSelectorOperator:
		return ""
	case LabelSelectorRequirement_FieldPathSelectorValues:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fp.selector))
	}
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) ClearValue(item *LabelSelectorRequirement) {
	if item != nil {
		switch fp.selector {
		case LabelSelectorRequirement_FieldPathSelectorKey:
			item.Key = ""
		case LabelSelectorRequirement_FieldPathSelectorOperator:
			item.Operator = ""
		case LabelSelectorRequirement_FieldPathSelectorValues:
			item.Values = nil
		default:
			panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fp.selector))
		}
	}
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*LabelSelectorRequirement))
}

// IsLeaf - whether field path is holds simple value
func (fp *LabelSelectorRequirement_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == LabelSelectorRequirement_FieldPathSelectorKey ||
		fp.selector == LabelSelectorRequirement_FieldPathSelectorOperator ||
		fp.selector == LabelSelectorRequirement_FieldPathSelectorValues
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) WithIValue(value interface{}) LabelSelectorRequirement_FieldPathValue {
	switch fp.selector {
	case LabelSelectorRequirement_FieldPathSelectorKey:
		return &LabelSelectorRequirement_FieldTerminalPathValue{LabelSelectorRequirement_FieldTerminalPath: *fp, value: value.(string)}
	case LabelSelectorRequirement_FieldPathSelectorOperator:
		return &LabelSelectorRequirement_FieldTerminalPathValue{LabelSelectorRequirement_FieldTerminalPath: *fp, value: value.(string)}
	case LabelSelectorRequirement_FieldPathSelectorValues:
		return &LabelSelectorRequirement_FieldTerminalPathValue{LabelSelectorRequirement_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fp.selector))
	}
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) WithIArrayOfValues(values interface{}) LabelSelectorRequirement_FieldPathArrayOfValues {
	fpaov := &LabelSelectorRequirement_FieldTerminalPathArrayOfValues{LabelSelectorRequirement_FieldTerminalPath: *fp}
	switch fp.selector {
	case LabelSelectorRequirement_FieldPathSelectorKey:
		return &LabelSelectorRequirement_FieldTerminalPathArrayOfValues{LabelSelectorRequirement_FieldTerminalPath: *fp, values: values.([]string)}
	case LabelSelectorRequirement_FieldPathSelectorOperator:
		return &LabelSelectorRequirement_FieldTerminalPathArrayOfValues{LabelSelectorRequirement_FieldTerminalPath: *fp, values: values.([]string)}
	case LabelSelectorRequirement_FieldPathSelectorValues:
		return &LabelSelectorRequirement_FieldTerminalPathArrayOfValues{LabelSelectorRequirement_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fp.selector))
	}
	return fpaov
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) WithIArrayItemValue(value interface{}) LabelSelectorRequirement_FieldPathArrayItemValue {
	switch fp.selector {
	case LabelSelectorRequirement_FieldPathSelectorValues:
		return &LabelSelectorRequirement_FieldTerminalPathArrayItemValue{LabelSelectorRequirement_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fp.selector))
	}
}

func (fp *LabelSelectorRequirement_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// LabelSelectorRequirement_FieldPathValue allows storing values for LabelSelectorRequirement fields according to their type
type LabelSelectorRequirement_FieldPathValue interface {
	LabelSelectorRequirement_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **LabelSelectorRequirement)
	CompareWith(*LabelSelectorRequirement) (cmp int, comparable bool)
}

func ParseLabelSelectorRequirement_FieldPathValue(pathStr, valueStr string) (LabelSelectorRequirement_FieldPathValue, error) {
	fp, err := ParseLabelSelectorRequirement_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelSelectorRequirement field path value from %s: %v", valueStr, err)
	}
	return fpv.(LabelSelectorRequirement_FieldPathValue), nil
}

func MustParseLabelSelectorRequirement_FieldPathValue(pathStr, valueStr string) LabelSelectorRequirement_FieldPathValue {
	fpv, err := ParseLabelSelectorRequirement_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type LabelSelectorRequirement_FieldTerminalPathValue struct {
	LabelSelectorRequirement_FieldTerminalPath
	value interface{}
}

var _ LabelSelectorRequirement_FieldPathValue = (*LabelSelectorRequirement_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'LabelSelectorRequirement' as interface{}
func (fpv *LabelSelectorRequirement_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *LabelSelectorRequirement_FieldTerminalPathValue) AsKeyValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *LabelSelectorRequirement_FieldTerminalPathValue) AsOperatorValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *LabelSelectorRequirement_FieldTerminalPathValue) AsValuesValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object LabelSelectorRequirement
func (fpv *LabelSelectorRequirement_FieldTerminalPathValue) SetTo(target **LabelSelectorRequirement) {
	if *target == nil {
		*target = new(LabelSelectorRequirement)
	}
	switch fpv.selector {
	case LabelSelectorRequirement_FieldPathSelectorKey:
		(*target).Key = fpv.value.(string)
	case LabelSelectorRequirement_FieldPathSelectorOperator:
		(*target).Operator = fpv.value.(string)
	case LabelSelectorRequirement_FieldPathSelectorValues:
		(*target).Values = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fpv.selector))
	}
}

func (fpv *LabelSelectorRequirement_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*LabelSelectorRequirement)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'LabelSelectorRequirement_FieldTerminalPathValue' with the value under path in 'LabelSelectorRequirement'.
func (fpv *LabelSelectorRequirement_FieldTerminalPathValue) CompareWith(source *LabelSelectorRequirement) (int, bool) {
	switch fpv.selector {
	case LabelSelectorRequirement_FieldPathSelectorKey:
		leftValue := fpv.value.(string)
		rightValue := source.GetKey()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case LabelSelectorRequirement_FieldPathSelectorOperator:
		leftValue := fpv.value.(string)
		rightValue := source.GetOperator()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case LabelSelectorRequirement_FieldPathSelectorValues:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for LabelSelectorRequirement: %d", fpv.selector))
	}
}

func (fpv *LabelSelectorRequirement_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*LabelSelectorRequirement))
}

// LabelSelectorRequirement_FieldPathArrayItemValue allows storing single item in Path-specific values for LabelSelectorRequirement according to their type
// Present only for array (repeated) types.
type LabelSelectorRequirement_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	LabelSelectorRequirement_FieldPath
	ContainsValue(*LabelSelectorRequirement) bool
}

// ParseLabelSelectorRequirement_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLabelSelectorRequirement_FieldPathArrayItemValue(pathStr, valueStr string) (LabelSelectorRequirement_FieldPathArrayItemValue, error) {
	fp, err := ParseLabelSelectorRequirement_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelSelectorRequirement field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(LabelSelectorRequirement_FieldPathArrayItemValue), nil
}

func MustParseLabelSelectorRequirement_FieldPathArrayItemValue(pathStr, valueStr string) LabelSelectorRequirement_FieldPathArrayItemValue {
	fpaiv, err := ParseLabelSelectorRequirement_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type LabelSelectorRequirement_FieldTerminalPathArrayItemValue struct {
	LabelSelectorRequirement_FieldTerminalPath
	value interface{}
}

var _ LabelSelectorRequirement_FieldPathArrayItemValue = (*LabelSelectorRequirement_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object LabelSelectorRequirement as interface{}
func (fpaiv *LabelSelectorRequirement_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *LabelSelectorRequirement_FieldTerminalPathArrayItemValue) AsValuesItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *LabelSelectorRequirement_FieldTerminalPathArrayItemValue) GetSingle(source *LabelSelectorRequirement) (interface{}, bool) {
	return nil, false
}

func (fpaiv *LabelSelectorRequirement_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*LabelSelectorRequirement))
}

// Contains returns a boolean indicating if value that is being held is present in given 'LabelSelectorRequirement'
func (fpaiv *LabelSelectorRequirement_FieldTerminalPathArrayItemValue) ContainsValue(source *LabelSelectorRequirement) bool {
	slice := fpaiv.LabelSelectorRequirement_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// LabelSelectorRequirement_FieldPathArrayOfValues allows storing slice of values for LabelSelectorRequirement fields according to their type
type LabelSelectorRequirement_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	LabelSelectorRequirement_FieldPath
}

func ParseLabelSelectorRequirement_FieldPathArrayOfValues(pathStr, valuesStr string) (LabelSelectorRequirement_FieldPathArrayOfValues, error) {
	fp, err := ParseLabelSelectorRequirement_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing LabelSelectorRequirement field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(LabelSelectorRequirement_FieldPathArrayOfValues), nil
}

func MustParseLabelSelectorRequirement_FieldPathArrayOfValues(pathStr, valuesStr string) LabelSelectorRequirement_FieldPathArrayOfValues {
	fpaov, err := ParseLabelSelectorRequirement_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type LabelSelectorRequirement_FieldTerminalPathArrayOfValues struct {
	LabelSelectorRequirement_FieldTerminalPath
	values interface{}
}

var _ LabelSelectorRequirement_FieldPathArrayOfValues = (*LabelSelectorRequirement_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *LabelSelectorRequirement_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case LabelSelectorRequirement_FieldPathSelectorKey:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case LabelSelectorRequirement_FieldPathSelectorOperator:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case LabelSelectorRequirement_FieldPathSelectorValues:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *LabelSelectorRequirement_FieldTerminalPathArrayOfValues) AsKeyArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *LabelSelectorRequirement_FieldTerminalPathArrayOfValues) AsOperatorArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *LabelSelectorRequirement_FieldTerminalPathArrayOfValues) AsValuesArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type OwnerReference_FieldPath interface {
	gotenobject.FieldPath
	Selector() OwnerReference_FieldPathSelector
	Get(source *OwnerReference) []interface{}
	GetSingle(source *OwnerReference) (interface{}, bool)
	ClearValue(item *OwnerReference)

	// Those methods build corresponding OwnerReference_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) OwnerReference_FieldPathValue
	WithIArrayOfValues(values interface{}) OwnerReference_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) OwnerReference_FieldPathArrayItemValue
}

type OwnerReference_FieldPathSelector int32

const (
	OwnerReference_FieldPathSelectorKind                   OwnerReference_FieldPathSelector = 0
	OwnerReference_FieldPathSelectorVersion                OwnerReference_FieldPathSelector = 1
	OwnerReference_FieldPathSelectorName                   OwnerReference_FieldPathSelector = 2
	OwnerReference_FieldPathSelectorRegion                 OwnerReference_FieldPathSelector = 3
	OwnerReference_FieldPathSelectorController             OwnerReference_FieldPathSelector = 4
	OwnerReference_FieldPathSelectorBlockOwnerDeletion     OwnerReference_FieldPathSelector = 5
	OwnerReference_FieldPathSelectorRequiresOwnerReference OwnerReference_FieldPathSelector = 6
)

func (s OwnerReference_FieldPathSelector) String() string {
	switch s {
	case OwnerReference_FieldPathSelectorKind:
		return "kind"
	case OwnerReference_FieldPathSelectorVersion:
		return "version"
	case OwnerReference_FieldPathSelectorName:
		return "name"
	case OwnerReference_FieldPathSelectorRegion:
		return "region"
	case OwnerReference_FieldPathSelectorController:
		return "controller"
	case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
		return "block_owner_deletion"
	case OwnerReference_FieldPathSelectorRequiresOwnerReference:
		return "requires_owner_reference"
	default:
		panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", s))
	}
}

func BuildOwnerReference_FieldPath(fp gotenobject.RawFieldPath) (OwnerReference_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object OwnerReference")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "kind":
			return &OwnerReference_FieldTerminalPath{selector: OwnerReference_FieldPathSelectorKind}, nil
		case "version":
			return &OwnerReference_FieldTerminalPath{selector: OwnerReference_FieldPathSelectorVersion}, nil
		case "name":
			return &OwnerReference_FieldTerminalPath{selector: OwnerReference_FieldPathSelectorName}, nil
		case "region":
			return &OwnerReference_FieldTerminalPath{selector: OwnerReference_FieldPathSelectorRegion}, nil
		case "controller":
			return &OwnerReference_FieldTerminalPath{selector: OwnerReference_FieldPathSelectorController}, nil
		case "block_owner_deletion", "blockOwnerDeletion", "block-owner-deletion":
			return &OwnerReference_FieldTerminalPath{selector: OwnerReference_FieldPathSelectorBlockOwnerDeletion}, nil
		case "requires_owner_reference", "requiresOwnerReference", "requires-owner-reference":
			return &OwnerReference_FieldTerminalPath{selector: OwnerReference_FieldPathSelectorRequiresOwnerReference}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object OwnerReference", fp)
}

func ParseOwnerReference_FieldPath(rawField string) (OwnerReference_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildOwnerReference_FieldPath(fp)
}

func MustParseOwnerReference_FieldPath(rawField string) OwnerReference_FieldPath {
	fp, err := ParseOwnerReference_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type OwnerReference_FieldTerminalPath struct {
	selector OwnerReference_FieldPathSelector
}

var _ OwnerReference_FieldPath = (*OwnerReference_FieldTerminalPath)(nil)

func (fp *OwnerReference_FieldTerminalPath) Selector() OwnerReference_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *OwnerReference_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *OwnerReference_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source OwnerReference
func (fp *OwnerReference_FieldTerminalPath) Get(source *OwnerReference) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case OwnerReference_FieldPathSelectorKind:
			values = append(values, source.Kind)
		case OwnerReference_FieldPathSelectorVersion:
			values = append(values, source.Version)
		case OwnerReference_FieldPathSelectorName:
			values = append(values, source.Name)
		case OwnerReference_FieldPathSelectorRegion:
			values = append(values, source.Region)
		case OwnerReference_FieldPathSelectorController:
			values = append(values, source.Controller)
		case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
			values = append(values, source.BlockOwnerDeletion)
		case OwnerReference_FieldPathSelectorRequiresOwnerReference:
			values = append(values, source.RequiresOwnerReference)
		default:
			panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fp.selector))
		}
	}
	return
}

func (fp *OwnerReference_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*OwnerReference))
}

// GetSingle returns value pointed by specific field of from source OwnerReference
func (fp *OwnerReference_FieldTerminalPath) GetSingle(source *OwnerReference) (interface{}, bool) {
	switch fp.selector {
	case OwnerReference_FieldPathSelectorKind:
		return source.GetKind(), source != nil
	case OwnerReference_FieldPathSelectorVersion:
		return source.GetVersion(), source != nil
	case OwnerReference_FieldPathSelectorName:
		return source.GetName(), source != nil
	case OwnerReference_FieldPathSelectorRegion:
		return source.GetRegion(), source != nil
	case OwnerReference_FieldPathSelectorController:
		return source.GetController(), source != nil
	case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
		return source.GetBlockOwnerDeletion(), source != nil
	case OwnerReference_FieldPathSelectorRequiresOwnerReference:
		return source.GetRequiresOwnerReference(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fp.selector))
	}
}

func (fp *OwnerReference_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*OwnerReference))
}

// GetDefault returns a default value of the field type
func (fp *OwnerReference_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case OwnerReference_FieldPathSelectorKind:
		return ""
	case OwnerReference_FieldPathSelectorVersion:
		return ""
	case OwnerReference_FieldPathSelectorName:
		return ""
	case OwnerReference_FieldPathSelectorRegion:
		return ""
	case OwnerReference_FieldPathSelectorController:
		return false
	case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
		return false
	case OwnerReference_FieldPathSelectorRequiresOwnerReference:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fp.selector))
	}
}

func (fp *OwnerReference_FieldTerminalPath) ClearValue(item *OwnerReference) {
	if item != nil {
		switch fp.selector {
		case OwnerReference_FieldPathSelectorKind:
			item.Kind = ""
		case OwnerReference_FieldPathSelectorVersion:
			item.Version = ""
		case OwnerReference_FieldPathSelectorName:
			item.Name = ""
		case OwnerReference_FieldPathSelectorRegion:
			item.Region = ""
		case OwnerReference_FieldPathSelectorController:
			item.Controller = false
		case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
			item.BlockOwnerDeletion = false
		case OwnerReference_FieldPathSelectorRequiresOwnerReference:
			item.RequiresOwnerReference = false
		default:
			panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fp.selector))
		}
	}
}

func (fp *OwnerReference_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*OwnerReference))
}

// IsLeaf - whether field path is holds simple value
func (fp *OwnerReference_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == OwnerReference_FieldPathSelectorKind ||
		fp.selector == OwnerReference_FieldPathSelectorVersion ||
		fp.selector == OwnerReference_FieldPathSelectorName ||
		fp.selector == OwnerReference_FieldPathSelectorRegion ||
		fp.selector == OwnerReference_FieldPathSelectorController ||
		fp.selector == OwnerReference_FieldPathSelectorBlockOwnerDeletion ||
		fp.selector == OwnerReference_FieldPathSelectorRequiresOwnerReference
}

func (fp *OwnerReference_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *OwnerReference_FieldTerminalPath) WithIValue(value interface{}) OwnerReference_FieldPathValue {
	switch fp.selector {
	case OwnerReference_FieldPathSelectorKind:
		return &OwnerReference_FieldTerminalPathValue{OwnerReference_FieldTerminalPath: *fp, value: value.(string)}
	case OwnerReference_FieldPathSelectorVersion:
		return &OwnerReference_FieldTerminalPathValue{OwnerReference_FieldTerminalPath: *fp, value: value.(string)}
	case OwnerReference_FieldPathSelectorName:
		return &OwnerReference_FieldTerminalPathValue{OwnerReference_FieldTerminalPath: *fp, value: value.(string)}
	case OwnerReference_FieldPathSelectorRegion:
		return &OwnerReference_FieldTerminalPathValue{OwnerReference_FieldTerminalPath: *fp, value: value.(string)}
	case OwnerReference_FieldPathSelectorController:
		return &OwnerReference_FieldTerminalPathValue{OwnerReference_FieldTerminalPath: *fp, value: value.(bool)}
	case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
		return &OwnerReference_FieldTerminalPathValue{OwnerReference_FieldTerminalPath: *fp, value: value.(bool)}
	case OwnerReference_FieldPathSelectorRequiresOwnerReference:
		return &OwnerReference_FieldTerminalPathValue{OwnerReference_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fp.selector))
	}
}

func (fp *OwnerReference_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *OwnerReference_FieldTerminalPath) WithIArrayOfValues(values interface{}) OwnerReference_FieldPathArrayOfValues {
	fpaov := &OwnerReference_FieldTerminalPathArrayOfValues{OwnerReference_FieldTerminalPath: *fp}
	switch fp.selector {
	case OwnerReference_FieldPathSelectorKind:
		return &OwnerReference_FieldTerminalPathArrayOfValues{OwnerReference_FieldTerminalPath: *fp, values: values.([]string)}
	case OwnerReference_FieldPathSelectorVersion:
		return &OwnerReference_FieldTerminalPathArrayOfValues{OwnerReference_FieldTerminalPath: *fp, values: values.([]string)}
	case OwnerReference_FieldPathSelectorName:
		return &OwnerReference_FieldTerminalPathArrayOfValues{OwnerReference_FieldTerminalPath: *fp, values: values.([]string)}
	case OwnerReference_FieldPathSelectorRegion:
		return &OwnerReference_FieldTerminalPathArrayOfValues{OwnerReference_FieldTerminalPath: *fp, values: values.([]string)}
	case OwnerReference_FieldPathSelectorController:
		return &OwnerReference_FieldTerminalPathArrayOfValues{OwnerReference_FieldTerminalPath: *fp, values: values.([]bool)}
	case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
		return &OwnerReference_FieldTerminalPathArrayOfValues{OwnerReference_FieldTerminalPath: *fp, values: values.([]bool)}
	case OwnerReference_FieldPathSelectorRequiresOwnerReference:
		return &OwnerReference_FieldTerminalPathArrayOfValues{OwnerReference_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fp.selector))
	}
	return fpaov
}

func (fp *OwnerReference_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *OwnerReference_FieldTerminalPath) WithIArrayItemValue(value interface{}) OwnerReference_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fp.selector))
	}
}

func (fp *OwnerReference_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// OwnerReference_FieldPathValue allows storing values for OwnerReference fields according to their type
type OwnerReference_FieldPathValue interface {
	OwnerReference_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **OwnerReference)
	CompareWith(*OwnerReference) (cmp int, comparable bool)
}

func ParseOwnerReference_FieldPathValue(pathStr, valueStr string) (OwnerReference_FieldPathValue, error) {
	fp, err := ParseOwnerReference_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing OwnerReference field path value from %s: %v", valueStr, err)
	}
	return fpv.(OwnerReference_FieldPathValue), nil
}

func MustParseOwnerReference_FieldPathValue(pathStr, valueStr string) OwnerReference_FieldPathValue {
	fpv, err := ParseOwnerReference_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type OwnerReference_FieldTerminalPathValue struct {
	OwnerReference_FieldTerminalPath
	value interface{}
}

var _ OwnerReference_FieldPathValue = (*OwnerReference_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'OwnerReference' as interface{}
func (fpv *OwnerReference_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *OwnerReference_FieldTerminalPathValue) AsKindValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *OwnerReference_FieldTerminalPathValue) AsVersionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *OwnerReference_FieldTerminalPathValue) AsNameValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *OwnerReference_FieldTerminalPathValue) AsRegionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *OwnerReference_FieldTerminalPathValue) AsControllerValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *OwnerReference_FieldTerminalPathValue) AsBlockOwnerDeletionValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}
func (fpv *OwnerReference_FieldTerminalPathValue) AsRequiresOwnerReferenceValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object OwnerReference
func (fpv *OwnerReference_FieldTerminalPathValue) SetTo(target **OwnerReference) {
	if *target == nil {
		*target = new(OwnerReference)
	}
	switch fpv.selector {
	case OwnerReference_FieldPathSelectorKind:
		(*target).Kind = fpv.value.(string)
	case OwnerReference_FieldPathSelectorVersion:
		(*target).Version = fpv.value.(string)
	case OwnerReference_FieldPathSelectorName:
		(*target).Name = fpv.value.(string)
	case OwnerReference_FieldPathSelectorRegion:
		(*target).Region = fpv.value.(string)
	case OwnerReference_FieldPathSelectorController:
		(*target).Controller = fpv.value.(bool)
	case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
		(*target).BlockOwnerDeletion = fpv.value.(bool)
	case OwnerReference_FieldPathSelectorRequiresOwnerReference:
		(*target).RequiresOwnerReference = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fpv.selector))
	}
}

func (fpv *OwnerReference_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*OwnerReference)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'OwnerReference_FieldTerminalPathValue' with the value under path in 'OwnerReference'.
func (fpv *OwnerReference_FieldTerminalPathValue) CompareWith(source *OwnerReference) (int, bool) {
	switch fpv.selector {
	case OwnerReference_FieldPathSelectorKind:
		leftValue := fpv.value.(string)
		rightValue := source.GetKind()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case OwnerReference_FieldPathSelectorVersion:
		leftValue := fpv.value.(string)
		rightValue := source.GetVersion()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case OwnerReference_FieldPathSelectorName:
		leftValue := fpv.value.(string)
		rightValue := source.GetName()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case OwnerReference_FieldPathSelectorRegion:
		leftValue := fpv.value.(string)
		rightValue := source.GetRegion()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case OwnerReference_FieldPathSelectorController:
		leftValue := fpv.value.(bool)
		rightValue := source.GetController()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
		leftValue := fpv.value.(bool)
		rightValue := source.GetBlockOwnerDeletion()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case OwnerReference_FieldPathSelectorRequiresOwnerReference:
		leftValue := fpv.value.(bool)
		rightValue := source.GetRequiresOwnerReference()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for OwnerReference: %d", fpv.selector))
	}
}

func (fpv *OwnerReference_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*OwnerReference))
}

// OwnerReference_FieldPathArrayItemValue allows storing single item in Path-specific values for OwnerReference according to their type
// Present only for array (repeated) types.
type OwnerReference_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	OwnerReference_FieldPath
	ContainsValue(*OwnerReference) bool
}

// ParseOwnerReference_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseOwnerReference_FieldPathArrayItemValue(pathStr, valueStr string) (OwnerReference_FieldPathArrayItemValue, error) {
	fp, err := ParseOwnerReference_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing OwnerReference field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(OwnerReference_FieldPathArrayItemValue), nil
}

func MustParseOwnerReference_FieldPathArrayItemValue(pathStr, valueStr string) OwnerReference_FieldPathArrayItemValue {
	fpaiv, err := ParseOwnerReference_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type OwnerReference_FieldTerminalPathArrayItemValue struct {
	OwnerReference_FieldTerminalPath
	value interface{}
}

var _ OwnerReference_FieldPathArrayItemValue = (*OwnerReference_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object OwnerReference as interface{}
func (fpaiv *OwnerReference_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *OwnerReference_FieldTerminalPathArrayItemValue) GetSingle(source *OwnerReference) (interface{}, bool) {
	return nil, false
}

func (fpaiv *OwnerReference_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*OwnerReference))
}

// Contains returns a boolean indicating if value that is being held is present in given 'OwnerReference'
func (fpaiv *OwnerReference_FieldTerminalPathArrayItemValue) ContainsValue(source *OwnerReference) bool {
	slice := fpaiv.OwnerReference_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// OwnerReference_FieldPathArrayOfValues allows storing slice of values for OwnerReference fields according to their type
type OwnerReference_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	OwnerReference_FieldPath
}

func ParseOwnerReference_FieldPathArrayOfValues(pathStr, valuesStr string) (OwnerReference_FieldPathArrayOfValues, error) {
	fp, err := ParseOwnerReference_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing OwnerReference field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(OwnerReference_FieldPathArrayOfValues), nil
}

func MustParseOwnerReference_FieldPathArrayOfValues(pathStr, valuesStr string) OwnerReference_FieldPathArrayOfValues {
	fpaov, err := ParseOwnerReference_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type OwnerReference_FieldTerminalPathArrayOfValues struct {
	OwnerReference_FieldTerminalPath
	values interface{}
}

var _ OwnerReference_FieldPathArrayOfValues = (*OwnerReference_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *OwnerReference_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case OwnerReference_FieldPathSelectorKind:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case OwnerReference_FieldPathSelectorVersion:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case OwnerReference_FieldPathSelectorName:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case OwnerReference_FieldPathSelectorRegion:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case OwnerReference_FieldPathSelectorController:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case OwnerReference_FieldPathSelectorBlockOwnerDeletion:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	case OwnerReference_FieldPathSelectorRequiresOwnerReference:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *OwnerReference_FieldTerminalPathArrayOfValues) AsKindArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *OwnerReference_FieldTerminalPathArrayOfValues) AsVersionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *OwnerReference_FieldTerminalPathArrayOfValues) AsNameArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *OwnerReference_FieldTerminalPathArrayOfValues) AsRegionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *OwnerReference_FieldTerminalPathArrayOfValues) AsControllerArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *OwnerReference_FieldTerminalPathArrayOfValues) AsBlockOwnerDeletionArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
func (fpaov *OwnerReference_FieldTerminalPathArrayOfValues) AsRequiresOwnerReferenceArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type SyncingMeta_FieldPath interface {
	gotenobject.FieldPath
	Selector() SyncingMeta_FieldPathSelector
	Get(source *SyncingMeta) []interface{}
	GetSingle(source *SyncingMeta) (interface{}, bool)
	ClearValue(item *SyncingMeta)

	// Those methods build corresponding SyncingMeta_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) SyncingMeta_FieldPathValue
	WithIArrayOfValues(values interface{}) SyncingMeta_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) SyncingMeta_FieldPathArrayItemValue
}

type SyncingMeta_FieldPathSelector int32

const (
	SyncingMeta_FieldPathSelectorOwningRegion SyncingMeta_FieldPathSelector = 0
	SyncingMeta_FieldPathSelectorRegions      SyncingMeta_FieldPathSelector = 1
)

func (s SyncingMeta_FieldPathSelector) String() string {
	switch s {
	case SyncingMeta_FieldPathSelectorOwningRegion:
		return "owning_region"
	case SyncingMeta_FieldPathSelectorRegions:
		return "regions"
	default:
		panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", s))
	}
}

func BuildSyncingMeta_FieldPath(fp gotenobject.RawFieldPath) (SyncingMeta_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object SyncingMeta")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "owning_region", "owningRegion", "owning-region":
			return &SyncingMeta_FieldTerminalPath{selector: SyncingMeta_FieldPathSelectorOwningRegion}, nil
		case "regions":
			return &SyncingMeta_FieldTerminalPath{selector: SyncingMeta_FieldPathSelectorRegions}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object SyncingMeta", fp)
}

func ParseSyncingMeta_FieldPath(rawField string) (SyncingMeta_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildSyncingMeta_FieldPath(fp)
}

func MustParseSyncingMeta_FieldPath(rawField string) SyncingMeta_FieldPath {
	fp, err := ParseSyncingMeta_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type SyncingMeta_FieldTerminalPath struct {
	selector SyncingMeta_FieldPathSelector
}

var _ SyncingMeta_FieldPath = (*SyncingMeta_FieldTerminalPath)(nil)

func (fp *SyncingMeta_FieldTerminalPath) Selector() SyncingMeta_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *SyncingMeta_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *SyncingMeta_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source SyncingMeta
func (fp *SyncingMeta_FieldTerminalPath) Get(source *SyncingMeta) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case SyncingMeta_FieldPathSelectorOwningRegion:
			values = append(values, source.OwningRegion)
		case SyncingMeta_FieldPathSelectorRegions:
			for _, value := range source.GetRegions() {
				values = append(values, value)
			}
		default:
			panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fp.selector))
		}
	}
	return
}

func (fp *SyncingMeta_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*SyncingMeta))
}

// GetSingle returns value pointed by specific field of from source SyncingMeta
func (fp *SyncingMeta_FieldTerminalPath) GetSingle(source *SyncingMeta) (interface{}, bool) {
	switch fp.selector {
	case SyncingMeta_FieldPathSelectorOwningRegion:
		return source.GetOwningRegion(), source != nil
	case SyncingMeta_FieldPathSelectorRegions:
		res := source.GetRegions()
		return res, res != nil
	default:
		panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fp.selector))
	}
}

func (fp *SyncingMeta_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*SyncingMeta))
}

// GetDefault returns a default value of the field type
func (fp *SyncingMeta_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case SyncingMeta_FieldPathSelectorOwningRegion:
		return ""
	case SyncingMeta_FieldPathSelectorRegions:
		return ([]string)(nil)
	default:
		panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fp.selector))
	}
}

func (fp *SyncingMeta_FieldTerminalPath) ClearValue(item *SyncingMeta) {
	if item != nil {
		switch fp.selector {
		case SyncingMeta_FieldPathSelectorOwningRegion:
			item.OwningRegion = ""
		case SyncingMeta_FieldPathSelectorRegions:
			item.Regions = nil
		default:
			panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fp.selector))
		}
	}
}

func (fp *SyncingMeta_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*SyncingMeta))
}

// IsLeaf - whether field path is holds simple value
func (fp *SyncingMeta_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == SyncingMeta_FieldPathSelectorOwningRegion ||
		fp.selector == SyncingMeta_FieldPathSelectorRegions
}

func (fp *SyncingMeta_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *SyncingMeta_FieldTerminalPath) WithIValue(value interface{}) SyncingMeta_FieldPathValue {
	switch fp.selector {
	case SyncingMeta_FieldPathSelectorOwningRegion:
		return &SyncingMeta_FieldTerminalPathValue{SyncingMeta_FieldTerminalPath: *fp, value: value.(string)}
	case SyncingMeta_FieldPathSelectorRegions:
		return &SyncingMeta_FieldTerminalPathValue{SyncingMeta_FieldTerminalPath: *fp, value: value.([]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fp.selector))
	}
}

func (fp *SyncingMeta_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *SyncingMeta_FieldTerminalPath) WithIArrayOfValues(values interface{}) SyncingMeta_FieldPathArrayOfValues {
	fpaov := &SyncingMeta_FieldTerminalPathArrayOfValues{SyncingMeta_FieldTerminalPath: *fp}
	switch fp.selector {
	case SyncingMeta_FieldPathSelectorOwningRegion:
		return &SyncingMeta_FieldTerminalPathArrayOfValues{SyncingMeta_FieldTerminalPath: *fp, values: values.([]string)}
	case SyncingMeta_FieldPathSelectorRegions:
		return &SyncingMeta_FieldTerminalPathArrayOfValues{SyncingMeta_FieldTerminalPath: *fp, values: values.([][]string)}
	default:
		panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fp.selector))
	}
	return fpaov
}

func (fp *SyncingMeta_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *SyncingMeta_FieldTerminalPath) WithIArrayItemValue(value interface{}) SyncingMeta_FieldPathArrayItemValue {
	switch fp.selector {
	case SyncingMeta_FieldPathSelectorRegions:
		return &SyncingMeta_FieldTerminalPathArrayItemValue{SyncingMeta_FieldTerminalPath: *fp, value: value.(string)}
	default:
		panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fp.selector))
	}
}

func (fp *SyncingMeta_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// SyncingMeta_FieldPathValue allows storing values for SyncingMeta fields according to their type
type SyncingMeta_FieldPathValue interface {
	SyncingMeta_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **SyncingMeta)
	CompareWith(*SyncingMeta) (cmp int, comparable bool)
}

func ParseSyncingMeta_FieldPathValue(pathStr, valueStr string) (SyncingMeta_FieldPathValue, error) {
	fp, err := ParseSyncingMeta_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SyncingMeta field path value from %s: %v", valueStr, err)
	}
	return fpv.(SyncingMeta_FieldPathValue), nil
}

func MustParseSyncingMeta_FieldPathValue(pathStr, valueStr string) SyncingMeta_FieldPathValue {
	fpv, err := ParseSyncingMeta_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type SyncingMeta_FieldTerminalPathValue struct {
	SyncingMeta_FieldTerminalPath
	value interface{}
}

var _ SyncingMeta_FieldPathValue = (*SyncingMeta_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'SyncingMeta' as interface{}
func (fpv *SyncingMeta_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *SyncingMeta_FieldTerminalPathValue) AsOwningRegionValue() (string, bool) {
	res, ok := fpv.value.(string)
	return res, ok
}
func (fpv *SyncingMeta_FieldTerminalPathValue) AsRegionsValue() ([]string, bool) {
	res, ok := fpv.value.([]string)
	return res, ok
}

// SetTo stores value for selected field for object SyncingMeta
func (fpv *SyncingMeta_FieldTerminalPathValue) SetTo(target **SyncingMeta) {
	if *target == nil {
		*target = new(SyncingMeta)
	}
	switch fpv.selector {
	case SyncingMeta_FieldPathSelectorOwningRegion:
		(*target).OwningRegion = fpv.value.(string)
	case SyncingMeta_FieldPathSelectorRegions:
		(*target).Regions = fpv.value.([]string)
	default:
		panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fpv.selector))
	}
}

func (fpv *SyncingMeta_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*SyncingMeta)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'SyncingMeta_FieldTerminalPathValue' with the value under path in 'SyncingMeta'.
func (fpv *SyncingMeta_FieldTerminalPathValue) CompareWith(source *SyncingMeta) (int, bool) {
	switch fpv.selector {
	case SyncingMeta_FieldPathSelectorOwningRegion:
		leftValue := fpv.value.(string)
		rightValue := source.GetOwningRegion()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case SyncingMeta_FieldPathSelectorRegions:
		return 0, false
	default:
		panic(fmt.Sprintf("Invalid selector for SyncingMeta: %d", fpv.selector))
	}
}

func (fpv *SyncingMeta_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*SyncingMeta))
}

// SyncingMeta_FieldPathArrayItemValue allows storing single item in Path-specific values for SyncingMeta according to their type
// Present only for array (repeated) types.
type SyncingMeta_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	SyncingMeta_FieldPath
	ContainsValue(*SyncingMeta) bool
}

// ParseSyncingMeta_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseSyncingMeta_FieldPathArrayItemValue(pathStr, valueStr string) (SyncingMeta_FieldPathArrayItemValue, error) {
	fp, err := ParseSyncingMeta_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SyncingMeta field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(SyncingMeta_FieldPathArrayItemValue), nil
}

func MustParseSyncingMeta_FieldPathArrayItemValue(pathStr, valueStr string) SyncingMeta_FieldPathArrayItemValue {
	fpaiv, err := ParseSyncingMeta_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type SyncingMeta_FieldTerminalPathArrayItemValue struct {
	SyncingMeta_FieldTerminalPath
	value interface{}
}

var _ SyncingMeta_FieldPathArrayItemValue = (*SyncingMeta_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object SyncingMeta as interface{}
func (fpaiv *SyncingMeta_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}
func (fpaiv *SyncingMeta_FieldTerminalPathArrayItemValue) AsRegionsItemValue() (string, bool) {
	res, ok := fpaiv.value.(string)
	return res, ok
}

func (fpaiv *SyncingMeta_FieldTerminalPathArrayItemValue) GetSingle(source *SyncingMeta) (interface{}, bool) {
	return nil, false
}

func (fpaiv *SyncingMeta_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*SyncingMeta))
}

// Contains returns a boolean indicating if value that is being held is present in given 'SyncingMeta'
func (fpaiv *SyncingMeta_FieldTerminalPathArrayItemValue) ContainsValue(source *SyncingMeta) bool {
	slice := fpaiv.SyncingMeta_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// SyncingMeta_FieldPathArrayOfValues allows storing slice of values for SyncingMeta fields according to their type
type SyncingMeta_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	SyncingMeta_FieldPath
}

func ParseSyncingMeta_FieldPathArrayOfValues(pathStr, valuesStr string) (SyncingMeta_FieldPathArrayOfValues, error) {
	fp, err := ParseSyncingMeta_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing SyncingMeta field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(SyncingMeta_FieldPathArrayOfValues), nil
}

func MustParseSyncingMeta_FieldPathArrayOfValues(pathStr, valuesStr string) SyncingMeta_FieldPathArrayOfValues {
	fpaov, err := ParseSyncingMeta_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type SyncingMeta_FieldTerminalPathArrayOfValues struct {
	SyncingMeta_FieldTerminalPath
	values interface{}
}

var _ SyncingMeta_FieldPathArrayOfValues = (*SyncingMeta_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *SyncingMeta_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case SyncingMeta_FieldPathSelectorOwningRegion:
		for _, v := range fpaov.values.([]string) {
			values = append(values, v)
		}
	case SyncingMeta_FieldPathSelectorRegions:
		for _, v := range fpaov.values.([][]string) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *SyncingMeta_FieldTerminalPathArrayOfValues) AsOwningRegionArrayOfValues() ([]string, bool) {
	res, ok := fpaov.values.([]string)
	return res, ok
}
func (fpaov *SyncingMeta_FieldTerminalPathArrayOfValues) AsRegionsArrayOfValues() ([][]string, bool) {
	res, ok := fpaov.values.([][]string)
	return res, ok
}

// FieldPath provides implementation to handle
// https://github.com/protocolbuffers/protobuf/blob/master/src/google/protobuf/field_mask.proto
type Lifecycle_FieldPath interface {
	gotenobject.FieldPath
	Selector() Lifecycle_FieldPathSelector
	Get(source *Lifecycle) []interface{}
	GetSingle(source *Lifecycle) (interface{}, bool)
	ClearValue(item *Lifecycle)

	// Those methods build corresponding Lifecycle_FieldPathValue
	// (or array of values) and holds passed value. Panics if injected type is incorrect.
	WithIValue(value interface{}) Lifecycle_FieldPathValue
	WithIArrayOfValues(values interface{}) Lifecycle_FieldPathArrayOfValues
	WithIArrayItemValue(value interface{}) Lifecycle_FieldPathArrayItemValue
}

type Lifecycle_FieldPathSelector int32

const (
	Lifecycle_FieldPathSelectorState         Lifecycle_FieldPathSelector = 0
	Lifecycle_FieldPathSelectorBlockDeletion Lifecycle_FieldPathSelector = 1
)

func (s Lifecycle_FieldPathSelector) String() string {
	switch s {
	case Lifecycle_FieldPathSelectorState:
		return "state"
	case Lifecycle_FieldPathSelectorBlockDeletion:
		return "block_deletion"
	default:
		panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", s))
	}
}

func BuildLifecycle_FieldPath(fp gotenobject.RawFieldPath) (Lifecycle_FieldPath, error) {
	if len(fp) == 0 {
		return nil, status.Error(codes.InvalidArgument, "empty field path for object Lifecycle")
	}
	if len(fp) == 1 {
		switch fp[0] {
		case "state":
			return &Lifecycle_FieldTerminalPath{selector: Lifecycle_FieldPathSelectorState}, nil
		case "block_deletion", "blockDeletion", "block-deletion":
			return &Lifecycle_FieldTerminalPath{selector: Lifecycle_FieldPathSelectorBlockDeletion}, nil
		}
	}
	return nil, status.Errorf(codes.InvalidArgument, "unknown field path '%s' for object Lifecycle", fp)
}

func ParseLifecycle_FieldPath(rawField string) (Lifecycle_FieldPath, error) {
	fp, err := gotenobject.ParseRawFieldPath(rawField)
	if err != nil {
		return nil, err
	}
	return BuildLifecycle_FieldPath(fp)
}

func MustParseLifecycle_FieldPath(rawField string) Lifecycle_FieldPath {
	fp, err := ParseLifecycle_FieldPath(rawField)
	if err != nil {
		panic(err)
	}
	return fp
}

type Lifecycle_FieldTerminalPath struct {
	selector Lifecycle_FieldPathSelector
}

var _ Lifecycle_FieldPath = (*Lifecycle_FieldTerminalPath)(nil)

func (fp *Lifecycle_FieldTerminalPath) Selector() Lifecycle_FieldPathSelector {
	return fp.selector
}

// String returns path representation in proto convention
func (fp *Lifecycle_FieldTerminalPath) String() string {
	return fp.selector.String()
}

// JSONString returns path representation is JSON convention
func (fp *Lifecycle_FieldTerminalPath) JSONString() string {
	return strcase.ToLowerCamel(fp.String())
}

// Get returns all values pointed by specific field from source Lifecycle
func (fp *Lifecycle_FieldTerminalPath) Get(source *Lifecycle) (values []interface{}) {
	if source != nil {
		switch fp.selector {
		case Lifecycle_FieldPathSelectorState:
			values = append(values, source.State)
		case Lifecycle_FieldPathSelectorBlockDeletion:
			values = append(values, source.BlockDeletion)
		default:
			panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fp.selector))
		}
	}
	return
}

func (fp *Lifecycle_FieldTerminalPath) GetRaw(source proto.Message) []interface{} {
	return fp.Get(source.(*Lifecycle))
}

// GetSingle returns value pointed by specific field of from source Lifecycle
func (fp *Lifecycle_FieldTerminalPath) GetSingle(source *Lifecycle) (interface{}, bool) {
	switch fp.selector {
	case Lifecycle_FieldPathSelectorState:
		return source.GetState(), source != nil
	case Lifecycle_FieldPathSelectorBlockDeletion:
		return source.GetBlockDeletion(), source != nil
	default:
		panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fp.selector))
	}
}

func (fp *Lifecycle_FieldTerminalPath) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fp.GetSingle(source.(*Lifecycle))
}

// GetDefault returns a default value of the field type
func (fp *Lifecycle_FieldTerminalPath) GetDefault() interface{} {
	switch fp.selector {
	case Lifecycle_FieldPathSelectorState:
		return Lifecycle_UNDEFINED
	case Lifecycle_FieldPathSelectorBlockDeletion:
		return false
	default:
		panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fp.selector))
	}
}

func (fp *Lifecycle_FieldTerminalPath) ClearValue(item *Lifecycle) {
	if item != nil {
		switch fp.selector {
		case Lifecycle_FieldPathSelectorState:
			item.State = Lifecycle_UNDEFINED
		case Lifecycle_FieldPathSelectorBlockDeletion:
			item.BlockDeletion = false
		default:
			panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fp.selector))
		}
	}
}

func (fp *Lifecycle_FieldTerminalPath) ClearValueRaw(item proto.Message) {
	fp.ClearValue(item.(*Lifecycle))
}

// IsLeaf - whether field path is holds simple value
func (fp *Lifecycle_FieldTerminalPath) IsLeaf() bool {
	return fp.selector == Lifecycle_FieldPathSelectorState ||
		fp.selector == Lifecycle_FieldPathSelectorBlockDeletion
}

func (fp *Lifecycle_FieldTerminalPath) SplitIntoTerminalIPaths() []gotenobject.FieldPath {
	return []gotenobject.FieldPath{fp}
}

func (fp *Lifecycle_FieldTerminalPath) WithIValue(value interface{}) Lifecycle_FieldPathValue {
	switch fp.selector {
	case Lifecycle_FieldPathSelectorState:
		return &Lifecycle_FieldTerminalPathValue{Lifecycle_FieldTerminalPath: *fp, value: value.(Lifecycle_State)}
	case Lifecycle_FieldPathSelectorBlockDeletion:
		return &Lifecycle_FieldTerminalPathValue{Lifecycle_FieldTerminalPath: *fp, value: value.(bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fp.selector))
	}
}

func (fp *Lifecycle_FieldTerminalPath) WithRawIValue(value interface{}) gotenobject.FieldPathValue {
	return fp.WithIValue(value)
}

func (fp *Lifecycle_FieldTerminalPath) WithIArrayOfValues(values interface{}) Lifecycle_FieldPathArrayOfValues {
	fpaov := &Lifecycle_FieldTerminalPathArrayOfValues{Lifecycle_FieldTerminalPath: *fp}
	switch fp.selector {
	case Lifecycle_FieldPathSelectorState:
		return &Lifecycle_FieldTerminalPathArrayOfValues{Lifecycle_FieldTerminalPath: *fp, values: values.([]Lifecycle_State)}
	case Lifecycle_FieldPathSelectorBlockDeletion:
		return &Lifecycle_FieldTerminalPathArrayOfValues{Lifecycle_FieldTerminalPath: *fp, values: values.([]bool)}
	default:
		panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fp.selector))
	}
	return fpaov
}

func (fp *Lifecycle_FieldTerminalPath) WithRawIArrayOfValues(values interface{}) gotenobject.FieldPathArrayOfValues {
	return fp.WithIArrayOfValues(values)
}

func (fp *Lifecycle_FieldTerminalPath) WithIArrayItemValue(value interface{}) Lifecycle_FieldPathArrayItemValue {
	switch fp.selector {
	default:
		panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fp.selector))
	}
}

func (fp *Lifecycle_FieldTerminalPath) WithRawIArrayItemValue(value interface{}) gotenobject.FieldPathArrayItemValue {
	return fp.WithIArrayItemValue(value)
}

// Lifecycle_FieldPathValue allows storing values for Lifecycle fields according to their type
type Lifecycle_FieldPathValue interface {
	Lifecycle_FieldPath
	gotenobject.FieldPathValue
	SetTo(target **Lifecycle)
	CompareWith(*Lifecycle) (cmp int, comparable bool)
}

func ParseLifecycle_FieldPathValue(pathStr, valueStr string) (Lifecycle_FieldPathValue, error) {
	fp, err := ParseLifecycle_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpv, err := gotenobject.ParseFieldPathValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Lifecycle field path value from %s: %v", valueStr, err)
	}
	return fpv.(Lifecycle_FieldPathValue), nil
}

func MustParseLifecycle_FieldPathValue(pathStr, valueStr string) Lifecycle_FieldPathValue {
	fpv, err := ParseLifecycle_FieldPathValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpv
}

type Lifecycle_FieldTerminalPathValue struct {
	Lifecycle_FieldTerminalPath
	value interface{}
}

var _ Lifecycle_FieldPathValue = (*Lifecycle_FieldTerminalPathValue)(nil)

// GetRawValue returns raw value stored under selected path for 'Lifecycle' as interface{}
func (fpv *Lifecycle_FieldTerminalPathValue) GetRawValue() interface{} {
	return fpv.value
}
func (fpv *Lifecycle_FieldTerminalPathValue) AsStateValue() (Lifecycle_State, bool) {
	res, ok := fpv.value.(Lifecycle_State)
	return res, ok
}
func (fpv *Lifecycle_FieldTerminalPathValue) AsBlockDeletionValue() (bool, bool) {
	res, ok := fpv.value.(bool)
	return res, ok
}

// SetTo stores value for selected field for object Lifecycle
func (fpv *Lifecycle_FieldTerminalPathValue) SetTo(target **Lifecycle) {
	if *target == nil {
		*target = new(Lifecycle)
	}
	switch fpv.selector {
	case Lifecycle_FieldPathSelectorState:
		(*target).State = fpv.value.(Lifecycle_State)
	case Lifecycle_FieldPathSelectorBlockDeletion:
		(*target).BlockDeletion = fpv.value.(bool)
	default:
		panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fpv.selector))
	}
}

func (fpv *Lifecycle_FieldTerminalPathValue) SetToRaw(target proto.Message) {
	typedObject := target.(*Lifecycle)
	fpv.SetTo(&typedObject)
}

// CompareWith compares value in the 'Lifecycle_FieldTerminalPathValue' with the value under path in 'Lifecycle'.
func (fpv *Lifecycle_FieldTerminalPathValue) CompareWith(source *Lifecycle) (int, bool) {
	switch fpv.selector {
	case Lifecycle_FieldPathSelectorState:
		leftValue := fpv.value.(Lifecycle_State)
		rightValue := source.GetState()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if (leftValue) < (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	case Lifecycle_FieldPathSelectorBlockDeletion:
		leftValue := fpv.value.(bool)
		rightValue := source.GetBlockDeletion()
		if (leftValue) == (rightValue) {
			return 0, true
		} else if !(leftValue) && (rightValue) {
			return -1, true
		} else {
			return 1, true
		}
	default:
		panic(fmt.Sprintf("Invalid selector for Lifecycle: %d", fpv.selector))
	}
}

func (fpv *Lifecycle_FieldTerminalPathValue) CompareWithRaw(source proto.Message) (int, bool) {
	return fpv.CompareWith(source.(*Lifecycle))
}

// Lifecycle_FieldPathArrayItemValue allows storing single item in Path-specific values for Lifecycle according to their type
// Present only for array (repeated) types.
type Lifecycle_FieldPathArrayItemValue interface {
	gotenobject.FieldPathArrayItemValue
	Lifecycle_FieldPath
	ContainsValue(*Lifecycle) bool
}

// ParseLifecycle_FieldPathArrayItemValue parses string and JSON-encoded value to its Value
func ParseLifecycle_FieldPathArrayItemValue(pathStr, valueStr string) (Lifecycle_FieldPathArrayItemValue, error) {
	fp, err := ParseLifecycle_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaiv, err := gotenobject.ParseFieldPathArrayItemValue(fp, valueStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Lifecycle field path array item value from %s: %v", valueStr, err)
	}
	return fpaiv.(Lifecycle_FieldPathArrayItemValue), nil
}

func MustParseLifecycle_FieldPathArrayItemValue(pathStr, valueStr string) Lifecycle_FieldPathArrayItemValue {
	fpaiv, err := ParseLifecycle_FieldPathArrayItemValue(pathStr, valueStr)
	if err != nil {
		panic(err)
	}
	return fpaiv
}

type Lifecycle_FieldTerminalPathArrayItemValue struct {
	Lifecycle_FieldTerminalPath
	value interface{}
}

var _ Lifecycle_FieldPathArrayItemValue = (*Lifecycle_FieldTerminalPathArrayItemValue)(nil)

// GetRawValue returns stored element value for array in object Lifecycle as interface{}
func (fpaiv *Lifecycle_FieldTerminalPathArrayItemValue) GetRawItemValue() interface{} {
	return fpaiv.value
}

func (fpaiv *Lifecycle_FieldTerminalPathArrayItemValue) GetSingle(source *Lifecycle) (interface{}, bool) {
	return nil, false
}

func (fpaiv *Lifecycle_FieldTerminalPathArrayItemValue) GetSingleRaw(source proto.Message) (interface{}, bool) {
	return fpaiv.GetSingle(source.(*Lifecycle))
}

// Contains returns a boolean indicating if value that is being held is present in given 'Lifecycle'
func (fpaiv *Lifecycle_FieldTerminalPathArrayItemValue) ContainsValue(source *Lifecycle) bool {
	slice := fpaiv.Lifecycle_FieldTerminalPath.Get(source)
	for _, v := range slice {
		if asProtoMsg, ok := fpaiv.value.(proto.Message); ok {
			if proto.Equal(asProtoMsg, v.(proto.Message)) {
				return true
			}
		} else if reflect.DeepEqual(v, fpaiv.value) {
			return true
		}
	}
	return false
}

// Lifecycle_FieldPathArrayOfValues allows storing slice of values for Lifecycle fields according to their type
type Lifecycle_FieldPathArrayOfValues interface {
	gotenobject.FieldPathArrayOfValues
	Lifecycle_FieldPath
}

func ParseLifecycle_FieldPathArrayOfValues(pathStr, valuesStr string) (Lifecycle_FieldPathArrayOfValues, error) {
	fp, err := ParseLifecycle_FieldPath(pathStr)
	if err != nil {
		return nil, err
	}
	fpaov, err := gotenobject.ParseFieldPathArrayOfValues(fp, valuesStr)
	if err != nil {
		return nil, status.Errorf(codes.InvalidArgument, "error parsing Lifecycle field path array of values from %s: %v", valuesStr, err)
	}
	return fpaov.(Lifecycle_FieldPathArrayOfValues), nil
}

func MustParseLifecycle_FieldPathArrayOfValues(pathStr, valuesStr string) Lifecycle_FieldPathArrayOfValues {
	fpaov, err := ParseLifecycle_FieldPathArrayOfValues(pathStr, valuesStr)
	if err != nil {
		panic(err)
	}
	return fpaov
}

type Lifecycle_FieldTerminalPathArrayOfValues struct {
	Lifecycle_FieldTerminalPath
	values interface{}
}

var _ Lifecycle_FieldPathArrayOfValues = (*Lifecycle_FieldTerminalPathArrayOfValues)(nil)

func (fpaov *Lifecycle_FieldTerminalPathArrayOfValues) GetRawValues() (values []interface{}) {
	switch fpaov.selector {
	case Lifecycle_FieldPathSelectorState:
		for _, v := range fpaov.values.([]Lifecycle_State) {
			values = append(values, v)
		}
	case Lifecycle_FieldPathSelectorBlockDeletion:
		for _, v := range fpaov.values.([]bool) {
			values = append(values, v)
		}
	}
	return
}
func (fpaov *Lifecycle_FieldTerminalPathArrayOfValues) AsStateArrayOfValues() ([]Lifecycle_State, bool) {
	res, ok := fpaov.values.([]Lifecycle_State)
	return res, ok
}
func (fpaov *Lifecycle_FieldTerminalPathArrayOfValues) AsBlockDeletionArrayOfValues() ([]bool, bool) {
	res, ok := fpaov.values.([]bool)
	return res, ok
}
