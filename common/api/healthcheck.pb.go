// Code generated by protoc-gen-goten-go
// File: edgelq/common/api/healthcheck.proto
// DO NOT EDIT!!!

package api

import (
	"fmt"
	"reflect"
	"sync"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/runtime/protoimpl"
)

// proto imports
import (
	durationpb "google.golang.org/protobuf/types/known/durationpb"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = fmt.Errorf
	_ = reflect.Method{}
	_ = sync.Once{}

	_ = protojson.MarshalOptions{}
	_ = proto.MarshalOptions{}
	_ = preflect.Value{}
	_ = protoimpl.DescBuilder{}
)

// make sure we're using proto imports
var (
	_ = &durationpb.Duration{}
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// HealthCheck describes a health check to be performed in the context of a
// device or a container. Only the exec check can be truly executed inside a
// container. All the other checks are run on the host device.
// When run for device health check, host/IP address is mandatory for
// connectivity checks. For container health checks, host/IP is optional and
// would default to IP address of the container. It is important to note that a
// health check for https://endpoint.com/api defined for a container would be
// run from the host device and not from withthin the container
type HealthCheckSpec struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// http_get_check specifies the http request to perform.
	HttpGetCheck *HTTPGetCheck `protobuf:"bytes,1,opt,name=http_get_check,json=httpGetCheck,proto3" json:"http_get_check,omitempty" firestore:"httpGetCheck"`
	// tcp_check specifies an action involving a TCP port.
	TcpCheck *TCPCheck `protobuf:"bytes,2,opt,name=tcp_check,json=tcpCheck,proto3" json:"tcp_check,omitempty" firestore:"tcpCheck"`
	// icmp_check specifies an icmp health check
	IcmpCheck *ICMPCheck `protobuf:"bytes,3,opt,name=icmp_check,json=icmpCheck,proto3" json:"icmp_check,omitempty" firestore:"icmpCheck"`
	// GRPC specifies an action involving a GRPC port.
	// It is essential that the grpc server inplements this api
	// https://github.com/grpc/grpc/blob/master/doc/health-checking.md
	// If not, tcp_check should be used.
	GrpcCheck *GRPCCheck `protobuf:"bytes,4,opt,name=grpc_check,json=grpcCheck,proto3" json:"grpc_check,omitempty" firestore:"grpcCheck"`
	// Exec specifies the command to execute in the container to determine its
	// health
	Exec *ExecCheck `protobuf:"bytes,5,opt,name=exec,proto3" json:"exec,omitempty" firestore:"exec"`
	// device_file_check is only available for device.
	// It can be configured to ensure specific hardware is connected
	// (eg modem /dev/cdc-wdm0, RFID reader device /dev/ttyACM0 etc)
	DeviceFileCheck *DeviceFileCheck `protobuf:"bytes,6,opt,name=device_file_check,json=deviceFileCheck,proto3" json:"device_file_check,omitempty" firestore:"deviceFileCheck"`
	// Timeout for the HealthCheck.
	// Defaults to 1 second, greater than 5 seconds is not allowed
	Timeout *durationpb.Duration `protobuf:"bytes,7,opt,name=timeout,proto3" json:"timeout,omitempty" firestore:"timeout"`
	// Interval for health check, 60 seconds minimum interval
	Interval *durationpb.Duration `protobuf:"bytes,8,opt,name=interval,proto3" json:"interval,omitempty" firestore:"interval"`
	// name for the health check. A meaningful name for this might be useful as a
	// metrics label
	Name string `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty" firestore:"name"`
}

func (m *HealthCheckSpec) Reset() {
	*m = HealthCheckSpec{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *HealthCheckSpec) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*HealthCheckSpec) ProtoMessage() {}

func (m *HealthCheckSpec) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*HealthCheckSpec) GotenMessage() {}

// Deprecated, Use HealthCheckSpec.ProtoReflect.Descriptor instead.
func (*HealthCheckSpec) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{0}
}

func (m *HealthCheckSpec) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *HealthCheckSpec) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *HealthCheckSpec) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *HealthCheckSpec) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *HealthCheckSpec) GetHttpGetCheck() *HTTPGetCheck {
	if m != nil {
		return m.HttpGetCheck
	}
	return nil
}

func (m *HealthCheckSpec) GetTcpCheck() *TCPCheck {
	if m != nil {
		return m.TcpCheck
	}
	return nil
}

func (m *HealthCheckSpec) GetIcmpCheck() *ICMPCheck {
	if m != nil {
		return m.IcmpCheck
	}
	return nil
}

func (m *HealthCheckSpec) GetGrpcCheck() *GRPCCheck {
	if m != nil {
		return m.GrpcCheck
	}
	return nil
}

func (m *HealthCheckSpec) GetExec() *ExecCheck {
	if m != nil {
		return m.Exec
	}
	return nil
}

func (m *HealthCheckSpec) GetDeviceFileCheck() *DeviceFileCheck {
	if m != nil {
		return m.DeviceFileCheck
	}
	return nil
}

func (m *HealthCheckSpec) GetTimeout() *durationpb.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *HealthCheckSpec) GetInterval() *durationpb.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *HealthCheckSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HealthCheckSpec) SetHttpGetCheck(fv *HTTPGetCheck) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "HttpGetCheck", "HealthCheckSpec"))
	}
	m.HttpGetCheck = fv
}

func (m *HealthCheckSpec) SetTcpCheck(fv *TCPCheck) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "TcpCheck", "HealthCheckSpec"))
	}
	m.TcpCheck = fv
}

func (m *HealthCheckSpec) SetIcmpCheck(fv *ICMPCheck) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IcmpCheck", "HealthCheckSpec"))
	}
	m.IcmpCheck = fv
}

func (m *HealthCheckSpec) SetGrpcCheck(fv *GRPCCheck) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "GrpcCheck", "HealthCheckSpec"))
	}
	m.GrpcCheck = fv
}

func (m *HealthCheckSpec) SetExec(fv *ExecCheck) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Exec", "HealthCheckSpec"))
	}
	m.Exec = fv
}

func (m *HealthCheckSpec) SetDeviceFileCheck(fv *DeviceFileCheck) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "DeviceFileCheck", "HealthCheckSpec"))
	}
	m.DeviceFileCheck = fv
}

func (m *HealthCheckSpec) SetTimeout(fv *durationpb.Duration) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Timeout", "HealthCheckSpec"))
	}
	m.Timeout = fv
}

func (m *HealthCheckSpec) SetInterval(fv *durationpb.Duration) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Interval", "HealthCheckSpec"))
	}
	m.Interval = fv
}

func (m *HealthCheckSpec) SetName(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Name", "HealthCheckSpec"))
	}
	m.Name = fv
}

// HTTPGetCheck describes health check based on HTTP Get requests.
type HTTPGetCheck struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// http_url field has to be used when the IP to perform health check is a
	// container IP that cannot not be known beforehand,  In all other cases,
	// simple url string can be used
	// Although not explicitly declared as oneof, url and http_url is oneof type
	Url     string                `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty" firestore:"url"`
	HttpUrl *HTTPGetCheck_HTTPUrl `protobuf:"bytes,2,opt,name=http_url,json=httpUrl,proto3" json:"http_url,omitempty" firestore:"httpUrl"`
	// Custom headers to set in the request. HTTP allows repeated headers.
	// optional
	HttpHeaders  []*HTTPGetCheck_HTTPHeader `protobuf:"bytes,3,rep,name=httpHeaders,proto3" json:"httpHeaders,omitempty" firestore:"httpHeaders"`
	SkipTlsCheck bool                       `protobuf:"varint,4,opt,name=skip_tls_check,json=skipTlsCheck,proto3" json:"skip_tls_check,omitempty" firestore:"skipTlsCheck"`
	// optional. By default any response code >= 400 or response code == 300 are
	// considered as failure Sometimes, the health check might actually expect
	// 401/403/511 without proper authentication setting expected_response_code
	// will help to consider this as successful for health check
	ExpectedResponseCode int32 `protobuf:"varint,5,opt,name=expected_response_code,json=expectedResponseCode,proto3" json:"expected_response_code,omitempty" firestore:"expectedResponseCode"`
	// By default only Success or Failure metric will be generated.
	// This field can be used to enable response time metric and network metrics
	// if supported
	EnableDetailedMetrics bool `protobuf:"varint,6,opt,name=enable_detailed_metrics,json=enableDetailedMetrics,proto3" json:"enable_detailed_metrics,omitempty" firestore:"enableDetailedMetrics"`
}

func (m *HTTPGetCheck) Reset() {
	*m = HTTPGetCheck{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *HTTPGetCheck) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*HTTPGetCheck) ProtoMessage() {}

func (m *HTTPGetCheck) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*HTTPGetCheck) GotenMessage() {}

// Deprecated, Use HTTPGetCheck.ProtoReflect.Descriptor instead.
func (*HTTPGetCheck) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{1}
}

func (m *HTTPGetCheck) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *HTTPGetCheck) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *HTTPGetCheck) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *HTTPGetCheck) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *HTTPGetCheck) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *HTTPGetCheck) GetHttpUrl() *HTTPGetCheck_HTTPUrl {
	if m != nil {
		return m.HttpUrl
	}
	return nil
}

func (m *HTTPGetCheck) GetHttpHeaders() []*HTTPGetCheck_HTTPHeader {
	if m != nil {
		return m.HttpHeaders
	}
	return nil
}

func (m *HTTPGetCheck) GetSkipTlsCheck() bool {
	if m != nil {
		return m.SkipTlsCheck
	}
	return false
}

func (m *HTTPGetCheck) GetExpectedResponseCode() int32 {
	if m != nil {
		return m.ExpectedResponseCode
	}
	return int32(0)
}

func (m *HTTPGetCheck) GetEnableDetailedMetrics() bool {
	if m != nil {
		return m.EnableDetailedMetrics
	}
	return false
}

func (m *HTTPGetCheck) SetUrl(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Url", "HTTPGetCheck"))
	}
	m.Url = fv
}

func (m *HTTPGetCheck) SetHttpUrl(fv *HTTPGetCheck_HTTPUrl) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "HttpUrl", "HTTPGetCheck"))
	}
	m.HttpUrl = fv
}

func (m *HTTPGetCheck) SetHttpHeaders(fv []*HTTPGetCheck_HTTPHeader) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "HttpHeaders", "HTTPGetCheck"))
	}
	m.HttpHeaders = fv
}

func (m *HTTPGetCheck) SetSkipTlsCheck(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "SkipTlsCheck", "HTTPGetCheck"))
	}
	m.SkipTlsCheck = fv
}

func (m *HTTPGetCheck) SetExpectedResponseCode(fv int32) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "ExpectedResponseCode", "HTTPGetCheck"))
	}
	m.ExpectedResponseCode = fv
}

func (m *HTTPGetCheck) SetEnableDetailedMetrics(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "EnableDetailedMetrics", "HTTPGetCheck"))
	}
	m.EnableDetailedMetrics = fv
}

type ICMPCheck struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// domain name or IP Addres to perform ICMP check
	Host string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty" firestore:"host"`
	// By default only Success or Failure metric will be generated.
	// This field can be used to enable network metrics such as latency/jitter
	EnableDetailedMetrics bool `protobuf:"varint,2,opt,name=enable_detailed_metrics,json=enableDetailedMetrics,proto3" json:"enable_detailed_metrics,omitempty" firestore:"enableDetailedMetrics"`
}

func (m *ICMPCheck) Reset() {
	*m = ICMPCheck{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *ICMPCheck) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*ICMPCheck) ProtoMessage() {}

func (m *ICMPCheck) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*ICMPCheck) GotenMessage() {}

// Deprecated, Use ICMPCheck.ProtoReflect.Descriptor instead.
func (*ICMPCheck) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{2}
}

func (m *ICMPCheck) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *ICMPCheck) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *ICMPCheck) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *ICMPCheck) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *ICMPCheck) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *ICMPCheck) GetEnableDetailedMetrics() bool {
	if m != nil {
		return m.EnableDetailedMetrics
	}
	return false
}

func (m *ICMPCheck) SetHost(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Host", "ICMPCheck"))
	}
	m.Host = fv
}

func (m *ICMPCheck) SetEnableDetailedMetrics(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "EnableDetailedMetrics", "ICMPCheck"))
	}
	m.EnableDetailedMetrics = fv
}

// TCPCheck performs a TCP connect check.
// Only TCP handshake is performed. No data is sent
type TCPCheck struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// Port number to access on the container or given destination.
	// Number must be in the range 1 to 65535.
	Port int32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty" firestore:"port"`
	// Host name to connect to.
	// For containers this defaults to the container IP or wan interface IP in
	// host mode networking For device, this is a mandatory parameter
	Host string `protobuf:"bytes,2,opt,name=host,proto3" json:"host,omitempty" firestore:"host"`
}

func (m *TCPCheck) Reset() {
	*m = TCPCheck{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *TCPCheck) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*TCPCheck) ProtoMessage() {}

func (m *TCPCheck) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*TCPCheck) GotenMessage() {}

// Deprecated, Use TCPCheck.ProtoReflect.Descriptor instead.
func (*TCPCheck) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{3}
}

func (m *TCPCheck) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *TCPCheck) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *TCPCheck) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *TCPCheck) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *TCPCheck) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return int32(0)
}

func (m *TCPCheck) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *TCPCheck) SetPort(fv int32) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Port", "TCPCheck"))
	}
	m.Port = fv
}

func (m *TCPCheck) SetHost(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Host", "TCPCheck"))
	}
	m.Host = fv
}

type GRPCCheck struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// Port number of the gRPC service. Number must be in the range 1 to
	// 65535.
	Port int32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty" firestore:"port"`
	// Service is the name of the service to place in the gRPC
	// HealthCheckRequest (see
	// https://github.com/grpc/grpc/blob/master/doc/health-checking.md).
	//
	// If this is not specified, the default behavior is defined by gRPC.
	Service string `protobuf:"bytes,2,opt,name=service,proto3" json:"service,omitempty" firestore:"service"`
	// Host name to connect to.
	// For containers this defaults to the container IP or wan interface IP in
	// host mode networking For device, this is a mandatory parameter
	Host         string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty" firestore:"host"`
	SkipTlsCheck bool   `protobuf:"varint,4,opt,name=skip_tls_check,json=skipTlsCheck,proto3" json:"skip_tls_check,omitempty" firestore:"skipTlsCheck"`
}

func (m *GRPCCheck) Reset() {
	*m = GRPCCheck{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *GRPCCheck) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*GRPCCheck) ProtoMessage() {}

func (m *GRPCCheck) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*GRPCCheck) GotenMessage() {}

// Deprecated, Use GRPCCheck.ProtoReflect.Descriptor instead.
func (*GRPCCheck) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{4}
}

func (m *GRPCCheck) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *GRPCCheck) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *GRPCCheck) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *GRPCCheck) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *GRPCCheck) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return int32(0)
}

func (m *GRPCCheck) GetService() string {
	if m != nil {
		return m.Service
	}
	return ""
}

func (m *GRPCCheck) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *GRPCCheck) GetSkipTlsCheck() bool {
	if m != nil {
		return m.SkipTlsCheck
	}
	return false
}

func (m *GRPCCheck) SetPort(fv int32) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Port", "GRPCCheck"))
	}
	m.Port = fv
}

func (m *GRPCCheck) SetService(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Service", "GRPCCheck"))
	}
	m.Service = fv
}

func (m *GRPCCheck) SetHost(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Host", "GRPCCheck"))
	}
	m.Host = fv
}

func (m *GRPCCheck) SetSkipTlsCheck(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "SkipTlsCheck", "GRPCCheck"))
	}
	m.SkipTlsCheck = fv
}

// ExecCheck describes a "run in container" action.
type ExecCheck struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// Command is the command line to execute inside the container, the
	// working directory for the command  is root ('/') in the container's
	// filesystem. The command is simply exec'd, it is not run inside a shell,
	// so traditional shell instructions ('|', etc) won't work. To use a
	// shell, you need to explicitly call out to that shell. Exit status of 0
	// is treated as live/healthy and non-zero is unhealthy.
	Command []string `protobuf:"bytes,1,rep,name=command,proto3" json:"command,omitempty" firestore:"command"`
}

func (m *ExecCheck) Reset() {
	*m = ExecCheck{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *ExecCheck) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*ExecCheck) ProtoMessage() {}

func (m *ExecCheck) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*ExecCheck) GotenMessage() {}

// Deprecated, Use ExecCheck.ProtoReflect.Descriptor instead.
func (*ExecCheck) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{5}
}

func (m *ExecCheck) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *ExecCheck) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *ExecCheck) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *ExecCheck) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *ExecCheck) GetCommand() []string {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ExecCheck) SetCommand(fv []string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Command", "ExecCheck"))
	}
	m.Command = fv
}

type DeviceFileCheck struct {
	state          protoimpl.MessageState
	sizeCache      protoimpl.SizeCache
	unknownFields  protoimpl.UnknownFields
	FileType       *DeviceFileCheck_FileTypeOneOf `protobuf:"bytes,1,opt,name=file_type,json=fileType,proto3" json:"file_type,omitempty" firestore:"fileType"`
	DeviceFileName string                         `protobuf:"bytes,2,opt,name=device_file_name,json=deviceFileName,proto3" json:"device_file_name,omitempty" firestore:"deviceFileName"`
}

func (m *DeviceFileCheck) Reset() {
	*m = DeviceFileCheck{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[6]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *DeviceFileCheck) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*DeviceFileCheck) ProtoMessage() {}

func (m *DeviceFileCheck) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[6]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*DeviceFileCheck) GotenMessage() {}

// Deprecated, Use DeviceFileCheck.ProtoReflect.Descriptor instead.
func (*DeviceFileCheck) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{6}
}

func (m *DeviceFileCheck) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *DeviceFileCheck) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *DeviceFileCheck) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *DeviceFileCheck) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *DeviceFileCheck) GetFileType() *DeviceFileCheck_FileTypeOneOf {
	if m != nil {
		return m.FileType
	}
	return nil
}

func (m *DeviceFileCheck) GetDeviceFileName() string {
	if m != nil {
		return m.DeviceFileName
	}
	return ""
}

func (m *DeviceFileCheck) SetFileType(fv *DeviceFileCheck_FileTypeOneOf) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "FileType", "DeviceFileCheck"))
	}
	m.FileType = fv
}

func (m *DeviceFileCheck) SetDeviceFileName(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "DeviceFileName", "DeviceFileCheck"))
	}
	m.DeviceFileName = fv
}

type HTTPGetCheck_HTTPUrl struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// Path to access on the HTTP server, defaults to /
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty" firestore:"path"`
	// port to access on the container. defaults to 80 for http and 443 for
	// https Number must be in the range 1 to 65535.
	Port int32 `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty" firestore:"port"`
	// Host name to connect to.
	// For containers this defaults to the container IP or wan interface IP in
	// host mode networking For device, this is a mandatory parameter
	Host string `protobuf:"bytes,3,opt,name=host,proto3" json:"host,omitempty" firestore:"host"`
	// Scheme to use for connecting to the host.
	// optional, defaults to HTTP.
	Scheme string `protobuf:"bytes,4,opt,name=scheme,proto3" json:"scheme,omitempty" firestore:"scheme"`
}

func (m *HTTPGetCheck_HTTPUrl) Reset() {
	*m = HTTPGetCheck_HTTPUrl{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[7]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *HTTPGetCheck_HTTPUrl) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*HTTPGetCheck_HTTPUrl) ProtoMessage() {}

func (m *HTTPGetCheck_HTTPUrl) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[7]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*HTTPGetCheck_HTTPUrl) GotenMessage() {}

// Deprecated, Use HTTPGetCheck_HTTPUrl.ProtoReflect.Descriptor instead.
func (*HTTPGetCheck_HTTPUrl) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{1, 0}
}

func (m *HTTPGetCheck_HTTPUrl) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *HTTPGetCheck_HTTPUrl) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *HTTPGetCheck_HTTPUrl) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *HTTPGetCheck_HTTPUrl) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *HTTPGetCheck_HTTPUrl) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *HTTPGetCheck_HTTPUrl) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return int32(0)
}

func (m *HTTPGetCheck_HTTPUrl) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *HTTPGetCheck_HTTPUrl) GetScheme() string {
	if m != nil {
		return m.Scheme
	}
	return ""
}

func (m *HTTPGetCheck_HTTPUrl) SetPath(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Path", "HTTPGetCheck_HTTPUrl"))
	}
	m.Path = fv
}

func (m *HTTPGetCheck_HTTPUrl) SetPort(fv int32) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Port", "HTTPGetCheck_HTTPUrl"))
	}
	m.Port = fv
}

func (m *HTTPGetCheck_HTTPUrl) SetHost(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Host", "HTTPGetCheck_HTTPUrl"))
	}
	m.Host = fv
}

func (m *HTTPGetCheck_HTTPUrl) SetScheme(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Scheme", "HTTPGetCheck_HTTPUrl"))
	}
	m.Scheme = fv
}

// HTTPHeader describes a custom header to be used in HTTP HealthChecks
type HTTPGetCheck_HTTPHeader struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// The header field name.
	// This will be canonicalized upon output, so case-variant names will be
	// understood as the same header.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" firestore:"name"`
	// The header field value
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty" firestore:"value"`
}

func (m *HTTPGetCheck_HTTPHeader) Reset() {
	*m = HTTPGetCheck_HTTPHeader{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[8]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *HTTPGetCheck_HTTPHeader) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*HTTPGetCheck_HTTPHeader) ProtoMessage() {}

func (m *HTTPGetCheck_HTTPHeader) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[8]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*HTTPGetCheck_HTTPHeader) GotenMessage() {}

// Deprecated, Use HTTPGetCheck_HTTPHeader.ProtoReflect.Descriptor instead.
func (*HTTPGetCheck_HTTPHeader) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{1, 1}
}

func (m *HTTPGetCheck_HTTPHeader) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *HTTPGetCheck_HTTPHeader) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *HTTPGetCheck_HTTPHeader) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *HTTPGetCheck_HTTPHeader) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *HTTPGetCheck_HTTPHeader) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *HTTPGetCheck_HTTPHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *HTTPGetCheck_HTTPHeader) SetName(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Name", "HTTPGetCheck_HTTPHeader"))
	}
	m.Name = fv
}

func (m *HTTPGetCheck_HTTPHeader) SetValue(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Value", "HTTPGetCheck_HTTPHeader"))
	}
	m.Value = fv
}

type DeviceFileCheck_FileTypeOneOf struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	IsDirectory   bool `protobuf:"varint,1,opt,name=is_directory,json=isDirectory,proto3" json:"is_directory,omitempty" firestore:"isDirectory"`
	IsBlockDevice bool `protobuf:"varint,2,opt,name=is_block_device,json=isBlockDevice,proto3" json:"is_block_device,omitempty" firestore:"isBlockDevice"`
	IsCharDevice  bool `protobuf:"varint,3,opt,name=is_char_device,json=isCharDevice,proto3" json:"is_char_device,omitempty" firestore:"isCharDevice"`
	IsFifo        bool `protobuf:"varint,4,opt,name=is_fifo,json=isFifo,proto3" json:"is_fifo,omitempty" firestore:"isFifo"`
	IsRegularFile bool `protobuf:"varint,5,opt,name=is_regular_file,json=isRegularFile,proto3" json:"is_regular_file,omitempty" firestore:"isRegularFile"`
}

func (m *DeviceFileCheck_FileTypeOneOf) Reset() {
	*m = DeviceFileCheck_FileTypeOneOf{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_healthcheck_proto_msgTypes[9]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *DeviceFileCheck_FileTypeOneOf) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*DeviceFileCheck_FileTypeOneOf) ProtoMessage() {}

func (m *DeviceFileCheck_FileTypeOneOf) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_healthcheck_proto_msgTypes[9]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*DeviceFileCheck_FileTypeOneOf) GotenMessage() {}

// Deprecated, Use DeviceFileCheck_FileTypeOneOf.ProtoReflect.Descriptor instead.
func (*DeviceFileCheck_FileTypeOneOf) Descriptor() ([]byte, []int) {
	return edgelq_common_api_healthcheck_proto_rawDescGZIP(), []int{6, 0}
}

func (m *DeviceFileCheck_FileTypeOneOf) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *DeviceFileCheck_FileTypeOneOf) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *DeviceFileCheck_FileTypeOneOf) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *DeviceFileCheck_FileTypeOneOf) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *DeviceFileCheck_FileTypeOneOf) GetIsDirectory() bool {
	if m != nil {
		return m.IsDirectory
	}
	return false
}

func (m *DeviceFileCheck_FileTypeOneOf) GetIsBlockDevice() bool {
	if m != nil {
		return m.IsBlockDevice
	}
	return false
}

func (m *DeviceFileCheck_FileTypeOneOf) GetIsCharDevice() bool {
	if m != nil {
		return m.IsCharDevice
	}
	return false
}

func (m *DeviceFileCheck_FileTypeOneOf) GetIsFifo() bool {
	if m != nil {
		return m.IsFifo
	}
	return false
}

func (m *DeviceFileCheck_FileTypeOneOf) GetIsRegularFile() bool {
	if m != nil {
		return m.IsRegularFile
	}
	return false
}

func (m *DeviceFileCheck_FileTypeOneOf) SetIsDirectory(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IsDirectory", "DeviceFileCheck_FileTypeOneOf"))
	}
	m.IsDirectory = fv
}

func (m *DeviceFileCheck_FileTypeOneOf) SetIsBlockDevice(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IsBlockDevice", "DeviceFileCheck_FileTypeOneOf"))
	}
	m.IsBlockDevice = fv
}

func (m *DeviceFileCheck_FileTypeOneOf) SetIsCharDevice(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IsCharDevice", "DeviceFileCheck_FileTypeOneOf"))
	}
	m.IsCharDevice = fv
}

func (m *DeviceFileCheck_FileTypeOneOf) SetIsFifo(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IsFifo", "DeviceFileCheck_FileTypeOneOf"))
	}
	m.IsFifo = fv
}

func (m *DeviceFileCheck_FileTypeOneOf) SetIsRegularFile(fv bool) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IsRegularFile", "DeviceFileCheck_FileTypeOneOf"))
	}
	m.IsRegularFile = fv
}

var edgelq_common_api_healthcheck_proto preflect.FileDescriptor

var edgelq_common_api_healthcheck_proto_rawDesc = []byte{
	0x0a, 0x23, 0x65, 0x64, 0x67, 0x65, 0x6c, 0x71, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f,
	0x61, 0x70, 0x69, 0x2f, 0x68, 0x65, 0x61, 0x6c, 0x74, 0x68, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x1a, 0x1e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2f,
	0x64, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x1d,
	0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x2f, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x20, 0x67,
	0x6f, 0x74, 0x65, 0x6e, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x2f, 0x76, 0x61, 0x6c, 0x69, 0x64, 0x61, 0x74, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a,
	0x24, 0x65, 0x64, 0x67, 0x65, 0x6c, 0x71, 0x2f, 0x61, 0x75, 0x64, 0x69, 0x74, 0x2f, 0x61, 0x6e,
	0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x61, 0x75, 0x64, 0x69, 0x74, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x22, 0xea, 0x03, 0x0a, 0x0f, 0x48, 0x65, 0x61, 0x6c, 0x74, 0x68,
	0x43, 0x68, 0x65, 0x63, 0x6b, 0x53, 0x70, 0x65, 0x63, 0x12, 0x3b, 0x0a, 0x0e, 0x68, 0x74, 0x74,
	0x70, 0x5f, 0x67, 0x65, 0x74, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x0b, 0x32, 0x15, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x48, 0x54, 0x54, 0x50,
	0x47, 0x65, 0x74, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x0c, 0x68, 0x74, 0x74, 0x70, 0x47, 0x65,
	0x74, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x2e, 0x0a, 0x09, 0x74, 0x63, 0x70, 0x5f, 0x63, 0x68,
	0x65, 0x63, 0x6b, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x11, 0x2e, 0x6e, 0x74, 0x74, 0x2e,
	0x61, 0x70, 0x69, 0x2e, 0x54, 0x43, 0x50, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x08, 0x74, 0x63,
	0x70, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x31, 0x0a, 0x0a, 0x69, 0x63, 0x6d, 0x70, 0x5f, 0x63,
	0x68, 0x65, 0x63, 0x6b, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6e, 0x74, 0x74,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x49, 0x43, 0x4d, 0x50, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x09,
	0x69, 0x63, 0x6d, 0x70, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x31, 0x0a, 0x0a, 0x67, 0x72, 0x70,
	0x63, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e,
	0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x47, 0x52, 0x50, 0x43, 0x43, 0x68, 0x65, 0x63,
	0x6b, 0x52, 0x09, 0x67, 0x72, 0x70, 0x63, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x26, 0x0a, 0x04,
	0x65, 0x78, 0x65, 0x63, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x12, 0x2e, 0x6e, 0x74, 0x74,
	0x2e, 0x61, 0x70, 0x69, 0x2e, 0x45, 0x78, 0x65, 0x63, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x04,
	0x65, 0x78, 0x65, 0x63, 0x12, 0x44, 0x0a, 0x11, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x66,
	0x69, 0x6c, 0x65, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x18, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
	0x46, 0x69, 0x6c, 0x65, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x52, 0x0f, 0x64, 0x65, 0x76, 0x69, 0x63,
	0x65, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x3f, 0x0a, 0x07, 0x74, 0x69,
	0x6d, 0x65, 0x6f, 0x75, 0x74, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e, 0x67, 0x6f,
	0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e, 0x44, 0x75,
	0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x0a, 0xca, 0xc6, 0x27, 0x06, 0x5a, 0x04, 0x22, 0x02,
	0x08, 0x05, 0x52, 0x07, 0x74, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x12, 0x41, 0x0a, 0x08, 0x69,
	0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x19, 0x2e,
	0x67, 0x6f, 0x6f, 0x67, 0x6c, 0x65, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x62, 0x75, 0x66, 0x2e,
	0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x0a, 0xca, 0xc6, 0x27, 0x06, 0x5a, 0x04,
	0x32, 0x02, 0x08, 0x3c, 0x52, 0x08, 0x69, 0x6e, 0x74, 0x65, 0x72, 0x76, 0x61, 0x6c, 0x12, 0x12,
	0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x09, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x6e, 0x61,
	0x6d, 0x65, 0x22, 0xc9, 0x03, 0x0a, 0x0c, 0x48, 0x54, 0x54, 0x50, 0x47, 0x65, 0x74, 0x43, 0x68,
	0x65, 0x63, 0x6b, 0x12, 0x10, 0x0a, 0x03, 0x75, 0x72, 0x6c, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x03, 0x75, 0x72, 0x6c, 0x12, 0x38, 0x0a, 0x08, 0x68, 0x74, 0x74, 0x70, 0x5f, 0x75, 0x72,
	0x6c, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x1d, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x48, 0x54, 0x54, 0x50, 0x47, 0x65, 0x74, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x2e, 0x48,
	0x54, 0x54, 0x50, 0x55, 0x72, 0x6c, 0x52, 0x07, 0x68, 0x74, 0x74, 0x70, 0x55, 0x72, 0x6c, 0x12,
	0x42, 0x0a, 0x0b, 0x68, 0x74, 0x74, 0x70, 0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x73, 0x18, 0x03,
	0x20, 0x03, 0x28, 0x0b, 0x32, 0x20, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x48,
	0x54, 0x54, 0x50, 0x47, 0x65, 0x74, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x2e, 0x48, 0x54, 0x54, 0x50,
	0x48, 0x65, 0x61, 0x64, 0x65, 0x72, 0x52, 0x0b, 0x68, 0x74, 0x74, 0x70, 0x48, 0x65, 0x61, 0x64,
	0x65, 0x72, 0x73, 0x12, 0x24, 0x0a, 0x0e, 0x73, 0x6b, 0x69, 0x70, 0x5f, 0x74, 0x6c, 0x73, 0x5f,
	0x63, 0x68, 0x65, 0x63, 0x6b, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0c, 0x73, 0x6b, 0x69,
	0x70, 0x54, 0x6c, 0x73, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x34, 0x0a, 0x16, 0x65, 0x78, 0x70,
	0x65, 0x63, 0x74, 0x65, 0x64, 0x5f, 0x72, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x5f, 0x63,
	0x6f, 0x64, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x05, 0x52, 0x14, 0x65, 0x78, 0x70, 0x65, 0x63,
	0x74, 0x65, 0x64, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x43, 0x6f, 0x64, 0x65, 0x12,
	0x36, 0x0a, 0x17, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c,
	0x65, 0x64, 0x5f, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x06, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x15, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x65, 0x64,
	0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x1a, 0x5d, 0x0a, 0x07, 0x48, 0x54, 0x54, 0x50, 0x55,
	0x72, 0x6c, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x61, 0x74, 0x68, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09,
	0x52, 0x04, 0x70, 0x61, 0x74, 0x68, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x02,
	0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x6f,
	0x73, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x12, 0x16,
	0x0a, 0x06, 0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x18, 0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x06,
	0x73, 0x63, 0x68, 0x65, 0x6d, 0x65, 0x1a, 0x36, 0x0a, 0x0a, 0x48, 0x54, 0x54, 0x50, 0x48, 0x65,
	0x61, 0x64, 0x65, 0x72, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x12, 0x14, 0x0a, 0x05, 0x76, 0x61, 0x6c, 0x75,
	0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x22, 0x57,
	0x0a, 0x09, 0x49, 0x43, 0x4d, 0x50, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x12, 0x0a, 0x04, 0x68,
	0x6f, 0x73, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x12,
	0x36, 0x0a, 0x17, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x64, 0x65, 0x74, 0x61, 0x69, 0x6c,
	0x65, 0x64, 0x5f, 0x6d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08,
	0x52, 0x15, 0x65, 0x6e, 0x61, 0x62, 0x6c, 0x65, 0x44, 0x65, 0x74, 0x61, 0x69, 0x6c, 0x65, 0x64,
	0x4d, 0x65, 0x74, 0x72, 0x69, 0x63, 0x73, 0x22, 0x32, 0x0a, 0x08, 0x54, 0x43, 0x50, 0x43, 0x68,
	0x65, 0x63, 0x6b, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28,
	0x05, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x22, 0x73, 0x0a, 0x09, 0x47,
	0x52, 0x50, 0x43, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x12, 0x0a, 0x04, 0x70, 0x6f, 0x72, 0x74,
	0x18, 0x01, 0x20, 0x01, 0x28, 0x05, 0x52, 0x04, 0x70, 0x6f, 0x72, 0x74, 0x12, 0x18, 0x0a, 0x07,
	0x73, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x73,
	0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x12, 0x12, 0x0a, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x18, 0x03,
	0x20, 0x01, 0x28, 0x09, 0x52, 0x04, 0x68, 0x6f, 0x73, 0x74, 0x12, 0x24, 0x0a, 0x0e, 0x73, 0x6b,
	0x69, 0x70, 0x5f, 0x74, 0x6c, 0x73, 0x5f, 0x63, 0x68, 0x65, 0x63, 0x6b, 0x18, 0x04, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x0c, 0x73, 0x6b, 0x69, 0x70, 0x54, 0x6c, 0x73, 0x43, 0x68, 0x65, 0x63, 0x6b,
	0x22, 0x25, 0x0a, 0x09, 0x45, 0x78, 0x65, 0x63, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x18, 0x0a,
	0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x18, 0x01, 0x20, 0x03, 0x28, 0x09, 0x52, 0x07,
	0x63, 0x6f, 0x6d, 0x6d, 0x61, 0x6e, 0x64, 0x22, 0xc4, 0x02, 0x0a, 0x0f, 0x44, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x12, 0x43, 0x0a, 0x09, 0x66,
	0x69, 0x6c, 0x65, 0x5f, 0x74, 0x79, 0x70, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0b, 0x32, 0x26,
	0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x46,
	0x69, 0x6c, 0x65, 0x43, 0x68, 0x65, 0x63, 0x6b, 0x2e, 0x46, 0x69, 0x6c, 0x65, 0x54, 0x79, 0x70,
	0x65, 0x4f, 0x6e, 0x65, 0x4f, 0x66, 0x52, 0x08, 0x66, 0x69, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65,
	0x12, 0x28, 0x0a, 0x10, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x5f,
	0x6e, 0x61, 0x6d, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x64, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x4e, 0x61, 0x6d, 0x65, 0x1a, 0xc1, 0x01, 0x0a, 0x0d, 0x46,
	0x69, 0x6c, 0x65, 0x54, 0x79, 0x70, 0x65, 0x4f, 0x6e, 0x65, 0x4f, 0x66, 0x12, 0x21, 0x0a, 0x0c,
	0x69, 0x73, 0x5f, 0x64, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x08, 0x52, 0x0b, 0x69, 0x73, 0x44, 0x69, 0x72, 0x65, 0x63, 0x74, 0x6f, 0x72, 0x79, 0x12,
	0x26, 0x0a, 0x0f, 0x69, 0x73, 0x5f, 0x62, 0x6c, 0x6f, 0x63, 0x6b, 0x5f, 0x64, 0x65, 0x76, 0x69,
	0x63, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x08, 0x52, 0x0d, 0x69, 0x73, 0x42, 0x6c, 0x6f, 0x63,
	0x6b, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x12, 0x24, 0x0a, 0x0e, 0x69, 0x73, 0x5f, 0x63, 0x68,
	0x61, 0x72, 0x5f, 0x64, 0x65, 0x76, 0x69, 0x63, 0x65, 0x18, 0x03, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0c, 0x69, 0x73, 0x43, 0x68, 0x61, 0x72, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x12, 0x17, 0x0a,
	0x07, 0x69, 0x73, 0x5f, 0x66, 0x69, 0x66, 0x6f, 0x18, 0x04, 0x20, 0x01, 0x28, 0x08, 0x52, 0x06,
	0x69, 0x73, 0x46, 0x69, 0x66, 0x6f, 0x12, 0x26, 0x0a, 0x0f, 0x69, 0x73, 0x5f, 0x72, 0x65, 0x67,
	0x75, 0x6c, 0x61, 0x72, 0x5f, 0x66, 0x69, 0x6c, 0x65, 0x18, 0x05, 0x20, 0x01, 0x28, 0x08, 0x52,
	0x0d, 0x69, 0x73, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x72, 0x46, 0x69, 0x6c, 0x65, 0x42, 0x3d,
	0x0a, 0x0e, 0x63, 0x6f, 0x6d, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x70, 0x62,
	0x50, 0x01, 0x5a, 0x29, 0x67, 0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63,
	0x6c, 0x6f, 0x75, 0x64, 0x77, 0x61, 0x6e, 0x2f, 0x65, 0x64, 0x67, 0x65, 0x6c, 0x71, 0x2f, 0x63,
	0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f, 0x61, 0x70, 0x69, 0x3b, 0x61, 0x70, 0x69, 0x62, 0x06, 0x70,
	0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	edgelq_common_api_healthcheck_proto_rawDescOnce sync.Once
	edgelq_common_api_healthcheck_proto_rawDescData = edgelq_common_api_healthcheck_proto_rawDesc
)

func edgelq_common_api_healthcheck_proto_rawDescGZIP() []byte {
	edgelq_common_api_healthcheck_proto_rawDescOnce.Do(func() {
		edgelq_common_api_healthcheck_proto_rawDescData = protoimpl.X.CompressGZIP(edgelq_common_api_healthcheck_proto_rawDescData)
	})
	return edgelq_common_api_healthcheck_proto_rawDescData
}

var edgelq_common_api_healthcheck_proto_msgTypes = make([]protoimpl.MessageInfo, 10)
var edgelq_common_api_healthcheck_proto_goTypes = []interface{}{
	(*HealthCheckSpec)(nil),               // 0: ntt.api.HealthCheckSpec
	(*HTTPGetCheck)(nil),                  // 1: ntt.api.HTTPGetCheck
	(*ICMPCheck)(nil),                     // 2: ntt.api.ICMPCheck
	(*TCPCheck)(nil),                      // 3: ntt.api.TCPCheck
	(*GRPCCheck)(nil),                     // 4: ntt.api.GRPCCheck
	(*ExecCheck)(nil),                     // 5: ntt.api.ExecCheck
	(*DeviceFileCheck)(nil),               // 6: ntt.api.DeviceFileCheck
	(*HTTPGetCheck_HTTPUrl)(nil),          // 7: ntt.api.HTTPGetCheck.HTTPUrl
	(*HTTPGetCheck_HTTPHeader)(nil),       // 8: ntt.api.HTTPGetCheck.HTTPHeader
	(*DeviceFileCheck_FileTypeOneOf)(nil), // 9: ntt.api.DeviceFileCheck.FileTypeOneOf
	(*durationpb.Duration)(nil),           // 10: google.protobuf.Duration
}
var edgelq_common_api_healthcheck_proto_depIdxs = []int32{
	1,  // 0: ntt.api.HealthCheckSpec.http_get_check:type_name -> ntt.api.HTTPGetCheck
	3,  // 1: ntt.api.HealthCheckSpec.tcp_check:type_name -> ntt.api.TCPCheck
	2,  // 2: ntt.api.HealthCheckSpec.icmp_check:type_name -> ntt.api.ICMPCheck
	4,  // 3: ntt.api.HealthCheckSpec.grpc_check:type_name -> ntt.api.GRPCCheck
	5,  // 4: ntt.api.HealthCheckSpec.exec:type_name -> ntt.api.ExecCheck
	6,  // 5: ntt.api.HealthCheckSpec.device_file_check:type_name -> ntt.api.DeviceFileCheck
	10, // 6: ntt.api.HealthCheckSpec.timeout:type_name -> google.protobuf.Duration
	10, // 7: ntt.api.HealthCheckSpec.interval:type_name -> google.protobuf.Duration
	7,  // 8: ntt.api.HTTPGetCheck.http_url:type_name -> ntt.api.HTTPGetCheck.HTTPUrl
	8,  // 9: ntt.api.HTTPGetCheck.httpHeaders:type_name -> ntt.api.HTTPGetCheck.HTTPHeader
	9,  // 10: ntt.api.DeviceFileCheck.file_type:type_name -> ntt.api.DeviceFileCheck.FileTypeOneOf
	11, // [11:11] is the sub-list for method output_type
	11, // [11:11] is the sub-list for method input_type
	11, // [11:11] is the sub-list for extension type_name
	11, // [11:11] is the sub-list for extension extendee
	0,  // [0:11] is the sub-list for field type_name
}

func init() { edgelq_common_api_healthcheck_proto_init() }
func edgelq_common_api_healthcheck_proto_init() {
	if edgelq_common_api_healthcheck_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {

		edgelq_common_api_healthcheck_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HealthCheckSpec); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HTTPGetCheck); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ICMPCheck); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*TCPCheck); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*GRPCCheck); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*ExecCheck); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[6].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeviceFileCheck); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[7].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HTTPGetCheck_HTTPUrl); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[8].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*HTTPGetCheck_HTTPHeader); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_healthcheck_proto_msgTypes[9].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeviceFileCheck_FileTypeOneOf); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}

	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: edgelq_common_api_healthcheck_proto_rawDesc,
			NumEnums:      0,
			NumMessages:   10,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           edgelq_common_api_healthcheck_proto_goTypes,
		DependencyIndexes: edgelq_common_api_healthcheck_proto_depIdxs,
		MessageInfos:      edgelq_common_api_healthcheck_proto_msgTypes,
	}.Build()
	edgelq_common_api_healthcheck_proto = out.File
	edgelq_common_api_healthcheck_proto_rawDesc = nil
	edgelq_common_api_healthcheck_proto_goTypes = nil
	edgelq_common_api_healthcheck_proto_depIdxs = nil
}
