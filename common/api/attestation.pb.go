// Code generated by protoc-gen-goten-go
// File: edgelq/common/api/attestation.proto
// DO NOT EDIT!!!

package api

import (
	"fmt"
	"reflect"
	"sync"

	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/runtime/protoimpl"
)

// proto imports
import ()

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = fmt.Errorf
	_ = reflect.Method{}
	_ = sync.Once{}

	_ = protojson.MarshalOptions{}
	_ = proto.MarshalOptions{}
	_ = preflect.Value{}
	_ = protoimpl.DescBuilder{}
)

// make sure we're using proto imports
var ()

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type TpmVersion int32

const (
	TpmVersion_TPMVAGNOSTIC TpmVersion = 0
	TpmVersion_TPMV12       TpmVersion = 1
	TpmVersion_TPMV20       TpmVersion = 2
)

var (
	TpmVersion_name = map[int32]string{
		0: "TPMVAGNOSTIC",
		1: "TPMV12",
		2: "TPMV20",
	}

	TpmVersion_value = map[string]int32{
		"TPMVAGNOSTIC": 0,
		"TPMV12":       1,
		"TPMV20":       2,
	}
)

func (x TpmVersion) Enum() *TpmVersion {
	p := new(TpmVersion)
	*p = x
	return p
}

func (x TpmVersion) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), preflect.EnumNumber(x))
}

func (TpmVersion) Descriptor() preflect.EnumDescriptor {
	return edgelq_common_api_attestation_proto_enumTypes[0].Descriptor()
}

func (TpmVersion) Type() preflect.EnumType {
	return &edgelq_common_api_attestation_proto_enumTypes[0]
}

func (x TpmVersion) Number() preflect.EnumNumber {
	return preflect.EnumNumber(x)
}

// Deprecated, Use TpmVersion.ProtoReflect.Descriptor instead.
func (TpmVersion) EnumDescriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{0}
}

type DigestAlg int32

const (
	DigestAlg_SHA1   DigestAlg = 0
	DigestAlg_SHA256 DigestAlg = 1
)

var (
	DigestAlg_name = map[int32]string{
		0: "SHA1",
		1: "SHA256",
	}

	DigestAlg_value = map[string]int32{
		"SHA1":   0,
		"SHA256": 1,
	}
)

func (x DigestAlg) Enum() *DigestAlg {
	p := new(DigestAlg)
	*p = x
	return p
}

func (x DigestAlg) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), preflect.EnumNumber(x))
}

func (DigestAlg) Descriptor() preflect.EnumDescriptor {
	return edgelq_common_api_attestation_proto_enumTypes[1].Descriptor()
}

func (DigestAlg) Type() preflect.EnumType {
	return &edgelq_common_api_attestation_proto_enumTypes[1]
}

func (x DigestAlg) Number() preflect.EnumNumber {
	return preflect.EnumNumber(x)
}

// Deprecated, Use DigestAlg.ProtoReflect.Descriptor instead.
func (DigestAlg) EnumDescriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{1}
}

type DeviceIdentity_ChallengeFormat int32

const (
	// Credential Protection as defined in section 24 of the TPM specification
	// revision 2 part 1 See:
	// https://trustedcomputinggroup.org/resource/tpm-library-specification/
	// Returned primitives are of type TPM2B_ID_OBJECT and
	// TPM2B_ENCRYPTED_SECRET.
	// NOTE: ECC is not supported.
	//
	// Reference implementation:
	//  github.com/google/go-attestation@v0.3.2/attest/activation.go:generateChallengeTPM20,
	//  which uses
	//  github.com/google/go-tmp@v0.3.2/tmp2/credactivation/credential_activation.go:Generate
	DeviceIdentity_TPM20_CREDENTIAL DeviceIdentity_ChallengeFormat = 0
)

var (
	DeviceIdentity_ChallengeFormat_name = map[int32]string{
		0: "TPM20_CREDENTIAL",
	}

	DeviceIdentity_ChallengeFormat_value = map[string]int32{
		"TPM20_CREDENTIAL": 0,
	}
)

func (x DeviceIdentity_ChallengeFormat) Enum() *DeviceIdentity_ChallengeFormat {
	p := new(DeviceIdentity_ChallengeFormat)
	*p = x
	return p
}

func (x DeviceIdentity_ChallengeFormat) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), preflect.EnumNumber(x))
}

func (DeviceIdentity_ChallengeFormat) Descriptor() preflect.EnumDescriptor {
	return edgelq_common_api_attestation_proto_enumTypes[2].Descriptor()
}

func (DeviceIdentity_ChallengeFormat) Type() preflect.EnumType {
	return &edgelq_common_api_attestation_proto_enumTypes[2]
}

func (x DeviceIdentity_ChallengeFormat) Number() preflect.EnumNumber {
	return preflect.EnumNumber(x)
}

// Deprecated, Use DeviceIdentity_ChallengeFormat.ProtoReflect.Descriptor instead.
func (DeviceIdentity_ChallengeFormat) EnumDescriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{0, 0}
}

type DeviceIdentity struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	SerialNumber  string `protobuf:"bytes,1,opt,name=serial_number,json=serialNumber,proto3" json:"serial_number,omitempty" firestore:"serialNumber"`
	Manufacturer  string `protobuf:"bytes,2,opt,name=manufacturer,proto3" json:"manufacturer,omitempty" firestore:"manufacturer"`
	ProductName   string `protobuf:"bytes,3,opt,name=product_name,json=productName,proto3" json:"product_name,omitempty" firestore:"productName"`
	// Only TPM2.0 is supported
	TpmVersion TpmVersion `protobuf:"varint,4,opt,name=tpm_version,json=tpmVersion,proto3,enum=ntt.api.TpmVersion" json:"tpm_version,omitempty" firestore:"tpmVersion"`
	// TPM_PUBLIC format object obtained by tpm2.ReadPublic
	EkTpmPub []byte `protobuf:"bytes,5,opt,name=ek_tpm_pub,json=ekTpmPub,proto3" json:"ek_tpm_pub,omitempty" firestore:"ekTpmPub"`
	// ASN.1 DER encoded EK certificate.
	Ekcert []byte `protobuf:"bytes,6,opt,name=ekcert,proto3" json:"ekcert,omitempty" firestore:"ekcert"`
	// For Intel TPMs, Intel hosts certificates at a public URL derived from the
	// Public key. Clients or servers can perform an HTTP GET to this URL, and
	// use ParseEKCertificate on the response body.
	Ekcerturl string `protobuf:"bytes,7,opt,name=ekcerturl,proto3" json:"ekcerturl,omitempty" firestore:"ekcerturl"`
	// TPM_PUBLIC format object obtained by tpm2.ReadPublic
	IdevidCertTpmPub []byte `protobuf:"bytes,8,opt,name=idevid_cert_tpm_pub,json=idevidCertTpmPub,proto3" json:"idevid_cert_tpm_pub,omitempty" firestore:"idevidCertTpmPub"`
	// ASN.1 DER encoded IDevID certificate.
	IdevidCert []byte `protobuf:"bytes,9,opt,name=idevid_cert,json=idevidCert,proto3" json:"idevid_cert,omitempty" firestore:"idevidCert"`
	// TPM_PUBLIC format object obtained by tpm2.ReadPublic
	LdevidCertTpmPub []byte `protobuf:"bytes,10,opt,name=ldevid_cert_tpm_pub,json=ldevidCertTpmPub,proto3" json:"ldevid_cert_tpm_pub,omitempty" firestore:"ldevidCertTpmPub"`
	// ASN.1 DER encoded LDevID certificate.
	LdevidCert []byte                            `protobuf:"bytes,11,opt,name=ldevid_cert,json=ldevidCert,proto3" json:"ldevid_cert,omitempty" firestore:"ldevidCert"`
	AkParams   *DeviceIdentity_AttestationParams `protobuf:"bytes,12,opt,name=ak_params,json=akParams,proto3" json:"ak_params,omitempty" firestore:"akParams"`
	// ChallengeFormat defines the method of generating identity activation
	// challenge by the Verifier (server). It should affect the interpretation
	// ChallengeResponse fields cred_encrypted_by_ekpub and
	// secret_encrypted_by_cred. Attestor (client) is responsible for chosing
	// the right format depending on TPM version and the presence of TrouSerS
	// daemon.
	ChallengeFormat DeviceIdentity_ChallengeFormat `protobuf:"varint,13,opt,name=challenge_format,json=challengeFormat,proto3,enum=ntt.api.DeviceIdentity_ChallengeFormat" json:"challenge_format,omitempty" firestore:"challengeFormat"`
}

func (m *DeviceIdentity) Reset() {
	*m = DeviceIdentity{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_attestation_proto_msgTypes[0]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *DeviceIdentity) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*DeviceIdentity) ProtoMessage() {}

func (m *DeviceIdentity) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_attestation_proto_msgTypes[0]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*DeviceIdentity) GotenMessage() {}

// Deprecated, Use DeviceIdentity.ProtoReflect.Descriptor instead.
func (*DeviceIdentity) Descriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{0}
}

func (m *DeviceIdentity) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *DeviceIdentity) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *DeviceIdentity) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *DeviceIdentity) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *DeviceIdentity) GetSerialNumber() string {
	if m != nil {
		return m.SerialNumber
	}
	return ""
}

func (m *DeviceIdentity) GetManufacturer() string {
	if m != nil {
		return m.Manufacturer
	}
	return ""
}

func (m *DeviceIdentity) GetProductName() string {
	if m != nil {
		return m.ProductName
	}
	return ""
}

func (m *DeviceIdentity) GetTpmVersion() TpmVersion {
	if m != nil {
		return m.TpmVersion
	}
	return TpmVersion_TPMVAGNOSTIC
}

func (m *DeviceIdentity) GetEkTpmPub() []byte {
	if m != nil {
		return m.EkTpmPub
	}
	return nil
}

func (m *DeviceIdentity) GetEkcert() []byte {
	if m != nil {
		return m.Ekcert
	}
	return nil
}

func (m *DeviceIdentity) GetEkcerturl() string {
	if m != nil {
		return m.Ekcerturl
	}
	return ""
}

func (m *DeviceIdentity) GetIdevidCertTpmPub() []byte {
	if m != nil {
		return m.IdevidCertTpmPub
	}
	return nil
}

func (m *DeviceIdentity) GetIdevidCert() []byte {
	if m != nil {
		return m.IdevidCert
	}
	return nil
}

func (m *DeviceIdentity) GetLdevidCertTpmPub() []byte {
	if m != nil {
		return m.LdevidCertTpmPub
	}
	return nil
}

func (m *DeviceIdentity) GetLdevidCert() []byte {
	if m != nil {
		return m.LdevidCert
	}
	return nil
}

func (m *DeviceIdentity) GetAkParams() *DeviceIdentity_AttestationParams {
	if m != nil {
		return m.AkParams
	}
	return nil
}

func (m *DeviceIdentity) GetChallengeFormat() DeviceIdentity_ChallengeFormat {
	if m != nil {
		return m.ChallengeFormat
	}
	return DeviceIdentity_TPM20_CREDENTIAL
}

func (m *DeviceIdentity) SetSerialNumber(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "SerialNumber", "DeviceIdentity"))
	}
	m.SerialNumber = fv
}

func (m *DeviceIdentity) SetManufacturer(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Manufacturer", "DeviceIdentity"))
	}
	m.Manufacturer = fv
}

func (m *DeviceIdentity) SetProductName(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "ProductName", "DeviceIdentity"))
	}
	m.ProductName = fv
}

func (m *DeviceIdentity) SetTpmVersion(fv TpmVersion) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "TpmVersion", "DeviceIdentity"))
	}
	m.TpmVersion = fv
}

func (m *DeviceIdentity) SetEkTpmPub(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "EkTpmPub", "DeviceIdentity"))
	}
	m.EkTpmPub = fv
}

func (m *DeviceIdentity) SetEkcert(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Ekcert", "DeviceIdentity"))
	}
	m.Ekcert = fv
}

func (m *DeviceIdentity) SetEkcerturl(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Ekcerturl", "DeviceIdentity"))
	}
	m.Ekcerturl = fv
}

func (m *DeviceIdentity) SetIdevidCertTpmPub(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IdevidCertTpmPub", "DeviceIdentity"))
	}
	m.IdevidCertTpmPub = fv
}

func (m *DeviceIdentity) SetIdevidCert(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IdevidCert", "DeviceIdentity"))
	}
	m.IdevidCert = fv
}

func (m *DeviceIdentity) SetLdevidCertTpmPub(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "LdevidCertTpmPub", "DeviceIdentity"))
	}
	m.LdevidCertTpmPub = fv
}

func (m *DeviceIdentity) SetLdevidCert(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "LdevidCert", "DeviceIdentity"))
	}
	m.LdevidCert = fv
}

func (m *DeviceIdentity) SetAkParams(fv *DeviceIdentity_AttestationParams) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "AkParams", "DeviceIdentity"))
	}
	m.AkParams = fv
}

func (m *DeviceIdentity) SetChallengeFormat(fv DeviceIdentity_ChallengeFormat) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "ChallengeFormat", "DeviceIdentity"))
	}
	m.ChallengeFormat = fv
}

// One of IDevID or LDevID is mandatory for IdentityChallenge to succeed
// DevID keys can be either signing or decrypt
// With GlobalSign + Compulab, we use decrypt keys, but other vendors like Dell
// may be using signing keys instead, so api should allow both
type IdentityChallenge struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// Platform attestation
	PlatformAttestationNonce []byte `protobuf:"bytes,1,opt,name=platform_attestation_nonce,json=platformAttestationNonce,proto3" json:"platform_attestation_nonce,omitempty" firestore:"platformAttestationNonce"`
	// AK TPM Residency check
	CredEncryptedByEkpub    []byte `protobuf:"bytes,2,opt,name=cred_encrypted_by_ekpub,json=credEncryptedByEkpub,proto3" json:"cred_encrypted_by_ekpub,omitempty" firestore:"credEncryptedByEkpub"`
	SecretEncryptedByEkcred []byte `protobuf:"bytes,3,opt,name=secret_encrypted_by_ekcred,json=secretEncryptedByEkcred,proto3" json:"secret_encrypted_by_ekcred,omitempty" firestore:"secretEncryptedByEkcred"`
	// IDevID TPM Residency check
	CredEncryptedByIdevidPub    []byte `protobuf:"bytes,4,opt,name=cred_encrypted_by_idevid_pub,json=credEncryptedByIdevidPub,proto3" json:"cred_encrypted_by_idevid_pub,omitempty" firestore:"credEncryptedByIdevidPub"`
	SecretEncryptedByIdevidCred []byte `protobuf:"bytes,5,opt,name=secret_encrypted_by_idevid_cred,json=secretEncryptedByIdevidCred,proto3" json:"secret_encrypted_by_idevid_cred,omitempty" firestore:"secretEncryptedByIdevidCred"`
	// LDevID TPM Residency check
	CredEncryptedByLdevidPub    []byte `protobuf:"bytes,6,opt,name=cred_encrypted_by_ldevid_pub,json=credEncryptedByLdevidPub,proto3" json:"cred_encrypted_by_ldevid_pub,omitempty" firestore:"credEncryptedByLdevidPub"`
	SecretEncryptedByLdevidCred []byte `protobuf:"bytes,7,opt,name=secret_encrypted_by_ldevid_cred,json=secretEncryptedByLdevidCred,proto3" json:"secret_encrypted_by_ldevid_cred,omitempty" firestore:"secretEncryptedByLdevidCred"`
	// IDevID verification when key is signing
	DigestToSignWithIdevid []byte `protobuf:"bytes,8,opt,name=digest_to_sign_with_idevid,json=digestToSignWithIdevid,proto3" json:"digest_to_sign_with_idevid,omitempty" firestore:"digestToSignWithIdevid"`
	// IDevID verification when key is decrypt
	RsaSecretToDecryptWithIdevid []byte `protobuf:"bytes,9,opt,name=rsa_secret_to_decrypt_with_idevid,json=rsaSecretToDecryptWithIdevid,proto3" json:"rsa_secret_to_decrypt_with_idevid,omitempty" firestore:"rsaSecretToDecryptWithIdevid"`
	// LDevID verification when key is signing
	DigestToSignWithLdevid []byte `protobuf:"bytes,10,opt,name=digest_to_sign_with_ldevid,json=digestToSignWithLdevid,proto3" json:"digest_to_sign_with_ldevid,omitempty" firestore:"digestToSignWithLdevid"`
	// LDevID verification when key is decrypt
	RsaSecretToDecryptWithLdevid []byte `protobuf:"bytes,11,opt,name=rsa_secret_to_decrypt_with_ldevid,json=rsaSecretToDecryptWithLdevid,proto3" json:"rsa_secret_to_decrypt_with_ldevid,omitempty" firestore:"rsaSecretToDecryptWithLdevid"`
}

func (m *IdentityChallenge) Reset() {
	*m = IdentityChallenge{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_attestation_proto_msgTypes[1]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *IdentityChallenge) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*IdentityChallenge) ProtoMessage() {}

func (m *IdentityChallenge) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_attestation_proto_msgTypes[1]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*IdentityChallenge) GotenMessage() {}

// Deprecated, Use IdentityChallenge.ProtoReflect.Descriptor instead.
func (*IdentityChallenge) Descriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{1}
}

func (m *IdentityChallenge) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *IdentityChallenge) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *IdentityChallenge) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *IdentityChallenge) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *IdentityChallenge) GetPlatformAttestationNonce() []byte {
	if m != nil {
		return m.PlatformAttestationNonce
	}
	return nil
}

func (m *IdentityChallenge) GetCredEncryptedByEkpub() []byte {
	if m != nil {
		return m.CredEncryptedByEkpub
	}
	return nil
}

func (m *IdentityChallenge) GetSecretEncryptedByEkcred() []byte {
	if m != nil {
		return m.SecretEncryptedByEkcred
	}
	return nil
}

func (m *IdentityChallenge) GetCredEncryptedByIdevidPub() []byte {
	if m != nil {
		return m.CredEncryptedByIdevidPub
	}
	return nil
}

func (m *IdentityChallenge) GetSecretEncryptedByIdevidCred() []byte {
	if m != nil {
		return m.SecretEncryptedByIdevidCred
	}
	return nil
}

func (m *IdentityChallenge) GetCredEncryptedByLdevidPub() []byte {
	if m != nil {
		return m.CredEncryptedByLdevidPub
	}
	return nil
}

func (m *IdentityChallenge) GetSecretEncryptedByLdevidCred() []byte {
	if m != nil {
		return m.SecretEncryptedByLdevidCred
	}
	return nil
}

func (m *IdentityChallenge) GetDigestToSignWithIdevid() []byte {
	if m != nil {
		return m.DigestToSignWithIdevid
	}
	return nil
}

func (m *IdentityChallenge) GetRsaSecretToDecryptWithIdevid() []byte {
	if m != nil {
		return m.RsaSecretToDecryptWithIdevid
	}
	return nil
}

func (m *IdentityChallenge) GetDigestToSignWithLdevid() []byte {
	if m != nil {
		return m.DigestToSignWithLdevid
	}
	return nil
}

func (m *IdentityChallenge) GetRsaSecretToDecryptWithLdevid() []byte {
	if m != nil {
		return m.RsaSecretToDecryptWithLdevid
	}
	return nil
}

func (m *IdentityChallenge) SetPlatformAttestationNonce(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "PlatformAttestationNonce", "IdentityChallenge"))
	}
	m.PlatformAttestationNonce = fv
}

func (m *IdentityChallenge) SetCredEncryptedByEkpub(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "CredEncryptedByEkpub", "IdentityChallenge"))
	}
	m.CredEncryptedByEkpub = fv
}

func (m *IdentityChallenge) SetSecretEncryptedByEkcred(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "SecretEncryptedByEkcred", "IdentityChallenge"))
	}
	m.SecretEncryptedByEkcred = fv
}

func (m *IdentityChallenge) SetCredEncryptedByIdevidPub(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "CredEncryptedByIdevidPub", "IdentityChallenge"))
	}
	m.CredEncryptedByIdevidPub = fv
}

func (m *IdentityChallenge) SetSecretEncryptedByIdevidCred(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "SecretEncryptedByIdevidCred", "IdentityChallenge"))
	}
	m.SecretEncryptedByIdevidCred = fv
}

func (m *IdentityChallenge) SetCredEncryptedByLdevidPub(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "CredEncryptedByLdevidPub", "IdentityChallenge"))
	}
	m.CredEncryptedByLdevidPub = fv
}

func (m *IdentityChallenge) SetSecretEncryptedByLdevidCred(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "SecretEncryptedByLdevidCred", "IdentityChallenge"))
	}
	m.SecretEncryptedByLdevidCred = fv
}

func (m *IdentityChallenge) SetDigestToSignWithIdevid(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "DigestToSignWithIdevid", "IdentityChallenge"))
	}
	m.DigestToSignWithIdevid = fv
}

func (m *IdentityChallenge) SetRsaSecretToDecryptWithIdevid(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "RsaSecretToDecryptWithIdevid", "IdentityChallenge"))
	}
	m.RsaSecretToDecryptWithIdevid = fv
}

func (m *IdentityChallenge) SetDigestToSignWithLdevid(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "DigestToSignWithLdevid", "IdentityChallenge"))
	}
	m.DigestToSignWithLdevid = fv
}

func (m *IdentityChallenge) SetRsaSecretToDecryptWithLdevid(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "RsaSecretToDecryptWithLdevid", "IdentityChallenge"))
	}
	m.RsaSecretToDecryptWithLdevid = fv
}

type IdentityChallengeResponse struct {
	state                           protoimpl.MessageState
	sizeCache                       protoimpl.SizeCache
	unknownFields                   protoimpl.UnknownFields
	AkActivationDecryptedSecret     []byte                             `protobuf:"bytes,1,opt,name=ak_activation_decrypted_secret,json=akActivationDecryptedSecret,proto3" json:"ak_activation_decrypted_secret,omitempty" firestore:"akActivationDecryptedSecret"`
	IdevidActivationDecryptedSecret []byte                             `protobuf:"bytes,2,opt,name=idevid_activation_decrypted_secret,json=idevidActivationDecryptedSecret,proto3" json:"idevid_activation_decrypted_secret,omitempty" firestore:"idevidActivationDecryptedSecret"`
	LdevidActivationDecryptedSecret []byte                             `protobuf:"bytes,3,opt,name=ldevid_activation_decrypted_secret,json=ldevidActivationDecryptedSecret,proto3" json:"ldevid_activation_decrypted_secret,omitempty" firestore:"ldevidActivationDecryptedSecret"`
	DigestSignedByIdevid            []byte                             `protobuf:"bytes,4,opt,name=digest_signed_by_idevid,json=digestSignedByIdevid,proto3" json:"digest_signed_by_idevid,omitempty" firestore:"digestSignedByIdevid"`
	DigestSignedByLdevid            []byte                             `protobuf:"bytes,5,opt,name=digest_signed_by_ldevid,json=digestSignedByLdevid,proto3" json:"digest_signed_by_ldevid,omitempty" firestore:"digestSignedByLdevid"`
	RsaDecryptedWithIdevid          []byte                             `protobuf:"bytes,6,opt,name=rsa_decrypted_with_idevid,json=rsaDecryptedWithIdevid,proto3" json:"rsa_decrypted_with_idevid,omitempty" firestore:"rsaDecryptedWithIdevid"`
	RsaDecryptedWithLdevid          []byte                             `protobuf:"bytes,7,opt,name=rsa_decrypted_with_ldevid,json=rsaDecryptedWithLdevid,proto3" json:"rsa_decrypted_with_ldevid,omitempty" firestore:"rsaDecryptedWithLdevid"`
	Quotes                          []*IdentityChallengeResponse_Quote `protobuf:"bytes,8,rep,name=quotes,proto3" json:"quotes,omitempty" firestore:"quotes"`
	Pcrs                            []*PCR                             `protobuf:"bytes,9,rep,name=pcrs,proto3" json:"pcrs,omitempty" firestore:"pcrs"`
	// Binary contents of /sys/kernel/security/tpm0/binary_bios_measurements
	Eventlog []byte `protobuf:"bytes,10,opt,name=eventlog,proto3" json:"eventlog,omitempty" firestore:"eventlog"`
}

func (m *IdentityChallengeResponse) Reset() {
	*m = IdentityChallengeResponse{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_attestation_proto_msgTypes[2]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *IdentityChallengeResponse) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*IdentityChallengeResponse) ProtoMessage() {}

func (m *IdentityChallengeResponse) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_attestation_proto_msgTypes[2]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*IdentityChallengeResponse) GotenMessage() {}

// Deprecated, Use IdentityChallengeResponse.ProtoReflect.Descriptor instead.
func (*IdentityChallengeResponse) Descriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{2}
}

func (m *IdentityChallengeResponse) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *IdentityChallengeResponse) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *IdentityChallengeResponse) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *IdentityChallengeResponse) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *IdentityChallengeResponse) GetAkActivationDecryptedSecret() []byte {
	if m != nil {
		return m.AkActivationDecryptedSecret
	}
	return nil
}

func (m *IdentityChallengeResponse) GetIdevidActivationDecryptedSecret() []byte {
	if m != nil {
		return m.IdevidActivationDecryptedSecret
	}
	return nil
}

func (m *IdentityChallengeResponse) GetLdevidActivationDecryptedSecret() []byte {
	if m != nil {
		return m.LdevidActivationDecryptedSecret
	}
	return nil
}

func (m *IdentityChallengeResponse) GetDigestSignedByIdevid() []byte {
	if m != nil {
		return m.DigestSignedByIdevid
	}
	return nil
}

func (m *IdentityChallengeResponse) GetDigestSignedByLdevid() []byte {
	if m != nil {
		return m.DigestSignedByLdevid
	}
	return nil
}

func (m *IdentityChallengeResponse) GetRsaDecryptedWithIdevid() []byte {
	if m != nil {
		return m.RsaDecryptedWithIdevid
	}
	return nil
}

func (m *IdentityChallengeResponse) GetRsaDecryptedWithLdevid() []byte {
	if m != nil {
		return m.RsaDecryptedWithLdevid
	}
	return nil
}

func (m *IdentityChallengeResponse) GetQuotes() []*IdentityChallengeResponse_Quote {
	if m != nil {
		return m.Quotes
	}
	return nil
}

func (m *IdentityChallengeResponse) GetPcrs() []*PCR {
	if m != nil {
		return m.Pcrs
	}
	return nil
}

func (m *IdentityChallengeResponse) GetEventlog() []byte {
	if m != nil {
		return m.Eventlog
	}
	return nil
}

func (m *IdentityChallengeResponse) SetAkActivationDecryptedSecret(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "AkActivationDecryptedSecret", "IdentityChallengeResponse"))
	}
	m.AkActivationDecryptedSecret = fv
}

func (m *IdentityChallengeResponse) SetIdevidActivationDecryptedSecret(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "IdevidActivationDecryptedSecret", "IdentityChallengeResponse"))
	}
	m.IdevidActivationDecryptedSecret = fv
}

func (m *IdentityChallengeResponse) SetLdevidActivationDecryptedSecret(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "LdevidActivationDecryptedSecret", "IdentityChallengeResponse"))
	}
	m.LdevidActivationDecryptedSecret = fv
}

func (m *IdentityChallengeResponse) SetDigestSignedByIdevid(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "DigestSignedByIdevid", "IdentityChallengeResponse"))
	}
	m.DigestSignedByIdevid = fv
}

func (m *IdentityChallengeResponse) SetDigestSignedByLdevid(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "DigestSignedByLdevid", "IdentityChallengeResponse"))
	}
	m.DigestSignedByLdevid = fv
}

func (m *IdentityChallengeResponse) SetRsaDecryptedWithIdevid(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "RsaDecryptedWithIdevid", "IdentityChallengeResponse"))
	}
	m.RsaDecryptedWithIdevid = fv
}

func (m *IdentityChallengeResponse) SetRsaDecryptedWithLdevid(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "RsaDecryptedWithLdevid", "IdentityChallengeResponse"))
	}
	m.RsaDecryptedWithLdevid = fv
}

func (m *IdentityChallengeResponse) SetQuotes(fv []*IdentityChallengeResponse_Quote) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Quotes", "IdentityChallengeResponse"))
	}
	m.Quotes = fv
}

func (m *IdentityChallengeResponse) SetPcrs(fv []*PCR) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Pcrs", "IdentityChallengeResponse"))
	}
	m.Pcrs = fv
}

func (m *IdentityChallengeResponse) SetEventlog(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Eventlog", "IdentityChallengeResponse"))
	}
	m.Eventlog = fv
}

type PCR struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	Index         uint32 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty" firestore:"index"`
	// Hex-encoded digest string (without 0x prefix, e.g. "DEADBEEF")
	DigestHex string    `protobuf:"bytes,2,opt,name=digest_hex,json=digestHex,proto3" json:"digest_hex,omitempty" firestore:"digestHex"`
	DigestAlg DigestAlg `protobuf:"varint,3,opt,name=digest_alg,json=digestAlg,proto3,enum=ntt.api.DigestAlg" json:"digest_alg,omitempty" firestore:"digestAlg"`
	// User's comments for this entry
	Comment string `protobuf:"bytes,4,opt,name=comment,proto3" json:"comment,omitempty" firestore:"comment"`
}

func (m *PCR) Reset() {
	*m = PCR{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_attestation_proto_msgTypes[3]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *PCR) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*PCR) ProtoMessage() {}

func (m *PCR) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_attestation_proto_msgTypes[3]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*PCR) GotenMessage() {}

// Deprecated, Use PCR.ProtoReflect.Descriptor instead.
func (*PCR) Descriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{3}
}

func (m *PCR) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *PCR) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *PCR) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *PCR) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *PCR) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return uint32(0)
}

func (m *PCR) GetDigestHex() string {
	if m != nil {
		return m.DigestHex
	}
	return ""
}

func (m *PCR) GetDigestAlg() DigestAlg {
	if m != nil {
		return m.DigestAlg
	}
	return DigestAlg_SHA1
}

func (m *PCR) GetComment() string {
	if m != nil {
		return m.Comment
	}
	return ""
}

func (m *PCR) SetIndex(fv uint32) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Index", "PCR"))
	}
	m.Index = fv
}

func (m *PCR) SetDigestHex(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "DigestHex", "PCR"))
	}
	m.DigestHex = fv
}

func (m *PCR) SetDigestAlg(fv DigestAlg) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "DigestAlg", "PCR"))
	}
	m.DigestAlg = fv
}

func (m *PCR) SetComment(fv string) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Comment", "PCR"))
	}
	m.Comment = fv
}

type DeviceIdentity_AttestationParams struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// https: //
	// trustedcomputinggroup.org/wp-content/uploads/TPM-Main-Part-2-TPM-Structures_v1.2_rev116_01032011.pdf
	// https: //
	// www.trustedcomputinggroup.org/wp-content/uploads/TPM-Rev-2.0-Part-2-Structures-01.38.pdf
	// TPMT_PUBLIC (TPM 2.0) or TPM_PUBKEY (TPM 1.2)
	Akpub []byte `protobuf:"bytes,1,opt,name=akpub,proto3" json:"akpub,omitempty" firestore:"akpub"`
	// TPMS_CREATION_DATA
	CreationData []byte `protobuf:"bytes,2,opt,name=creation_data,json=creationData,proto3" json:"creation_data,omitempty" firestore:"creationData"`
	// TPMS_ATTEST
	Attest []byte `protobuf:"bytes,3,opt,name=attest,proto3" json:"attest,omitempty" firestore:"attest"`
	// TPMT_SIGNATURE
	Signature []byte `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty" firestore:"signature"`
}

func (m *DeviceIdentity_AttestationParams) Reset() {
	*m = DeviceIdentity_AttestationParams{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_attestation_proto_msgTypes[4]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *DeviceIdentity_AttestationParams) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*DeviceIdentity_AttestationParams) ProtoMessage() {}

func (m *DeviceIdentity_AttestationParams) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_attestation_proto_msgTypes[4]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*DeviceIdentity_AttestationParams) GotenMessage() {}

// Deprecated, Use DeviceIdentity_AttestationParams.ProtoReflect.Descriptor instead.
func (*DeviceIdentity_AttestationParams) Descriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{0, 0}
}

func (m *DeviceIdentity_AttestationParams) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *DeviceIdentity_AttestationParams) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *DeviceIdentity_AttestationParams) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *DeviceIdentity_AttestationParams) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *DeviceIdentity_AttestationParams) GetAkpub() []byte {
	if m != nil {
		return m.Akpub
	}
	return nil
}

func (m *DeviceIdentity_AttestationParams) GetCreationData() []byte {
	if m != nil {
		return m.CreationData
	}
	return nil
}

func (m *DeviceIdentity_AttestationParams) GetAttest() []byte {
	if m != nil {
		return m.Attest
	}
	return nil
}

func (m *DeviceIdentity_AttestationParams) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DeviceIdentity_AttestationParams) SetAkpub(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Akpub", "DeviceIdentity_AttestationParams"))
	}
	m.Akpub = fv
}

func (m *DeviceIdentity_AttestationParams) SetCreationData(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "CreationData", "DeviceIdentity_AttestationParams"))
	}
	m.CreationData = fv
}

func (m *DeviceIdentity_AttestationParams) SetAttest(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Attest", "DeviceIdentity_AttestationParams"))
	}
	m.Attest = fv
}

func (m *DeviceIdentity_AttestationParams) SetSignature(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Signature", "DeviceIdentity_AttestationParams"))
	}
	m.Signature = fv
}

type IdentityChallengeResponse_Quote struct {
	state         protoimpl.MessageState
	sizeCache     protoimpl.SizeCache
	unknownFields protoimpl.UnknownFields
	// TPMS_ATTEST (TSS_VALIDATION.Data or TSS_VALIDATION.rgbData)
	// This contains PCR selection information for which the signature was
	// calculated and other required data, like nonce.
	Quote []byte `protobuf:"bytes,1,opt,name=quote,proto3" json:"quote,omitempty" firestore:"quote"`
	// TSS_VALIDATION.ValidationData or TSS_VALIDATION.rgbValidationData
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty" firestore:"signature"`
}

func (m *IdentityChallengeResponse_Quote) Reset() {
	*m = IdentityChallengeResponse_Quote{}
	if protoimpl.UnsafeEnabled {
		mi := &edgelq_common_api_attestation_proto_msgTypes[5]
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		ms.StoreMessageInfo(mi)
	}
}

func (m *IdentityChallengeResponse_Quote) String() string {
	return protoimpl.X.MessageStringOf(m)
}

func (*IdentityChallengeResponse_Quote) ProtoMessage() {}

func (m *IdentityChallengeResponse_Quote) ProtoReflect() preflect.Message {
	mi := &edgelq_common_api_attestation_proto_msgTypes[5]
	if protoimpl.UnsafeEnabled && m != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(m))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(m)
}

func (*IdentityChallengeResponse_Quote) GotenMessage() {}

// Deprecated, Use IdentityChallengeResponse_Quote.ProtoReflect.Descriptor instead.
func (*IdentityChallengeResponse_Quote) Descriptor() ([]byte, []int) {
	return edgelq_common_api_attestation_proto_rawDescGZIP(), []int{2, 0}
}

func (m *IdentityChallengeResponse_Quote) Unmarshal(b []byte) error {
	return proto.Unmarshal(b, m)
}

func (m *IdentityChallengeResponse_Quote) Marshal() ([]byte, error) {
	return proto.Marshal(m)
}

func (m *IdentityChallengeResponse_Quote) MarshalJSON() ([]byte, error) {
	return protojson.MarshalOptions{}.Marshal(m)
}

func (m *IdentityChallengeResponse_Quote) UnmarshalJSON(data []byte) error {
	return protojson.Unmarshal(data, m)
}

func (m *IdentityChallengeResponse_Quote) GetQuote() []byte {
	if m != nil {
		return m.Quote
	}
	return nil
}

func (m *IdentityChallengeResponse_Quote) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *IdentityChallengeResponse_Quote) SetQuote(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Quote", "IdentityChallengeResponse_Quote"))
	}
	m.Quote = fv
}

func (m *IdentityChallengeResponse_Quote) SetSignature(fv []byte) {
	if m == nil {
		panic(fmt.Errorf("can't set %s on nil %s", "Signature", "IdentityChallengeResponse_Quote"))
	}
	m.Signature = fv
}

var edgelq_common_api_attestation_proto preflect.FileDescriptor

var edgelq_common_api_attestation_proto_rawDesc = []byte{
	0x0a, 0x23, 0x65, 0x64, 0x67, 0x65, 0x6c, 0x71, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e, 0x2f,
	0x61, 0x70, 0x69, 0x2f, 0x61, 0x74, 0x74, 0x65, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2e,
	0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x07, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x1a, 0x1d,
	0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2f, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x73, 0x2f, 0x67, 0x6f, 0x74, 0x65, 0x6e, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x1a, 0x24, 0x65,
	0x64, 0x67, 0x65, 0x6c, 0x71, 0x2f, 0x61, 0x75, 0x64, 0x69, 0x74, 0x2f, 0x61, 0x6e, 0x6e, 0x6f,
	0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x2f, 0x61, 0x75, 0x64, 0x69, 0x74, 0x2e, 0x70, 0x72,
	0x6f, 0x74, 0x6f, 0x22, 0xf2, 0x05, 0x0a, 0x0e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49, 0x64,
	0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x12, 0x23, 0x0a, 0x0d, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c,
	0x5f, 0x6e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0c, 0x73,
	0x65, 0x72, 0x69, 0x61, 0x6c, 0x4e, 0x75, 0x6d, 0x62, 0x65, 0x72, 0x12, 0x22, 0x0a, 0x0c, 0x6d,
	0x61, 0x6e, 0x75, 0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x18, 0x02, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x0c, 0x6d, 0x61, 0x6e, 0x75, 0x66, 0x61, 0x63, 0x74, 0x75, 0x72, 0x65, 0x72, 0x12,
	0x21, 0x0a, 0x0c, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x5f, 0x6e, 0x61, 0x6d, 0x65, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0b, 0x70, 0x72, 0x6f, 0x64, 0x75, 0x63, 0x74, 0x4e, 0x61,
	0x6d, 0x65, 0x12, 0x34, 0x0a, 0x0b, 0x74, 0x70, 0x6d, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x18, 0x04, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x13, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x54, 0x70, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x52, 0x0a, 0x74, 0x70,
	0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x1c, 0x0a, 0x0a, 0x65, 0x6b, 0x5f, 0x74,
	0x70, 0x6d, 0x5f, 0x70, 0x75, 0x62, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x65, 0x6b,
	0x54, 0x70, 0x6d, 0x50, 0x75, 0x62, 0x12, 0x16, 0x0a, 0x06, 0x65, 0x6b, 0x63, 0x65, 0x72, 0x74,
	0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x65, 0x6b, 0x63, 0x65, 0x72, 0x74, 0x12, 0x1c,
	0x0a, 0x09, 0x65, 0x6b, 0x63, 0x65, 0x72, 0x74, 0x75, 0x72, 0x6c, 0x18, 0x07, 0x20, 0x01, 0x28,
	0x09, 0x52, 0x09, 0x65, 0x6b, 0x63, 0x65, 0x72, 0x74, 0x75, 0x72, 0x6c, 0x12, 0x2d, 0x0a, 0x13,
	0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x5f, 0x63, 0x65, 0x72, 0x74, 0x5f, 0x74, 0x70, 0x6d, 0x5f,
	0x70, 0x75, 0x62, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x10, 0x69, 0x64, 0x65, 0x76, 0x69,
	0x64, 0x43, 0x65, 0x72, 0x74, 0x54, 0x70, 0x6d, 0x50, 0x75, 0x62, 0x12, 0x1f, 0x0a, 0x0b, 0x69,
	0x64, 0x65, 0x76, 0x69, 0x64, 0x5f, 0x63, 0x65, 0x72, 0x74, 0x18, 0x09, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x0a, 0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x43, 0x65, 0x72, 0x74, 0x12, 0x2d, 0x0a, 0x13,
	0x6c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x5f, 0x63, 0x65, 0x72, 0x74, 0x5f, 0x74, 0x70, 0x6d, 0x5f,
	0x70, 0x75, 0x62, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x10, 0x6c, 0x64, 0x65, 0x76, 0x69,
	0x64, 0x43, 0x65, 0x72, 0x74, 0x54, 0x70, 0x6d, 0x50, 0x75, 0x62, 0x12, 0x1f, 0x0a, 0x0b, 0x6c,
	0x64, 0x65, 0x76, 0x69, 0x64, 0x5f, 0x63, 0x65, 0x72, 0x74, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x0a, 0x6c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x43, 0x65, 0x72, 0x74, 0x12, 0x46, 0x0a, 0x09,
	0x61, 0x6b, 0x5f, 0x70, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x18, 0x0c, 0x20, 0x01, 0x28, 0x0b, 0x32,
	0x29, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65,
	0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x2e, 0x41, 0x74, 0x74, 0x65, 0x73, 0x74, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x52, 0x08, 0x61, 0x6b, 0x50, 0x61,
	0x72, 0x61, 0x6d, 0x73, 0x12, 0x52, 0x0a, 0x10, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67,
	0x65, 0x5f, 0x66, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x18, 0x0d, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x27,
	0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x44, 0x65, 0x76, 0x69, 0x63, 0x65, 0x49,
	0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x2e, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67,
	0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x52, 0x0f, 0x63, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e,
	0x67, 0x65, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x1a, 0x84, 0x01, 0x0a, 0x11, 0x41, 0x74, 0x74,
	0x65, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x61, 0x72, 0x61, 0x6d, 0x73, 0x12, 0x14,
	0x0a, 0x05, 0x61, 0x6b, 0x70, 0x75, 0x62, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x05, 0x61,
	0x6b, 0x70, 0x75, 0x62, 0x12, 0x23, 0x0a, 0x0d, 0x63, 0x72, 0x65, 0x61, 0x74, 0x69, 0x6f, 0x6e,
	0x5f, 0x64, 0x61, 0x74, 0x61, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x0c, 0x63, 0x72, 0x65,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x61, 0x74, 0x61, 0x12, 0x16, 0x0a, 0x06, 0x61, 0x74, 0x74,
	0x65, 0x73, 0x74, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x06, 0x61, 0x74, 0x74, 0x65, 0x73,
	0x74, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74, 0x75, 0x72, 0x65, 0x22,
	0x27, 0x0a, 0x0f, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x46, 0x6f, 0x72, 0x6d,
	0x61, 0x74, 0x12, 0x14, 0x0a, 0x10, 0x54, 0x50, 0x4d, 0x32, 0x30, 0x5f, 0x43, 0x52, 0x45, 0x44,
	0x45, 0x4e, 0x54, 0x49, 0x41, 0x4c, 0x10, 0x00, 0x22, 0xdb, 0x05, 0x0a, 0x11, 0x49, 0x64, 0x65,
	0x6e, 0x74, 0x69, 0x74, 0x79, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x12, 0x3c,
	0x0a, 0x1a, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x5f, 0x61, 0x74, 0x74, 0x65, 0x73,
	0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x6e, 0x6f, 0x6e, 0x63, 0x65, 0x18, 0x01, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x18, 0x70, 0x6c, 0x61, 0x74, 0x66, 0x6f, 0x72, 0x6d, 0x41, 0x74, 0x74, 0x65,
	0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x4e, 0x6f, 0x6e, 0x63, 0x65, 0x12, 0x35, 0x0a, 0x17,
	0x63, 0x72, 0x65, 0x64, 0x5f, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x62,
	0x79, 0x5f, 0x65, 0x6b, 0x70, 0x75, 0x62, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x14, 0x63,
	0x72, 0x65, 0x64, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x42, 0x79, 0x45, 0x6b,
	0x70, 0x75, 0x62, 0x12, 0x3b, 0x0a, 0x1a, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x5f, 0x65, 0x6e,
	0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x5f, 0x65, 0x6b, 0x63, 0x72, 0x65,
	0x64, 0x18, 0x03, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x17, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x45,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x42, 0x79, 0x45, 0x6b, 0x63, 0x72, 0x65, 0x64,
	0x12, 0x3e, 0x0a, 0x1c, 0x63, 0x72, 0x65, 0x64, 0x5f, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x65, 0x64, 0x5f, 0x62, 0x79, 0x5f, 0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x5f, 0x70, 0x75, 0x62,
	0x18, 0x04, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x18, 0x63, 0x72, 0x65, 0x64, 0x45, 0x6e, 0x63, 0x72,
	0x79, 0x70, 0x74, 0x65, 0x64, 0x42, 0x79, 0x49, 0x64, 0x65, 0x76, 0x69, 0x64, 0x50, 0x75, 0x62,
	0x12, 0x44, 0x0a, 0x1f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x5f, 0x65, 0x6e, 0x63, 0x72, 0x79,
	0x70, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x5f, 0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x5f, 0x63,
	0x72, 0x65, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x1b, 0x73, 0x65, 0x63, 0x72, 0x65,
	0x74, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x42, 0x79, 0x49, 0x64, 0x65, 0x76,
	0x69, 0x64, 0x43, 0x72, 0x65, 0x64, 0x12, 0x3e, 0x0a, 0x1c, 0x63, 0x72, 0x65, 0x64, 0x5f, 0x65,
	0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x5f, 0x6c, 0x64, 0x65, 0x76,
	0x69, 0x64, 0x5f, 0x70, 0x75, 0x62, 0x18, 0x06, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x18, 0x63, 0x72,
	0x65, 0x64, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x42, 0x79, 0x4c, 0x64, 0x65,
	0x76, 0x69, 0x64, 0x50, 0x75, 0x62, 0x12, 0x44, 0x0a, 0x1f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74,
	0x5f, 0x65, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x5f, 0x6c, 0x64,
	0x65, 0x76, 0x69, 0x64, 0x5f, 0x63, 0x72, 0x65, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x1b, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x45, 0x6e, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,
	0x42, 0x79, 0x4c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x43, 0x72, 0x65, 0x64, 0x12, 0x3a, 0x0a, 0x1a,
	0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x5f, 0x74, 0x6f, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x5f, 0x77,
	0x69, 0x74, 0x68, 0x5f, 0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x18, 0x08, 0x20, 0x01, 0x28, 0x0c,
	0x52, 0x16, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x54, 0x6f, 0x53, 0x69, 0x67, 0x6e, 0x57, 0x69,
	0x74, 0x68, 0x49, 0x64, 0x65, 0x76, 0x69, 0x64, 0x12, 0x47, 0x0a, 0x21, 0x72, 0x73, 0x61, 0x5f,
	0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x5f, 0x74, 0x6f, 0x5f, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x18, 0x09, 0x20,
	0x01, 0x28, 0x0c, 0x52, 0x1c, 0x72, 0x73, 0x61, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x54, 0x6f,
	0x44, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x57, 0x69, 0x74, 0x68, 0x49, 0x64, 0x65, 0x76, 0x69,
	0x64, 0x12, 0x3a, 0x0a, 0x1a, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x5f, 0x74, 0x6f, 0x5f, 0x73,
	0x69, 0x67, 0x6e, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x6c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x18,
	0x0a, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x16, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x54, 0x6f, 0x53,
	0x69, 0x67, 0x6e, 0x57, 0x69, 0x74, 0x68, 0x4c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x12, 0x47, 0x0a,
	0x21, 0x72, 0x73, 0x61, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x5f, 0x74, 0x6f, 0x5f, 0x64,
	0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x6c, 0x64, 0x65, 0x76,
	0x69, 0x64, 0x18, 0x0b, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x1c, 0x72, 0x73, 0x61, 0x53, 0x65, 0x63,
	0x72, 0x65, 0x74, 0x54, 0x6f, 0x44, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x57, 0x69, 0x74, 0x68,
	0x4c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x22, 0x9b, 0x05, 0x0a, 0x19, 0x49, 0x64, 0x65, 0x6e, 0x74,
	0x69, 0x74, 0x79, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65, 0x6e, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70,
	0x6f, 0x6e, 0x73, 0x65, 0x12, 0x43, 0x0a, 0x1e, 0x61, 0x6b, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76,
	0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f,
	0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x1b, 0x61, 0x6b,
	0x41, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x65, 0x63, 0x72, 0x79, 0x70,
	0x74, 0x65, 0x64, 0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x12, 0x4b, 0x0a, 0x22, 0x69, 0x64, 0x65,
	0x76, 0x69, 0x64, 0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x64,
	0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18,
	0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x1f, 0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x41, 0x63, 0x74,
	0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64,
	0x53, 0x65, 0x63, 0x72, 0x65, 0x74, 0x12, 0x4b, 0x0a, 0x22, 0x6c, 0x64, 0x65, 0x76, 0x69, 0x64,
	0x5f, 0x61, 0x63, 0x74, 0x69, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x5f, 0x64, 0x65, 0x63, 0x72,
	0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x73, 0x65, 0x63, 0x72, 0x65, 0x74, 0x18, 0x03, 0x20, 0x01,
	0x28, 0x0c, 0x52, 0x1f, 0x6c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x41, 0x63, 0x74, 0x69, 0x76, 0x61,
	0x74, 0x69, 0x6f, 0x6e, 0x44, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x53, 0x65, 0x63,
	0x72, 0x65, 0x74, 0x12, 0x35, 0x0a, 0x17, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x5f, 0x73, 0x69,
	0x67, 0x6e, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x5f, 0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x18, 0x04,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x14, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x53, 0x69, 0x67, 0x6e,
	0x65, 0x64, 0x42, 0x79, 0x49, 0x64, 0x65, 0x76, 0x69, 0x64, 0x12, 0x35, 0x0a, 0x17, 0x64, 0x69,
	0x67, 0x65, 0x73, 0x74, 0x5f, 0x73, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x5f, 0x62, 0x79, 0x5f, 0x6c,
	0x64, 0x65, 0x76, 0x69, 0x64, 0x18, 0x05, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x14, 0x64, 0x69, 0x67,
	0x65, 0x73, 0x74, 0x53, 0x69, 0x67, 0x6e, 0x65, 0x64, 0x42, 0x79, 0x4c, 0x64, 0x65, 0x76, 0x69,
	0x64, 0x12, 0x39, 0x0a, 0x19, 0x72, 0x73, 0x61, 0x5f, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x65, 0x64, 0x5f, 0x77, 0x69, 0x74, 0x68, 0x5f, 0x69, 0x64, 0x65, 0x76, 0x69, 0x64, 0x18, 0x06,
	0x20, 0x01, 0x28, 0x0c, 0x52, 0x16, 0x72, 0x73, 0x61, 0x44, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74,
	0x65, 0x64, 0x57, 0x69, 0x74, 0x68, 0x49, 0x64, 0x65, 0x76, 0x69, 0x64, 0x12, 0x39, 0x0a, 0x19,
	0x72, 0x73, 0x61, 0x5f, 0x64, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x5f, 0x77, 0x69,
	0x74, 0x68, 0x5f, 0x6c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x18, 0x07, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x16, 0x72, 0x73, 0x61, 0x44, 0x65, 0x63, 0x72, 0x79, 0x70, 0x74, 0x65, 0x64, 0x57, 0x69, 0x74,
	0x68, 0x4c, 0x64, 0x65, 0x76, 0x69, 0x64, 0x12, 0x40, 0x0a, 0x06, 0x71, 0x75, 0x6f, 0x74, 0x65,
	0x73, 0x18, 0x08, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x28, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x43, 0x68, 0x61, 0x6c, 0x6c, 0x65,
	0x6e, 0x67, 0x65, 0x52, 0x65, 0x73, 0x70, 0x6f, 0x6e, 0x73, 0x65, 0x2e, 0x51, 0x75, 0x6f, 0x74,
	0x65, 0x52, 0x06, 0x71, 0x75, 0x6f, 0x74, 0x65, 0x73, 0x12, 0x20, 0x0a, 0x04, 0x70, 0x63, 0x72,
	0x73, 0x18, 0x09, 0x20, 0x03, 0x28, 0x0b, 0x32, 0x0c, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70,
	0x69, 0x2e, 0x50, 0x43, 0x52, 0x52, 0x04, 0x70, 0x63, 0x72, 0x73, 0x12, 0x1a, 0x0a, 0x08, 0x65,
	0x76, 0x65, 0x6e, 0x74, 0x6c, 0x6f, 0x67, 0x18, 0x0a, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x08, 0x65,
	0x76, 0x65, 0x6e, 0x74, 0x6c, 0x6f, 0x67, 0x1a, 0x3b, 0x0a, 0x05, 0x51, 0x75, 0x6f, 0x74, 0x65,
	0x12, 0x14, 0x0a, 0x05, 0x71, 0x75, 0x6f, 0x74, 0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0c, 0x52,
	0x05, 0x71, 0x75, 0x6f, 0x74, 0x65, 0x12, 0x1c, 0x0a, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61, 0x74,
	0x75, 0x72, 0x65, 0x18, 0x02, 0x20, 0x01, 0x28, 0x0c, 0x52, 0x09, 0x73, 0x69, 0x67, 0x6e, 0x61,
	0x74, 0x75, 0x72, 0x65, 0x22, 0x87, 0x01, 0x0a, 0x03, 0x50, 0x43, 0x52, 0x12, 0x14, 0x0a, 0x05,
	0x69, 0x6e, 0x64, 0x65, 0x78, 0x18, 0x01, 0x20, 0x01, 0x28, 0x0d, 0x52, 0x05, 0x69, 0x6e, 0x64,
	0x65, 0x78, 0x12, 0x1d, 0x0a, 0x0a, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x5f, 0x68, 0x65, 0x78,
	0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x09, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x48, 0x65,
	0x78, 0x12, 0x31, 0x0a, 0x0a, 0x64, 0x69, 0x67, 0x65, 0x73, 0x74, 0x5f, 0x61, 0x6c, 0x67, 0x18,
	0x03, 0x20, 0x01, 0x28, 0x0e, 0x32, 0x12, 0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e,
	0x44, 0x69, 0x67, 0x65, 0x73, 0x74, 0x41, 0x6c, 0x67, 0x52, 0x09, 0x64, 0x69, 0x67, 0x65, 0x73,
	0x74, 0x41, 0x6c, 0x67, 0x12, 0x18, 0x0a, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x18,
	0x04, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x63, 0x6f, 0x6d, 0x6d, 0x65, 0x6e, 0x74, 0x2a, 0x36,
	0x0a, 0x0a, 0x54, 0x70, 0x6d, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x12, 0x10, 0x0a, 0x0c,
	0x54, 0x50, 0x4d, 0x56, 0x41, 0x47, 0x4e, 0x4f, 0x53, 0x54, 0x49, 0x43, 0x10, 0x00, 0x12, 0x0a,
	0x0a, 0x06, 0x54, 0x50, 0x4d, 0x56, 0x31, 0x32, 0x10, 0x01, 0x12, 0x0a, 0x0a, 0x06, 0x54, 0x50,
	0x4d, 0x56, 0x32, 0x30, 0x10, 0x02, 0x2a, 0x21, 0x0a, 0x09, 0x44, 0x69, 0x67, 0x65, 0x73, 0x74,
	0x41, 0x6c, 0x67, 0x12, 0x08, 0x0a, 0x04, 0x53, 0x48, 0x41, 0x31, 0x10, 0x00, 0x12, 0x0a, 0x0a,
	0x06, 0x53, 0x48, 0x41, 0x32, 0x35, 0x36, 0x10, 0x01, 0x42, 0x3d, 0x0a, 0x0e, 0x63, 0x6f, 0x6d,
	0x2e, 0x6e, 0x74, 0x74, 0x2e, 0x61, 0x70, 0x69, 0x2e, 0x70, 0x62, 0x50, 0x01, 0x5a, 0x29, 0x67,
	0x69, 0x74, 0x68, 0x75, 0x62, 0x2e, 0x63, 0x6f, 0x6d, 0x2f, 0x63, 0x6c, 0x6f, 0x75, 0x64, 0x77,
	0x61, 0x6e, 0x2f, 0x65, 0x64, 0x67, 0x65, 0x6c, 0x71, 0x2f, 0x63, 0x6f, 0x6d, 0x6d, 0x6f, 0x6e,
	0x2f, 0x61, 0x70, 0x69, 0x3b, 0x61, 0x70, 0x69, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
	edgelq_common_api_attestation_proto_rawDescOnce sync.Once
	edgelq_common_api_attestation_proto_rawDescData = edgelq_common_api_attestation_proto_rawDesc
)

func edgelq_common_api_attestation_proto_rawDescGZIP() []byte {
	edgelq_common_api_attestation_proto_rawDescOnce.Do(func() {
		edgelq_common_api_attestation_proto_rawDescData = protoimpl.X.CompressGZIP(edgelq_common_api_attestation_proto_rawDescData)
	})
	return edgelq_common_api_attestation_proto_rawDescData
}

var edgelq_common_api_attestation_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var edgelq_common_api_attestation_proto_msgTypes = make([]protoimpl.MessageInfo, 6)
var edgelq_common_api_attestation_proto_goTypes = []interface{}{
	(TpmVersion)(0),                          // 0: ntt.api.TpmVersion
	(DigestAlg)(0),                           // 1: ntt.api.DigestAlg
	(DeviceIdentity_ChallengeFormat)(0),      // 2: ntt.api.DeviceIdentity_ChallengeFormat
	(*DeviceIdentity)(nil),                   // 3: ntt.api.DeviceIdentity
	(*IdentityChallenge)(nil),                // 4: ntt.api.IdentityChallenge
	(*IdentityChallengeResponse)(nil),        // 5: ntt.api.IdentityChallengeResponse
	(*PCR)(nil),                              // 6: ntt.api.PCR
	(*DeviceIdentity_AttestationParams)(nil), // 7: ntt.api.DeviceIdentity.AttestationParams
	(*IdentityChallengeResponse_Quote)(nil),  // 8: ntt.api.IdentityChallengeResponse.Quote
}
var edgelq_common_api_attestation_proto_depIdxs = []int32{
	0, // 0: ntt.api.DeviceIdentity.tpm_version:type_name -> ntt.api.TpmVersion
	7, // 1: ntt.api.DeviceIdentity.ak_params:type_name -> ntt.api.DeviceIdentity.AttestationParams
	2, // 2: ntt.api.DeviceIdentity.challenge_format:type_name -> ntt.api.DeviceIdentity_ChallengeFormat
	8, // 3: ntt.api.IdentityChallengeResponse.quotes:type_name -> ntt.api.IdentityChallengeResponse.Quote
	6, // 4: ntt.api.IdentityChallengeResponse.pcrs:type_name -> ntt.api.PCR
	1, // 5: ntt.api.PCR.digest_alg:type_name -> ntt.api.DigestAlg
	6, // [6:6] is the sub-list for method output_type
	6, // [6:6] is the sub-list for method input_type
	6, // [6:6] is the sub-list for extension type_name
	6, // [6:6] is the sub-list for extension extendee
	0, // [0:6] is the sub-list for field type_name
}

func init() { edgelq_common_api_attestation_proto_init() }
func edgelq_common_api_attestation_proto_init() {
	if edgelq_common_api_attestation_proto != nil {
		return
	}
	if !protoimpl.UnsafeEnabled {

		edgelq_common_api_attestation_proto_msgTypes[0].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeviceIdentity); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_attestation_proto_msgTypes[1].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IdentityChallenge); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_attestation_proto_msgTypes[2].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IdentityChallengeResponse); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_attestation_proto_msgTypes[3].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*PCR); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_attestation_proto_msgTypes[4].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*DeviceIdentity_AttestationParams); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
		edgelq_common_api_attestation_proto_msgTypes[5].Exporter = func(v interface{}, i int) interface{} {
			switch v := v.(*IdentityChallengeResponse_Quote); i {
			case 0:
				return &v.state
			case 1:
				return &v.sizeCache
			case 2:
				return &v.unknownFields
			default:
				return nil
			}
		}
	}

	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: edgelq_common_api_attestation_proto_rawDesc,
			NumEnums:      3,
			NumMessages:   6,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           edgelq_common_api_attestation_proto_goTypes,
		DependencyIndexes: edgelq_common_api_attestation_proto_depIdxs,
		EnumInfos:         edgelq_common_api_attestation_proto_enumTypes,
		MessageInfos:      edgelq_common_api_attestation_proto_msgTypes,
	}.Build()
	edgelq_common_api_attestation_proto = out.File
	edgelq_common_api_attestation_proto_rawDesc = nil
	edgelq_common_api_attestation_proto_goTypes = nil
	edgelq_common_api_attestation_proto_depIdxs = nil
}
