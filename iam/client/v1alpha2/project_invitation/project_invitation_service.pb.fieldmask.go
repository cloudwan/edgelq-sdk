// Code generated by protoc-gen-goten-object
// File: edgelq/iam/proto/v1alpha2/project_invitation_service.proto
// DO NOT EDIT!!!

package project_invitation_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	project "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/project"
	project_invitation "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha2/project_invitation"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &project.Project{}
	_ = &project_invitation.ProjectInvitation{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetProjectInvitationRequest_FieldMask struct {
	Paths []GetProjectInvitationRequest_FieldPath
}

func FullGetProjectInvitationRequest_FieldMask() *GetProjectInvitationRequest_FieldMask {
	res := &GetProjectInvitationRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetProjectInvitationRequest_FieldTerminalPath{selector: GetProjectInvitationRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetProjectInvitationRequest_FieldTerminalPath{selector: GetProjectInvitationRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetProjectInvitationRequest_FieldTerminalPath{selector: GetProjectInvitationRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetProjectInvitationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetProjectInvitationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetProjectInvitationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetProjectInvitationRequest_FieldPath(raw)
	})
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetProjectInvitationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) Subtract(other *GetProjectInvitationRequest_FieldMask) *GetProjectInvitationRequest_FieldMask {
	result := &GetProjectInvitationRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetProjectInvitationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetProjectInvitationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetProjectInvitationRequest_FieldMask) FilterInputFields() *GetProjectInvitationRequest_FieldMask {
	result := &GetProjectInvitationRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetProjectInvitationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetProjectInvitationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetProjectInvitationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetProjectInvitationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetProjectInvitationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) AppendPath(path GetProjectInvitationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetProjectInvitationRequest_FieldPath))
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) GetPaths() []GetProjectInvitationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetProjectInvitationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) Set(target, source *GetProjectInvitationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetProjectInvitationRequest), source.(*GetProjectInvitationRequest))
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) Project(source *GetProjectInvitationRequest) *GetProjectInvitationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetProjectInvitationRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetProjectInvitationRequest_FieldTerminalPath:
			switch tp.selector {
			case GetProjectInvitationRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetProjectInvitationRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetProjectInvitationRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetProjectInvitationRequest))
}

func (fieldMask *GetProjectInvitationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProjectInvitationsRequest_FieldMask struct {
	Paths []BatchGetProjectInvitationsRequest_FieldPath
}

func FullBatchGetProjectInvitationsRequest_FieldMask() *BatchGetProjectInvitationsRequest_FieldMask {
	res := &BatchGetProjectInvitationsRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProjectInvitationsRequest_FieldTerminalPath{selector: BatchGetProjectInvitationsRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetProjectInvitationsRequest_FieldTerminalPath{selector: BatchGetProjectInvitationsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetProjectInvitationsRequest_FieldTerminalPath{selector: BatchGetProjectInvitationsRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProjectInvitationsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProjectInvitationsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProjectInvitationsRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) Subtract(other *BatchGetProjectInvitationsRequest_FieldMask) *BatchGetProjectInvitationsRequest_FieldMask {
	result := &BatchGetProjectInvitationsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProjectInvitationsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProjectInvitationsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) FilterInputFields() *BatchGetProjectInvitationsRequest_FieldMask {
	result := &BatchGetProjectInvitationsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProjectInvitationsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProjectInvitationsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProjectInvitationsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProjectInvitationsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) AppendPath(path BatchGetProjectInvitationsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProjectInvitationsRequest_FieldPath))
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) GetPaths() []BatchGetProjectInvitationsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProjectInvitationsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) Set(target, source *BatchGetProjectInvitationsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProjectInvitationsRequest), source.(*BatchGetProjectInvitationsRequest))
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) Project(source *BatchGetProjectInvitationsRequest) *BatchGetProjectInvitationsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProjectInvitationsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProjectInvitationsRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProjectInvitationsRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetProjectInvitationsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetProjectInvitationsRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProjectInvitationsRequest))
}

func (fieldMask *BatchGetProjectInvitationsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetProjectInvitationsResponse_FieldMask struct {
	Paths []BatchGetProjectInvitationsResponse_FieldPath
}

func FullBatchGetProjectInvitationsResponse_FieldMask() *BatchGetProjectInvitationsResponse_FieldMask {
	res := &BatchGetProjectInvitationsResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetProjectInvitationsResponse_FieldTerminalPath{selector: BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations})
	res.Paths = append(res.Paths, &BatchGetProjectInvitationsResponse_FieldTerminalPath{selector: BatchGetProjectInvitationsResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetProjectInvitationsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetProjectInvitationsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetProjectInvitationsResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) Subtract(other *BatchGetProjectInvitationsResponse_FieldMask) *BatchGetProjectInvitationsResponse_FieldMask {
	result := &BatchGetProjectInvitationsResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetProjectInvitationsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations: &project_invitation.ProjectInvitation_FieldMask{},
	}
	mySubMasks := map[BatchGetProjectInvitationsResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations: &project_invitation.ProjectInvitation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetProjectInvitationsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetProjectInvitationsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetProjectInvitationsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations:
						mySubMasks[BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations] = project_invitation.FullProjectInvitation_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetProjectInvitationsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetProjectInvitationsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetProjectInvitationsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) FilterInputFields() *BatchGetProjectInvitationsResponse_FieldMask {
	result := &BatchGetProjectInvitationsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations:
			if _, ok := path.(*BatchGetProjectInvitationsResponse_FieldTerminalPath); ok {
				for _, subpath := range project_invitation.FullProjectInvitation_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProjectInvitationsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetProjectInvitationsResponse_FieldSubPath); ok {
				selectedMask := &project_invitation.ProjectInvitation_FieldMask{
					Paths: []project_invitation.ProjectInvitation_FieldPath{sub.subPath.(project_invitation.ProjectInvitation_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetProjectInvitationsResponse_FieldSubPath{selector: BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetProjectInvitationsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetProjectInvitationsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetProjectInvitationsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetProjectInvitationsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) AppendPath(path BatchGetProjectInvitationsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetProjectInvitationsResponse_FieldPath))
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) GetPaths() []BatchGetProjectInvitationsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetProjectInvitationsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) Set(target, source *BatchGetProjectInvitationsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetProjectInvitationsResponse), source.(*BatchGetProjectInvitationsResponse))
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) Project(source *BatchGetProjectInvitationsResponse) *BatchGetProjectInvitationsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetProjectInvitationsResponse{}
	projectInvitationsMask := &project_invitation.ProjectInvitation_FieldMask{}
	wholeProjectInvitationsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetProjectInvitationsResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations:
				result.ProjectInvitations = source.ProjectInvitations
				wholeProjectInvitationsAccepted = true
			case BatchGetProjectInvitationsResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetProjectInvitationsResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetProjectInvitationsResponse_FieldPathSelectorProjectInvitations:
				projectInvitationsMask.AppendPath(tp.subPath.(project_invitation.ProjectInvitation_FieldPath))
			}
		}
	}
	if wholeProjectInvitationsAccepted == false && len(projectInvitationsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProjectInvitations() {
			result.ProjectInvitations = append(result.ProjectInvitations, projectInvitationsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetProjectInvitationsResponse))
}

func (fieldMask *BatchGetProjectInvitationsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProjectInvitationsRequest_FieldMask struct {
	Paths []ListProjectInvitationsRequest_FieldPath
}

func FullListProjectInvitationsRequest_FieldMask() *ListProjectInvitationsRequest_FieldMask {
	res := &ListProjectInvitationsRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListProjectInvitationsRequest_FieldTerminalPath{selector: ListProjectInvitationsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListProjectInvitationsRequest_FieldTerminalPath{selector: ListProjectInvitationsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListProjectInvitationsRequest_FieldTerminalPath{selector: ListProjectInvitationsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListProjectInvitationsRequest_FieldTerminalPath{selector: ListProjectInvitationsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListProjectInvitationsRequest_FieldTerminalPath{selector: ListProjectInvitationsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListProjectInvitationsRequest_FieldTerminalPath{selector: ListProjectInvitationsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListProjectInvitationsRequest_FieldTerminalPath{selector: ListProjectInvitationsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListProjectInvitationsRequest_FieldTerminalPath{selector: ListProjectInvitationsRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProjectInvitationsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProjectInvitationsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProjectInvitationsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProjectInvitationsRequest_FieldPath(raw)
	})
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) Subtract(other *ListProjectInvitationsRequest_FieldMask) *ListProjectInvitationsRequest_FieldMask {
	result := &ListProjectInvitationsRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProjectInvitationsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProjectInvitationsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProjectInvitationsRequest_FieldMask) FilterInputFields() *ListProjectInvitationsRequest_FieldMask {
	result := &ListProjectInvitationsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProjectInvitationsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProjectInvitationsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProjectInvitationsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProjectInvitationsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProjectInvitationsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) AppendPath(path ListProjectInvitationsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProjectInvitationsRequest_FieldPath))
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) GetPaths() []ListProjectInvitationsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProjectInvitationsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) Set(target, source *ListProjectInvitationsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProjectInvitationsRequest), source.(*ListProjectInvitationsRequest))
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) Project(source *ListProjectInvitationsRequest) *ListProjectInvitationsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProjectInvitationsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProjectInvitationsRequest_FieldTerminalPath:
			switch tp.selector {
			case ListProjectInvitationsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListProjectInvitationsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListProjectInvitationsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListProjectInvitationsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListProjectInvitationsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListProjectInvitationsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListProjectInvitationsRequest_FieldPathSelectorView:
				result.View = source.View
			case ListProjectInvitationsRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProjectInvitationsRequest))
}

func (fieldMask *ListProjectInvitationsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListProjectInvitationsResponse_FieldMask struct {
	Paths []ListProjectInvitationsResponse_FieldPath
}

func FullListProjectInvitationsResponse_FieldMask() *ListProjectInvitationsResponse_FieldMask {
	res := &ListProjectInvitationsResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListProjectInvitationsResponse_FieldTerminalPath{selector: ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations})
	res.Paths = append(res.Paths, &ListProjectInvitationsResponse_FieldTerminalPath{selector: ListProjectInvitationsResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListProjectInvitationsResponse_FieldTerminalPath{selector: ListProjectInvitationsResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListProjectInvitationsResponse_FieldTerminalPath{selector: ListProjectInvitationsResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListProjectInvitationsResponse_FieldTerminalPath{selector: ListProjectInvitationsResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListProjectInvitationsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListProjectInvitationsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListProjectInvitationsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListProjectInvitationsResponse_FieldPath(raw)
	})
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) Subtract(other *ListProjectInvitationsResponse_FieldMask) *ListProjectInvitationsResponse_FieldMask {
	result := &ListProjectInvitationsResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListProjectInvitationsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations: &project_invitation.ProjectInvitation_FieldMask{},
	}
	mySubMasks := map[ListProjectInvitationsResponse_FieldPathSelector]gotenobject.FieldMask{
		ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations: &project_invitation.ProjectInvitation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListProjectInvitationsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListProjectInvitationsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListProjectInvitationsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations:
						mySubMasks[ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations] = project_invitation.FullProjectInvitation_FieldMask()
					}
				} else if tp, ok := path.(*ListProjectInvitationsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListProjectInvitationsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListProjectInvitationsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListProjectInvitationsResponse_FieldMask) FilterInputFields() *ListProjectInvitationsResponse_FieldMask {
	result := &ListProjectInvitationsResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations:
			if _, ok := path.(*ListProjectInvitationsResponse_FieldTerminalPath); ok {
				for _, subpath := range project_invitation.FullProjectInvitation_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProjectInvitationsResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListProjectInvitationsResponse_FieldSubPath); ok {
				selectedMask := &project_invitation.ProjectInvitation_FieldMask{
					Paths: []project_invitation.ProjectInvitation_FieldPath{sub.subPath.(project_invitation.ProjectInvitation_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListProjectInvitationsResponse_FieldSubPath{selector: ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListProjectInvitationsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListProjectInvitationsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListProjectInvitationsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListProjectInvitationsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListProjectInvitationsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) AppendPath(path ListProjectInvitationsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListProjectInvitationsResponse_FieldPath))
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) GetPaths() []ListProjectInvitationsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListProjectInvitationsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) Set(target, source *ListProjectInvitationsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListProjectInvitationsResponse), source.(*ListProjectInvitationsResponse))
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) Project(source *ListProjectInvitationsResponse) *ListProjectInvitationsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListProjectInvitationsResponse{}
	projectInvitationsMask := &project_invitation.ProjectInvitation_FieldMask{}
	wholeProjectInvitationsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListProjectInvitationsResponse_FieldTerminalPath:
			switch tp.selector {
			case ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations:
				result.ProjectInvitations = source.ProjectInvitations
				wholeProjectInvitationsAccepted = true
			case ListProjectInvitationsResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListProjectInvitationsResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListProjectInvitationsResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListProjectInvitationsResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListProjectInvitationsResponse_FieldSubPath:
			switch tp.selector {
			case ListProjectInvitationsResponse_FieldPathSelectorProjectInvitations:
				projectInvitationsMask.AppendPath(tp.subPath.(project_invitation.ProjectInvitation_FieldPath))
			}
		}
	}
	if wholeProjectInvitationsAccepted == false && len(projectInvitationsMask.Paths) > 0 {
		for _, sourceItem := range source.GetProjectInvitations() {
			result.ProjectInvitations = append(result.ProjectInvitations, projectInvitationsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListProjectInvitationsResponse))
}

func (fieldMask *ListProjectInvitationsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProjectInvitationRequest_FieldMask struct {
	Paths []WatchProjectInvitationRequest_FieldPath
}

func FullWatchProjectInvitationRequest_FieldMask() *WatchProjectInvitationRequest_FieldMask {
	res := &WatchProjectInvitationRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProjectInvitationRequest_FieldTerminalPath{selector: WatchProjectInvitationRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchProjectInvitationRequest_FieldTerminalPath{selector: WatchProjectInvitationRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProjectInvitationRequest_FieldTerminalPath{selector: WatchProjectInvitationRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProjectInvitationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProjectInvitationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProjectInvitationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProjectInvitationRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) Subtract(other *WatchProjectInvitationRequest_FieldMask) *WatchProjectInvitationRequest_FieldMask {
	result := &WatchProjectInvitationRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProjectInvitationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProjectInvitationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProjectInvitationRequest_FieldMask) FilterInputFields() *WatchProjectInvitationRequest_FieldMask {
	result := &WatchProjectInvitationRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProjectInvitationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProjectInvitationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProjectInvitationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProjectInvitationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProjectInvitationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) AppendPath(path WatchProjectInvitationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProjectInvitationRequest_FieldPath))
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) GetPaths() []WatchProjectInvitationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProjectInvitationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) Set(target, source *WatchProjectInvitationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProjectInvitationRequest), source.(*WatchProjectInvitationRequest))
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) Project(source *WatchProjectInvitationRequest) *WatchProjectInvitationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProjectInvitationRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProjectInvitationRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProjectInvitationRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchProjectInvitationRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProjectInvitationRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProjectInvitationRequest))
}

func (fieldMask *WatchProjectInvitationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProjectInvitationResponse_FieldMask struct {
	Paths []WatchProjectInvitationResponse_FieldPath
}

func FullWatchProjectInvitationResponse_FieldMask() *WatchProjectInvitationResponse_FieldMask {
	res := &WatchProjectInvitationResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProjectInvitationResponse_FieldTerminalPath{selector: WatchProjectInvitationResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProjectInvitationResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProjectInvitationResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProjectInvitationResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProjectInvitationResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) Subtract(other *WatchProjectInvitationResponse_FieldMask) *WatchProjectInvitationResponse_FieldMask {
	result := &WatchProjectInvitationResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProjectInvitationResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProjectInvitationResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProjectInvitationResponse_FieldMask) FilterInputFields() *WatchProjectInvitationResponse_FieldMask {
	result := &WatchProjectInvitationResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProjectInvitationResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProjectInvitationResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProjectInvitationResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProjectInvitationResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProjectInvitationResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) AppendPath(path WatchProjectInvitationResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProjectInvitationResponse_FieldPath))
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) GetPaths() []WatchProjectInvitationResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProjectInvitationResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) Set(target, source *WatchProjectInvitationResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProjectInvitationResponse), source.(*WatchProjectInvitationResponse))
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) Project(source *WatchProjectInvitationResponse) *WatchProjectInvitationResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProjectInvitationResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProjectInvitationResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProjectInvitationResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProjectInvitationResponse))
}

func (fieldMask *WatchProjectInvitationResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProjectInvitationsRequest_FieldMask struct {
	Paths []WatchProjectInvitationsRequest_FieldPath
}

func FullWatchProjectInvitationsRequest_FieldMask() *WatchProjectInvitationsRequest_FieldMask {
	res := &WatchProjectInvitationsRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchProjectInvitationsRequest_FieldTerminalPath{selector: WatchProjectInvitationsRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProjectInvitationsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProjectInvitationsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProjectInvitationsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProjectInvitationsRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) Subtract(other *WatchProjectInvitationsRequest_FieldMask) *WatchProjectInvitationsRequest_FieldMask {
	result := &WatchProjectInvitationsRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProjectInvitationsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProjectInvitationsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProjectInvitationsRequest_FieldMask) FilterInputFields() *WatchProjectInvitationsRequest_FieldMask {
	result := &WatchProjectInvitationsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProjectInvitationsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProjectInvitationsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProjectInvitationsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProjectInvitationsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProjectInvitationsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) AppendPath(path WatchProjectInvitationsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProjectInvitationsRequest_FieldPath))
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) GetPaths() []WatchProjectInvitationsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProjectInvitationsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) Set(target, source *WatchProjectInvitationsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProjectInvitationsRequest), source.(*WatchProjectInvitationsRequest))
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) Project(source *WatchProjectInvitationsRequest) *WatchProjectInvitationsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProjectInvitationsRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProjectInvitationsRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchProjectInvitationsRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchProjectInvitationsRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchProjectInvitationsRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchProjectInvitationsRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchProjectInvitationsRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchProjectInvitationsRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProjectInvitationsRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchProjectInvitationsRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchProjectInvitationsRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchProjectInvitationsRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchProjectInvitationsRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProjectInvitationsRequest))
}

func (fieldMask *WatchProjectInvitationsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProjectInvitationsResponse_FieldMask struct {
	Paths []WatchProjectInvitationsResponse_FieldPath
}

func FullWatchProjectInvitationsResponse_FieldMask() *WatchProjectInvitationsResponse_FieldMask {
	res := &WatchProjectInvitationsResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponse_FieldTerminalPath{selector: WatchProjectInvitationsResponse_FieldPathSelectorProjectInvitationChanges})
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponse_FieldTerminalPath{selector: WatchProjectInvitationsResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponse_FieldTerminalPath{selector: WatchProjectInvitationsResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponse_FieldTerminalPath{selector: WatchProjectInvitationsResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponse_FieldTerminalPath{selector: WatchProjectInvitationsResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponse_FieldTerminalPath{selector: WatchProjectInvitationsResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponse_FieldTerminalPath{selector: WatchProjectInvitationsResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProjectInvitationsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProjectInvitationsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProjectInvitationsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProjectInvitationsResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) Subtract(other *WatchProjectInvitationsResponse_FieldMask) *WatchProjectInvitationsResponse_FieldMask {
	result := &WatchProjectInvitationsResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchProjectInvitationsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProjectInvitationsResponse_FieldPathSelectorPageTokenChange: &WatchProjectInvitationsResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchProjectInvitationsResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchProjectInvitationsResponse_FieldPathSelectorPageTokenChange: &WatchProjectInvitationsResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProjectInvitationsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchProjectInvitationsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchProjectInvitationsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchProjectInvitationsResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchProjectInvitationsResponse_FieldPathSelectorPageTokenChange] = FullWatchProjectInvitationsResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchProjectInvitationsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchProjectInvitationsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProjectInvitationsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProjectInvitationsResponse_FieldMask) FilterInputFields() *WatchProjectInvitationsResponse_FieldMask {
	result := &WatchProjectInvitationsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProjectInvitationsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProjectInvitationsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProjectInvitationsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProjectInvitationsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProjectInvitationsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) AppendPath(path WatchProjectInvitationsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProjectInvitationsResponse_FieldPath))
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) GetPaths() []WatchProjectInvitationsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProjectInvitationsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) Set(target, source *WatchProjectInvitationsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProjectInvitationsResponse), source.(*WatchProjectInvitationsResponse))
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) Project(source *WatchProjectInvitationsResponse) *WatchProjectInvitationsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProjectInvitationsResponse{}
	pageTokenChangeMask := &WatchProjectInvitationsResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProjectInvitationsResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchProjectInvitationsResponse_FieldPathSelectorProjectInvitationChanges:
				result.ProjectInvitationChanges = source.ProjectInvitationChanges
			case WatchProjectInvitationsResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchProjectInvitationsResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchProjectInvitationsResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchProjectInvitationsResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchProjectInvitationsResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchProjectInvitationsResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchProjectInvitationsResponse_FieldSubPath:
			switch tp.selector {
			case WatchProjectInvitationsResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchProjectInvitationsResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProjectInvitationsResponse))
}

func (fieldMask *WatchProjectInvitationsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchProjectInvitationsResponse_PageTokenChange_FieldMask struct {
	Paths []WatchProjectInvitationsResponsePageTokenChange_FieldPath
}

func FullWatchProjectInvitationsResponse_PageTokenChange_FieldMask() *WatchProjectInvitationsResponse_PageTokenChange_FieldMask {
	res := &WatchProjectInvitationsResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponsePageTokenChange_FieldTerminalPath{selector: WatchProjectInvitationsResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchProjectInvitationsResponsePageTokenChange_FieldTerminalPath{selector: WatchProjectInvitationsResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchProjectInvitationsResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchProjectInvitationsResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchProjectInvitationsResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) Subtract(other *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) *WatchProjectInvitationsResponse_PageTokenChange_FieldMask {
	result := &WatchProjectInvitationsResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchProjectInvitationsResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchProjectInvitationsResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchProjectInvitationsResponse_PageTokenChange_FieldMask {
	result := &WatchProjectInvitationsResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchProjectInvitationsResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchProjectInvitationsResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchProjectInvitationsResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchProjectInvitationsResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) AppendPath(path WatchProjectInvitationsResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchProjectInvitationsResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) GetPaths() []WatchProjectInvitationsResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchProjectInvitationsResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) Set(target, source *WatchProjectInvitationsResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchProjectInvitationsResponse_PageTokenChange), source.(*WatchProjectInvitationsResponse_PageTokenChange))
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) Project(source *WatchProjectInvitationsResponse_PageTokenChange) *WatchProjectInvitationsResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchProjectInvitationsResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchProjectInvitationsResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchProjectInvitationsResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchProjectInvitationsResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchProjectInvitationsResponse_PageTokenChange))
}

func (fieldMask *WatchProjectInvitationsResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateProjectInvitationRequest_FieldMask struct {
	Paths []CreateProjectInvitationRequest_FieldPath
}

func FullCreateProjectInvitationRequest_FieldMask() *CreateProjectInvitationRequest_FieldMask {
	res := &CreateProjectInvitationRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateProjectInvitationRequest_FieldTerminalPath{selector: CreateProjectInvitationRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateProjectInvitationRequest_FieldTerminalPath{selector: CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation})
	return res
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateProjectInvitationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateProjectInvitationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateProjectInvitationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateProjectInvitationRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) Subtract(other *CreateProjectInvitationRequest_FieldMask) *CreateProjectInvitationRequest_FieldMask {
	result := &CreateProjectInvitationRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateProjectInvitationRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation: &project_invitation.ProjectInvitation_FieldMask{},
	}
	mySubMasks := map[CreateProjectInvitationRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation: &project_invitation.ProjectInvitation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateProjectInvitationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateProjectInvitationRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateProjectInvitationRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation:
						mySubMasks[CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation] = project_invitation.FullProjectInvitation_FieldMask()
					}
				} else if tp, ok := path.(*CreateProjectInvitationRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateProjectInvitationRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateProjectInvitationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateProjectInvitationRequest_FieldMask) FilterInputFields() *CreateProjectInvitationRequest_FieldMask {
	result := &CreateProjectInvitationRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation:
			if _, ok := path.(*CreateProjectInvitationRequest_FieldTerminalPath); ok {
				for _, subpath := range project_invitation.FullProjectInvitation_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProjectInvitationRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateProjectInvitationRequest_FieldSubPath); ok {
				selectedMask := &project_invitation.ProjectInvitation_FieldMask{
					Paths: []project_invitation.ProjectInvitation_FieldPath{sub.subPath.(project_invitation.ProjectInvitation_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateProjectInvitationRequest_FieldSubPath{selector: CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateProjectInvitationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateProjectInvitationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateProjectInvitationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateProjectInvitationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateProjectInvitationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) AppendPath(path CreateProjectInvitationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateProjectInvitationRequest_FieldPath))
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) GetPaths() []CreateProjectInvitationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateProjectInvitationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) Set(target, source *CreateProjectInvitationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateProjectInvitationRequest), source.(*CreateProjectInvitationRequest))
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) Project(source *CreateProjectInvitationRequest) *CreateProjectInvitationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateProjectInvitationRequest{}
	projectInvitationMask := &project_invitation.ProjectInvitation_FieldMask{}
	wholeProjectInvitationAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateProjectInvitationRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateProjectInvitationRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation:
				result.ProjectInvitation = source.ProjectInvitation
				wholeProjectInvitationAccepted = true
			}
		case *CreateProjectInvitationRequest_FieldSubPath:
			switch tp.selector {
			case CreateProjectInvitationRequest_FieldPathSelectorProjectInvitation:
				projectInvitationMask.AppendPath(tp.subPath.(project_invitation.ProjectInvitation_FieldPath))
			}
		}
	}
	if wholeProjectInvitationAccepted == false && len(projectInvitationMask.Paths) > 0 {
		result.ProjectInvitation = projectInvitationMask.Project(source.GetProjectInvitation())
	}
	return result
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateProjectInvitationRequest))
}

func (fieldMask *CreateProjectInvitationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProjectInvitationRequest_FieldMask struct {
	Paths []UpdateProjectInvitationRequest_FieldPath
}

func FullUpdateProjectInvitationRequest_FieldMask() *UpdateProjectInvitationRequest_FieldMask {
	res := &UpdateProjectInvitationRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProjectInvitationRequest_FieldTerminalPath{selector: UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation})
	res.Paths = append(res.Paths, &UpdateProjectInvitationRequest_FieldTerminalPath{selector: UpdateProjectInvitationRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateProjectInvitationRequest_FieldTerminalPath{selector: UpdateProjectInvitationRequest_FieldPathSelectorCas})
	res.Paths = append(res.Paths, &UpdateProjectInvitationRequest_FieldTerminalPath{selector: UpdateProjectInvitationRequest_FieldPathSelectorAllowMissing})
	return res
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProjectInvitationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProjectInvitationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 4)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProjectInvitationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProjectInvitationRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) Subtract(other *UpdateProjectInvitationRequest_FieldMask) *UpdateProjectInvitationRequest_FieldMask {
	result := &UpdateProjectInvitationRequest_FieldMask{}
	removedSelectors := make([]bool, 4)
	otherSubMasks := map[UpdateProjectInvitationRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation: &project_invitation.ProjectInvitation_FieldMask{},
		UpdateProjectInvitationRequest_FieldPathSelectorCas:               &UpdateProjectInvitationRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateProjectInvitationRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation: &project_invitation.ProjectInvitation_FieldMask{},
		UpdateProjectInvitationRequest_FieldPathSelectorCas:               &UpdateProjectInvitationRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProjectInvitationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProjectInvitationRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProjectInvitationRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation:
						mySubMasks[UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation] = project_invitation.FullProjectInvitation_FieldMask()
					case UpdateProjectInvitationRequest_FieldPathSelectorCas:
						mySubMasks[UpdateProjectInvitationRequest_FieldPathSelectorCas] = FullUpdateProjectInvitationRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProjectInvitationRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProjectInvitationRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProjectInvitationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProjectInvitationRequest_FieldMask) FilterInputFields() *UpdateProjectInvitationRequest_FieldMask {
	result := &UpdateProjectInvitationRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation:
			if _, ok := path.(*UpdateProjectInvitationRequest_FieldTerminalPath); ok {
				for _, subpath := range project_invitation.FullProjectInvitation_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProjectInvitationRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProjectInvitationRequest_FieldSubPath); ok {
				selectedMask := &project_invitation.ProjectInvitation_FieldMask{
					Paths: []project_invitation.ProjectInvitation_FieldPath{sub.subPath.(project_invitation.ProjectInvitation_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProjectInvitationRequest_FieldSubPath{selector: UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation, subPath: allowedPath})
				}
			}
		case UpdateProjectInvitationRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateProjectInvitationRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateProjectInvitationRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProjectInvitationRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProjectInvitationRequest_FieldSubPath); ok {
				selectedMask := &UpdateProjectInvitationRequest_CAS_FieldMask{
					Paths: []UpdateProjectInvitationRequestCAS_FieldPath{sub.subPath.(UpdateProjectInvitationRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProjectInvitationRequest_FieldSubPath{selector: UpdateProjectInvitationRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProjectInvitationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProjectInvitationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProjectInvitationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProjectInvitationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProjectInvitationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) AppendPath(path UpdateProjectInvitationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProjectInvitationRequest_FieldPath))
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) GetPaths() []UpdateProjectInvitationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProjectInvitationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) Set(target, source *UpdateProjectInvitationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProjectInvitationRequest), source.(*UpdateProjectInvitationRequest))
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) Project(source *UpdateProjectInvitationRequest) *UpdateProjectInvitationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProjectInvitationRequest{}
	projectInvitationMask := &project_invitation.ProjectInvitation_FieldMask{}
	wholeProjectInvitationAccepted := false
	casMask := &UpdateProjectInvitationRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProjectInvitationRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation:
				result.ProjectInvitation = source.ProjectInvitation
				wholeProjectInvitationAccepted = true
			case UpdateProjectInvitationRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateProjectInvitationRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			case UpdateProjectInvitationRequest_FieldPathSelectorAllowMissing:
				result.AllowMissing = source.AllowMissing
			}
		case *UpdateProjectInvitationRequest_FieldSubPath:
			switch tp.selector {
			case UpdateProjectInvitationRequest_FieldPathSelectorProjectInvitation:
				projectInvitationMask.AppendPath(tp.subPath.(project_invitation.ProjectInvitation_FieldPath))
			case UpdateProjectInvitationRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateProjectInvitationRequestCAS_FieldPath))
			}
		}
	}
	if wholeProjectInvitationAccepted == false && len(projectInvitationMask.Paths) > 0 {
		result.ProjectInvitation = projectInvitationMask.Project(source.GetProjectInvitation())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProjectInvitationRequest))
}

func (fieldMask *UpdateProjectInvitationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateProjectInvitationRequest_CAS_FieldMask struct {
	Paths []UpdateProjectInvitationRequestCAS_FieldPath
}

func FullUpdateProjectInvitationRequest_CAS_FieldMask() *UpdateProjectInvitationRequest_CAS_FieldMask {
	res := &UpdateProjectInvitationRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateProjectInvitationRequestCAS_FieldTerminalPath{selector: UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateProjectInvitationRequestCAS_FieldTerminalPath{selector: UpdateProjectInvitationRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateProjectInvitationRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateProjectInvitationRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateProjectInvitationRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) Subtract(other *UpdateProjectInvitationRequest_CAS_FieldMask) *UpdateProjectInvitationRequest_CAS_FieldMask {
	result := &UpdateProjectInvitationRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateProjectInvitationRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState: &project_invitation.ProjectInvitation_FieldMask{},
	}
	mySubMasks := map[UpdateProjectInvitationRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState: &project_invitation.ProjectInvitation_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateProjectInvitationRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateProjectInvitationRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateProjectInvitationRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState] = project_invitation.FullProjectInvitation_FieldMask()
					}
				} else if tp, ok := path.(*UpdateProjectInvitationRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateProjectInvitationRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateProjectInvitationRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) FilterInputFields() *UpdateProjectInvitationRequest_CAS_FieldMask {
	result := &UpdateProjectInvitationRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateProjectInvitationRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range project_invitation.FullProjectInvitation_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProjectInvitationRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateProjectInvitationRequestCAS_FieldSubPath); ok {
				selectedMask := &project_invitation.ProjectInvitation_FieldMask{
					Paths: []project_invitation.ProjectInvitation_FieldPath{sub.subPath.(project_invitation.ProjectInvitation_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateProjectInvitationRequestCAS_FieldSubPath{selector: UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateProjectInvitationRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateProjectInvitationRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateProjectInvitationRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateProjectInvitationRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) AppendPath(path UpdateProjectInvitationRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateProjectInvitationRequestCAS_FieldPath))
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) GetPaths() []UpdateProjectInvitationRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateProjectInvitationRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) Set(target, source *UpdateProjectInvitationRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateProjectInvitationRequest_CAS), source.(*UpdateProjectInvitationRequest_CAS))
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) Project(source *UpdateProjectInvitationRequest_CAS) *UpdateProjectInvitationRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateProjectInvitationRequest_CAS{}
	conditionalStateMask := &project_invitation.ProjectInvitation_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateProjectInvitationRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateProjectInvitationRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateProjectInvitationRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateProjectInvitationRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(project_invitation.ProjectInvitation_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateProjectInvitationRequest_CAS))
}

func (fieldMask *UpdateProjectInvitationRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteProjectInvitationRequest_FieldMask struct {
	Paths []DeleteProjectInvitationRequest_FieldPath
}

func FullDeleteProjectInvitationRequest_FieldMask() *DeleteProjectInvitationRequest_FieldMask {
	res := &DeleteProjectInvitationRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteProjectInvitationRequest_FieldTerminalPath{selector: DeleteProjectInvitationRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteProjectInvitationRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteProjectInvitationRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteProjectInvitationRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteProjectInvitationRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) Subtract(other *DeleteProjectInvitationRequest_FieldMask) *DeleteProjectInvitationRequest_FieldMask {
	result := &DeleteProjectInvitationRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteProjectInvitationRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteProjectInvitationRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteProjectInvitationRequest_FieldMask) FilterInputFields() *DeleteProjectInvitationRequest_FieldMask {
	result := &DeleteProjectInvitationRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteProjectInvitationRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteProjectInvitationRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteProjectInvitationRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteProjectInvitationRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteProjectInvitationRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) AppendPath(path DeleteProjectInvitationRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteProjectInvitationRequest_FieldPath))
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) GetPaths() []DeleteProjectInvitationRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteProjectInvitationRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) Set(target, source *DeleteProjectInvitationRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteProjectInvitationRequest), source.(*DeleteProjectInvitationRequest))
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) Project(source *DeleteProjectInvitationRequest) *DeleteProjectInvitationRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteProjectInvitationRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteProjectInvitationRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteProjectInvitationRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteProjectInvitationRequest))
}

func (fieldMask *DeleteProjectInvitationRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
