// Code generated by protoc-gen-goten-object
// File: edgelq/iam/proto/v1alpha/authorization_custom.proto
// DO NOT EDIT!!!

package authorization_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	condition "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha/condition"
	permission "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha/permission"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &condition.Condition{}
	_ = &permission.Permission{}
)

type Check_FieldMask struct {
	Paths []Check_FieldPath
}

func FullCheck_FieldMask() *Check_FieldMask {
	res := &Check_FieldMask{}
	res.Paths = append(res.Paths, &Check_FieldTerminalPath{selector: Check_FieldPathSelectorObject})
	res.Paths = append(res.Paths, &Check_FieldTerminalPath{selector: Check_FieldPathSelectorPermissions})
	return res
}

func (fieldMask *Check_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *Check_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *Check_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCheck_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *Check_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*Check_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *Check_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCheck_FieldPath(raw)
	})
}

func (fieldMask *Check_FieldMask) ProtoMessage() {}

func (fieldMask *Check_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *Check_FieldMask) Subtract(other *Check_FieldMask) *Check_FieldMask {
	result := &Check_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *Check_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *Check_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*Check_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *Check_FieldMask) FilterInputFields() *Check_FieldMask {
	result := &Check_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *Check_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *Check_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]Check_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCheck_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask Check_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *Check_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Check_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask Check_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *Check_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *Check_FieldMask) AppendPath(path Check_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *Check_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(Check_FieldPath))
}

func (fieldMask *Check_FieldMask) GetPaths() []Check_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *Check_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *Check_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCheck_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *Check_FieldMask) Set(target, source *Check) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *Check_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*Check), source.(*Check))
}

func (fieldMask *Check_FieldMask) Project(source *Check) *Check {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &Check{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *Check_FieldTerminalPath:
			switch tp.selector {
			case Check_FieldPathSelectorObject:
				result.Object = source.Object
			case Check_FieldPathSelectorPermissions:
				result.Permissions = source.Permissions
			}
		}
	}
	return result
}

func (fieldMask *Check_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*Check))
}

func (fieldMask *Check_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ConditionalGrant_FieldMask struct {
	Paths []ConditionalGrant_FieldPath
}

func FullConditionalGrant_FieldMask() *ConditionalGrant_FieldMask {
	res := &ConditionalGrant_FieldMask{}
	res.Paths = append(res.Paths, &ConditionalGrant_FieldTerminalPath{selector: ConditionalGrant_FieldPathSelectorPermissions})
	res.Paths = append(res.Paths, &ConditionalGrant_FieldTerminalPath{selector: ConditionalGrant_FieldPathSelectorConditionBindings})
	return res
}

func (fieldMask *ConditionalGrant_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ConditionalGrant_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ConditionalGrant_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseConditionalGrant_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ConditionalGrant_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ConditionalGrant_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ConditionalGrant_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseConditionalGrant_FieldPath(raw)
	})
}

func (fieldMask *ConditionalGrant_FieldMask) ProtoMessage() {}

func (fieldMask *ConditionalGrant_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ConditionalGrant_FieldMask) Subtract(other *ConditionalGrant_FieldMask) *ConditionalGrant_FieldMask {
	result := &ConditionalGrant_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[ConditionalGrant_FieldPathSelector]gotenobject.FieldMask{
		ConditionalGrant_FieldPathSelectorConditionBindings: &condition.ConditionBinding_FieldMask{},
	}
	mySubMasks := map[ConditionalGrant_FieldPathSelector]gotenobject.FieldMask{
		ConditionalGrant_FieldPathSelectorConditionBindings: &condition.ConditionBinding_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ConditionalGrant_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ConditionalGrant_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ConditionalGrant_FieldTerminalPath); ok {
					switch tp.selector {
					case ConditionalGrant_FieldPathSelectorConditionBindings:
						mySubMasks[ConditionalGrant_FieldPathSelectorConditionBindings] = condition.FullConditionBinding_FieldMask()
					}
				} else if tp, ok := path.(*ConditionalGrant_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ConditionalGrant_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ConditionalGrant_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ConditionalGrant_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ConditionalGrant_FieldMask) FilterInputFields() *ConditionalGrant_FieldMask {
	result := &ConditionalGrant_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ConditionalGrant_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ConditionalGrant_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ConditionalGrant_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseConditionalGrant_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ConditionalGrant_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ConditionalGrant_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConditionalGrant_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ConditionalGrant_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ConditionalGrant_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ConditionalGrant_FieldMask) AppendPath(path ConditionalGrant_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ConditionalGrant_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ConditionalGrant_FieldPath))
}

func (fieldMask *ConditionalGrant_FieldMask) GetPaths() []ConditionalGrant_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ConditionalGrant_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ConditionalGrant_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseConditionalGrant_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ConditionalGrant_FieldMask) Set(target, source *ConditionalGrant) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ConditionalGrant_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ConditionalGrant), source.(*ConditionalGrant))
}

func (fieldMask *ConditionalGrant_FieldMask) Project(source *ConditionalGrant) *ConditionalGrant {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ConditionalGrant{}
	conditionBindingsMask := &condition.ConditionBinding_FieldMask{}
	wholeConditionBindingsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ConditionalGrant_FieldTerminalPath:
			switch tp.selector {
			case ConditionalGrant_FieldPathSelectorPermissions:
				result.Permissions = source.Permissions
			case ConditionalGrant_FieldPathSelectorConditionBindings:
				result.ConditionBindings = source.ConditionBindings
				wholeConditionBindingsAccepted = true
			}
		case *ConditionalGrant_FieldSubPath:
			switch tp.selector {
			case ConditionalGrant_FieldPathSelectorConditionBindings:
				conditionBindingsMask.AppendPath(tp.subPath.(condition.ConditionBinding_FieldPath))
			}
		}
	}
	if wholeConditionBindingsAccepted == false && len(conditionBindingsMask.Paths) > 0 {
		for _, sourceItem := range source.GetConditionBindings() {
			result.ConditionBindings = append(result.ConditionBindings, conditionBindingsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ConditionalGrant_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ConditionalGrant))
}

func (fieldMask *ConditionalGrant_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CheckResult_FieldMask struct {
	Paths []CheckResult_FieldPath
}

func FullCheckResult_FieldMask() *CheckResult_FieldMask {
	res := &CheckResult_FieldMask{}
	res.Paths = append(res.Paths, &CheckResult_FieldTerminalPath{selector: CheckResult_FieldPathSelectorObject})
	res.Paths = append(res.Paths, &CheckResult_FieldTerminalPath{selector: CheckResult_FieldPathSelectorGrantedPermissions})
	res.Paths = append(res.Paths, &CheckResult_FieldTerminalPath{selector: CheckResult_FieldPathSelectorConditionallyGrantedPermissions})
	return res
}

func (fieldMask *CheckResult_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CheckResult_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CheckResult_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCheckResult_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CheckResult_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CheckResult_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CheckResult_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCheckResult_FieldPath(raw)
	})
}

func (fieldMask *CheckResult_FieldMask) ProtoMessage() {}

func (fieldMask *CheckResult_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CheckResult_FieldMask) Subtract(other *CheckResult_FieldMask) *CheckResult_FieldMask {
	result := &CheckResult_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[CheckResult_FieldPathSelector]gotenobject.FieldMask{
		CheckResult_FieldPathSelectorConditionallyGrantedPermissions: &ConditionalGrant_FieldMask{},
	}
	mySubMasks := map[CheckResult_FieldPathSelector]gotenobject.FieldMask{
		CheckResult_FieldPathSelectorConditionallyGrantedPermissions: &ConditionalGrant_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CheckResult_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CheckResult_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CheckResult_FieldTerminalPath); ok {
					switch tp.selector {
					case CheckResult_FieldPathSelectorConditionallyGrantedPermissions:
						mySubMasks[CheckResult_FieldPathSelectorConditionallyGrantedPermissions] = FullConditionalGrant_FieldMask()
					}
				} else if tp, ok := path.(*CheckResult_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CheckResult_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CheckResult_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CheckResult_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CheckResult_FieldMask) FilterInputFields() *CheckResult_FieldMask {
	result := &CheckResult_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CheckResult_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CheckResult_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CheckResult_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCheckResult_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CheckResult_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CheckResult_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckResult_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CheckResult_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CheckResult_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckResult_FieldMask) AppendPath(path CheckResult_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CheckResult_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CheckResult_FieldPath))
}

func (fieldMask *CheckResult_FieldMask) GetPaths() []CheckResult_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CheckResult_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CheckResult_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCheckResult_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CheckResult_FieldMask) Set(target, source *CheckResult) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CheckResult_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CheckResult), source.(*CheckResult))
}

func (fieldMask *CheckResult_FieldMask) Project(source *CheckResult) *CheckResult {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CheckResult{}
	conditionallyGrantedPermissionsMask := &ConditionalGrant_FieldMask{}
	wholeConditionallyGrantedPermissionsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CheckResult_FieldTerminalPath:
			switch tp.selector {
			case CheckResult_FieldPathSelectorObject:
				result.Object = source.Object
			case CheckResult_FieldPathSelectorGrantedPermissions:
				result.GrantedPermissions = source.GrantedPermissions
			case CheckResult_FieldPathSelectorConditionallyGrantedPermissions:
				result.ConditionallyGrantedPermissions = source.ConditionallyGrantedPermissions
				wholeConditionallyGrantedPermissionsAccepted = true
			}
		case *CheckResult_FieldSubPath:
			switch tp.selector {
			case CheckResult_FieldPathSelectorConditionallyGrantedPermissions:
				conditionallyGrantedPermissionsMask.AppendPath(tp.subPath.(ConditionalGrant_FieldPath))
			}
		}
	}
	if wholeConditionallyGrantedPermissionsAccepted == false && len(conditionallyGrantedPermissionsMask.Paths) > 0 {
		for _, sourceItem := range source.GetConditionallyGrantedPermissions() {
			result.ConditionallyGrantedPermissions = append(result.ConditionallyGrantedPermissions, conditionallyGrantedPermissionsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *CheckResult_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CheckResult))
}

func (fieldMask *CheckResult_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CheckPermissionsRequest_FieldMask struct {
	Paths []CheckPermissionsRequest_FieldPath
}

func FullCheckPermissionsRequest_FieldMask() *CheckPermissionsRequest_FieldMask {
	res := &CheckPermissionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &CheckPermissionsRequest_FieldTerminalPath{selector: CheckPermissionsRequest_FieldPathSelectorMember})
	res.Paths = append(res.Paths, &CheckPermissionsRequest_FieldTerminalPath{selector: CheckPermissionsRequest_FieldPathSelectorChecks})
	res.Paths = append(res.Paths, &CheckPermissionsRequest_FieldTerminalPath{selector: CheckPermissionsRequest_FieldPathSelectorSkipCache})
	return res
}

func (fieldMask *CheckPermissionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CheckPermissionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CheckPermissionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCheckPermissionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CheckPermissionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CheckPermissionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CheckPermissionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCheckPermissionsRequest_FieldPath(raw)
	})
}

func (fieldMask *CheckPermissionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CheckPermissionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CheckPermissionsRequest_FieldMask) Subtract(other *CheckPermissionsRequest_FieldMask) *CheckPermissionsRequest_FieldMask {
	result := &CheckPermissionsRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[CheckPermissionsRequest_FieldPathSelector]gotenobject.FieldMask{
		CheckPermissionsRequest_FieldPathSelectorChecks: &Check_FieldMask{},
	}
	mySubMasks := map[CheckPermissionsRequest_FieldPathSelector]gotenobject.FieldMask{
		CheckPermissionsRequest_FieldPathSelectorChecks: &Check_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CheckPermissionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CheckPermissionsRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CheckPermissionsRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CheckPermissionsRequest_FieldPathSelectorChecks:
						mySubMasks[CheckPermissionsRequest_FieldPathSelectorChecks] = FullCheck_FieldMask()
					}
				} else if tp, ok := path.(*CheckPermissionsRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CheckPermissionsRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CheckPermissionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CheckPermissionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CheckPermissionsRequest_FieldMask) FilterInputFields() *CheckPermissionsRequest_FieldMask {
	result := &CheckPermissionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CheckPermissionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CheckPermissionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CheckPermissionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCheckPermissionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CheckPermissionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CheckPermissionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckPermissionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CheckPermissionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CheckPermissionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckPermissionsRequest_FieldMask) AppendPath(path CheckPermissionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CheckPermissionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CheckPermissionsRequest_FieldPath))
}

func (fieldMask *CheckPermissionsRequest_FieldMask) GetPaths() []CheckPermissionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CheckPermissionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CheckPermissionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCheckPermissionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CheckPermissionsRequest_FieldMask) Set(target, source *CheckPermissionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CheckPermissionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CheckPermissionsRequest), source.(*CheckPermissionsRequest))
}

func (fieldMask *CheckPermissionsRequest_FieldMask) Project(source *CheckPermissionsRequest) *CheckPermissionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CheckPermissionsRequest{}
	checksMask := &Check_FieldMask{}
	wholeChecksAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CheckPermissionsRequest_FieldTerminalPath:
			switch tp.selector {
			case CheckPermissionsRequest_FieldPathSelectorMember:
				result.Member = source.Member
			case CheckPermissionsRequest_FieldPathSelectorChecks:
				result.Checks = source.Checks
				wholeChecksAccepted = true
			case CheckPermissionsRequest_FieldPathSelectorSkipCache:
				result.SkipCache = source.SkipCache
			}
		case *CheckPermissionsRequest_FieldSubPath:
			switch tp.selector {
			case CheckPermissionsRequest_FieldPathSelectorChecks:
				checksMask.AppendPath(tp.subPath.(Check_FieldPath))
			}
		}
	}
	if wholeChecksAccepted == false && len(checksMask.Paths) > 0 {
		for _, sourceItem := range source.GetChecks() {
			result.Checks = append(result.Checks, checksMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *CheckPermissionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CheckPermissionsRequest))
}

func (fieldMask *CheckPermissionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CheckPermissionsResponse_FieldMask struct {
	Paths []CheckPermissionsResponse_FieldPath
}

func FullCheckPermissionsResponse_FieldMask() *CheckPermissionsResponse_FieldMask {
	res := &CheckPermissionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &CheckPermissionsResponse_FieldTerminalPath{selector: CheckPermissionsResponse_FieldPathSelectorCheckResults})
	return res
}

func (fieldMask *CheckPermissionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CheckPermissionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CheckPermissionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCheckPermissionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CheckPermissionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CheckPermissionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CheckPermissionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCheckPermissionsResponse_FieldPath(raw)
	})
}

func (fieldMask *CheckPermissionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *CheckPermissionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CheckPermissionsResponse_FieldMask) Subtract(other *CheckPermissionsResponse_FieldMask) *CheckPermissionsResponse_FieldMask {
	result := &CheckPermissionsResponse_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[CheckPermissionsResponse_FieldPathSelector]gotenobject.FieldMask{
		CheckPermissionsResponse_FieldPathSelectorCheckResults: &CheckResult_FieldMask{},
	}
	mySubMasks := map[CheckPermissionsResponse_FieldPathSelector]gotenobject.FieldMask{
		CheckPermissionsResponse_FieldPathSelectorCheckResults: &CheckResult_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CheckPermissionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CheckPermissionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CheckPermissionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case CheckPermissionsResponse_FieldPathSelectorCheckResults:
						mySubMasks[CheckPermissionsResponse_FieldPathSelectorCheckResults] = FullCheckResult_FieldMask()
					}
				} else if tp, ok := path.(*CheckPermissionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CheckPermissionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CheckPermissionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CheckPermissionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CheckPermissionsResponse_FieldMask) FilterInputFields() *CheckPermissionsResponse_FieldMask {
	result := &CheckPermissionsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CheckPermissionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CheckPermissionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CheckPermissionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCheckPermissionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CheckPermissionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CheckPermissionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckPermissionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CheckPermissionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CheckPermissionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckPermissionsResponse_FieldMask) AppendPath(path CheckPermissionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CheckPermissionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CheckPermissionsResponse_FieldPath))
}

func (fieldMask *CheckPermissionsResponse_FieldMask) GetPaths() []CheckPermissionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CheckPermissionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CheckPermissionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCheckPermissionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CheckPermissionsResponse_FieldMask) Set(target, source *CheckPermissionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CheckPermissionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CheckPermissionsResponse), source.(*CheckPermissionsResponse))
}

func (fieldMask *CheckPermissionsResponse_FieldMask) Project(source *CheckPermissionsResponse) *CheckPermissionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CheckPermissionsResponse{}
	checkResultsMask := &CheckResult_FieldMask{}
	wholeCheckResultsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CheckPermissionsResponse_FieldTerminalPath:
			switch tp.selector {
			case CheckPermissionsResponse_FieldPathSelectorCheckResults:
				result.CheckResults = source.CheckResults
				wholeCheckResultsAccepted = true
			}
		case *CheckPermissionsResponse_FieldSubPath:
			switch tp.selector {
			case CheckPermissionsResponse_FieldPathSelectorCheckResults:
				checkResultsMask.AppendPath(tp.subPath.(CheckResult_FieldPath))
			}
		}
	}
	if wholeCheckResultsAccepted == false && len(checkResultsMask.Paths) > 0 {
		for _, sourceItem := range source.GetCheckResults() {
			result.CheckResults = append(result.CheckResults, checkResultsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *CheckPermissionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CheckPermissionsResponse))
}

func (fieldMask *CheckPermissionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CheckMyPermissionsRequest_FieldMask struct {
	Paths []CheckMyPermissionsRequest_FieldPath
}

func FullCheckMyPermissionsRequest_FieldMask() *CheckMyPermissionsRequest_FieldMask {
	res := &CheckMyPermissionsRequest_FieldMask{}
	res.Paths = append(res.Paths, &CheckMyPermissionsRequest_FieldTerminalPath{selector: CheckMyPermissionsRequest_FieldPathSelectorChecks})
	res.Paths = append(res.Paths, &CheckMyPermissionsRequest_FieldTerminalPath{selector: CheckMyPermissionsRequest_FieldPathSelectorSkipCache})
	return res
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CheckMyPermissionsRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCheckMyPermissionsRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CheckMyPermissionsRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCheckMyPermissionsRequest_FieldPath(raw)
	})
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) Subtract(other *CheckMyPermissionsRequest_FieldMask) *CheckMyPermissionsRequest_FieldMask {
	result := &CheckMyPermissionsRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CheckMyPermissionsRequest_FieldPathSelector]gotenobject.FieldMask{
		CheckMyPermissionsRequest_FieldPathSelectorChecks: &Check_FieldMask{},
	}
	mySubMasks := map[CheckMyPermissionsRequest_FieldPathSelector]gotenobject.FieldMask{
		CheckMyPermissionsRequest_FieldPathSelectorChecks: &Check_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CheckMyPermissionsRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CheckMyPermissionsRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CheckMyPermissionsRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CheckMyPermissionsRequest_FieldPathSelectorChecks:
						mySubMasks[CheckMyPermissionsRequest_FieldPathSelectorChecks] = FullCheck_FieldMask()
					}
				} else if tp, ok := path.(*CheckMyPermissionsRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CheckMyPermissionsRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CheckMyPermissionsRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CheckMyPermissionsRequest_FieldMask) FilterInputFields() *CheckMyPermissionsRequest_FieldMask {
	result := &CheckMyPermissionsRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CheckMyPermissionsRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CheckMyPermissionsRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCheckMyPermissionsRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CheckMyPermissionsRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CheckMyPermissionsRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) AppendPath(path CheckMyPermissionsRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CheckMyPermissionsRequest_FieldPath))
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) GetPaths() []CheckMyPermissionsRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCheckMyPermissionsRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) Set(target, source *CheckMyPermissionsRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CheckMyPermissionsRequest), source.(*CheckMyPermissionsRequest))
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) Project(source *CheckMyPermissionsRequest) *CheckMyPermissionsRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CheckMyPermissionsRequest{}
	checksMask := &Check_FieldMask{}
	wholeChecksAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CheckMyPermissionsRequest_FieldTerminalPath:
			switch tp.selector {
			case CheckMyPermissionsRequest_FieldPathSelectorChecks:
				result.Checks = source.Checks
				wholeChecksAccepted = true
			case CheckMyPermissionsRequest_FieldPathSelectorSkipCache:
				result.SkipCache = source.SkipCache
			}
		case *CheckMyPermissionsRequest_FieldSubPath:
			switch tp.selector {
			case CheckMyPermissionsRequest_FieldPathSelectorChecks:
				checksMask.AppendPath(tp.subPath.(Check_FieldPath))
			}
		}
	}
	if wholeChecksAccepted == false && len(checksMask.Paths) > 0 {
		for _, sourceItem := range source.GetChecks() {
			result.Checks = append(result.Checks, checksMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CheckMyPermissionsRequest))
}

func (fieldMask *CheckMyPermissionsRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CheckMyPermissionsResponse_FieldMask struct {
	Paths []CheckMyPermissionsResponse_FieldPath
}

func FullCheckMyPermissionsResponse_FieldMask() *CheckMyPermissionsResponse_FieldMask {
	res := &CheckMyPermissionsResponse_FieldMask{}
	res.Paths = append(res.Paths, &CheckMyPermissionsResponse_FieldTerminalPath{selector: CheckMyPermissionsResponse_FieldPathSelectorCheckResults})
	return res
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CheckMyPermissionsResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCheckMyPermissionsResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CheckMyPermissionsResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCheckMyPermissionsResponse_FieldPath(raw)
	})
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) ProtoMessage() {}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) Subtract(other *CheckMyPermissionsResponse_FieldMask) *CheckMyPermissionsResponse_FieldMask {
	result := &CheckMyPermissionsResponse_FieldMask{}
	removedSelectors := make([]bool, 1)
	otherSubMasks := map[CheckMyPermissionsResponse_FieldPathSelector]gotenobject.FieldMask{
		CheckMyPermissionsResponse_FieldPathSelectorCheckResults: &CheckResult_FieldMask{},
	}
	mySubMasks := map[CheckMyPermissionsResponse_FieldPathSelector]gotenobject.FieldMask{
		CheckMyPermissionsResponse_FieldPathSelectorCheckResults: &CheckResult_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CheckMyPermissionsResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CheckMyPermissionsResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CheckMyPermissionsResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case CheckMyPermissionsResponse_FieldPathSelectorCheckResults:
						mySubMasks[CheckMyPermissionsResponse_FieldPathSelectorCheckResults] = FullCheckResult_FieldMask()
					}
				} else if tp, ok := path.(*CheckMyPermissionsResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CheckMyPermissionsResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CheckMyPermissionsResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CheckMyPermissionsResponse_FieldMask) FilterInputFields() *CheckMyPermissionsResponse_FieldMask {
	result := &CheckMyPermissionsResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CheckMyPermissionsResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CheckMyPermissionsResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCheckMyPermissionsResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CheckMyPermissionsResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CheckMyPermissionsResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) AppendPath(path CheckMyPermissionsResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CheckMyPermissionsResponse_FieldPath))
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) GetPaths() []CheckMyPermissionsResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCheckMyPermissionsResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) Set(target, source *CheckMyPermissionsResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CheckMyPermissionsResponse), source.(*CheckMyPermissionsResponse))
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) Project(source *CheckMyPermissionsResponse) *CheckMyPermissionsResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CheckMyPermissionsResponse{}
	checkResultsMask := &CheckResult_FieldMask{}
	wholeCheckResultsAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CheckMyPermissionsResponse_FieldTerminalPath:
			switch tp.selector {
			case CheckMyPermissionsResponse_FieldPathSelectorCheckResults:
				result.CheckResults = source.CheckResults
				wholeCheckResultsAccepted = true
			}
		case *CheckMyPermissionsResponse_FieldSubPath:
			switch tp.selector {
			case CheckMyPermissionsResponse_FieldPathSelectorCheckResults:
				checkResultsMask.AppendPath(tp.subPath.(CheckResult_FieldPath))
			}
		}
	}
	if wholeCheckResultsAccepted == false && len(checkResultsMask.Paths) > 0 {
		for _, sourceItem := range source.GetCheckResults() {
			result.CheckResults = append(result.CheckResults, checkResultsMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CheckMyPermissionsResponse))
}

func (fieldMask *CheckMyPermissionsResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
