// Code generated by protoc-gen-goten-object
// File: edgelq/iam/proto/v1alpha/service_account_key_service.proto
// DO NOT EDIT!!!

package service_account_key_client

import (
	"encoding/json"
	"strings"

	firestorepb "google.golang.org/genproto/googleapis/firestore/v1"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/proto"
	preflect "google.golang.org/protobuf/reflect/protoreflect"
	"google.golang.org/protobuf/types/known/fieldmaskpb"

	gotenobject "github.com/cloudwan/goten-sdk/runtime/object"
)

// proto imports
import (
	service_account "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha/service_account"
	service_account_key "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha/service_account_key"
	view "github.com/cloudwan/goten-sdk/runtime/api/view"
	watch_type "github.com/cloudwan/goten-sdk/runtime/api/watch_type"
	empty "github.com/golang/protobuf/ptypes/empty"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

// ensure the imports are used
var (
	_ = new(json.Marshaler)
	_ = strings.Builder{}

	_ = firestorepb.Value{}
	_ = codes.NotFound
	_ = status.Status{}
	_ = new(proto.Message)
	_ = new(preflect.Message)
	_ = fieldmaskpb.FieldMask{}

	_ = new(gotenobject.FieldMask)
)

// make sure we're using proto imports
var (
	_ = &service_account.ServiceAccount{}
	_ = &service_account_key.ServiceAccountKey{}
	_ = &empty.Empty{}
	_ = &field_mask.FieldMask{}
	_ = &timestamp.Timestamp{}
	_ = view.View(0)
	_ = watch_type.WatchType(0)
)

type GetServiceAccountKeyRequest_FieldMask struct {
	Paths []GetServiceAccountKeyRequest_FieldPath
}

func FullGetServiceAccountKeyRequest_FieldMask() *GetServiceAccountKeyRequest_FieldMask {
	res := &GetServiceAccountKeyRequest_FieldMask{}
	res.Paths = append(res.Paths, &GetServiceAccountKeyRequest_FieldTerminalPath{selector: GetServiceAccountKeyRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &GetServiceAccountKeyRequest_FieldTerminalPath{selector: GetServiceAccountKeyRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &GetServiceAccountKeyRequest_FieldTerminalPath{selector: GetServiceAccountKeyRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *GetServiceAccountKeyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseGetServiceAccountKeyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*GetServiceAccountKeyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseGetServiceAccountKeyRequest_FieldPath(raw)
	})
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) Subtract(other *GetServiceAccountKeyRequest_FieldMask) *GetServiceAccountKeyRequest_FieldMask {
	result := &GetServiceAccountKeyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *GetServiceAccountKeyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*GetServiceAccountKeyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *GetServiceAccountKeyRequest_FieldMask) FilterInputFields() *GetServiceAccountKeyRequest_FieldMask {
	result := &GetServiceAccountKeyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *GetServiceAccountKeyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]GetServiceAccountKeyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseGetServiceAccountKeyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask GetServiceAccountKeyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask GetServiceAccountKeyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) AppendPath(path GetServiceAccountKeyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(GetServiceAccountKeyRequest_FieldPath))
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) GetPaths() []GetServiceAccountKeyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseGetServiceAccountKeyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) Set(target, source *GetServiceAccountKeyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*GetServiceAccountKeyRequest), source.(*GetServiceAccountKeyRequest))
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) Project(source *GetServiceAccountKeyRequest) *GetServiceAccountKeyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &GetServiceAccountKeyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *GetServiceAccountKeyRequest_FieldTerminalPath:
			switch tp.selector {
			case GetServiceAccountKeyRequest_FieldPathSelectorName:
				result.Name = source.Name
			case GetServiceAccountKeyRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case GetServiceAccountKeyRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*GetServiceAccountKeyRequest))
}

func (fieldMask *GetServiceAccountKeyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetServiceAccountKeysRequest_FieldMask struct {
	Paths []BatchGetServiceAccountKeysRequest_FieldPath
}

func FullBatchGetServiceAccountKeysRequest_FieldMask() *BatchGetServiceAccountKeysRequest_FieldMask {
	res := &BatchGetServiceAccountKeysRequest_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetServiceAccountKeysRequest_FieldTerminalPath{selector: BatchGetServiceAccountKeysRequest_FieldPathSelectorNames})
	res.Paths = append(res.Paths, &BatchGetServiceAccountKeysRequest_FieldTerminalPath{selector: BatchGetServiceAccountKeysRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &BatchGetServiceAccountKeysRequest_FieldTerminalPath{selector: BatchGetServiceAccountKeysRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetServiceAccountKeysRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetServiceAccountKeysRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetServiceAccountKeysRequest_FieldPath(raw)
	})
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) Subtract(other *BatchGetServiceAccountKeysRequest_FieldMask) *BatchGetServiceAccountKeysRequest_FieldMask {
	result := &BatchGetServiceAccountKeysRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetServiceAccountKeysRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetServiceAccountKeysRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) FilterInputFields() *BatchGetServiceAccountKeysRequest_FieldMask {
	result := &BatchGetServiceAccountKeysRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetServiceAccountKeysRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetServiceAccountKeysRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetServiceAccountKeysRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetServiceAccountKeysRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) AppendPath(path BatchGetServiceAccountKeysRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetServiceAccountKeysRequest_FieldPath))
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) GetPaths() []BatchGetServiceAccountKeysRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetServiceAccountKeysRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) Set(target, source *BatchGetServiceAccountKeysRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetServiceAccountKeysRequest), source.(*BatchGetServiceAccountKeysRequest))
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) Project(source *BatchGetServiceAccountKeysRequest) *BatchGetServiceAccountKeysRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetServiceAccountKeysRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetServiceAccountKeysRequest_FieldTerminalPath:
			switch tp.selector {
			case BatchGetServiceAccountKeysRequest_FieldPathSelectorNames:
				result.Names = source.Names
			case BatchGetServiceAccountKeysRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case BatchGetServiceAccountKeysRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetServiceAccountKeysRequest))
}

func (fieldMask *BatchGetServiceAccountKeysRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type BatchGetServiceAccountKeysResponse_FieldMask struct {
	Paths []BatchGetServiceAccountKeysResponse_FieldPath
}

func FullBatchGetServiceAccountKeysResponse_FieldMask() *BatchGetServiceAccountKeysResponse_FieldMask {
	res := &BatchGetServiceAccountKeysResponse_FieldMask{}
	res.Paths = append(res.Paths, &BatchGetServiceAccountKeysResponse_FieldTerminalPath{selector: BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys})
	res.Paths = append(res.Paths, &BatchGetServiceAccountKeysResponse_FieldTerminalPath{selector: BatchGetServiceAccountKeysResponse_FieldPathSelectorMissing})
	return res
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseBatchGetServiceAccountKeysResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*BatchGetServiceAccountKeysResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseBatchGetServiceAccountKeysResponse_FieldPath(raw)
	})
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) ProtoMessage() {}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) Subtract(other *BatchGetServiceAccountKeysResponse_FieldMask) *BatchGetServiceAccountKeysResponse_FieldMask {
	result := &BatchGetServiceAccountKeysResponse_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[BatchGetServiceAccountKeysResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys: &service_account_key.ServiceAccountKey_FieldMask{},
	}
	mySubMasks := map[BatchGetServiceAccountKeysResponse_FieldPathSelector]gotenobject.FieldMask{
		BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys: &service_account_key.ServiceAccountKey_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *BatchGetServiceAccountKeysResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *BatchGetServiceAccountKeysResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*BatchGetServiceAccountKeysResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys:
						mySubMasks[BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys] = service_account_key.FullServiceAccountKey_FieldMask()
					}
				} else if tp, ok := path.(*BatchGetServiceAccountKeysResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &BatchGetServiceAccountKeysResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*BatchGetServiceAccountKeysResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) FilterInputFields() *BatchGetServiceAccountKeysResponse_FieldMask {
	result := &BatchGetServiceAccountKeysResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys:
			if _, ok := path.(*BatchGetServiceAccountKeysResponse_FieldTerminalPath); ok {
				for _, subpath := range service_account_key.FullServiceAccountKey_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetServiceAccountKeysResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*BatchGetServiceAccountKeysResponse_FieldSubPath); ok {
				selectedMask := &service_account_key.ServiceAccountKey_FieldMask{
					Paths: []service_account_key.ServiceAccountKey_FieldPath{sub.subPath.(service_account_key.ServiceAccountKey_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &BatchGetServiceAccountKeysResponse_FieldSubPath{selector: BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]BatchGetServiceAccountKeysResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseBatchGetServiceAccountKeysResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask BatchGetServiceAccountKeysResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask BatchGetServiceAccountKeysResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) AppendPath(path BatchGetServiceAccountKeysResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(BatchGetServiceAccountKeysResponse_FieldPath))
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) GetPaths() []BatchGetServiceAccountKeysResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseBatchGetServiceAccountKeysResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) Set(target, source *BatchGetServiceAccountKeysResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*BatchGetServiceAccountKeysResponse), source.(*BatchGetServiceAccountKeysResponse))
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) Project(source *BatchGetServiceAccountKeysResponse) *BatchGetServiceAccountKeysResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &BatchGetServiceAccountKeysResponse{}
	serviceAccountKeysMask := &service_account_key.ServiceAccountKey_FieldMask{}
	wholeServiceAccountKeysAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *BatchGetServiceAccountKeysResponse_FieldTerminalPath:
			switch tp.selector {
			case BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys:
				result.ServiceAccountKeys = source.ServiceAccountKeys
				wholeServiceAccountKeysAccepted = true
			case BatchGetServiceAccountKeysResponse_FieldPathSelectorMissing:
				result.Missing = source.Missing
			}
		case *BatchGetServiceAccountKeysResponse_FieldSubPath:
			switch tp.selector {
			case BatchGetServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys:
				serviceAccountKeysMask.AppendPath(tp.subPath.(service_account_key.ServiceAccountKey_FieldPath))
			}
		}
	}
	if wholeServiceAccountKeysAccepted == false && len(serviceAccountKeysMask.Paths) > 0 {
		for _, sourceItem := range source.GetServiceAccountKeys() {
			result.ServiceAccountKeys = append(result.ServiceAccountKeys, serviceAccountKeysMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*BatchGetServiceAccountKeysResponse))
}

func (fieldMask *BatchGetServiceAccountKeysResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListServiceAccountKeysRequest_FieldMask struct {
	Paths []ListServiceAccountKeysRequest_FieldPath
}

func FullListServiceAccountKeysRequest_FieldMask() *ListServiceAccountKeysRequest_FieldMask {
	res := &ListServiceAccountKeysRequest_FieldMask{}
	res.Paths = append(res.Paths, &ListServiceAccountKeysRequest_FieldTerminalPath{selector: ListServiceAccountKeysRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &ListServiceAccountKeysRequest_FieldTerminalPath{selector: ListServiceAccountKeysRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &ListServiceAccountKeysRequest_FieldTerminalPath{selector: ListServiceAccountKeysRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &ListServiceAccountKeysRequest_FieldTerminalPath{selector: ListServiceAccountKeysRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &ListServiceAccountKeysRequest_FieldTerminalPath{selector: ListServiceAccountKeysRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &ListServiceAccountKeysRequest_FieldTerminalPath{selector: ListServiceAccountKeysRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &ListServiceAccountKeysRequest_FieldTerminalPath{selector: ListServiceAccountKeysRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &ListServiceAccountKeysRequest_FieldTerminalPath{selector: ListServiceAccountKeysRequest_FieldPathSelectorIncludePagingInfo})
	return res
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListServiceAccountKeysRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListServiceAccountKeysRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 8)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListServiceAccountKeysRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListServiceAccountKeysRequest_FieldPath(raw)
	})
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) ProtoMessage() {}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) Subtract(other *ListServiceAccountKeysRequest_FieldMask) *ListServiceAccountKeysRequest_FieldMask {
	result := &ListServiceAccountKeysRequest_FieldMask{}
	removedSelectors := make([]bool, 8)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListServiceAccountKeysRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListServiceAccountKeysRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListServiceAccountKeysRequest_FieldMask) FilterInputFields() *ListServiceAccountKeysRequest_FieldMask {
	result := &ListServiceAccountKeysRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListServiceAccountKeysRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListServiceAccountKeysRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListServiceAccountKeysRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListServiceAccountKeysRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListServiceAccountKeysRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) AppendPath(path ListServiceAccountKeysRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListServiceAccountKeysRequest_FieldPath))
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) GetPaths() []ListServiceAccountKeysRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListServiceAccountKeysRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) Set(target, source *ListServiceAccountKeysRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListServiceAccountKeysRequest), source.(*ListServiceAccountKeysRequest))
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) Project(source *ListServiceAccountKeysRequest) *ListServiceAccountKeysRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListServiceAccountKeysRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListServiceAccountKeysRequest_FieldTerminalPath:
			switch tp.selector {
			case ListServiceAccountKeysRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case ListServiceAccountKeysRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case ListServiceAccountKeysRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case ListServiceAccountKeysRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case ListServiceAccountKeysRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case ListServiceAccountKeysRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case ListServiceAccountKeysRequest_FieldPathSelectorView:
				result.View = source.View
			case ListServiceAccountKeysRequest_FieldPathSelectorIncludePagingInfo:
				result.IncludePagingInfo = source.IncludePagingInfo
			}
		}
	}
	return result
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListServiceAccountKeysRequest))
}

func (fieldMask *ListServiceAccountKeysRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type ListServiceAccountKeysResponse_FieldMask struct {
	Paths []ListServiceAccountKeysResponse_FieldPath
}

func FullListServiceAccountKeysResponse_FieldMask() *ListServiceAccountKeysResponse_FieldMask {
	res := &ListServiceAccountKeysResponse_FieldMask{}
	res.Paths = append(res.Paths, &ListServiceAccountKeysResponse_FieldTerminalPath{selector: ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys})
	res.Paths = append(res.Paths, &ListServiceAccountKeysResponse_FieldTerminalPath{selector: ListServiceAccountKeysResponse_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &ListServiceAccountKeysResponse_FieldTerminalPath{selector: ListServiceAccountKeysResponse_FieldPathSelectorNextPageToken})
	res.Paths = append(res.Paths, &ListServiceAccountKeysResponse_FieldTerminalPath{selector: ListServiceAccountKeysResponse_FieldPathSelectorCurrentOffset})
	res.Paths = append(res.Paths, &ListServiceAccountKeysResponse_FieldTerminalPath{selector: ListServiceAccountKeysResponse_FieldPathSelectorTotalResultsCount})
	return res
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *ListServiceAccountKeysResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseListServiceAccountKeysResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 5)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*ListServiceAccountKeysResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseListServiceAccountKeysResponse_FieldPath(raw)
	})
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) ProtoMessage() {}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) Subtract(other *ListServiceAccountKeysResponse_FieldMask) *ListServiceAccountKeysResponse_FieldMask {
	result := &ListServiceAccountKeysResponse_FieldMask{}
	removedSelectors := make([]bool, 5)
	otherSubMasks := map[ListServiceAccountKeysResponse_FieldPathSelector]gotenobject.FieldMask{
		ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys: &service_account_key.ServiceAccountKey_FieldMask{},
	}
	mySubMasks := map[ListServiceAccountKeysResponse_FieldPathSelector]gotenobject.FieldMask{
		ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys: &service_account_key.ServiceAccountKey_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *ListServiceAccountKeysResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *ListServiceAccountKeysResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*ListServiceAccountKeysResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys:
						mySubMasks[ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys] = service_account_key.FullServiceAccountKey_FieldMask()
					}
				} else if tp, ok := path.(*ListServiceAccountKeysResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &ListServiceAccountKeysResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*ListServiceAccountKeysResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *ListServiceAccountKeysResponse_FieldMask) FilterInputFields() *ListServiceAccountKeysResponse_FieldMask {
	result := &ListServiceAccountKeysResponse_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys:
			if _, ok := path.(*ListServiceAccountKeysResponse_FieldTerminalPath); ok {
				for _, subpath := range service_account_key.FullServiceAccountKey_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListServiceAccountKeysResponse_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*ListServiceAccountKeysResponse_FieldSubPath); ok {
				selectedMask := &service_account_key.ServiceAccountKey_FieldMask{
					Paths: []service_account_key.ServiceAccountKey_FieldPath{sub.subPath.(service_account_key.ServiceAccountKey_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &ListServiceAccountKeysResponse_FieldSubPath{selector: ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *ListServiceAccountKeysResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]ListServiceAccountKeysResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseListServiceAccountKeysResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask ListServiceAccountKeysResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask ListServiceAccountKeysResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) AppendPath(path ListServiceAccountKeysResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(ListServiceAccountKeysResponse_FieldPath))
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) GetPaths() []ListServiceAccountKeysResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseListServiceAccountKeysResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) Set(target, source *ListServiceAccountKeysResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*ListServiceAccountKeysResponse), source.(*ListServiceAccountKeysResponse))
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) Project(source *ListServiceAccountKeysResponse) *ListServiceAccountKeysResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &ListServiceAccountKeysResponse{}
	serviceAccountKeysMask := &service_account_key.ServiceAccountKey_FieldMask{}
	wholeServiceAccountKeysAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *ListServiceAccountKeysResponse_FieldTerminalPath:
			switch tp.selector {
			case ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys:
				result.ServiceAccountKeys = source.ServiceAccountKeys
				wholeServiceAccountKeysAccepted = true
			case ListServiceAccountKeysResponse_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case ListServiceAccountKeysResponse_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			case ListServiceAccountKeysResponse_FieldPathSelectorCurrentOffset:
				result.CurrentOffset = source.CurrentOffset
			case ListServiceAccountKeysResponse_FieldPathSelectorTotalResultsCount:
				result.TotalResultsCount = source.TotalResultsCount
			}
		case *ListServiceAccountKeysResponse_FieldSubPath:
			switch tp.selector {
			case ListServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeys:
				serviceAccountKeysMask.AppendPath(tp.subPath.(service_account_key.ServiceAccountKey_FieldPath))
			}
		}
	}
	if wholeServiceAccountKeysAccepted == false && len(serviceAccountKeysMask.Paths) > 0 {
		for _, sourceItem := range source.GetServiceAccountKeys() {
			result.ServiceAccountKeys = append(result.ServiceAccountKeys, serviceAccountKeysMask.Project(sourceItem))
		}
	}
	return result
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*ListServiceAccountKeysResponse))
}

func (fieldMask *ListServiceAccountKeysResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchServiceAccountKeyRequest_FieldMask struct {
	Paths []WatchServiceAccountKeyRequest_FieldPath
}

func FullWatchServiceAccountKeyRequest_FieldMask() *WatchServiceAccountKeyRequest_FieldMask {
	res := &WatchServiceAccountKeyRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchServiceAccountKeyRequest_FieldTerminalPath{selector: WatchServiceAccountKeyRequest_FieldPathSelectorName})
	res.Paths = append(res.Paths, &WatchServiceAccountKeyRequest_FieldTerminalPath{selector: WatchServiceAccountKeyRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchServiceAccountKeyRequest_FieldTerminalPath{selector: WatchServiceAccountKeyRequest_FieldPathSelectorView})
	return res
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchServiceAccountKeyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchServiceAccountKeyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchServiceAccountKeyRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) Subtract(other *WatchServiceAccountKeyRequest_FieldMask) *WatchServiceAccountKeyRequest_FieldMask {
	result := &WatchServiceAccountKeyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchServiceAccountKeyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchServiceAccountKeyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) FilterInputFields() *WatchServiceAccountKeyRequest_FieldMask {
	result := &WatchServiceAccountKeyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchServiceAccountKeyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchServiceAccountKeyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchServiceAccountKeyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchServiceAccountKeyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) AppendPath(path WatchServiceAccountKeyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchServiceAccountKeyRequest_FieldPath))
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) GetPaths() []WatchServiceAccountKeyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchServiceAccountKeyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) Set(target, source *WatchServiceAccountKeyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchServiceAccountKeyRequest), source.(*WatchServiceAccountKeyRequest))
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) Project(source *WatchServiceAccountKeyRequest) *WatchServiceAccountKeyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchServiceAccountKeyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchServiceAccountKeyRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchServiceAccountKeyRequest_FieldPathSelectorName:
				result.Name = source.Name
			case WatchServiceAccountKeyRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchServiceAccountKeyRequest_FieldPathSelectorView:
				result.View = source.View
			}
		}
	}
	return result
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchServiceAccountKeyRequest))
}

func (fieldMask *WatchServiceAccountKeyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchServiceAccountKeyResponse_FieldMask struct {
	Paths []WatchServiceAccountKeyResponse_FieldPath
}

func FullWatchServiceAccountKeyResponse_FieldMask() *WatchServiceAccountKeyResponse_FieldMask {
	res := &WatchServiceAccountKeyResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchServiceAccountKeyResponse_FieldTerminalPath{selector: WatchServiceAccountKeyResponse_FieldPathSelectorChange})
	return res
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchServiceAccountKeyResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchServiceAccountKeyResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchServiceAccountKeyResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) Subtract(other *WatchServiceAccountKeyResponse_FieldMask) *WatchServiceAccountKeyResponse_FieldMask {
	result := &WatchServiceAccountKeyResponse_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchServiceAccountKeyResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchServiceAccountKeyResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) FilterInputFields() *WatchServiceAccountKeyResponse_FieldMask {
	result := &WatchServiceAccountKeyResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchServiceAccountKeyResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchServiceAccountKeyResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchServiceAccountKeyResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchServiceAccountKeyResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) AppendPath(path WatchServiceAccountKeyResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchServiceAccountKeyResponse_FieldPath))
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) GetPaths() []WatchServiceAccountKeyResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchServiceAccountKeyResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) Set(target, source *WatchServiceAccountKeyResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchServiceAccountKeyResponse), source.(*WatchServiceAccountKeyResponse))
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) Project(source *WatchServiceAccountKeyResponse) *WatchServiceAccountKeyResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchServiceAccountKeyResponse{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchServiceAccountKeyResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchServiceAccountKeyResponse_FieldPathSelectorChange:
				result.Change = source.Change
			}
		}
	}
	return result
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchServiceAccountKeyResponse))
}

func (fieldMask *WatchServiceAccountKeyResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchServiceAccountKeysRequest_FieldMask struct {
	Paths []WatchServiceAccountKeysRequest_FieldPath
}

func FullWatchServiceAccountKeysRequest_FieldMask() *WatchServiceAccountKeysRequest_FieldMask {
	res := &WatchServiceAccountKeysRequest_FieldMask{}
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorType})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorPageSize})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorPageToken})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorOrderBy})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorStartingTime})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorFilter})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorFieldMask})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorView})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysRequest_FieldTerminalPath{selector: WatchServiceAccountKeysRequest_FieldPathSelectorMaxChunkSize})
	return res
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchServiceAccountKeysRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 11)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchServiceAccountKeysRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchServiceAccountKeysRequest_FieldPath(raw)
	})
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) ProtoMessage() {}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) Subtract(other *WatchServiceAccountKeysRequest_FieldMask) *WatchServiceAccountKeysRequest_FieldMask {
	result := &WatchServiceAccountKeysRequest_FieldMask{}
	removedSelectors := make([]bool, 11)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchServiceAccountKeysRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchServiceAccountKeysRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) FilterInputFields() *WatchServiceAccountKeysRequest_FieldMask {
	result := &WatchServiceAccountKeysRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchServiceAccountKeysRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchServiceAccountKeysRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchServiceAccountKeysRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchServiceAccountKeysRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) AppendPath(path WatchServiceAccountKeysRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchServiceAccountKeysRequest_FieldPath))
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) GetPaths() []WatchServiceAccountKeysRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchServiceAccountKeysRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) Set(target, source *WatchServiceAccountKeysRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchServiceAccountKeysRequest), source.(*WatchServiceAccountKeysRequest))
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) Project(source *WatchServiceAccountKeysRequest) *WatchServiceAccountKeysRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchServiceAccountKeysRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchServiceAccountKeysRequest_FieldTerminalPath:
			switch tp.selector {
			case WatchServiceAccountKeysRequest_FieldPathSelectorType:
				result.Type = source.Type
			case WatchServiceAccountKeysRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case WatchServiceAccountKeysRequest_FieldPathSelectorPageSize:
				result.PageSize = source.PageSize
			case WatchServiceAccountKeysRequest_FieldPathSelectorPageToken:
				result.PageToken = source.PageToken
			case WatchServiceAccountKeysRequest_FieldPathSelectorOrderBy:
				result.OrderBy = source.OrderBy
			case WatchServiceAccountKeysRequest_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchServiceAccountKeysRequest_FieldPathSelectorStartingTime:
				result.StartingTime = source.StartingTime
			case WatchServiceAccountKeysRequest_FieldPathSelectorFilter:
				result.Filter = source.Filter
			case WatchServiceAccountKeysRequest_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			case WatchServiceAccountKeysRequest_FieldPathSelectorView:
				result.View = source.View
			case WatchServiceAccountKeysRequest_FieldPathSelectorMaxChunkSize:
				result.MaxChunkSize = source.MaxChunkSize
			}
		}
	}
	return result
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchServiceAccountKeysRequest))
}

func (fieldMask *WatchServiceAccountKeysRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchServiceAccountKeysResponse_FieldMask struct {
	Paths []WatchServiceAccountKeysResponse_FieldPath
}

func FullWatchServiceAccountKeysResponse_FieldMask() *WatchServiceAccountKeysResponse_FieldMask {
	res := &WatchServiceAccountKeysResponse_FieldMask{}
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponse_FieldTerminalPath{selector: WatchServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeyChanges})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponse_FieldTerminalPath{selector: WatchServiceAccountKeysResponse_FieldPathSelectorIsCurrent})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponse_FieldTerminalPath{selector: WatchServiceAccountKeysResponse_FieldPathSelectorPageTokenChange})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponse_FieldTerminalPath{selector: WatchServiceAccountKeysResponse_FieldPathSelectorResumeToken})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponse_FieldTerminalPath{selector: WatchServiceAccountKeysResponse_FieldPathSelectorSnapshotSize})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponse_FieldTerminalPath{selector: WatchServiceAccountKeysResponse_FieldPathSelectorIsSoftReset})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponse_FieldTerminalPath{selector: WatchServiceAccountKeysResponse_FieldPathSelectorIsHardReset})
	return res
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchServiceAccountKeysResponse_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 7)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchServiceAccountKeysResponse_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchServiceAccountKeysResponse_FieldPath(raw)
	})
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) ProtoMessage() {}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) Subtract(other *WatchServiceAccountKeysResponse_FieldMask) *WatchServiceAccountKeysResponse_FieldMask {
	result := &WatchServiceAccountKeysResponse_FieldMask{}
	removedSelectors := make([]bool, 7)
	otherSubMasks := map[WatchServiceAccountKeysResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchServiceAccountKeysResponse_FieldPathSelectorPageTokenChange: &WatchServiceAccountKeysResponse_PageTokenChange_FieldMask{},
	}
	mySubMasks := map[WatchServiceAccountKeysResponse_FieldPathSelector]gotenobject.FieldMask{
		WatchServiceAccountKeysResponse_FieldPathSelectorPageTokenChange: &WatchServiceAccountKeysResponse_PageTokenChange_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchServiceAccountKeysResponse_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *WatchServiceAccountKeysResponse_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*WatchServiceAccountKeysResponse_FieldTerminalPath); ok {
					switch tp.selector {
					case WatchServiceAccountKeysResponse_FieldPathSelectorPageTokenChange:
						mySubMasks[WatchServiceAccountKeysResponse_FieldPathSelectorPageTokenChange] = FullWatchServiceAccountKeysResponse_PageTokenChange_FieldMask()
					}
				} else if tp, ok := path.(*WatchServiceAccountKeysResponse_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &WatchServiceAccountKeysResponse_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchServiceAccountKeysResponse_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) FilterInputFields() *WatchServiceAccountKeysResponse_FieldMask {
	result := &WatchServiceAccountKeysResponse_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchServiceAccountKeysResponse_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchServiceAccountKeysResponse_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchServiceAccountKeysResponse_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchServiceAccountKeysResponse_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) AppendPath(path WatchServiceAccountKeysResponse_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchServiceAccountKeysResponse_FieldPath))
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) GetPaths() []WatchServiceAccountKeysResponse_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchServiceAccountKeysResponse_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) Set(target, source *WatchServiceAccountKeysResponse) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchServiceAccountKeysResponse), source.(*WatchServiceAccountKeysResponse))
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) Project(source *WatchServiceAccountKeysResponse) *WatchServiceAccountKeysResponse {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchServiceAccountKeysResponse{}
	pageTokenChangeMask := &WatchServiceAccountKeysResponse_PageTokenChange_FieldMask{}
	wholePageTokenChangeAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchServiceAccountKeysResponse_FieldTerminalPath:
			switch tp.selector {
			case WatchServiceAccountKeysResponse_FieldPathSelectorServiceAccountKeyChanges:
				result.ServiceAccountKeyChanges = source.ServiceAccountKeyChanges
			case WatchServiceAccountKeysResponse_FieldPathSelectorIsCurrent:
				result.IsCurrent = source.IsCurrent
			case WatchServiceAccountKeysResponse_FieldPathSelectorPageTokenChange:
				result.PageTokenChange = source.PageTokenChange
				wholePageTokenChangeAccepted = true
			case WatchServiceAccountKeysResponse_FieldPathSelectorResumeToken:
				result.ResumeToken = source.ResumeToken
			case WatchServiceAccountKeysResponse_FieldPathSelectorSnapshotSize:
				result.SnapshotSize = source.SnapshotSize
			case WatchServiceAccountKeysResponse_FieldPathSelectorIsSoftReset:
				result.IsSoftReset = source.IsSoftReset
			case WatchServiceAccountKeysResponse_FieldPathSelectorIsHardReset:
				result.IsHardReset = source.IsHardReset
			}
		case *WatchServiceAccountKeysResponse_FieldSubPath:
			switch tp.selector {
			case WatchServiceAccountKeysResponse_FieldPathSelectorPageTokenChange:
				pageTokenChangeMask.AppendPath(tp.subPath.(WatchServiceAccountKeysResponsePageTokenChange_FieldPath))
			}
		}
	}
	if wholePageTokenChangeAccepted == false && len(pageTokenChangeMask.Paths) > 0 {
		result.PageTokenChange = pageTokenChangeMask.Project(source.GetPageTokenChange())
	}
	return result
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchServiceAccountKeysResponse))
}

func (fieldMask *WatchServiceAccountKeysResponse_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type WatchServiceAccountKeysResponse_PageTokenChange_FieldMask struct {
	Paths []WatchServiceAccountKeysResponsePageTokenChange_FieldPath
}

func FullWatchServiceAccountKeysResponse_PageTokenChange_FieldMask() *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask {
	res := &WatchServiceAccountKeysResponse_PageTokenChange_FieldMask{}
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponsePageTokenChange_FieldTerminalPath{selector: WatchServiceAccountKeysResponsePageTokenChange_FieldPathSelectorPrevPageToken})
	res.Paths = append(res.Paths, &WatchServiceAccountKeysResponsePageTokenChange_FieldTerminalPath{selector: WatchServiceAccountKeysResponsePageTokenChange_FieldPathSelectorNextPageToken})
	return res
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseWatchServiceAccountKeysResponsePageTokenChange_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*WatchServiceAccountKeysResponsePageTokenChange_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseWatchServiceAccountKeysResponsePageTokenChange_FieldPath(raw)
	})
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) ProtoMessage() {}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) Subtract(other *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask {
	result := &WatchServiceAccountKeysResponse_PageTokenChange_FieldMask{}
	removedSelectors := make([]bool, 2)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *WatchServiceAccountKeysResponsePageTokenChange_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*WatchServiceAccountKeysResponse_PageTokenChange_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) FilterInputFields() *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask {
	result := &WatchServiceAccountKeysResponse_PageTokenChange_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]WatchServiceAccountKeysResponsePageTokenChange_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseWatchServiceAccountKeysResponsePageTokenChange_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) AppendPath(path WatchServiceAccountKeysResponsePageTokenChange_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(WatchServiceAccountKeysResponsePageTokenChange_FieldPath))
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) GetPaths() []WatchServiceAccountKeysResponsePageTokenChange_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseWatchServiceAccountKeysResponsePageTokenChange_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) Set(target, source *WatchServiceAccountKeysResponse_PageTokenChange) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*WatchServiceAccountKeysResponse_PageTokenChange), source.(*WatchServiceAccountKeysResponse_PageTokenChange))
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) Project(source *WatchServiceAccountKeysResponse_PageTokenChange) *WatchServiceAccountKeysResponse_PageTokenChange {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &WatchServiceAccountKeysResponse_PageTokenChange{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *WatchServiceAccountKeysResponsePageTokenChange_FieldTerminalPath:
			switch tp.selector {
			case WatchServiceAccountKeysResponsePageTokenChange_FieldPathSelectorPrevPageToken:
				result.PrevPageToken = source.PrevPageToken
			case WatchServiceAccountKeysResponsePageTokenChange_FieldPathSelectorNextPageToken:
				result.NextPageToken = source.NextPageToken
			}
		}
	}
	return result
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*WatchServiceAccountKeysResponse_PageTokenChange))
}

func (fieldMask *WatchServiceAccountKeysResponse_PageTokenChange_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type CreateServiceAccountKeyRequest_FieldMask struct {
	Paths []CreateServiceAccountKeyRequest_FieldPath
}

func FullCreateServiceAccountKeyRequest_FieldMask() *CreateServiceAccountKeyRequest_FieldMask {
	res := &CreateServiceAccountKeyRequest_FieldMask{}
	res.Paths = append(res.Paths, &CreateServiceAccountKeyRequest_FieldTerminalPath{selector: CreateServiceAccountKeyRequest_FieldPathSelectorParent})
	res.Paths = append(res.Paths, &CreateServiceAccountKeyRequest_FieldTerminalPath{selector: CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey})
	return res
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseCreateServiceAccountKeyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*CreateServiceAccountKeyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseCreateServiceAccountKeyRequest_FieldPath(raw)
	})
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) Subtract(other *CreateServiceAccountKeyRequest_FieldMask) *CreateServiceAccountKeyRequest_FieldMask {
	result := &CreateServiceAccountKeyRequest_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[CreateServiceAccountKeyRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey: &service_account_key.ServiceAccountKey_FieldMask{},
	}
	mySubMasks := map[CreateServiceAccountKeyRequest_FieldPathSelector]gotenobject.FieldMask{
		CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey: &service_account_key.ServiceAccountKey_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *CreateServiceAccountKeyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *CreateServiceAccountKeyRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*CreateServiceAccountKeyRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey:
						mySubMasks[CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey] = service_account_key.FullServiceAccountKey_FieldMask()
					}
				} else if tp, ok := path.(*CreateServiceAccountKeyRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &CreateServiceAccountKeyRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*CreateServiceAccountKeyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) FilterInputFields() *CreateServiceAccountKeyRequest_FieldMask {
	result := &CreateServiceAccountKeyRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey:
			if _, ok := path.(*CreateServiceAccountKeyRequest_FieldTerminalPath); ok {
				for _, subpath := range service_account_key.FullServiceAccountKey_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateServiceAccountKeyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*CreateServiceAccountKeyRequest_FieldSubPath); ok {
				selectedMask := &service_account_key.ServiceAccountKey_FieldMask{
					Paths: []service_account_key.ServiceAccountKey_FieldPath{sub.subPath.(service_account_key.ServiceAccountKey_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &CreateServiceAccountKeyRequest_FieldSubPath{selector: CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]CreateServiceAccountKeyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseCreateServiceAccountKeyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask CreateServiceAccountKeyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask CreateServiceAccountKeyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) AppendPath(path CreateServiceAccountKeyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(CreateServiceAccountKeyRequest_FieldPath))
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) GetPaths() []CreateServiceAccountKeyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseCreateServiceAccountKeyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) Set(target, source *CreateServiceAccountKeyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*CreateServiceAccountKeyRequest), source.(*CreateServiceAccountKeyRequest))
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) Project(source *CreateServiceAccountKeyRequest) *CreateServiceAccountKeyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &CreateServiceAccountKeyRequest{}
	serviceAccountKeyMask := &service_account_key.ServiceAccountKey_FieldMask{}
	wholeServiceAccountKeyAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *CreateServiceAccountKeyRequest_FieldTerminalPath:
			switch tp.selector {
			case CreateServiceAccountKeyRequest_FieldPathSelectorParent:
				result.Parent = source.Parent
			case CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey:
				result.ServiceAccountKey = source.ServiceAccountKey
				wholeServiceAccountKeyAccepted = true
			}
		case *CreateServiceAccountKeyRequest_FieldSubPath:
			switch tp.selector {
			case CreateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey:
				serviceAccountKeyMask.AppendPath(tp.subPath.(service_account_key.ServiceAccountKey_FieldPath))
			}
		}
	}
	if wholeServiceAccountKeyAccepted == false && len(serviceAccountKeyMask.Paths) > 0 {
		result.ServiceAccountKey = serviceAccountKeyMask.Project(source.GetServiceAccountKey())
	}
	return result
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*CreateServiceAccountKeyRequest))
}

func (fieldMask *CreateServiceAccountKeyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateServiceAccountKeyRequest_FieldMask struct {
	Paths []UpdateServiceAccountKeyRequest_FieldPath
}

func FullUpdateServiceAccountKeyRequest_FieldMask() *UpdateServiceAccountKeyRequest_FieldMask {
	res := &UpdateServiceAccountKeyRequest_FieldMask{}
	res.Paths = append(res.Paths, &UpdateServiceAccountKeyRequest_FieldTerminalPath{selector: UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey})
	res.Paths = append(res.Paths, &UpdateServiceAccountKeyRequest_FieldTerminalPath{selector: UpdateServiceAccountKeyRequest_FieldPathSelectorUpdateMask})
	res.Paths = append(res.Paths, &UpdateServiceAccountKeyRequest_FieldTerminalPath{selector: UpdateServiceAccountKeyRequest_FieldPathSelectorCas})
	return res
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateServiceAccountKeyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 3)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateServiceAccountKeyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateServiceAccountKeyRequest_FieldPath(raw)
	})
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) Subtract(other *UpdateServiceAccountKeyRequest_FieldMask) *UpdateServiceAccountKeyRequest_FieldMask {
	result := &UpdateServiceAccountKeyRequest_FieldMask{}
	removedSelectors := make([]bool, 3)
	otherSubMasks := map[UpdateServiceAccountKeyRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey: &service_account_key.ServiceAccountKey_FieldMask{},
		UpdateServiceAccountKeyRequest_FieldPathSelectorCas:               &UpdateServiceAccountKeyRequest_CAS_FieldMask{},
	}
	mySubMasks := map[UpdateServiceAccountKeyRequest_FieldPathSelector]gotenobject.FieldMask{
		UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey: &service_account_key.ServiceAccountKey_FieldMask{},
		UpdateServiceAccountKeyRequest_FieldPathSelectorCas:               &UpdateServiceAccountKeyRequest_CAS_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateServiceAccountKeyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateServiceAccountKeyRequest_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateServiceAccountKeyRequest_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey:
						mySubMasks[UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey] = service_account_key.FullServiceAccountKey_FieldMask()
					case UpdateServiceAccountKeyRequest_FieldPathSelectorCas:
						mySubMasks[UpdateServiceAccountKeyRequest_FieldPathSelectorCas] = FullUpdateServiceAccountKeyRequest_CAS_FieldMask()
					}
				} else if tp, ok := path.(*UpdateServiceAccountKeyRequest_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateServiceAccountKeyRequest_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateServiceAccountKeyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) FilterInputFields() *UpdateServiceAccountKeyRequest_FieldMask {
	result := &UpdateServiceAccountKeyRequest_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey:
			if _, ok := path.(*UpdateServiceAccountKeyRequest_FieldTerminalPath); ok {
				for _, subpath := range service_account_key.FullServiceAccountKey_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateServiceAccountKeyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateServiceAccountKeyRequest_FieldSubPath); ok {
				selectedMask := &service_account_key.ServiceAccountKey_FieldMask{
					Paths: []service_account_key.ServiceAccountKey_FieldPath{sub.subPath.(service_account_key.ServiceAccountKey_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateServiceAccountKeyRequest_FieldSubPath{selector: UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey, subPath: allowedPath})
				}
			}
		case UpdateServiceAccountKeyRequest_FieldPathSelectorCas:
			if _, ok := path.(*UpdateServiceAccountKeyRequest_FieldTerminalPath); ok {
				for _, subpath := range FullUpdateServiceAccountKeyRequest_CAS_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateServiceAccountKeyRequest_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateServiceAccountKeyRequest_FieldSubPath); ok {
				selectedMask := &UpdateServiceAccountKeyRequest_CAS_FieldMask{
					Paths: []UpdateServiceAccountKeyRequestCAS_FieldPath{sub.subPath.(UpdateServiceAccountKeyRequestCAS_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateServiceAccountKeyRequest_FieldSubPath{selector: UpdateServiceAccountKeyRequest_FieldPathSelectorCas, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateServiceAccountKeyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateServiceAccountKeyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateServiceAccountKeyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateServiceAccountKeyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) AppendPath(path UpdateServiceAccountKeyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateServiceAccountKeyRequest_FieldPath))
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) GetPaths() []UpdateServiceAccountKeyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateServiceAccountKeyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) Set(target, source *UpdateServiceAccountKeyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateServiceAccountKeyRequest), source.(*UpdateServiceAccountKeyRequest))
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) Project(source *UpdateServiceAccountKeyRequest) *UpdateServiceAccountKeyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateServiceAccountKeyRequest{}
	serviceAccountKeyMask := &service_account_key.ServiceAccountKey_FieldMask{}
	wholeServiceAccountKeyAccepted := false
	casMask := &UpdateServiceAccountKeyRequest_CAS_FieldMask{}
	wholeCasAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateServiceAccountKeyRequest_FieldTerminalPath:
			switch tp.selector {
			case UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey:
				result.ServiceAccountKey = source.ServiceAccountKey
				wholeServiceAccountKeyAccepted = true
			case UpdateServiceAccountKeyRequest_FieldPathSelectorUpdateMask:
				result.UpdateMask = source.UpdateMask
			case UpdateServiceAccountKeyRequest_FieldPathSelectorCas:
				result.Cas = source.Cas
				wholeCasAccepted = true
			}
		case *UpdateServiceAccountKeyRequest_FieldSubPath:
			switch tp.selector {
			case UpdateServiceAccountKeyRequest_FieldPathSelectorServiceAccountKey:
				serviceAccountKeyMask.AppendPath(tp.subPath.(service_account_key.ServiceAccountKey_FieldPath))
			case UpdateServiceAccountKeyRequest_FieldPathSelectorCas:
				casMask.AppendPath(tp.subPath.(UpdateServiceAccountKeyRequestCAS_FieldPath))
			}
		}
	}
	if wholeServiceAccountKeyAccepted == false && len(serviceAccountKeyMask.Paths) > 0 {
		result.ServiceAccountKey = serviceAccountKeyMask.Project(source.GetServiceAccountKey())
	}
	if wholeCasAccepted == false && len(casMask.Paths) > 0 {
		result.Cas = casMask.Project(source.GetCas())
	}
	return result
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateServiceAccountKeyRequest))
}

func (fieldMask *UpdateServiceAccountKeyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type UpdateServiceAccountKeyRequest_CAS_FieldMask struct {
	Paths []UpdateServiceAccountKeyRequestCAS_FieldPath
}

func FullUpdateServiceAccountKeyRequest_CAS_FieldMask() *UpdateServiceAccountKeyRequest_CAS_FieldMask {
	res := &UpdateServiceAccountKeyRequest_CAS_FieldMask{}
	res.Paths = append(res.Paths, &UpdateServiceAccountKeyRequestCAS_FieldTerminalPath{selector: UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState})
	res.Paths = append(res.Paths, &UpdateServiceAccountKeyRequestCAS_FieldTerminalPath{selector: UpdateServiceAccountKeyRequestCAS_FieldPathSelectorFieldMask})
	return res
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseUpdateServiceAccountKeyRequestCAS_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 2)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*UpdateServiceAccountKeyRequestCAS_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseUpdateServiceAccountKeyRequestCAS_FieldPath(raw)
	})
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) ProtoMessage() {}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) Subtract(other *UpdateServiceAccountKeyRequest_CAS_FieldMask) *UpdateServiceAccountKeyRequest_CAS_FieldMask {
	result := &UpdateServiceAccountKeyRequest_CAS_FieldMask{}
	removedSelectors := make([]bool, 2)
	otherSubMasks := map[UpdateServiceAccountKeyRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState: &service_account_key.ServiceAccountKey_FieldMask{},
	}
	mySubMasks := map[UpdateServiceAccountKeyRequestCAS_FieldPathSelector]gotenobject.FieldMask{
		UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState: &service_account_key.ServiceAccountKey_FieldMask{},
	}

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *UpdateServiceAccountKeyRequestCAS_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		case *UpdateServiceAccountKeyRequestCAS_FieldSubPath:
			otherSubMasks[tp.selector].AppendRawPath(tp.subPath)
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			if otherSubMask := otherSubMasks[path.Selector()]; otherSubMask != nil && otherSubMask.PathsCount() > 0 {
				if tp, ok := path.(*UpdateServiceAccountKeyRequestCAS_FieldTerminalPath); ok {
					switch tp.selector {
					case UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState:
						mySubMasks[UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState] = service_account_key.FullServiceAccountKey_FieldMask()
					}
				} else if tp, ok := path.(*UpdateServiceAccountKeyRequestCAS_FieldSubPath); ok {
					mySubMasks[tp.selector].AppendRawPath(tp.subPath)
				}
			} else {
				result.Paths = append(result.Paths, path)
			}
		}
	}
	for selector, mySubMask := range mySubMasks {
		if mySubMask.PathsCount() > 0 {
			for _, allowedPath := range mySubMask.SubtractRaw(otherSubMasks[selector]).GetRawPaths() {
				result.Paths = append(result.Paths, &UpdateServiceAccountKeyRequestCAS_FieldSubPath{selector: selector, subPath: allowedPath})
			}
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*UpdateServiceAccountKeyRequest_CAS_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) FilterInputFields() *UpdateServiceAccountKeyRequest_CAS_FieldMask {
	result := &UpdateServiceAccountKeyRequest_CAS_FieldMask{}
	for _, path := range fieldMask.Paths {
		switch path.Selector() {
		case UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState:
			if _, ok := path.(*UpdateServiceAccountKeyRequestCAS_FieldTerminalPath); ok {
				for _, subpath := range service_account_key.FullServiceAccountKey_FieldMask().FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateServiceAccountKeyRequestCAS_FieldSubPath{selector: path.Selector(), subPath: subpath})
				}
			} else if sub, ok := path.(*UpdateServiceAccountKeyRequestCAS_FieldSubPath); ok {
				selectedMask := &service_account_key.ServiceAccountKey_FieldMask{
					Paths: []service_account_key.ServiceAccountKey_FieldPath{sub.subPath.(service_account_key.ServiceAccountKey_FieldPath)},
				}
				for _, allowedPath := range selectedMask.FilterInputFields().Paths {
					result.Paths = append(result.Paths, &UpdateServiceAccountKeyRequestCAS_FieldSubPath{selector: UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState, subPath: allowedPath})
				}
			}
		default:
			result.Paths = append(result.Paths, path)
		}
	}
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]UpdateServiceAccountKeyRequestCAS_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseUpdateServiceAccountKeyRequestCAS_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask UpdateServiceAccountKeyRequest_CAS_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask UpdateServiceAccountKeyRequest_CAS_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) AppendPath(path UpdateServiceAccountKeyRequestCAS_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(UpdateServiceAccountKeyRequestCAS_FieldPath))
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) GetPaths() []UpdateServiceAccountKeyRequestCAS_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseUpdateServiceAccountKeyRequestCAS_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) Set(target, source *UpdateServiceAccountKeyRequest_CAS) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*UpdateServiceAccountKeyRequest_CAS), source.(*UpdateServiceAccountKeyRequest_CAS))
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) Project(source *UpdateServiceAccountKeyRequest_CAS) *UpdateServiceAccountKeyRequest_CAS {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &UpdateServiceAccountKeyRequest_CAS{}
	conditionalStateMask := &service_account_key.ServiceAccountKey_FieldMask{}
	wholeConditionalStateAccepted := false

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *UpdateServiceAccountKeyRequestCAS_FieldTerminalPath:
			switch tp.selector {
			case UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState:
				result.ConditionalState = source.ConditionalState
				wholeConditionalStateAccepted = true
			case UpdateServiceAccountKeyRequestCAS_FieldPathSelectorFieldMask:
				result.FieldMask = source.FieldMask
			}
		case *UpdateServiceAccountKeyRequestCAS_FieldSubPath:
			switch tp.selector {
			case UpdateServiceAccountKeyRequestCAS_FieldPathSelectorConditionalState:
				conditionalStateMask.AppendPath(tp.subPath.(service_account_key.ServiceAccountKey_FieldPath))
			}
		}
	}
	if wholeConditionalStateAccepted == false && len(conditionalStateMask.Paths) > 0 {
		result.ConditionalState = conditionalStateMask.Project(source.GetConditionalState())
	}
	return result
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*UpdateServiceAccountKeyRequest_CAS))
}

func (fieldMask *UpdateServiceAccountKeyRequest_CAS_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}

type DeleteServiceAccountKeyRequest_FieldMask struct {
	Paths []DeleteServiceAccountKeyRequest_FieldPath
}

func FullDeleteServiceAccountKeyRequest_FieldMask() *DeleteServiceAccountKeyRequest_FieldMask {
	res := &DeleteServiceAccountKeyRequest_FieldMask{}
	res.Paths = append(res.Paths, &DeleteServiceAccountKeyRequest_FieldTerminalPath{selector: DeleteServiceAccountKeyRequest_FieldPathSelectorName})
	return res
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) String() string {
	if fieldMask == nil {
		return "<nil>"
	}
	pathsStr := make([]string, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		pathsStr = append(pathsStr, path.String())
	}
	return strings.Join(pathsStr, ", ")
}

// firestore encoding/decoding integration
func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) EncodeFirestore() (*firestorepb.Value, error) {
	if fieldMask == nil {
		return &firestorepb.Value{ValueType: &firestorepb.Value_NullValue{}}, nil
	}
	arrayValues := make([]*firestorepb.Value, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.GetPaths() {
		arrayValues = append(arrayValues, &firestorepb.Value{ValueType: &firestorepb.Value_StringValue{StringValue: path.String()}})
	}
	return &firestorepb.Value{
		ValueType: &firestorepb.Value_ArrayValue{ArrayValue: &firestorepb.ArrayValue{Values: arrayValues}},
	}, nil
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) DecodeFirestore(fpbv *firestorepb.Value) error {
	for _, value := range fpbv.GetArrayValue().GetValues() {
		parsedPath, err := ParseDeleteServiceAccountKeyRequest_FieldPath(value.GetStringValue())
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, parsedPath)
	}
	return nil
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) IsFull() bool {
	if fieldMask == nil {
		return false
	}
	presentSelectors := make([]bool, 1)
	for _, path := range fieldMask.Paths {
		if asFinal, ok := path.(*DeleteServiceAccountKeyRequest_FieldTerminalPath); ok {
			presentSelectors[int(asFinal.selector)] = true
		}
	}
	for _, flag := range presentSelectors {
		if !flag {
			return false
		}
	}
	return true
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) ProtoReflect() preflect.Message {
	return gotenobject.MakeFieldMaskReflection(fieldMask, func(raw string) (gotenobject.FieldPath, error) {
		return ParseDeleteServiceAccountKeyRequest_FieldPath(raw)
	})
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) ProtoMessage() {}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) Reset() {
	if fieldMask != nil {
		fieldMask.Paths = nil
	}
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) Subtract(other *DeleteServiceAccountKeyRequest_FieldMask) *DeleteServiceAccountKeyRequest_FieldMask {
	result := &DeleteServiceAccountKeyRequest_FieldMask{}
	removedSelectors := make([]bool, 1)

	for _, path := range other.GetPaths() {
		switch tp := path.(type) {
		case *DeleteServiceAccountKeyRequest_FieldTerminalPath:
			removedSelectors[int(tp.selector)] = true
		}
	}
	for _, path := range fieldMask.GetPaths() {
		if !removedSelectors[int(path.Selector())] {
			result.Paths = append(result.Paths, path)
		}
	}

	if len(result.Paths) == 0 {
		return nil
	}
	return result
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) SubtractRaw(other gotenobject.FieldMask) gotenobject.FieldMask {
	return fieldMask.Subtract(other.(*DeleteServiceAccountKeyRequest_FieldMask))
}

// FilterInputFields generates copy of field paths with output_only field paths removed
func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) FilterInputFields() *DeleteServiceAccountKeyRequest_FieldMask {
	result := &DeleteServiceAccountKeyRequest_FieldMask{}
	result.Paths = append(result.Paths, fieldMask.Paths...)
	return result
}

// ToFieldMask is used for proto conversions
func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) ToProtoFieldMask() *fieldmaskpb.FieldMask {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	for _, path := range fieldMask.Paths {
		protoFieldMask.Paths = append(protoFieldMask.Paths, path.String())
	}
	return protoFieldMask
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) FromProtoFieldMask(protoFieldMask *fieldmaskpb.FieldMask) error {
	if fieldMask == nil {
		return status.Error(codes.Internal, "target field mask is nil")
	}
	fieldMask.Paths = make([]DeleteServiceAccountKeyRequest_FieldPath, 0, len(protoFieldMask.Paths))
	for _, strPath := range protoFieldMask.Paths {
		path, err := ParseDeleteServiceAccountKeyRequest_FieldPath(strPath)
		if err != nil {
			return err
		}
		fieldMask.Paths = append(fieldMask.Paths, path)
	}
	return nil
}

// implement methods required by customType
func (fieldMask DeleteServiceAccountKeyRequest_FieldMask) Marshal() ([]byte, error) {
	protoFieldMask := fieldMask.ToProtoFieldMask()
	return proto.Marshal(protoFieldMask)
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) Unmarshal(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := proto.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) Size() int {
	return proto.Size(fieldMask.ToProtoFieldMask())
}

func (fieldMask DeleteServiceAccountKeyRequest_FieldMask) MarshalJSON() ([]byte, error) {
	return json.Marshal(fieldMask.ToProtoFieldMask())
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) UnmarshalJSON(data []byte) error {
	protoFieldMask := &fieldmaskpb.FieldMask{}
	if err := json.Unmarshal(data, protoFieldMask); err != nil {
		return err
	}
	if err := fieldMask.FromProtoFieldMask(protoFieldMask); err != nil {
		return err
	}
	return nil
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) AppendPath(path DeleteServiceAccountKeyRequest_FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path)
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) AppendRawPath(path gotenobject.FieldPath) {
	fieldMask.Paths = append(fieldMask.Paths, path.(DeleteServiceAccountKeyRequest_FieldPath))
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) GetPaths() []DeleteServiceAccountKeyRequest_FieldPath {
	if fieldMask == nil {
		return nil
	}
	return fieldMask.Paths
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) GetRawPaths() []gotenobject.FieldPath {
	if fieldMask == nil {
		return nil
	}
	rawPaths := make([]gotenobject.FieldPath, 0, len(fieldMask.Paths))
	for _, path := range fieldMask.Paths {
		rawPaths = append(rawPaths, path)
	}
	return rawPaths
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) SetFromCliFlag(raw string) error {
	path, err := ParseDeleteServiceAccountKeyRequest_FieldPath(raw)
	if err != nil {
		return err
	}
	fieldMask.Paths = append(fieldMask.Paths, path)
	return nil
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) Set(target, source *DeleteServiceAccountKeyRequest) {
	for _, path := range fieldMask.Paths {
		val, _ := path.GetSingle(source)
		// if val is nil, then field does not exist in source, skip
		// otherwise, process (can still reflect.ValueOf(val).IsNil!)
		if val != nil {
			path.WithIValue(val).SetTo(&target)
		}
	}
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) SetRaw(target, source gotenobject.GotenObjectExt) {
	fieldMask.Set(target.(*DeleteServiceAccountKeyRequest), source.(*DeleteServiceAccountKeyRequest))
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) Project(source *DeleteServiceAccountKeyRequest) *DeleteServiceAccountKeyRequest {
	if source == nil {
		return nil
	}
	if fieldMask == nil {
		return source
	}
	result := &DeleteServiceAccountKeyRequest{}

	for _, p := range fieldMask.Paths {
		switch tp := p.(type) {
		case *DeleteServiceAccountKeyRequest_FieldTerminalPath:
			switch tp.selector {
			case DeleteServiceAccountKeyRequest_FieldPathSelectorName:
				result.Name = source.Name
			}
		}
	}
	return result
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) ProjectRaw(source gotenobject.GotenObjectExt) gotenobject.GotenObjectExt {
	return fieldMask.Project(source.(*DeleteServiceAccountKeyRequest))
}

func (fieldMask *DeleteServiceAccountKeyRequest_FieldMask) PathsCount() int {
	if fieldMask == nil {
		return 0
	}
	return len(fieldMask.Paths)
}
