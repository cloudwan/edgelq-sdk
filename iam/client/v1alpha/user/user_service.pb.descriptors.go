// Code generated by protoc-gen-goten-client
// API: UserService
// DO NOT EDIT!!!

package user_client

import (
	"google.golang.org/protobuf/proto"

	gotenclient "github.com/cloudwan/goten-sdk/runtime/client"
	gotenresource "github.com/cloudwan/goten-sdk/runtime/resource"
)

// proto imports
import (
	user "github.com/cloudwan/edgelq-sdk/iam/resources/v1alpha/user"
	empty "github.com/golang/protobuf/ptypes/empty"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = new(proto.Message)
	_ = new(gotenclient.MethodDescriptor)
	_ = gotenresource.WildcardId
)

// make sure we're using proto imports
var (
	_ = &user.User{}
	_ = &empty.Empty{}
)

var (
	descriptorsInitialized           bool
	userServiceDescriptor            *UserServiceDescriptor
	getUserDescriptor                *GetUserDescriptor
	batchGetUsersDescriptor          *BatchGetUsersDescriptor
	listUsersDescriptor              *ListUsersDescriptor
	watchUserDescriptor              *WatchUserDescriptor
	watchUsersDescriptor             *WatchUsersDescriptor
	createUserDescriptor             *CreateUserDescriptor
	updateUserDescriptor             *UpdateUserDescriptor
	deleteUserDescriptor             *DeleteUserDescriptor
	getUserByEmailDescriptor         *GetUserByEmailDescriptor
	batchGetUsersByEmailDescriptor   *BatchGetUsersByEmailDescriptor
	getMySettingsDescriptor          *GetMySettingsDescriptor
	setMySettingsDescriptor          *SetMySettingsDescriptor
	refreshUserFromIdTokenDescriptor *RefreshUserFromIdTokenDescriptor
)

type GetUserDescriptor struct{}

type GetUserDescriptorClientMsgHandle struct{}

type GetUserDescriptorServerMsgHandle struct{}

func (d *GetUserDescriptor) NewEmptyClientMsg() proto.Message {
	return &GetUserRequest{}
}

func (d *GetUserDescriptor) NewEmptyServerMsg() proto.Message {
	return &user.User{}
}

func (d *GetUserDescriptor) IsUnary() bool {
	return true
}

func (d *GetUserDescriptor) IsClientStream() bool {
	return false
}

func (d *GetUserDescriptor) IsServerStream() bool {
	return false
}

func (d *GetUserDescriptor) IsCollection() bool {
	return false
}

func (d *GetUserDescriptor) IsPlural() bool {
	return false
}

func (d *GetUserDescriptor) HasResource() bool {
	return true
}

func (d *GetUserDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *GetUserDescriptor) GetVerb() string {
	return "get"
}

func (d *GetUserDescriptor) GetMethodName() string {
	return "GetUser"
}

func (d *GetUserDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/GetUser"
}

func (d *GetUserDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *GetUserDescriptor) GetApiName() string {
	return "UserService"
}

func (d *GetUserDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *GetUserDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *GetUserDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *GetUserDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *GetUserDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetUserDescriptorClientMsgHandle{}
}

func (d *GetUserDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetUserDescriptorServerMsgHandle{}
}

func (h *GetUserDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*GetUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*GetUserRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*user.Name)(nil)
}

func (h *GetUserDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*GetUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*GetUserRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetUserDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *GetUserDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*user.User)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*user.User) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if name := typedMsg.GetName(); name != nil {
			return name
		}
	}
	return (*user.Name)(nil)
}

func (h *GetUserDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*user.User)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*user.User) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetUserDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetGetUserDescriptor() *GetUserDescriptor {
	return getUserDescriptor
}

type BatchGetUsersDescriptor struct{}

type BatchGetUsersDescriptorClientMsgHandle struct{}

type BatchGetUsersDescriptorServerMsgHandle struct{}

func (d *BatchGetUsersDescriptor) NewEmptyClientMsg() proto.Message {
	return &BatchGetUsersRequest{}
}

func (d *BatchGetUsersDescriptor) NewEmptyServerMsg() proto.Message {
	return &BatchGetUsersResponse{}
}

func (d *BatchGetUsersDescriptor) IsUnary() bool {
	return true
}

func (d *BatchGetUsersDescriptor) IsClientStream() bool {
	return false
}

func (d *BatchGetUsersDescriptor) IsServerStream() bool {
	return false
}

func (d *BatchGetUsersDescriptor) IsCollection() bool {
	return false
}

func (d *BatchGetUsersDescriptor) IsPlural() bool {
	return true
}

func (d *BatchGetUsersDescriptor) HasResource() bool {
	return true
}

func (d *BatchGetUsersDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *BatchGetUsersDescriptor) GetVerb() string {
	return "batchGet"
}

func (d *BatchGetUsersDescriptor) GetMethodName() string {
	return "BatchGetUsers"
}

func (d *BatchGetUsersDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/BatchGetUsers"
}

func (d *BatchGetUsersDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *BatchGetUsersDescriptor) GetApiName() string {
	return "UserService"
}

func (d *BatchGetUsersDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *BatchGetUsersDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *BatchGetUsersDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *BatchGetUsersDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *BatchGetUsersDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &BatchGetUsersDescriptorClientMsgHandle{}
}

func (d *BatchGetUsersDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &BatchGetUsersDescriptorServerMsgHandle{}
}

func (h *BatchGetUsersDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetUsersRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*BatchGetUsersRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *BatchGetUsersDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*BatchGetUsersRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*BatchGetUsersRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if refs := typedMsg.GetNames(); len(refs) > 0 {
			list := make(user.UserNameList, 0, len(refs))
			for _, ref := range refs {
				list = append(list, &ref.Name)
			}
			return list
		}
	}
	return (user.UserNameList)(nil)
}

func (h *BatchGetUsersDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *BatchGetUsersDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetUsersResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*BatchGetUsersResponse) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *BatchGetUsersDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*BatchGetUsersResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*BatchGetUsersResponse) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resources := typedMsg.GetUsers(); len(resources) > 0 {
			list := make(user.UserNameList, 0, len(resources))
			for _, res := range resources {
				list = append(list, res.GetName())
			}
			return list
		}
	}
	return (user.UserNameList)(nil)
}

func (h *BatchGetUsersDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetBatchGetUsersDescriptor() *BatchGetUsersDescriptor {
	return batchGetUsersDescriptor
}

type ListUsersDescriptor struct{}

type ListUsersDescriptorClientMsgHandle struct{}

type ListUsersDescriptorServerMsgHandle struct{}

func (d *ListUsersDescriptor) NewEmptyClientMsg() proto.Message {
	return &ListUsersRequest{}
}

func (d *ListUsersDescriptor) NewEmptyServerMsg() proto.Message {
	return &ListUsersResponse{}
}

func (d *ListUsersDescriptor) IsUnary() bool {
	return true
}

func (d *ListUsersDescriptor) IsClientStream() bool {
	return false
}

func (d *ListUsersDescriptor) IsServerStream() bool {
	return false
}

func (d *ListUsersDescriptor) IsCollection() bool {
	return true
}

func (d *ListUsersDescriptor) IsPlural() bool {
	return true
}

func (d *ListUsersDescriptor) HasResource() bool {
	return true
}

func (d *ListUsersDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *ListUsersDescriptor) GetVerb() string {
	return "list"
}

func (d *ListUsersDescriptor) GetMethodName() string {
	return "ListUsers"
}

func (d *ListUsersDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/ListUsers"
}

func (d *ListUsersDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *ListUsersDescriptor) GetApiName() string {
	return "UserService"
}

func (d *ListUsersDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *ListUsersDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *ListUsersDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *ListUsersDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *ListUsersDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &ListUsersDescriptorClientMsgHandle{}
}

func (d *ListUsersDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &ListUsersDescriptorServerMsgHandle{}
}

func (h *ListUsersDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListUsersRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*ListUsersRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *ListUsersDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*ListUsersRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*ListUsersRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *ListUsersDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *ListUsersDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*ListUsersResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*ListUsersResponse) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *ListUsersDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*ListUsersResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*ListUsersResponse) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resources := typedMsg.GetUsers(); len(resources) > 0 {
			list := make(user.UserNameList, 0, len(resources))
			for _, res := range resources {
				list = append(list, res.GetName())
			}
			return list
		}
	}
	return (user.UserNameList)(nil)
}

func (h *ListUsersDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetListUsersDescriptor() *ListUsersDescriptor {
	return listUsersDescriptor
}

type WatchUserDescriptor struct{}

type WatchUserDescriptorClientMsgHandle struct{}

type WatchUserDescriptorServerMsgHandle struct{}

func (d *WatchUserDescriptor) NewEmptyClientMsg() proto.Message {
	return &WatchUserRequest{}
}

func (d *WatchUserDescriptor) NewEmptyServerMsg() proto.Message {
	return &WatchUserResponse{}
}

func (d *WatchUserDescriptor) IsUnary() bool {
	return false
}

func (d *WatchUserDescriptor) IsClientStream() bool {
	return false
}

func (d *WatchUserDescriptor) IsServerStream() bool {
	return true
}

func (d *WatchUserDescriptor) IsCollection() bool {
	return false
}

func (d *WatchUserDescriptor) IsPlural() bool {
	return false
}

func (d *WatchUserDescriptor) HasResource() bool {
	return true
}

func (d *WatchUserDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *WatchUserDescriptor) GetVerb() string {
	return "watch"
}

func (d *WatchUserDescriptor) GetMethodName() string {
	return "WatchUser"
}

func (d *WatchUserDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/WatchUser"
}

func (d *WatchUserDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *WatchUserDescriptor) GetApiName() string {
	return "UserService"
}

func (d *WatchUserDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *WatchUserDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *WatchUserDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *WatchUserDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *WatchUserDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchUserDescriptorClientMsgHandle{}
}

func (d *WatchUserDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchUserDescriptorServerMsgHandle{}
}

func (h *WatchUserDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchUserRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*user.Name)(nil)
}

func (h *WatchUserDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchUserRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchUserDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *WatchUserDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchUserResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchUserResponse) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if resChange := typedMsg.GetChange(); resChange != nil {
			switch tResChange := resChange.ChangeType.(type) {
			case *user.UserChange_Added_:
				return tResChange.Added.GetUser().GetName()
			case *user.UserChange_Modified_:
				return tResChange.Modified.GetName()
			case *user.UserChange_Removed_:
				return tResChange.Removed.GetName()
			case *user.UserChange_Current_:
				return tResChange.Current.GetUser().GetName()
			}
		}
	}
	return (*user.Name)(nil)
}

func (h *WatchUserDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchUserResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchUserResponse) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchUserDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetWatchUserDescriptor() *WatchUserDescriptor {
	return watchUserDescriptor
}

type WatchUsersDescriptor struct{}

type WatchUsersDescriptorClientMsgHandle struct{}

type WatchUsersDescriptorServerMsgHandle struct{}

func (d *WatchUsersDescriptor) NewEmptyClientMsg() proto.Message {
	return &WatchUsersRequest{}
}

func (d *WatchUsersDescriptor) NewEmptyServerMsg() proto.Message {
	return &WatchUsersResponse{}
}

func (d *WatchUsersDescriptor) IsUnary() bool {
	return false
}

func (d *WatchUsersDescriptor) IsClientStream() bool {
	return false
}

func (d *WatchUsersDescriptor) IsServerStream() bool {
	return true
}

func (d *WatchUsersDescriptor) IsCollection() bool {
	return true
}

func (d *WatchUsersDescriptor) IsPlural() bool {
	return true
}

func (d *WatchUsersDescriptor) HasResource() bool {
	return true
}

func (d *WatchUsersDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *WatchUsersDescriptor) GetVerb() string {
	return "watch"
}

func (d *WatchUsersDescriptor) GetMethodName() string {
	return "WatchUsers"
}

func (d *WatchUsersDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/WatchUsers"
}

func (d *WatchUsersDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *WatchUsersDescriptor) GetApiName() string {
	return "UserService"
}

func (d *WatchUsersDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *WatchUsersDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *WatchUsersDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *WatchUsersDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *WatchUsersDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchUsersDescriptorClientMsgHandle{}
}

func (d *WatchUsersDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &WatchUsersDescriptorServerMsgHandle{}
}

func (h *WatchUsersDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchUsersRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchUsersRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *WatchUsersDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchUsersRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchUsersRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *WatchUsersDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *WatchUsersDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*WatchUsersResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*WatchUsersResponse) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *WatchUsersDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*WatchUsersResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*WatchUsersResponse) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	{
		if resChanges := typedMsg.GetUserChanges(); len(resChanges) > 0 {
			list := make(user.UserNameList, 0, len(resChanges))
			for _, resChange := range resChanges {
				switch tResChange := resChange.ChangeType.(type) {
				case *user.UserChange_Added_:
					list = append(list, tResChange.Added.GetUser().GetName())
				case *user.UserChange_Modified_:
					list = append(list, tResChange.Modified.GetName())
				case *user.UserChange_Removed_:
					list = append(list, tResChange.Removed.GetName())
				case *user.UserChange_Current_:
					list = append(list, tResChange.Current.GetUser().GetName())
				}
			}
			return list
		}
	}
	return (user.UserNameList)(nil)
}

func (h *WatchUsersDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetWatchUsersDescriptor() *WatchUsersDescriptor {
	return watchUsersDescriptor
}

type CreateUserDescriptor struct{}

type CreateUserDescriptorClientMsgHandle struct{}

type CreateUserDescriptorServerMsgHandle struct{}

func (d *CreateUserDescriptor) NewEmptyClientMsg() proto.Message {
	return &CreateUserRequest{}
}

func (d *CreateUserDescriptor) NewEmptyServerMsg() proto.Message {
	return &user.User{}
}

func (d *CreateUserDescriptor) IsUnary() bool {
	return true
}

func (d *CreateUserDescriptor) IsClientStream() bool {
	return false
}

func (d *CreateUserDescriptor) IsServerStream() bool {
	return false
}

func (d *CreateUserDescriptor) IsCollection() bool {
	return true
}

func (d *CreateUserDescriptor) IsPlural() bool {
	return false
}

func (d *CreateUserDescriptor) HasResource() bool {
	return true
}

func (d *CreateUserDescriptor) RequestHasResourceBody() bool {
	return true
}

func (d *CreateUserDescriptor) GetVerb() string {
	return "create"
}

func (d *CreateUserDescriptor) GetMethodName() string {
	return "CreateUser"
}

func (d *CreateUserDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/CreateUser"
}

func (d *CreateUserDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *CreateUserDescriptor) GetApiName() string {
	return "UserService"
}

func (d *CreateUserDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *CreateUserDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *CreateUserDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *CreateUserDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *CreateUserDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &CreateUserDescriptorClientMsgHandle{}
}

func (d *CreateUserDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &CreateUserDescriptorServerMsgHandle{}
}

func (h *CreateUserDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*CreateUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*CreateUserRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		res := typedMsg.GetUser()
		if name := res.GetName(); name != nil {
			return name
		}
	}
	return (*user.Name)(nil)
}

func (h *CreateUserDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*CreateUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*CreateUserRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *CreateUserDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *CreateUserDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*user.User)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*user.User) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if name := typedMsg.GetName(); name != nil {
			return name
		}
	}
	return (*user.Name)(nil)
}

func (h *CreateUserDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*user.User)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*user.User) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *CreateUserDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetCreateUserDescriptor() *CreateUserDescriptor {
	return createUserDescriptor
}

type UpdateUserDescriptor struct{}

type UpdateUserDescriptorClientMsgHandle struct{}

type UpdateUserDescriptorServerMsgHandle struct{}

func (d *UpdateUserDescriptor) NewEmptyClientMsg() proto.Message {
	return &UpdateUserRequest{}
}

func (d *UpdateUserDescriptor) NewEmptyServerMsg() proto.Message {
	return &user.User{}
}

func (d *UpdateUserDescriptor) IsUnary() bool {
	return true
}

func (d *UpdateUserDescriptor) IsClientStream() bool {
	return false
}

func (d *UpdateUserDescriptor) IsServerStream() bool {
	return false
}

func (d *UpdateUserDescriptor) IsCollection() bool {
	return false
}

func (d *UpdateUserDescriptor) IsPlural() bool {
	return false
}

func (d *UpdateUserDescriptor) HasResource() bool {
	return true
}

func (d *UpdateUserDescriptor) RequestHasResourceBody() bool {
	return true
}

func (d *UpdateUserDescriptor) GetVerb() string {
	return "update"
}

func (d *UpdateUserDescriptor) GetMethodName() string {
	return "UpdateUser"
}

func (d *UpdateUserDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/UpdateUser"
}

func (d *UpdateUserDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *UpdateUserDescriptor) GetApiName() string {
	return "UserService"
}

func (d *UpdateUserDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *UpdateUserDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *UpdateUserDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *UpdateUserDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *UpdateUserDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &UpdateUserDescriptorClientMsgHandle{}
}

func (d *UpdateUserDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &UpdateUserDescriptorServerMsgHandle{}
}

func (h *UpdateUserDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*UpdateUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*UpdateUserRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		res := typedMsg.GetUser()
		if name := res.GetName(); name != nil {
			return name
		}
	}
	return (*user.Name)(nil)
}

func (h *UpdateUserDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*UpdateUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*UpdateUserRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *UpdateUserDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *UpdateUserDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*user.User)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*user.User) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if name := typedMsg.GetName(); name != nil {
			return name
		}
	}
	return (*user.Name)(nil)
}

func (h *UpdateUserDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*user.User)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*user.User) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *UpdateUserDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetUpdateUserDescriptor() *UpdateUserDescriptor {
	return updateUserDescriptor
}

type DeleteUserDescriptor struct{}

type DeleteUserDescriptorClientMsgHandle struct{}

type DeleteUserDescriptorServerMsgHandle struct{}

func (d *DeleteUserDescriptor) NewEmptyClientMsg() proto.Message {
	return &DeleteUserRequest{}
}

func (d *DeleteUserDescriptor) NewEmptyServerMsg() proto.Message {
	return &empty.Empty{}
}

func (d *DeleteUserDescriptor) IsUnary() bool {
	return true
}

func (d *DeleteUserDescriptor) IsClientStream() bool {
	return false
}

func (d *DeleteUserDescriptor) IsServerStream() bool {
	return false
}

func (d *DeleteUserDescriptor) IsCollection() bool {
	return false
}

func (d *DeleteUserDescriptor) IsPlural() bool {
	return false
}

func (d *DeleteUserDescriptor) HasResource() bool {
	return true
}

func (d *DeleteUserDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *DeleteUserDescriptor) GetVerb() string {
	return "delete"
}

func (d *DeleteUserDescriptor) GetMethodName() string {
	return "DeleteUser"
}

func (d *DeleteUserDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/DeleteUser"
}

func (d *DeleteUserDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *DeleteUserDescriptor) GetApiName() string {
	return "UserService"
}

func (d *DeleteUserDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *DeleteUserDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *DeleteUserDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *DeleteUserDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *DeleteUserDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &DeleteUserDescriptorClientMsgHandle{}
}

func (d *DeleteUserDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &DeleteUserDescriptorServerMsgHandle{}
}

func (h *DeleteUserDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*DeleteUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*DeleteUserRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	{
		if ref := typedMsg.GetName(); ref != nil {
			return &ref.Name
		}
	}
	return (*user.Name)(nil)
}

func (h *DeleteUserDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*DeleteUserRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*DeleteUserRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *DeleteUserDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *DeleteUserDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*empty.Empty) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *DeleteUserDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*empty.Empty) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *DeleteUserDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetDeleteUserDescriptor() *DeleteUserDescriptor {
	return deleteUserDescriptor
}

type GetUserByEmailDescriptor struct{}

type GetUserByEmailDescriptorClientMsgHandle struct{}

type GetUserByEmailDescriptorServerMsgHandle struct{}

func (d *GetUserByEmailDescriptor) NewEmptyClientMsg() proto.Message {
	return &GetUserByEmailRequest{}
}

func (d *GetUserByEmailDescriptor) NewEmptyServerMsg() proto.Message {
	return &user.User{}
}

func (d *GetUserByEmailDescriptor) IsUnary() bool {
	return true
}

func (d *GetUserByEmailDescriptor) IsClientStream() bool {
	return false
}

func (d *GetUserByEmailDescriptor) IsServerStream() bool {
	return false
}

func (d *GetUserByEmailDescriptor) IsCollection() bool {
	return false
}

func (d *GetUserByEmailDescriptor) IsPlural() bool {
	return false
}

func (d *GetUserByEmailDescriptor) HasResource() bool {
	return true
}

func (d *GetUserByEmailDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *GetUserByEmailDescriptor) GetVerb() string {
	return "getByEmail"
}

func (d *GetUserByEmailDescriptor) GetMethodName() string {
	return "GetUserByEmail"
}

func (d *GetUserByEmailDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/GetUserByEmail"
}

func (d *GetUserByEmailDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *GetUserByEmailDescriptor) GetApiName() string {
	return "UserService"
}

func (d *GetUserByEmailDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *GetUserByEmailDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *GetUserByEmailDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *GetUserByEmailDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *GetUserByEmailDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetUserByEmailDescriptorClientMsgHandle{}
}

func (d *GetUserByEmailDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetUserByEmailDescriptorServerMsgHandle{}
}

func (h *GetUserByEmailDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*GetUserByEmailRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*GetUserByEmailRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *GetUserByEmailDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*GetUserByEmailRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*GetUserByEmailRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetUserByEmailDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *GetUserByEmailDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*user.User)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*user.User) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *GetUserByEmailDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*user.User)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*user.User) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetUserByEmailDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetGetUserByEmailDescriptor() *GetUserByEmailDescriptor {
	return getUserByEmailDescriptor
}

type BatchGetUsersByEmailDescriptor struct{}

type BatchGetUsersByEmailDescriptorClientMsgHandle struct{}

type BatchGetUsersByEmailDescriptorServerMsgHandle struct{}

func (d *BatchGetUsersByEmailDescriptor) NewEmptyClientMsg() proto.Message {
	return &BatchGetUsersByEmailRequest{}
}

func (d *BatchGetUsersByEmailDescriptor) NewEmptyServerMsg() proto.Message {
	return &BatchGetUsersByEmailResponse{}
}

func (d *BatchGetUsersByEmailDescriptor) IsUnary() bool {
	return true
}

func (d *BatchGetUsersByEmailDescriptor) IsClientStream() bool {
	return false
}

func (d *BatchGetUsersByEmailDescriptor) IsServerStream() bool {
	return false
}

func (d *BatchGetUsersByEmailDescriptor) IsCollection() bool {
	return true
}

func (d *BatchGetUsersByEmailDescriptor) IsPlural() bool {
	return true
}

func (d *BatchGetUsersByEmailDescriptor) HasResource() bool {
	return true
}

func (d *BatchGetUsersByEmailDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *BatchGetUsersByEmailDescriptor) GetVerb() string {
	return "batchGetByEmail"
}

func (d *BatchGetUsersByEmailDescriptor) GetMethodName() string {
	return "BatchGetUsersByEmail"
}

func (d *BatchGetUsersByEmailDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/BatchGetUsersByEmail"
}

func (d *BatchGetUsersByEmailDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *BatchGetUsersByEmailDescriptor) GetApiName() string {
	return "UserService"
}

func (d *BatchGetUsersByEmailDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *BatchGetUsersByEmailDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *BatchGetUsersByEmailDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *BatchGetUsersByEmailDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *BatchGetUsersByEmailDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &BatchGetUsersByEmailDescriptorClientMsgHandle{}
}

func (d *BatchGetUsersByEmailDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &BatchGetUsersByEmailDescriptorServerMsgHandle{}
}

func (h *BatchGetUsersByEmailDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetUsersByEmailRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*BatchGetUsersByEmailRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *BatchGetUsersByEmailDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*BatchGetUsersByEmailRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*BatchGetUsersByEmailRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *BatchGetUsersByEmailDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *BatchGetUsersByEmailDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*BatchGetUsersByEmailResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*BatchGetUsersByEmailResponse) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *BatchGetUsersByEmailDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*BatchGetUsersByEmailResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*BatchGetUsersByEmailResponse) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *BatchGetUsersByEmailDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetBatchGetUsersByEmailDescriptor() *BatchGetUsersByEmailDescriptor {
	return batchGetUsersByEmailDescriptor
}

type GetMySettingsDescriptor struct{}

type GetMySettingsDescriptorClientMsgHandle struct{}

type GetMySettingsDescriptorServerMsgHandle struct{}

func (d *GetMySettingsDescriptor) NewEmptyClientMsg() proto.Message {
	return &GetMySettingsRequest{}
}

func (d *GetMySettingsDescriptor) NewEmptyServerMsg() proto.Message {
	return &GetMySettingsResponse{}
}

func (d *GetMySettingsDescriptor) IsUnary() bool {
	return true
}

func (d *GetMySettingsDescriptor) IsClientStream() bool {
	return false
}

func (d *GetMySettingsDescriptor) IsServerStream() bool {
	return false
}

func (d *GetMySettingsDescriptor) IsCollection() bool {
	return true
}

func (d *GetMySettingsDescriptor) IsPlural() bool {
	return false
}

func (d *GetMySettingsDescriptor) HasResource() bool {
	return true
}

func (d *GetMySettingsDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *GetMySettingsDescriptor) GetVerb() string {
	return "getMySettings"
}

func (d *GetMySettingsDescriptor) GetMethodName() string {
	return "GetMySettings"
}

func (d *GetMySettingsDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/GetMySettings"
}

func (d *GetMySettingsDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *GetMySettingsDescriptor) GetApiName() string {
	return "UserService"
}

func (d *GetMySettingsDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *GetMySettingsDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *GetMySettingsDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *GetMySettingsDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *GetMySettingsDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetMySettingsDescriptorClientMsgHandle{}
}

func (d *GetMySettingsDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &GetMySettingsDescriptorServerMsgHandle{}
}

func (h *GetMySettingsDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*GetMySettingsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*GetMySettingsRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *GetMySettingsDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*GetMySettingsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*GetMySettingsRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetMySettingsDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *GetMySettingsDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*GetMySettingsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*GetMySettingsResponse) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *GetMySettingsDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*GetMySettingsResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*GetMySettingsResponse) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *GetMySettingsDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetGetMySettingsDescriptor() *GetMySettingsDescriptor {
	return getMySettingsDescriptor
}

type SetMySettingsDescriptor struct{}

type SetMySettingsDescriptorClientMsgHandle struct{}

type SetMySettingsDescriptorServerMsgHandle struct{}

func (d *SetMySettingsDescriptor) NewEmptyClientMsg() proto.Message {
	return &SetMySettingsRequest{}
}

func (d *SetMySettingsDescriptor) NewEmptyServerMsg() proto.Message {
	return &empty.Empty{}
}

func (d *SetMySettingsDescriptor) IsUnary() bool {
	return true
}

func (d *SetMySettingsDescriptor) IsClientStream() bool {
	return false
}

func (d *SetMySettingsDescriptor) IsServerStream() bool {
	return false
}

func (d *SetMySettingsDescriptor) IsCollection() bool {
	return true
}

func (d *SetMySettingsDescriptor) IsPlural() bool {
	return false
}

func (d *SetMySettingsDescriptor) HasResource() bool {
	return true
}

func (d *SetMySettingsDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *SetMySettingsDescriptor) GetVerb() string {
	return "setMySettings"
}

func (d *SetMySettingsDescriptor) GetMethodName() string {
	return "SetMySettings"
}

func (d *SetMySettingsDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/SetMySettings"
}

func (d *SetMySettingsDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *SetMySettingsDescriptor) GetApiName() string {
	return "UserService"
}

func (d *SetMySettingsDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *SetMySettingsDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *SetMySettingsDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *SetMySettingsDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *SetMySettingsDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &SetMySettingsDescriptorClientMsgHandle{}
}

func (d *SetMySettingsDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &SetMySettingsDescriptorServerMsgHandle{}
}

func (h *SetMySettingsDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*SetMySettingsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*SetMySettingsRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *SetMySettingsDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*SetMySettingsRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*SetMySettingsRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *SetMySettingsDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *SetMySettingsDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*empty.Empty) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *SetMySettingsDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*empty.Empty)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*empty.Empty) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *SetMySettingsDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetSetMySettingsDescriptor() *SetMySettingsDescriptor {
	return setMySettingsDescriptor
}

type RefreshUserFromIdTokenDescriptor struct{}

type RefreshUserFromIdTokenDescriptorClientMsgHandle struct{}

type RefreshUserFromIdTokenDescriptorServerMsgHandle struct{}

func (d *RefreshUserFromIdTokenDescriptor) NewEmptyClientMsg() proto.Message {
	return &RefreshUserFromIdTokenRequest{}
}

func (d *RefreshUserFromIdTokenDescriptor) NewEmptyServerMsg() proto.Message {
	return &RefreshUserFromIdTokenResponse{}
}

func (d *RefreshUserFromIdTokenDescriptor) IsUnary() bool {
	return true
}

func (d *RefreshUserFromIdTokenDescriptor) IsClientStream() bool {
	return false
}

func (d *RefreshUserFromIdTokenDescriptor) IsServerStream() bool {
	return false
}

func (d *RefreshUserFromIdTokenDescriptor) IsCollection() bool {
	return true
}

func (d *RefreshUserFromIdTokenDescriptor) IsPlural() bool {
	return false
}

func (d *RefreshUserFromIdTokenDescriptor) HasResource() bool {
	return true
}

func (d *RefreshUserFromIdTokenDescriptor) RequestHasResourceBody() bool {
	return false
}

func (d *RefreshUserFromIdTokenDescriptor) GetVerb() string {
	return "refreshUserFromIdToken"
}

func (d *RefreshUserFromIdTokenDescriptor) GetMethodName() string {
	return "RefreshUserFromIdToken"
}

func (d *RefreshUserFromIdTokenDescriptor) GetFullMethodName() string {
	return "/ntt.iam.v1alpha.UserService/RefreshUserFromIdToken"
}

func (d *RefreshUserFromIdTokenDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *RefreshUserFromIdTokenDescriptor) GetApiName() string {
	return "UserService"
}

func (d *RefreshUserFromIdTokenDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *RefreshUserFromIdTokenDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func (d *RefreshUserFromIdTokenDescriptor) GetApiDescriptor() gotenclient.ApiDescriptor {
	return userServiceDescriptor
}

func (d *RefreshUserFromIdTokenDescriptor) GetResourceDescriptor() gotenresource.Descriptor {
	return user.GetDescriptor()
}

func (d *RefreshUserFromIdTokenDescriptor) GetClientMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &RefreshUserFromIdTokenDescriptorClientMsgHandle{}
}

func (d *RefreshUserFromIdTokenDescriptor) GetServerMsgReflectHandle() gotenclient.MethodMsgHandle {
	return &RefreshUserFromIdTokenDescriptorServerMsgHandle{}
}

func (h *RefreshUserFromIdTokenDescriptorClientMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*RefreshUserFromIdTokenRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*RefreshUserFromIdTokenRequest) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *RefreshUserFromIdTokenDescriptorClientMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*RefreshUserFromIdTokenRequest)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*RefreshUserFromIdTokenRequest) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *RefreshUserFromIdTokenDescriptorClientMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func (h *RefreshUserFromIdTokenDescriptorServerMsgHandle) ExtractResourceName(msg proto.Message) gotenresource.Name {
	typedMsg := msg.(*RefreshUserFromIdTokenResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceName(*RefreshUserFromIdTokenResponse) *user.Name
	})
	if ok {
		return override.OverrideExtractResourceName(typedMsg)
	}
	return nil
}

func (h *RefreshUserFromIdTokenDescriptorServerMsgHandle) ExtractResourceNames(msg proto.Message) gotenresource.NameList {
	typedMsg := msg.(*RefreshUserFromIdTokenResponse)
	var asInterface interface{} = h
	override, ok := asInterface.(interface {
		OverrideExtractResourceNames(*RefreshUserFromIdTokenResponse) []*user.Name
	})
	if ok {
		return user.UserNameList(override.OverrideExtractResourceNames(typedMsg))
	}
	return nil
}

func (h *RefreshUserFromIdTokenDescriptorServerMsgHandle) ExtractCollectionName(msg proto.Message) gotenresource.Name {
	return nil
}

func GetRefreshUserFromIdTokenDescriptor() *RefreshUserFromIdTokenDescriptor {
	return refreshUserFromIdTokenDescriptor
}

type UserServiceDescriptor struct{}

func (d *UserServiceDescriptor) AllMethodDescriptors() []gotenclient.MethodDescriptor {
	return []gotenclient.MethodDescriptor{
		getUserDescriptor,
		batchGetUsersDescriptor,
		listUsersDescriptor,
		watchUserDescriptor,
		watchUsersDescriptor,
		createUserDescriptor,
		updateUserDescriptor,
		deleteUserDescriptor,
		getUserByEmailDescriptor,
		batchGetUsersByEmailDescriptor,
		getMySettingsDescriptor,
		setMySettingsDescriptor,
		refreshUserFromIdTokenDescriptor,
	}
}

func (d *UserServiceDescriptor) GetFullAPIName() string {
	return "/ntt.iam.v1alpha.UserService"
}

func (d *UserServiceDescriptor) GetProtoPkgName() string {
	return "ntt.iam.v1alpha"
}

func (d *UserServiceDescriptor) GetApiName() string {
	return "UserService"
}

func (d *UserServiceDescriptor) GetServiceDomain() string {
	return "iam.edgelq.com"
}

func (d *UserServiceDescriptor) GetServiceVersion() string {
	return "v1alpha"
}

func GetUserServiceDescriptor() *UserServiceDescriptor {
	return userServiceDescriptor
}

func initDescriptors() {
	userServiceDescriptor = &UserServiceDescriptor{}
	getUserDescriptor = &GetUserDescriptor{}
	batchGetUsersDescriptor = &BatchGetUsersDescriptor{}
	listUsersDescriptor = &ListUsersDescriptor{}
	watchUserDescriptor = &WatchUserDescriptor{}
	watchUsersDescriptor = &WatchUsersDescriptor{}
	createUserDescriptor = &CreateUserDescriptor{}
	updateUserDescriptor = &UpdateUserDescriptor{}
	deleteUserDescriptor = &DeleteUserDescriptor{}
	getUserByEmailDescriptor = &GetUserByEmailDescriptor{}
	batchGetUsersByEmailDescriptor = &BatchGetUsersByEmailDescriptor{}
	getMySettingsDescriptor = &GetMySettingsDescriptor{}
	setMySettingsDescriptor = &SetMySettingsDescriptor{}
	refreshUserFromIdTokenDescriptor = &RefreshUserFromIdTokenDescriptor{}
	gotenclient.GetRegistry().RegisterApiDescriptor(userServiceDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(getUserDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(batchGetUsersDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(listUsersDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(watchUserDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(watchUsersDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(createUserDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(updateUserDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(deleteUserDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(getUserByEmailDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(batchGetUsersByEmailDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(getMySettingsDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(setMySettingsDescriptor)
	gotenclient.GetRegistry().RegisterMethodDescriptor(refreshUserFromIdTokenDescriptor)
}

func init() {
	if !descriptorsInitialized {
		initDescriptors()
		descriptorsInitialized = true
	}
}
